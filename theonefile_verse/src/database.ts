import { Database } from "bun:sqlite";
import { existsSync, mkdirSync, readdirSync, readFileSync, unlinkSync } from "fs";
import { join } from "path";

const DATA_DIR = process.env.DATA_DIR || "./data";
const DB_PATH = join(DATA_DIR, "theonefile.db");
const ROOMS_DIR = join(DATA_DIR, "rooms");
const ADMIN_CONFIG_PATH = join(DATA_DIR, "admin.json");
const SETTINGS_PATH = join(DATA_DIR, "settings.json");

if (!existsSync(DATA_DIR)) mkdirSync(DATA_DIR, { recursive: true });

const db = new Database(DB_PATH);
db.exec("PRAGMA journal_mode = WAL");
db.exec("PRAGMA foreign_keys = ON");

db.exec(`
  CREATE TABLE IF NOT EXISTS rooms (
    id TEXT PRIMARY KEY,
    created TEXT NOT NULL,
    last_activity TEXT NOT NULL,
    creator_id TEXT NOT NULL,
    password_hash TEXT,
    destruct_mode TEXT NOT NULL DEFAULT 'time',
    destruct_value INTEGER NOT NULL DEFAULT 86400000,
    topology TEXT
  )
`);

db.exec(`
  CREATE TABLE IF NOT EXISTS admin_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL
  )
`);

db.exec(`
  CREATE TABLE IF NOT EXISTS audit_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    action TEXT NOT NULL,
    actor TEXT,
    actor_ip TEXT,
    target_type TEXT,
    target_id TEXT,
    details TEXT,
    created_at TEXT DEFAULT CURRENT_TIMESTAMP
  )
`);

db.exec(`
  CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp)
`);

db.exec(`
  CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action)
`);

db.exec(`
  CREATE INDEX IF NOT EXISTS idx_audit_logs_target ON audit_logs(target_type, target_id)
`);

db.exec(`
  CREATE TABLE IF NOT EXISTS activity_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT NOT NULL,
    room_id TEXT NOT NULL,
    user_id TEXT,
    user_name TEXT,
    event_type TEXT NOT NULL,
    details TEXT,
    ip_address TEXT
  )
`);

db.exec(`
  CREATE INDEX IF NOT EXISTS idx_activity_logs_room ON activity_logs(room_id)
`);

db.exec(`
  CREATE INDEX IF NOT EXISTS idx_activity_logs_timestamp ON activity_logs(timestamp)
`);

db.exec(`
  CREATE TABLE IF NOT EXISTS api_keys (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    key_hash TEXT NOT NULL,
    permissions TEXT NOT NULL,
    created_at TEXT NOT NULL,
    last_used TEXT,
    expires_at TEXT,
    active INTEGER NOT NULL DEFAULT 1
  )
`);

db.exec(`
  CREATE TABLE IF NOT EXISTS backups (
    id TEXT PRIMARY KEY,
    filename TEXT NOT NULL,
    created_at TEXT NOT NULL,
    size_bytes INTEGER NOT NULL,
    room_count INTEGER NOT NULL,
    auto_generated INTEGER NOT NULL DEFAULT 0
  )
`);

export interface Room {
  id: string;
  created: string;
  lastActivity: string;
  creatorId: string;
  passwordHash: string | null;
  destruct: { mode: "time" | "empty" | "never"; value: number };
  topology: any;
}

export interface AuditLog {
  id?: number;
  timestamp: string;
  action: string;
  actor?: string;
  actorIp?: string;
  targetType?: string;
  targetId?: string;
  details?: any;
}

export interface ActivityLog {
  id?: number;
  timestamp: string;
  roomId: string;
  userId?: string;
  userName?: string;
  eventType: string;
  details?: any;
  ipAddress?: string;
}

export interface ApiKey {
  id: string;
  name: string;
  keyHash: string;
  permissions: string[];
  createdAt: string;
  lastUsed?: string;
  expiresAt?: string;
  active: boolean;
}

export interface Backup {
  id: string;
  filename: string;
  createdAt: string;
  sizeBytes: number;
  roomCount: number;
  autoGenerated: boolean;
}

const stmtInsertRoom = db.prepare(`
  INSERT INTO rooms (id, created, last_activity, creator_id, password_hash, destruct_mode, destruct_value, topology)
  VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`);

const stmtUpdateRoom = db.prepare(`
  UPDATE rooms SET last_activity = ?, topology = ? WHERE id = ?
`);

const stmtGetRoom = db.prepare(`
  SELECT * FROM rooms WHERE id = ?
`);

const stmtDeleteRoom = db.prepare(`
  DELETE FROM rooms WHERE id = ?
`);

const stmtListRooms = db.prepare(`
  SELECT * FROM rooms ORDER BY created DESC
`);

const stmtSearchRooms = db.prepare(`
  SELECT * FROM rooms WHERE id LIKE ? OR creator_id LIKE ? ORDER BY created DESC LIMIT ? OFFSET ?
`);

const stmtCountRooms = db.prepare(`
  SELECT COUNT(*) as count FROM rooms
`);

const stmtGetSetting = db.prepare(`
  SELECT value FROM admin_settings WHERE key = ?
`);

const stmtSetSetting = db.prepare(`
  INSERT OR REPLACE INTO admin_settings (key, value) VALUES (?, ?)
`);

const stmtGetAllSettings = db.prepare(`
  SELECT key, value FROM admin_settings
`);

const stmtInsertAuditLog = db.prepare(`
  INSERT INTO audit_logs (timestamp, action, actor, actor_ip, target_type, target_id, details)
  VALUES (?, ?, ?, ?, ?, ?, ?)
`);

const stmtGetAuditLogs = db.prepare(`
  SELECT * FROM audit_logs ORDER BY timestamp DESC LIMIT ? OFFSET ?
`);

const stmtSearchAuditLogs = db.prepare(`
  SELECT * FROM audit_logs WHERE action LIKE ? OR actor LIKE ? OR target_id LIKE ? ORDER BY timestamp DESC LIMIT ? OFFSET ?
`);

const stmtInsertActivityLog = db.prepare(`
  INSERT INTO activity_logs (timestamp, room_id, user_id, user_name, event_type, details, ip_address)
  VALUES (?, ?, ?, ?, ?, ?, ?)
`);

const stmtGetActivityLogs = db.prepare(`
  SELECT * FROM activity_logs WHERE room_id = ? ORDER BY timestamp DESC LIMIT ? OFFSET ?
`);

const stmtGetAllActivityLogs = db.prepare(`
  SELECT * FROM activity_logs ORDER BY timestamp DESC LIMIT ? OFFSET ?
`);

const stmtInsertApiKey = db.prepare(`
  INSERT INTO api_keys (id, name, key_hash, permissions, created_at, expires_at, active)
  VALUES (?, ?, ?, ?, ?, ?, ?)
`);

const stmtGetApiKey = db.prepare(`
  SELECT * FROM api_keys WHERE id = ? AND active = 1
`);

const stmtGetApiKeyByHash = db.prepare(`
  SELECT * FROM api_keys WHERE key_hash = ? AND active = 1
`);

const stmtUpdateApiKeyLastUsed = db.prepare(`
  UPDATE api_keys SET last_used = ? WHERE id = ?
`);

const stmtListApiKeys = db.prepare(`
  SELECT id, name, permissions, created_at, last_used, expires_at, active FROM api_keys ORDER BY created_at DESC
`);

const stmtDeactivateApiKey = db.prepare(`
  UPDATE api_keys SET active = 0 WHERE id = ?
`);

const stmtInsertBackup = db.prepare(`
  INSERT INTO backups (id, filename, created_at, size_bytes, room_count, auto_generated)
  VALUES (?, ?, ?, ?, ?, ?)
`);

const stmtListBackups = db.prepare(`
  SELECT * FROM backups ORDER BY created_at DESC
`);

const stmtDeleteBackup = db.prepare(`
  DELETE FROM backups WHERE id = ?
`);

const stmtGetOldAutoBackups = db.prepare(`
  SELECT * FROM backups WHERE auto_generated = 1 ORDER BY created_at DESC LIMIT -1 OFFSET ?
`);

function rowToRoom(row: any): Room | null {
  if (!row) return null;
  return {
    id: row.id,
    created: row.created,
    lastActivity: row.last_activity,
    creatorId: row.creator_id,
    passwordHash: row.password_hash,
    destruct: { mode: row.destruct_mode, value: row.destruct_value },
    topology: row.topology ? JSON.parse(row.topology) : null
  };
}

export function createRoom(room: Room): void {
  stmtInsertRoom.run(
    room.id,
    room.created,
    room.lastActivity,
    room.creatorId,
    room.passwordHash,
    room.destruct.mode,
    room.destruct.value,
    room.topology ? JSON.stringify(room.topology) : null
  );
}

export function getRoom(id: string): Room | null {
  return rowToRoom(stmtGetRoom.get(id));
}

export function updateRoom(id: string, lastActivity: string, topology: any): void {
  stmtUpdateRoom.run(lastActivity, topology ? JSON.stringify(topology) : null, id);
}

export function deleteRoom(id: string): boolean {
  const result = stmtDeleteRoom.run(id);
  return result.changes > 0;
}

export function listRooms(): Room[] {
  return (stmtListRooms.all() as any[]).map(rowToRoom).filter(r => r !== null) as Room[];
}

export function searchRooms(query: string, limit: number = 50, offset: number = 0): Room[] {
  const searchPattern = `%${query}%`;
  return (stmtSearchRooms.all(searchPattern, searchPattern, limit, offset) as any[])
    .map(rowToRoom)
    .filter(r => r !== null) as Room[];
}

export function countRooms(): number {
  const result = stmtCountRooms.get() as { count: number };
  return result.count;
}

export function getSetting(key: string): string | null {
  const row = stmtGetSetting.get(key) as { value: string } | undefined;
  return row?.value ?? null;
}

export function setSetting(key: string, value: string): void {
  stmtSetSetting.run(key, value);
}

export function getAllSettings(): Record<string, string> {
  const rows = stmtGetAllSettings.all() as { key: string; value: string }[];
  const result: Record<string, string> = {};
  for (const row of rows) {
    result[row.key] = row.value;
  }
  return result;
}

export function addAuditLog(log: AuditLog): void {
  stmtInsertAuditLog.run(
    log.timestamp,
    log.action,
    log.actor || null,
    log.actorIp || null,
    log.targetType || null,
    log.targetId || null,
    log.details ? JSON.stringify(log.details) : null
  );
}

export function getAuditLogs(limit: number = 100, offset: number = 0): AuditLog[] {
  return (stmtGetAuditLogs.all(limit, offset) as any[]).map(row => ({
    id: row.id,
    timestamp: row.timestamp,
    action: row.action,
    actor: row.actor,
    actorIp: row.actor_ip,
    targetType: row.target_type,
    targetId: row.target_id,
    details: row.details ? JSON.parse(row.details) : null
  }));
}

export function searchAuditLogs(query: string, limit: number = 100, offset: number = 0): AuditLog[] {
  const searchPattern = `%${query}%`;
  return (stmtSearchAuditLogs.all(searchPattern, searchPattern, searchPattern, limit, offset) as any[]).map(row => ({
    id: row.id,
    timestamp: row.timestamp,
    action: row.action,
    actor: row.actor,
    actorIp: row.actor_ip,
    targetType: row.target_type,
    targetId: row.target_id,
    details: row.details ? JSON.parse(row.details) : null
  }));
}

export function addActivityLog(log: ActivityLog): void {
  stmtInsertActivityLog.run(
    log.timestamp,
    log.roomId,
    log.userId || null,
    log.userName || null,
    log.eventType,
    log.details ? JSON.stringify(log.details) : null,
    log.ipAddress || null
  );
}

export function getActivityLogs(roomId: string, limit: number = 100, offset: number = 0): ActivityLog[] {
  return (stmtGetActivityLogs.all(roomId, limit, offset) as any[]).map(row => ({
    id: row.id,
    timestamp: row.timestamp,
    roomId: row.room_id,
    userId: row.user_id,
    userName: row.user_name,
    eventType: row.event_type,
    details: row.details ? JSON.parse(row.details) : null,
    ipAddress: row.ip_address
  }));
}

export function getAllActivityLogs(limit: number = 100, offset: number = 0): ActivityLog[] {
  return (stmtGetAllActivityLogs.all(limit, offset) as any[]).map(row => ({
    id: row.id,
    timestamp: row.timestamp,
    roomId: row.room_id,
    userId: row.user_id,
    userName: row.user_name,
    eventType: row.event_type,
    details: row.details ? JSON.parse(row.details) : null,
    ipAddress: row.ip_address
  }));
}

export function createApiKey(apiKey: ApiKey): void {
  stmtInsertApiKey.run(
    apiKey.id,
    apiKey.name,
    apiKey.keyHash,
    JSON.stringify(apiKey.permissions),
    apiKey.createdAt,
    apiKey.expiresAt || null,
    apiKey.active ? 1 : 0
  );
}

export function getApiKeyById(id: string): ApiKey | null {
  const row = stmtGetApiKey.get(id) as any;
  if (!row) return null;
  return {
    id: row.id,
    name: row.name,
    keyHash: row.key_hash,
    permissions: JSON.parse(row.permissions),
    createdAt: row.created_at,
    lastUsed: row.last_used,
    expiresAt: row.expires_at,
    active: row.active === 1
  };
}

export function getApiKeyByHash(hash: string): ApiKey | null {
  const row = stmtGetApiKeyByHash.get(hash) as any;
  if (!row) return null;
  return {
    id: row.id,
    name: row.name,
    keyHash: row.key_hash,
    permissions: JSON.parse(row.permissions),
    createdAt: row.created_at,
    lastUsed: row.last_used,
    expiresAt: row.expires_at,
    active: row.active === 1
  };
}

export function updateApiKeyLastUsed(id: string): void {
  stmtUpdateApiKeyLastUsed.run(new Date().toISOString(), id);
}

export function listApiKeys(): Omit<ApiKey, "keyHash">[] {
  return (stmtListApiKeys.all() as any[]).map(row => ({
    id: row.id,
    name: row.name,
    permissions: JSON.parse(row.permissions),
    createdAt: row.created_at,
    lastUsed: row.last_used,
    expiresAt: row.expires_at,
    active: row.active === 1
  }));
}

export function deactivateApiKey(id: string): boolean {
  const result = stmtDeactivateApiKey.run(id);
  return result.changes > 0;
}

export function createBackupRecord(backup: Backup): void {
  stmtInsertBackup.run(
    backup.id,
    backup.filename,
    backup.createdAt,
    backup.sizeBytes,
    backup.roomCount,
    backup.autoGenerated ? 1 : 0
  );
}

export function listBackups(): Backup[] {
  return (stmtListBackups.all() as any[]).map(row => ({
    id: row.id,
    filename: row.filename,
    createdAt: row.created_at,
    sizeBytes: row.size_bytes,
    roomCount: row.room_count,
    autoGenerated: row.auto_generated === 1
  }));
}

export function deleteBackupRecord(id: string): boolean {
  const result = stmtDeleteBackup.run(id);
  return result.changes > 0;
}

export function getOldAutoBackups(keepCount: number): Backup[] {
  return (stmtGetOldAutoBackups.all(keepCount) as any[]).map(row => ({
    id: row.id,
    filename: row.filename,
    createdAt: row.created_at,
    sizeBytes: row.size_bytes,
    roomCount: row.room_count,
    autoGenerated: row.auto_generated === 1
  }));
}

export function migrateFromFlatFiles(): { rooms: number; settings: boolean; admin: boolean } {
  let roomsMigrated = 0;
  let settingsMigrated = false;
  let adminMigrated = false;

  if (existsSync(ROOMS_DIR)) {
    const files = readdirSync(ROOMS_DIR).filter(f => f.endsWith(".json"));
    for (const file of files) {
      try {
        const roomPath = join(ROOMS_DIR, file);
        const roomData = JSON.parse(readFileSync(roomPath, "utf-8"));
        const existing = getRoom(roomData.id);
        if (!existing) {
          createRoom({
            id: roomData.id,
            created: roomData.created,
            lastActivity: roomData.lastActivity,
            creatorId: roomData.creatorId,
            passwordHash: roomData.passwordHash,
            destruct: roomData.destruct,
            topology: roomData.topology
          });
          roomsMigrated++;
        }
        unlinkSync(roomPath);
      } catch (e) {
        console.error(`Failed to migrate room ${file}:`, e);
      }
    }
  }

  if (existsSync(SETTINGS_PATH)) {
    try {
      const settings = JSON.parse(readFileSync(SETTINGS_PATH, "utf-8"));
      for (const [key, value] of Object.entries(settings)) {
        setSetting(key, JSON.stringify(value));
      }
      unlinkSync(SETTINGS_PATH);
      settingsMigrated = true;
    } catch (e) {
      console.error("Failed to migrate settings:", e);
    }
  }

  if (existsSync(ADMIN_CONFIG_PATH)) {
    try {
      const adminConfig = JSON.parse(readFileSync(ADMIN_CONFIG_PATH, "utf-8"));
      setSetting("admin_password_hash", adminConfig.passwordHash);
      setSetting("admin_created_at", adminConfig.createdAt);
      unlinkSync(ADMIN_CONFIG_PATH);
      adminMigrated = true;
    } catch (e) {
      console.error("Failed to migrate admin config:", e);
    }
  }

  return { rooms: roomsMigrated, settings: settingsMigrated, admin: adminMigrated };
}

export function getDatabase(): Database {
  return db;
}

export function closeDatabase(): void {
  db.close();
}
