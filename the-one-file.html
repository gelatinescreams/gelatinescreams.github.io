<!DOCTYPE html> 
 <html lang="en" style="--panel: #0b0e13; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #4fd1c5; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 103px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #0f172a; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 41px; --node-sub-size: 27px; --node-font: monospace; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
	  .toggle-switch{position:relative;display:inline-block;min-width:44px !important;height:24px;flex-shrink:0;vertical-align:middle;}
		.toggle-switch input{opacity:0;width:0;height:0;position:absolute;}
		.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#475569;transition:.25s;border-radius:24px;}
		.toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#e2e8f0;transition:.25s;border-radius:50%;}
		.toggle-switch input:checked+.toggle-slider{background:var(--accent);}
		.toggle-switch input:checked+.toggle-slider:before{transform:translateX(20px);}
		.anim-zone-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;}
		.anim-zone-row label{color:var(--text-main);font-size:14px;}
		.anim-zone-section{font-size:11px;color:var(--text-soft);margin:12px 0 6px;text-transform:uppercase;letter-spacing:0.05em;border-bottom:1px solid var(--edge-main);padding-bottom:4px;}
		.anim-zone-header{font-size:12px;color:var(--accent);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.05em;font-weight:600;}
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
	  .fov-group {
        transition: opacity 0.3s ease;
      }
      g[data-node-id]:not(:hover) .fov-group {
        opacity: 0.7;
      }
      g[data-node-id]:hover .fov-group {
        opacity: 1;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
	  .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 8px;
      fill: none;
      }
	  .minimap-wall {
      pointer-events: none;
      }
      .minimap-rect {
      pointer-events: none;
      }	  
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      pointer-events: auto;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
.style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
.style-row {
  display: contents;
}
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  #dialog-modal {
	  z-index: 9999999;
	  background: rgba(0, 0, 0, 0.7);
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
	  .fov-group {
  transition: opacity 0.3s ease;
}
g[data-node-id]:not(:hover) .fov-group {
  opacity: 0.6;
}
g[data-node-id]:hover .fov-group {
  opacity: 1;
}
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      align-items: center;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }

	  #map .node-hit-area,
	  #map .group-indicator,
	  #map .lock-indicator,
	  #map .fov-group,
	  #map .edge-arrow-forward,
	  #map .edge-arrow-backward {
		display: none !important;
	  }

	  #map .node-circle,
	  #map .node-shape {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }

	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

	  #map .rect-group rect {
		stroke: #333 !important;
	  }

	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

html.rtl {
  direction: rtl;
}
html.rtl .sidebar { left: auto; right: 0; }
html.rtl .mobile-footer { direction: rtl; }
html.rtl .modal-content { text-align: right; }
html.rtl .modal-buttons { flex-direction: row-reverse; }
html.rtl .style-row { flex-direction: row-reverse; }
html.rtl .style-row label { text-align: right; }
html.rtl input, html.rtl select, html.rtl textarea { text-align: right; }
html.rtl .topbar { flex-direction: row-reverse; }
html.rtl .topbar-left { flex-direction: row-reverse; }
html.rtl .topbar-right { flex-direction: row-reverse; }
html.rtl details summary { text-align: right; }
html.rtl .node-panel-content { direction: rtl; }
html.rtl .help-content li { text-align: right; }
html.rtl table { direction: rtl; }
html.rtl td:first-child { text-align: right; }
html.rtl .lang-string-row { flex-direction: row-reverse; }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title" data-lang="editModal.editTitle">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-save" id="modal-save" data-lang="ui.buttons.save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3 data-lang="confirmModal.confirm">Confirm</h3>
        <p id="confirm-message" data-lang="confirmModal.deleteLineQuestion"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete" data-lang="ui.buttons.delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="error-modal">
      <div class="modal-content">
        <h3 id="error-modal-title" style="color: #dc2626;" data-lang="ui.modals.error">Error</h3>
        <p id="error-modal-message" style="margin: 16px 0; line-height: 1.6;"></p>
        <div class="modal-buttons">
          <button class="btn-save" id="error-modal-ok" data-lang="ui.buttons.close">OK</button>
        </div>
      </div>
    </div>
    <div class="modal" id="dialog-modal">
      <div class="modal-content">
        <h3 id="dialog-modal-title" data-lang="dialogs.confirm">Confirm</h3>
        <p id="dialog-modal-message" style="margin: 16px 0; line-height: 1.6; white-space: pre-wrap;"></p>
        <input type="text" id="dialog-modal-input" style="display: none; width: 100%; padding: 10px; margin-bottom: 16px; background: var(--input-bg); color: var(--input-text); border: 1px solid var(--input-border); border-radius: 6px; font-size: 14px;">
        <div class="modal-buttons" id="dialog-modal-buttons">
          <button class="btn-cancel" id="dialog-modal-cancel" data-lang="dialogs.cancel">Cancel</button>
          <button class="btn-save" id="dialog-modal-ok" data-lang="dialogs.ok">OK</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;" data-lang="help.title">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;" data-lang="help.tabs.general">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;" data-lang="help.tabs.desktop">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;" data-lang="help.tabs.mobile">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;" data-lang="help.tabs.formats">Import/Export</button>
          <button class="help-tab" data-tab="recording" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;" data-lang="help.tabs.recording">Recording</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong data-lang="help.general.addNodes">Add Nodes:</strong> <span data-lang="help.general.addNodesDesc">Click "+ Node" or "+ Rack" in the top menu</span></li>
            <li><strong data-lang="help.general.connectNodes">Connect Nodes:</strong> <span data-lang="help.general.connectNodesDesc">Select a node, then use "Add Connection" in the panel</span></li>
            <li><strong data-lang="help.general.moveNodes">Move Nodes:</strong> <span data-lang="help.general.moveNodesDesc">Drag nodes to reposition them</span></li>
            <li><strong data-lang="help.general.enterRackView">Enter Rack View:</strong> <span data-lang="help.general.enterRackViewDesc">Double click on desktop or Long press on mobile</span></li>
            <li><strong data-lang="help.general.multiSelect">Multi Select:</strong> <span data-lang="help.general.multiSelectDesc">Right click (desktop) or double tap (mobile)</span></li>
            <li><strong data-lang="help.general.panCanvas">Pan Canvas:</strong> <span data-lang="help.general.panCanvasDesc">Drag empty space or hold Space + drag</span></li>
            <li><strong data-lang="help.general.zoom">Zoom:</strong> <span data-lang="help.general.zoomDesc">Scroll wheel or pinch gesture</span></li>
            <li><strong data-lang="help.general.freeDraw">Free Draw:</strong> <span data-lang="help.general.freeDrawDesc">Use draw toolbar for drawing lines, boxes/zones, and text</span></li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;" data-lang="help.general.savingEncryption">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;" data-lang="help.general.savingNote">Browsers cannot overwrite local files. Click Save File to download an updated HTML with all changes. Replace your old file to keep edits. An automatic backup is also saved to your browser's local storage and will prompt for recovery if you close without saving.</p>
          <p style="margin-bottom: 8px;"><strong data-lang="help.general.encryptionNote">Encryption of data:</strong> <span data-lang="help.general.encryptionDesc">Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</span></p>
          <p><strong data-lang="help.general.decryptionNote">Decryption of data:</strong> <span data-lang="help.general.decryptionDesc">Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</span></p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.desktop.navigation">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.arrowKeys">Arrow Keys</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.moveSelected1px">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.shiftArrows">Shift + Arrows</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.moveSelected10px">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.tabShiftTab">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.cycleNodes">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.fKey">F</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.focusSelected">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.spaceDrag">Space + Drag</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.panCanvas">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.desktop.management">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.lKey">L</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.lockUnlock">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.gKey">G</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.groupUngroup">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.ctrlCV">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.copyPaste">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.ctrlD">Ctrl+D</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.duplicate">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.ctrlA">Ctrl+A</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.selectAll">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.deleteKey">Delete</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.deleteSelected">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.escapeKey">Escape</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.clearSelection">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.ctrlZY">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.undoRedo">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.rightClick">Right Click</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.multiSelectToggle">Multi select toggle</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.dblClickRack">Double click rack</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.enterRackView">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.dblClickConnection">Double click connection</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.addWaypoint">Add waypoint</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;" data-lang="help.desktop.dblClickEmpty">Double click empty (in rack)</code></td>
              <td style="padding: 8px;" data-lang="help.desktop.exitRackView">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.mobile.basicGestures">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.tapNode">Tap node</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.selectOpenProperties">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.tapEmpty">Tap empty</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.deselectAll">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.dragNode">Drag node</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.moveNode">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.dragEmpty">Drag empty</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.panCanvas">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.pinch">Pinch</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.zoomInOut">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.doubleTapNode">Double tap node</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.addRemoveSelection">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.mobile.rackView">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.longPressRack">Long press rack</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.enterRackView">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.longPressConnection">Long press connection</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.addWaypoint">Add waypoint</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong data-lang="help.mobile.doubleTapEmpty">Double tap empty</strong></td>
              <td style="padding: 8px;" data-lang="help.mobile.exitRackView">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.formats.exportHelp">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.html">HTML</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.htmlDesc">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.json">JSON</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.jsonExportDesc">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.markdown">Markdown</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.markdownExportDesc">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.csv">CSV</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.csvExportDesc">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.png">PNG</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.pngDesc">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.svg">SVG</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.svgDesc">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.formats.importHelp">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.json">JSON</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.jsonImportDesc">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.markdown">Markdown</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.markdownImportDesc">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.csv">CSV</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.csvImportDesc">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.formats.html">HTML</strong></td>
                <td style="padding: 8px;" data-lang="help.formats.htmlImportDesc">Import data from another saved HTML file. Extracts and restores all topology data from a previously exported file.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div id="help-tab-recording" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;" data-lang="help.recording.title">Canvas Recording</h4>
          <p style="margin-bottom: 12px;" data-lang="help.recording.overview">Record your canvas activity to create visual documentation, tutorials, or demonstrations of your network topology changes.</p>
          <h4 style="color: var(--accent); margin-bottom: 8px; margin-top: 16px;" data-lang="help.recording.howItWorks">How It Works</h4>
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li data-lang="help.recording.capturesCanvas">Records the canvas area in real-time as you work</li>
            <li data-lang="help.recording.fullInteraction">Continue adding nodes, creating connections, dragging elements, and making any changes while recording</li>
            <li data-lang="help.recording.savedInFile">Recordings are saved within your data file for later playback</li>
            <li data-lang="help.recording.exportVideo">Can be exported as a video file (WebM format) for sharing</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px; margin-top: 16px;" data-lang="help.recording.controls">Controls</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong style="color: #f56565;">●</strong> <span data-lang="help.recording.recordBtn">Record</span></td>
                <td style="padding: 8px;" data-lang="help.recording.recordBtnDesc">Start recording the canvas</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>▶</strong> <span data-lang="help.recording.playBtn">Play</span></td>
                <td style="padding: 8px;" data-lang="help.recording.playBtnDesc">Play back a saved recording</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>■</strong> <span data-lang="help.recording.stopBtn">Stop</span></td>
                <td style="padding: 8px;" data-lang="help.recording.stopBtnDesc">Stop recording or playback</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>❚❚</strong> <span data-lang="help.recording.pauseBtn">Pause</span></td>
                <td style="padding: 8px;" data-lang="help.recording.pauseBtnDesc">Pause playback</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.recording.scrubber">Scrubber</strong></td>
                <td style="padding: 8px;" data-lang="help.recording.scrubberDesc">Seek to any point in the recording</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.recording.speed">Speed</strong></td>
                <td style="padding: 8px;" data-lang="help.recording.speedDesc">Adjust playback speed (0.5x, 1x, 2x, 4x)</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong data-lang="help.recording.loop">Loop</strong></td>
                <td style="padding: 8px;" data-lang="help.recording.loopDesc">Toggle continuous loop playback</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>...</strong> <span data-lang="help.recording.manage">Manage</span></td>
                <td style="padding: 8px;" data-lang="help.recording.manageDesc">View, rename, export, or delete saved recordings</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2 data-lang="ui.modals.settings">Settings</h2>
        <details class="style-section" open>
          <summary data-lang="ui.sections.mappingModeTheme">Mapping Mode & Theme</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.mode">Mode</label>
              <select id="mapping-mode-select">
                <option value="network" data-lang="modes.network.name">Network Topology</option>
                <option value="mindmap" data-lang="modes.mindmap.name">Mind Map</option>
                <option value="sports" data-lang="modes.sports.name">Sports Playbook</option>
                <option value="smarthome" data-lang="modes.smarthome.name">Smart Home</option>
                <option value="floorplan" data-lang="modes.floorplan.name">Floor Plan / Blueprint</option>
              </select>
            </div>
            <div class="style-row" id="canvas-style-row">
              <label data-lang="ui.labels.canvasStyle">Canvas Style</label>
              <select id="canvas-style-select">
                <option value="grid" data-lang="canvas.grid">Standard Grid</option>
                <option value="dots" data-lang="canvas.dots">Dot Grid</option>
                <option value="blueprint" data-lang="canvas.blueprint">Blueprint Grid</option>
                <option value="none" data-lang="canvas.none">No Grid</option>
              </select>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.themePreset">Theme Preset</label>
              <div style="display:flex;gap:6px;align-items:center;">
                <select id="theme-preset" style="flex:1;">
                  <option value="defaulted" data-lang="themes.default">Default</option>
                  <option value="" data-lang="ui.options.custom">Custom</option>
                  <optgroup label="Corporate" data-lang-label="themeGroups.corporate">
                    <option value="slate" data-lang="themes.slate">Slate</option>
                    <option value="graphite" data-lang="themes.graphite">Graphite</option>
                    <option value="frost" data-lang="themes.frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab" data-lang-label="themeGroups.homelab">
                    <option value="synthwave" data-lang="themes.synthwave">Synthwave</option>
                    <option value="terminal" data-lang="themes.terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev" data-lang-label="themeGroups.dev">
                    <option value="dracula" data-lang="themes.dracula">Dracula</option>
                    <option value="cobalt" data-lang="themes.cobalt">Cobalt</option>
                    <option value="solarized" data-lang="themes.solarized">Solarized</option>
                  </optgroup>
                  <optgroup label="Mind Map" data-lang-label="themeGroups.mindMap">
                    <option value="brainwave" data-lang="themes.brainwave">Brainwave</option>
                                        <option value="neonMint" data-lang="themes.neonMint">Neon Mint</option>
                    <option value="velvetDusk" data-lang="themes.velvetDusk">Velvet Dusk</option>
                    <option value="sunburst" data-lang="themes.sunburst">Sunburst</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes" data-lang-label="themeGroups.myThemes"></optgroup>
                </select>
                <button onclick="saveCurrentTheme()" data-lang="tooltips.saveCurrentTheme" data-lang-attr="title" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;" data-lang-text="ui.buttons.save">Save</button>
                <button id="delete-theme-btn" onclick="deleteCurrentTheme()" data-lang="tooltips.deleteTheme" data-lang-attr="title" style="padding:4px 8px;background:var(--danger);color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:12px;" data-lang-text="ui.buttons.del">Del</button>
              </div>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.mainBackground">Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.accentColor">Accent Color</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.primaryText">Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.viewOnlyMode">View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.viewOnly">View Only (disable editing)</label>
              <label class="toggle-switch"><input type="checkbox" id="view-only-mode"><span class="toggle-slider"></span></label>
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);" data-lang="messages.viewOnlyNote">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.moreThemeOptions">More Theme Options</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.sidebar">Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.modalBg">Modal Window Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.dangerButtons">Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.secondaryText">Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.tagFill">Tag(s) Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.tagText">Tag(s) Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.tagBorder">Tag(s) Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary data-lang="ui.sections.topBar">Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.background">Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.border">Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.buttonFill">Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.buttonText">Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.mainCanvas">Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.border">Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.gridLines">Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.gridSize">Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
			<label data-lang="ui.labels.showGrid">Show Grid</label>
			<label class="toggle-switch"><input type="checkbox" id="canvas-grid-enabled" checked><span class="toggle-slider"></span></label>
			</div>
			<div class="style-row">
              <label data-lang="ui.labels.bgTop">Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.bgBottom">Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.solidBg">Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);" data-lang="messages.setSolidBgNote">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary data-lang="ui.sections.rackCanvas">Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.frameFill">Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.frameBorder">Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.gridLines">Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
			<div class="style-row">
			  <label data-lang="ui.labels.showGrid">Show Grid</label>
			  <label class="toggle-switch"><input type="checkbox" id="rack-grid-enabled" checked><span class="toggle-slider"></span></label>
			</div>
            <div class="style-row">
              <label data-lang="ui.labels.uLabels">U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary data-lang="ui.sections.canvasToolbars">Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.background">Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.border">Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.text">Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.buttonFill">Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.buttonText">Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.minimapDots">Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.nodes">Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.fill">Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.border">Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.titleColor">Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.titleSize">Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.subtitleColor">Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.subtitleSize">Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.font">Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif" data-lang="ui.fonts.inter">Inter</option>
                <option value="Arial, sans-serif" data-lang="ui.fonts.arial">Arial</option>
                <option value="Helvetica, sans-serif" data-lang="ui.fonts.helvetica">Helvetica</option>
                <option value="Georgia, serif" data-lang="ui.fonts.georgia">Georgia</option>
                <option value="monospace" data-lang="ui.fonts.monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.connections">Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.defaultColor">Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.defaultRouting">Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal" data-lang="ui.options.orthogonal">Orthogonal (90°)</option>
                <option value="curved" data-lang="ui.options.curved">Curved</option>
                <option value="straight" data-lang="ui.options.straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.animationStyle">Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows" data-lang="ui.options.flowingArrows">Flowing Arrows</option>
                <option value="dots" data-lang="ui.options.dotArrows">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.animateDirections">Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all" data-lang="ui.options.allDirections">All Directions</option>
                <option value="forward" data-lang="ui.options.forwardOnly">Forward Only</option>
                <option value="backward" data-lang="ui.options.backwardOnly">Backward Only</option>
                <option value="both" data-lang="ui.options.bidirectionalOnly">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.animationSpeed">Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5" data-lang="ui.options.veryFast">Very Fast</option>
                <option value="1" data-lang="ui.options.fast">Fast</option>
                <option value="1.5" data-lang="ui.options.normal">Normal</option>
                <option value="2.5" data-lang="ui.options.slow">Slow</option>
                <option value="4" data-lang="ui.options.verySlow">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;" data-lang="ui.buttons.applyRoutingAll">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary data-lang="ui.sections.animationsZones">Animations &amp; Zones</summary>
          <div class="style-content">
            <div class="style-row"><label data-lang="ui.labels.allAnimations">All Animations</label><label class="toggle-switch"><input type="checkbox" id="anim-master" checked><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;" data-lang="ui.sections.byType">By Type</div>
            <div class="style-row"><label data-lang="ui.labels.sweepPan">Sweep (Pan)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-sweep" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.pulseBreathe">Pulse (Breathe)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-pulse" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.ringsEmanate">Rings (Emanate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-rings" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.spinRotate">Spin (Rotate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-spin" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.connectionsFlow">Connections (Flow)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-connections" checked><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;" data-lang="ui.sections.byCategory">By Category</div>
            <div class="style-row"><label data-lang="ui.labels.cameras">Cameras</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-camera" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.doorbells">Doorbells</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-doorbell" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.motionSensors">Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-motion" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.smokeDetectors">Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-smoke" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.wifiApRouter">WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-wifi" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.sensorsIot">Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sensor" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.sprinklers">Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sprinkler" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.sections.connections">Connections</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-connections" checked><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:12px;color:var(--accent);text-transform:uppercase;letter-spacing:0.05em;font-weight:600;margin-top:16px;padding-top:12px;border-top:1px solid var(--edge-main);" data-lang="ui.sections.zoneSettings">Zone (Animation Cone) Settings</div>
            <div class="style-row"><label data-lang="ui.labels.allZones">All Zones</label><label class="toggle-switch"><input type="checkbox" id="zone-master" checked><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;" data-lang="ui.sections.byCategory">By Category</div>
            <div class="style-row"><label data-lang="ui.labels.cameras">Cameras</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-camera" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.doorbells">Doorbells</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-doorbell" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.motionSensors">Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-motion" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.smokeDetectors">Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-smoke" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.wifiApRouter">WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-wifi" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.sensorsIot">Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sensor" checked><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label data-lang="ui.labels.sprinklers">Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sprinkler" checked><span class="toggle-slider"></span></label></div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.groupsEditing">Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.resizeHandleColor">Resize Handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.resizeHandleSize">Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.groupedIconOutline">Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.multiselectFill">Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.multiselectFillOpacity">Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.multiselectBorder">Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.multiselectBorderWidth">Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.multiselectBorderStyle">Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5" data-lang="ui.options.dashed">Dashed</option>
                <option value="2,4" data-lang="ui.options.dotted">Dotted</option>
                <option value="none" data-lang="ui.options.solid">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.inputsDropdowns">Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.background">Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.text">Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.border">Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.font">Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif" data-lang="ui.fonts.inter">Inter</option>
                <option value="Arial, sans-serif" data-lang="ui.fonts.arial">Arial</option>
                <option value="Helvetica, sans-serif" data-lang="ui.fonts.helvetica">Helvetica</option>
                <option value="Georgia, serif" data-lang="ui.fonts.georgia">Georgia</option>
                <option value="monospace" data-lang="ui.fonts.monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.fontSize">Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.sections.welcomeMessage">Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.enabled">Enabled</label>
              <label class="toggle-switch"><input type="checkbox" id="canvas-hint-enabled" checked><span class="toggle-slider"></span></label>
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.background">Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label data-lang="ui.labels.textColor">Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label data-lang="ui.labels.customText">Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default" data-lang="ui.placeholders.leaveEmpty" data-lang-attr="placeholder"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary data-lang="ui.labels.language">Language</summary>
          <div class="style-content">
            <div class="style-row">
              <label data-lang="ui.labels.currentLanguage">Current:</label>
              <span id="current-lang-name" style="color:var(--accent);font-weight:600;">English</span>
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;gap:8px;">
		    <div class="style-row">
				<button onclick="openLanguageEditor()" style="width:100%;fflex:1;padding:6px 12px;background:var(--accent);color:var(--bg);border:1px solid var(--topbar-border);border-radius:6px;cursor:pointer;font-size:13px;" data-lang="ui.buttons.editStrings">Edit Strings</button>
            </div>
            <div class="style-row">
           <button onclick="exportLanguageFile()" style="width:100%;flex:1;padding:6px 12px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--topbar-border);border-radius:6px;cursor:pointer;font-size:13px;" data-lang="ui.buttons.exportLang">Export Language File</button>
            </div>
			    <div class="style-row">
					<button onclick="document.getElementById('import-lang-file').click()" style="width:100%;fflex:1;padding:6px 12px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--topbar-border);border-radius:6px;cursor:pointer;font-size:13px;" data-lang="ui.buttons.importLang">Import Language File</button>
				<input type="file" id="import-lang-file" accept=".json" style="display:none">
            </div>
            <div class="style-row">
        <button onclick="resetToDefaultLanguage()" style="width:100%;padding:6px 12px;background:var(--btn-bg);color:var(--text-soft);border:1px solid var(--topbar-border);border-radius:6px;cursor:pointer;font-size:13px;" data-lang="ui.buttons.resetLang">Reset to English</button>
            </div>		          
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary data-lang="ui.sections.dangerZone">Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);" data-lang="messages.dangerZoneNote">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" data-lang="tooltips.clearAllNodes" data-lang-attr="title" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;" data-lang-text="ui.buttons.clearAll">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="language-editor-modal">
      <div class="modal-content" style="max-width:900px;max-height:85vh;display:flex;flex-direction:column;">
        <h3 data-lang="ui.modals.languageEditor">Language Editor</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;" class="lang-editor-tabs">
          <button class="lang-tab active" data-filter="all" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--accent);color:var(--bg);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.all">All</button>
          <button class="lang-tab" data-filter="modes" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.modes">Modes</button>
          <button class="lang-tab" data-filter="modes.network" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.network">Network</button>
          <button class="lang-tab" data-filter="modes.mindmap" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.mindMap">Mind Map</button>
          <button class="lang-tab" data-filter="modes.sports" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.sports">Sports</button>
          <button class="lang-tab" data-filter="modes.smarthome" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.smartHome">Smart Home</button>
          <button class="lang-tab" data-filter="modes.floorplan" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.floorPlan">Floor Plan</button>
          <button class="lang-tab" data-filter="ui" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.ui">UI</button>
          <button class="lang-tab" data-filter="shapes" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.shapes">Shapes</button>
          <button class="lang-tab" data-filter="messages" style="padding:6px 12px;border:1px solid var(--topbar-border);border-radius:4px;background:var(--btn-bg);color:var(--btn-text);cursor:pointer;font-size:12px;" data-lang="langEditor.tabs.messages">Messages</button>
        </div>
        <input type="text" id="lang-search" placeholder="Search strings..." style="width:100%;padding:8px 12px;margin-bottom:12px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:6px;" data-lang="langEditor.searchPlaceholder" data-lang-attr="placeholder">
        <div class="lang-editor-list" style="flex:1;overflow-y:auto;border:1px solid var(--topbar-border);border-radius:6px;background:var(--panel-alt);"></div>
        <div class="modal-buttons" style="margin-top:12px;">
          <button class="btn-cancel" onclick="closeLanguageEditor()" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-save" onclick="saveLangEdits()" data-lang="ui.buttons.saveChanges">Save Changes</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3 id="add-node-title" data-lang="ui.modals.addNode">Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.name">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server" data-lang="ui.placeholders.nodeName" data-lang-attr="placeholder">
        <label id="new-node-ip-label" style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.ip">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100" data-lang="ui.placeholders.nodeIp" data-lang-attr="placeholder">
        <label id="new-node-tags-label" style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.tagsComma">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn" data-lang="ui.placeholders.tags" data-lang-attr="placeholder">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.category">Category</label>
        <select id="new-node-category">
          <option value="basic" data-lang="shapes.categories.basic">Basic Shapes</option>
          <option value="computers" data-lang="shapes.categories.computers">Computers & Devices</option>
          <option value="network" data-lang="shapes.categories.network">Network Equipment</option>
          <option value="cloud" data-lang="shapes.categories.cloud">Cloud & Services</option>
          <option value="security" data-lang="shapes.categories.security">Security & Monitoring</option>
          <option value="smarthome" data-lang="shapes.categories.smarthome">Smart Home</option>
          <option value="sports" data-lang="shapes.categories.sports">Sports</option>
          <option value="rack" data-lang="shapes.categories.rack">Rack Equipment</option>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.shape">Shape</label>
        <select id="new-node-shape"></select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-save" id="add-node-save" data-lang="ui.buttons.addNode">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3 id="add-rack-title" data-lang="ui.modals.addRack">Add New Rack</h3>
        <label id="new-rack-name-label" style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.name">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01" data-lang="ui.placeholders.rackName" data-lang-attr="placeholder">
        <label id="new-rack-ip-label" style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.networkRange">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24" data-lang="ui.placeholders.rackIp" data-lang-attr="placeholder">
        <label id="new-rack-tags-label" style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.tagsComma">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1" data-lang="ui.placeholders.rackTags" data-lang-attr="placeholder">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.category">Category</label>
        <select id="new-rack-category">
          <option value="basic" data-lang="shapes.categories.basic">Basic Shapes</option>
          <option value="computers" data-lang="shapes.categories.computers">Computers & Devices</option>
          <option value="network" data-lang="shapes.categories.network">Network Equipment</option>
          <option value="cloud" data-lang="shapes.categories.cloud">Cloud & Services</option>
          <option value="security" data-lang="shapes.categories.security">Security & Monitoring</option>
          <option value="smarthome" data-lang="shapes.categories.smarthome">Smart Home</option>
          <option value="sports" data-lang="shapes.categories.sports">Sports</option>
          <option value="rack" data-lang="shapes.categories.rack">Rack Equipment</option>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.icon">Icon / Shape</label>
        <select id="new-rack-shape"></select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;" data-lang="ui.labels.rackCapacity">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="" data-lang="rack.capacity42">42U (Standard Full Rack)</option>
          <option value="48" data-lang="rack.capacity48">48U (Large Rack)</option>
          <option value="24" data-lang="rack.capacity24">24U (Half Rack)</option>
          <option value="12" data-lang="rack.capacity12">12U (Small/Wall Mount)</option>
          <option value="6" data-lang="rack.capacity6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save" data-lang="ui.buttons.addRack">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3 data-lang="ui.modals.clearAllNodes">Clear All Nodes</h3>
        <p data-lang="messages.clearAllWarning"> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm" data-lang="messages.clearEverything">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3 data-lang="ui.modals.layerVisibility">Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.layerToggleNote">Toggle which layers are visible on the canvas</p>
        <div id="layer-toggles-container" style="display: flex; flex-direction: column; gap: 10px;">
          <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <label class="toggle-switch"><input type="checkbox" id="layer-1" checked><span class="toggle-slider"></span></label>
          <span id="layer-1-label" style="flex: 1; font-weight: 500;">Physical Layer</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <label class="toggle-switch"><input type="checkbox" id="layer-2" checked><span class="toggle-slider"></span></label>
          <span id="layer-2-label" style="flex: 1; font-weight: 500;">Logical Layer</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <label class="toggle-switch"><input type="checkbox" id="layer-3" checked><span class="toggle-slider"></span></label>
          <span id="layer-3-label" style="flex: 1; font-weight: 500;">Security Layer</span>
          </div>
          <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <label class="toggle-switch"><input type="checkbox" id="layer-4" checked><span class="toggle-slider"></span></label>
          <span id="layer-4-label" style="flex: 1; font-weight: 500;">Application Layer</span>
          </div>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();" data-lang="ui.buttons.hideAll">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();" data-lang="ui.buttons.showAll">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 data-lang="ui.modals.tabs">Tabs</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.manageTopologies">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name" data-lang="tabsModal.mainTopology">Main Topology</div>
              <div class="tab-stats" data-lang="ui.stats.nodesConnections">0 nodes • 0 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" data-lang="tooltips.renameTab" data-lang-attr="title">✏️</button>
                
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);" data-lang="ui.placeholders.newTabName" data-lang-attr="placeholder">
          <button class="btn-save" onclick="createNewTab()" data-lang="ui.buttons.addTab">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3 data-lang="ui.modals.versionHistory">Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.snapshotLimit">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()" data-lang="ui.buttons.clearHistory">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()" data-lang="ui.buttons.createSnapshot">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3 data-lang="ui.modals.auditLog">Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.trackChanges">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all" data-lang="auditLog.allEvents">All Events</option>
            <option value="node" data-lang="auditLog.nodeOperations">Node Operations</option>
            <option value="connection" data-lang="auditLog.connections">Connections</option>
            <option value="style" data-lang="auditLog.styleChanges">Style Changes</option>
            <option value="rack" data-lang="auditLog.rackOperations">Rack Operations</option>
            <option value="layer" data-lang="auditLog.layerChanges">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()" data-lang="ui.buttons.export">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()" data-lang="ui.buttons.clearLog">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3 data-lang="ui.modals.portMap">Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.portMapDesc">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);" data-lang="portMap.searchPlaceholder" data-lang-attr="placeholder">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all" data-lang="portMap.allConnections">All Connections</option>
            <option value="with-ports" data-lang="portMap.withPorts">With Ports Only</option>
            <option value="without-ports" data-lang="portMap.missingPorts">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);" data-lang="portMap.noConnections">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()" data-lang="ui.buttons.exportCsv">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 data-lang="ui.modals.notes">Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.notesEncryptionNote">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);" data-lang="notes.noNotes">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);" data-lang="notes.namePlaceholder" data-lang-attr="placeholder">
          <button class="btn-save" onclick="createNewSecret()" data-lang="ui.buttons.addNote">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title" data-lang="notes.editNote">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;" data-lang="notes.contentPlaceholder" data-lang-attr="placeholder"></textarea>
        <div style="margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
          <label class="toggle-switch"><input type="checkbox" id="secret-auto-encrypt" checked><span class="toggle-slider"></span></label>
          <span data-lang="notes.encryptNote">Encrypt Note</span>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()" data-lang="ui.buttons.cancel">Cancel</button>
          <button class="btn-save" onclick="saveSecret()" data-lang="ui.buttons.save">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;" data-lang="ui.modals.export">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.pngImage">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.svgVector">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.jsonBackup">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.markdown">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.csv">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.printBW">Print B&W</button>
          <button onclick="printTopologyColor(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.printColor">Print Color</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileExport.exportHelp">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;" data-lang="ui.buttons.cancel">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;" data-lang="ui.modals.import">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-html-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileImport.html">HTML</button>
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileImport.json">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileImport.markdown">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileImport.csv">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;" data-lang="mobileImport.importHelp">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;" data-lang="ui.buttons.cancel">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <div class="modal" id="welcome-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
        <h2 style="margin-bottom: 8px; text-align: center;" data-lang="welcome.title">Welcome to The One File</h2>
        <p style="font-size: 14px; color: var(--text-soft); margin-bottom: 16px; text-align: center;" data-lang="welcome.subtitle">What are you mapping today?</p>
        <div id="welcome-mode-buttons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 20px;">
          <button class="welcome-mode-btn" data-mode="network" style="padding: 12px 16px; background: var(--panel-alt); border: 2px solid var(--accent); border-radius: 8px; color: var(--text-main); font-size: 14px; cursor: pointer; text-align: left; transition: all 0.2s;">
            <strong data-lang="welcome.modes.network">Network Topology</strong>
            <span style="display: block; font-size: 11px; color: var(--text-soft); margin-top: 2px;" data-lang="welcome.modes.networkDesc">Servers, routers, switches</span>
          </button>
          <button class="welcome-mode-btn" data-mode="mindmap" style="padding: 12px 16px; background: var(--panel-alt); border: 2px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 14px; cursor: pointer; text-align: left; transition: all 0.2s;">
            <strong data-lang="welcome.modes.mindmap">Mind Map</strong>
            <span style="display: block; font-size: 11px; color: var(--text-soft); margin-top: 2px;" data-lang="welcome.modes.mindmapDesc">Ideas, concepts, brainstorming</span>
          </button>
          <button class="welcome-mode-btn" data-mode="sports" style="padding: 12px 16px; background: var(--panel-alt); border: 2px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 14px; cursor: pointer; text-align: left; transition: all 0.2s;">
            <strong data-lang="welcome.modes.sports">Sports Playbook</strong>
            <span style="display: block; font-size: 11px; color: var(--text-soft); margin-top: 2px;" data-lang="welcome.modes.sportsDesc">Plays, formations, positions</span>
          </button>
          <button class="welcome-mode-btn" data-mode="smarthome" style="padding: 12px 16px; background: var(--panel-alt); border: 2px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 14px; cursor: pointer; text-align: left; transition: all 0.2s;">
            <strong data-lang="welcome.modes.smarthome">Smart Home</strong>
            <span style="display: block; font-size: 11px; color: var(--text-soft); margin-top: 2px;" data-lang="welcome.modes.smarthomeDesc">IoT devices, automation</span>
          </button>
          <button class="welcome-mode-btn" data-mode="floorplan" style="padding: 12px 16px; background: var(--panel-alt); border: 2px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 14px; cursor: pointer; text-align: left; transition: all 0.2s; grid-column: span 2;">
            <strong data-lang="welcome.modes.floorplan">Floor Plan / Blueprint</strong>
            <span style="display: block; font-size: 11px; color: var(--text-soft); margin-top: 2px;" data-lang="welcome.modes.floorplanDesc">Rooms, layouts, physical spaces</span>
          </button>
        </div>
        <div id="welcome-canvas-row" style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
          <label style="font-size: 13px; color: var(--text-main); min-width: 80px;" data-lang="welcome.canvasStyle">Canvas Style</label>
          <select id="welcome-canvas-select" style="flex: 1; padding: 6px 10px; background: var(--input-bg); color: var(--input-text); border: 1px solid var(--input-border); border-radius: 4px;">
            <option value="grid" data-lang="welcome.canvas.grid">Standard Grid</option>
            <option value="dots" data-lang="welcome.canvas.dots">Dot Grid</option>
            <option value="blueprint" data-lang="welcome.canvas.blueprint">Blueprint Grid</option>
            <option value="none" data-lang="welcome.canvas.none">No Grid</option>
          </select>
        </div>
        <div id="welcome-canvas-preview" style="height: 60px; margin-bottom: 12px; border: 1px solid var(--edge-main); border-radius: 4px; background: var(--bg); overflow: hidden;"></div>
        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
          <label style="font-size: 13px; color: var(--text-main); min-width: 80px;" data-lang="welcome.theme">Theme</label>
          <select id="welcome-theme-select" style="flex: 1; padding: 6px 10px; background: var(--input-bg); color: var(--input-text); border: 1px solid var(--input-border); border-radius: 4px;">
            <option value="defaulted" selected data-lang="themes.default">Default</option>
            <option value="" data-lang="ui.options.customColors">Custom Colors</option>
            <optgroup label="Corporate" data-lang-label="themeGroups.corporate">
              <option value="slate" data-lang="themes.slate">Slate</option>
              <option value="graphite" data-lang="themes.graphite">Graphite</option>
              <option value="frost" data-lang="themes.frost">Frost (Light)</option>
            </optgroup>
            <optgroup label="Homelab" data-lang-label="themeGroups.homelab">
              <option value="synthwave" data-lang="themes.synthwave">Synthwave</option>
              <option value="terminal" data-lang="themes.terminal">Terminal</option>
            </optgroup>
            <optgroup label="Dev" data-lang-label="themeGroups.dev">
              <option value="dracula" data-lang="themes.dracula">Dracula</option>
              <option value="cobalt" data-lang="themes.cobalt">Cobalt</option>
              <option value="solarized" data-lang="themes.solarized">Solarized</option>
            </optgroup>
            <optgroup label="Mind Map" data-lang-label="themeGroups.mindMap">
              <option value="brainwave" data-lang="themes.brainwave">Brainwave</option>
                            <option value="neonMint" data-lang="themes.neonMint">Neon Mint</option>
              <option value="velvetDusk" data-lang="themes.velvetDusk">Velvet Dusk</option>
              <option value="sunburst" data-lang="themes.sunburst">Sunburst</option>
            </optgroup>
          </select>
        </div>
        <details style="margin-bottom: 12px; border: 1px solid var(--edge-main); border-radius: 6px; padding: 8px;">
          <summary style="cursor: pointer; font-size: 13px; color: var(--text-main); font-weight: 600;" data-lang="welcome.colorCustomization">Color Customization</summary>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px;">
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-bg-color" value="#0b0e13" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.mainBg">Top Bar Background</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-accent-color" value="#4fd1c5" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.accent">Accent</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-text-color" value="#e2e8f0" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.primaryText">Primary Text</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-text-soft-color" value="#94a3b8" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.secondaryText">Secondary Text</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-panel-color" value="#0f1318" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.sidebarPanel">Main Background</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-modal-color" value="#141921" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.modalWindows">Modal Background</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-danger-color" value="#f56565" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.dangerButtons">Grid Color</label>
            </div>
            <div style="display: flex; align-items: center; gap: 6px;">
              <input type="color" id="welcome-mobile-footer-color" value="#0b0e13" style="width: 32px; height: 24px; border: 1px solid var(--input-border); border-radius: 3px; cursor: pointer;">
              <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.mobileFooter">Sidebar Background</label>
            </div>
          </div>
		  <div style="text-align:center">
            <label style="font-size: 11px; color: var(--text-soft);" data-lang="welcome.colors.moreStyles">More styles available in main settings panel</label>
          </div>
        </details>
        <div style="display: flex; gap: 10px; justify-content: center;">
          <button id="welcome-start-btn" style="padding: 10px 24px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer;" data-lang="welcome.startMapping">Start Mapping</button>
          <button id="welcome-skip-btn" style="padding: 10px 24px; background: transparent; border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-soft); font-size: 14px; cursor: pointer;" data-lang="welcome.skip">Skip</button>
        </div>
      </div>
    </div>
    <div class="modal" id="recordings-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 data-lang="ui.modals.recordings">Recordings</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;" data-lang="messages.manageRecordings">Manage recorded movement sequences</p>
        <div id="recordings-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);" data-lang="recordings.noRecordings">No recordings yet. Press Record to start.</div></div>
        <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-start;">
          <button class="btn-save" onclick="exportRecordingVideo()" style="flex:0 0 auto;" data-lang="recordings.exportVideo">Export Video</button>
          <button class="btn-cancel" onclick="deleteSelectedRecording()" style="background:var(--danger);color:white;flex:0 0 auto;" data-lang="ui.buttons.delete">Delete</button>
          <button class="btn-cancel" id="recordings-modal-close" style="flex:0 0 auto;" data-lang="ui.buttons.close">Close</button>
        </div>
      </div>
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button" data-lang="topbar.saveHtml">Save HTML</button>
          <div style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);user-select: none;">
            <label class="toggle-switch"><input type="checkbox" id="encrypt-toggle"><span class="toggle-slider"></span></label>
            <span data-lang="ui.buttons.encrypt" data-lang-attr="title">🔒</span>
          </div>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button" data-lang="topbar.export">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()" data-lang="mobileExport.pngImage">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()" data-lang="mobileExport.svgVector">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()" data-lang="help.formats.json">JSON</button>
              <button type="button" onclick="exportMarkdown()" data-lang="help.formats.markdown">Markdown</button>
              <button type="button" onclick="exportCSV()" data-lang="help.formats.csv">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()" data-lang="ui.buttons.printBW">Print B&W</button>
              <button type="button" onclick="printTopologyColor()" data-lang="ui.buttons.printColor">Print Color</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()" data-lang="ui.buttons.exportHelp">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button" data-lang="topbar.import">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-html-file').click()" data-lang="help.formats.html">HTML</button>
              <button type="button" onclick="document.getElementById('import-json-file').click()" data-lang="help.formats.json">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()" data-lang="help.formats.markdown">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()" data-lang="help.formats.csv">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()" data-lang="ui.buttons.importHelp">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-html-file" accept=".html,.htm" style="display:none">
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" data-lang="tooltips.whySave" data-lang-attr="title">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" data-lang="tooltips.exitRackView" data-lang-attr="title" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;" data-lang-text="topbar.backToTopology">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" data-lang="tooltips.addNewNode" data-lang-attr="title" style="background: var(--accent)" draggable="true" data-lang-text="sidebar.addNode">+ Node</button>
        <button id="add-rack-btn" class="save-btn" data-lang="tooltips.addNewRack" data-lang-attr="title" style="background: var(--accent); margin-left: 8px;" draggable="true" data-lang-text="sidebar.addRack">+ Rack</button>
        <button id="undo-btn" data-lang="ui.tooltips.undo" data-lang-attr="title" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↶</button>
        <button id="redo-btn" data-lang="ui.tooltips.redo" data-lang-attr="title" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." data-lang="tooltips.searchNodes" data-lang-attr="title" data-lang-placeholder="ui.placeholders.search" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" data-lang="ui.tooltips.toggleLayers" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="ui.buttons.layers">Layers</button>
        <button id="tabs-btn" data-lang="tooltips.manageTabs" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="topbar.tabs">Tabs</button>
        <button id="rollback-btn" data-lang="tooltips.viewVersionHistory" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="topbar.snapshots">Snapshots</button>
        <button id="audit-log-btn" data-lang="ui.tooltips.viewAuditLog" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="ui.buttons.auditLog">Audit</button>
        <button id="port-map-btn" data-lang="ui.tooltips.viewPortMap" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="ui.buttons.portMap">Ports</button>
        <button id="secrets-btn" data-lang="ui.tooltips.manageNotes" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="ui.buttons.notes">Notes</button>
		<div id="recording-controls" style="display:inline-flex;align-items:center;gap:4px;margin-left:8px;padding:4px 8px;background:var(--panel-alt);border:1px solid var(--edge-main);border-radius:6px;">
          <button id="record-btn" data-lang="recording.startRecording" data-lang-attr="title" style="padding:4px 8px;background:var(--btn-bg);color:#f56565;border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;font-size:14px;">●</button>
          <button id="play-btn" data-lang="recording.playRecording" data-lang-attr="title" style="padding:4px 8px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;font-size:14px;">▶</button>
          <div id="recording-expanded" style="display:none;align-items:center;gap:4px;">
            <button id="stop-btn" data-lang="recording.stop" data-lang-attr="title" style="padding:4px 8px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;font-size:14px;">■</button>
            <button id="pause-btn" data-lang="recording.pause" data-lang-attr="title" style="padding:4px 8px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;font-size:14px;display:none;">❚❚</button>
            <span id="recording-time" style="font-size:11px;color:var(--text-soft);min-width:40px;text-align:center;">0:00</span>
            <input type="range" id="playback-scrubber" min="0" max="100" value="0" style="width:80px;cursor:pointer;" data-lang="recording.playbackPosition" data-lang-attr="title">
            <select id="playback-speed" data-lang="recording.playbackSpeed" data-lang-attr="title" style="padding:2px 4px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;font-size:12px;">
              <option value="0.5">0.5x</option>
              <option value="1" selected>1x</option>
              <option value="2">2x</option>
              <option value="4">4x</option>
            </select>
            <label class="toggle-switch" data-lang="recording.loop" data-lang-attr="title"><input type="checkbox" id="loop-playback"><span class="toggle-slider"></span></label>
            <button id="recordings-btn" data-lang="recording.manageRecordings" data-lang-attr="title" style="padding:4px 8px;background:var(--btn-bg);color:var(--btn-text);border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;font-size:12px;">...</button>
          </div>
        </div>
		<button id="mobile-export-btn" data-lang="tooltips.exportTopology" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="topbar.export">Export</button>
        <button id="mobile-import-btn" data-lang="tooltips.importTopology" data-lang-attr="title" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;" data-lang-text="topbar.import">Import</button>
        <button id="settings-btn" data-lang="ui.buttons.settings" data-lang-attr="title">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" data-lang="tooltips.hideDrawToolbar" data-lang-attr="title">✕</button>
          <button id="draw-toggle" data-lang="tooltips.drawCustomLine" data-lang-attr="title">✏️</button>
          <button id="rect-toggle" data-lang="tooltips.drawZone" data-lang-attr="title">▭</button>
          <button id="text-toggle" data-lang="tooltips.addText" data-lang-attr="title">T</button>
          <span style="border-left: 1px solid var(--edge-main); height: 20px; margin: 0 4px;"></span>
          <select id="rect-style" data-lang="tooltips.zoneStyle" data-lang-attr="title">
            <option value="filled" data-lang="drawToolbar.filled">Filled</option>
            <option value="outlined" data-lang="drawToolbar.outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" data-lang="tooltips.lineColor" data-lang-attr="title">
          <select id="draw-style" data-lang="tooltips.lineStyle" data-lang-attr="title">
  <option value="solid" data-lang="drawToolbar.solid">Solid</option>
  <option value="dashed" data-lang="drawToolbar.dashed">Dashed</option>
  <option value="dotted" data-lang="drawToolbar.dotted">Dotted</option>
  <option value="wall" data-lang="drawToolbar.wall">Wall</option>
</select>
          <select id="draw-arrow" data-lang="tooltips.arrowDirection" data-lang-attr="title">
            <option value="none" data-lang="drawToolbar.noArrows">No arrows</option>
            <option value="forward" data-lang="drawToolbar.arrowRight">→ Right</option>
            <option value="backward" data-lang="drawToolbar.arrowLeft">← Left</option>
            <option value="both" data-lang="drawToolbar.arrowBoth">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" data-lang="tooltips.undoLastPoint" data-lang-attr="title" data-lang-text="drawToolbar.undoLastPoint">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" data-lang="tooltips.hideAddLineToolbar" data-lang-attr="title">✕</button>
          <label for="add-line-select" data-lang="topologyToolbar.addLineTo">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" data-lang="tooltips.lineColor" data-lang-attr="title" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" data-lang="tooltips.lineDirection" data-lang-attr="title">
            <option value="none" data-lang="topologyToolbar.noArrows">No arrows</option>
            <option value="forward" data-lang="topologyToolbar.forward">→ Forward</option>
            <option value="backward" data-lang="topologyToolbar.backward">← Backward</option>
            <option value="both" data-lang="topologyToolbar.bidirectional">↔ Bidirectional</option>
          </select>
          <select id="add-line-routing" data-lang="tooltips.lineRouting" data-lang-attr="title">
            <option value="orthogonal" data-lang="ui.options.orthogonal">Orthogonal</option>
            <option value="curved" data-lang="ui.options.curved">Curved</option>
            <option value="straight" data-lang="ui.options.straight">Straight</option>
          </select>
          <button id="add-line-btn" data-lang="ui.buttons.add">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" data-lang="tooltips.clearSelection" data-lang-attr="title">✕</button>
          <label style="font-weight: 600; color: var(--accent)" data-lang="bulkToolbar.selected">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" data-lang="tooltips.alignLeft" data-lang-attr="title" data-lang-text="bulkToolbar.alignLeft">⬅ Left</button>
          <button id="bulk-align-right" data-lang="tooltips.alignRight" data-lang-attr="title" data-lang-text="bulkToolbar.alignRight">➡ Right</button>
          <button id="bulk-align-top" data-lang="tooltips.alignTop" data-lang-attr="title" data-lang-text="bulkToolbar.alignTop">⬆ Top</button>
          <button id="bulk-align-bottom" data-lang="tooltips.alignBottom" data-lang-attr="title" data-lang-text="bulkToolbar.alignBottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" data-lang="tooltips.distributeH" data-lang-attr="title" data-lang-text="bulkToolbar.distributeH">↔ Distribute H</button>
          <button id="bulk-distribute-v" data-lang="tooltips.distributeV" data-lang-attr="title" data-lang-text="bulkToolbar.distributeV">↕ Distribute V</button>
          <button id="bulk-clone" data-lang="tooltips.cloneSelected" data-lang-attr="title" data-lang-text="bulkToolbar.clone">📋 Clone</button>
          <button id="bulk-zone-copy" data-lang="tooltips.copyZone" data-lang-attr="title" data-lang-text="bulkToolbar.copyZone">📡 Copy Zone</button>
          <button id="bulk-zone-paste" data-lang="tooltips.pasteZone" data-lang-attr="title" data-lang-text="bulkToolbar.pasteZone">📡 Paste Zone</button>
          <button id="bulk-zone-toggle" data-lang="tooltips.toggleZones" data-lang-attr="title" data-lang-text="bulkToolbar.toggleZones">📡 Toggle Zones</button>
          <button id="bulk-delete" data-lang="tooltips.deleteSelected" data-lang-attr="title" style="background: var(--danger); color: white;" data-lang-text="ui.buttons.delete">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none;">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span><span data-lang="bulkToolbar.selected">Selected</span></button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> <span data-lang="bulkToolbar.nodesSelected">Nodes Selected</span>
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;" data-lang="bulkToolbar.alignLeftShort">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;" data-lang="bulkToolbar.alignRightShort">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;" data-lang="bulkToolbar.alignTopShort">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;" data-lang="bulkToolbar.alignBottomShort">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;" data-lang="bulkToolbar.distributeHShort">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;" data-lang="bulkToolbar.distributeVShort">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;" data-lang="bulkToolbar.lockToggle">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;" data-lang="bulkToolbar.groupToggle">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;" data-lang="bulkToolbar.cloneAll">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;" data-lang="bulkToolbar.deleteAll">Delete All</span></button>
          </div>
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--edge-main);">
            <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em;" data-lang="bulkToolbar.coverageZones">Coverage Zones</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
              <button id="bulk-zone-copy-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;" data-lang="bulkToolbar.copyZoneShort">Copy Zone</span></button>
              <button id="bulk-zone-paste-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;" data-lang="bulkToolbar.pasteZoneShort">Paste Zone</span></button>
              <button id="bulk-zone-toggle-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;" data-lang="bulkToolbar.toggleZonesShort">Toggle Zones</span></button>
            </div>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;" data-lang="bulkToolbar.clearSelection">Clear Selection</button>
        </div>
        <div class="canvas-hint visible" id="canvas-hint">
          <ul>
            <li data-lang="canvasHints.scrollZoom">Scroll to zoom</li>
            <li data-lang="canvasHints.dragPan">Drag to pan</li>
            <li data-lang="canvasHints.rightClickClone">Right click to clone and align</li>
            <li data-lang="canvasHints.rightClickMulti">Right click to select multiple</li>
			<li data-lang="canvasHints.shiftMarquee">Hold Shift + drag mouse for marquee selection</li>
            <li data-lang="canvasHints.power">You have the power</li>
            <li data-lang="canvasHints.timeNow">Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: none;"><div class="legend-title" data-lang="legend.connectionLegend">Connection Legend</div><button type="button" class="legend-close-btn">✕</button></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="0 0 4000 3000" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" data-lang="tooltips.hideMapZoom" data-lang-attr="title">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="0" y="0" width="4000" height="3000"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" data-lang="tooltips.zoomIn" data-lang-attr="title">+</button>
            <div class="zoom-level" id="zoom-level">100%</div>
            <button id="zoom-out-btn" data-lang="tooltips.zoomOut" data-lang-attr="title">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" data-lang="tooltips.fitToView" data-lang-attr="title">[ ]</button>
            <button id="zoom-reset-btn" data-lang="tooltips.resetView" data-lang-attr="title">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;" data-lang="toolbar.legendMini">Connection & Zone Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;" data-lang="toolbar.minimapMini">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;" data-lang="toolbar.drawMini">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;" data-lang="toolbar.topologyMini">Add Connection</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row" id="mac-row">
            <span style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.mac">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row" id="rack-unit-row">
            <span style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.rackUnit">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.uHeight">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.layer">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="layer1" id="node-layer-opt1">Physical</option>
              <option value="layer2" id="node-layer-opt2">Logical</option>
              <option value="layer3" id="node-layer-opt3">Security</option>
              <option value="layer4" id="node-layer-opt4">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span id="assigned-rack-label" style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.assignedRack">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="" data-lang="ui.options.none">None</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;" data-lang="nodePanel.rackCapacity">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;" data-lang="nodePanel.nodesInRack">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
		  </details>
          <details id="fov-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;" data-lang="zone.coverageZone">Coverage Zone</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.preset">Preset:</label>
                <select id="fov-preset" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                  <option value="" data-lang="zone.applyPreset">-- Apply Preset --</option>
                  <option value="security-cam" data-lang="zone.presets.securityCam">Security Camera</option>
                  <option value="ptz-cam" data-lang="zone.presets.ptzCam">PTZ Camera</option>
                  <option value="motion-detect" data-lang="zone.presets.motionDetector">Motion Detector</option>
                  <option value="wifi-strong" data-lang="zone.presets.wifi">WiFi</option>
                  <option value="wifi-extended" data-lang="zone.presets.wifiExtender">WiFi Extender</option>
                  <option value="smoke-alarm" data-lang="zone.presets.smokeAlarm">Smoke Alarm</option>
                  <option value="sprinkler-arc" data-lang="zone.presets.sprinklerArc">Sprinkler Arc</option>
                </select>
                <button id="fov-save-preset" data-lang="tooltips.saveAsPreset" data-lang-attr="title" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">💾</button>
                <button id="fov-copy-style" data-lang="tooltips.copyZoneStyle" data-lang-attr="title" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📋</button>
                <button id="fov-paste-style" data-lang="tooltips.pasteZoneStyle" data-lang-attr="title" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📥</button>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.showZone">Show Zone:</label>
                <label class="toggle-switch"><input type="checkbox" id="fov-enabled"><span class="toggle-slider"></span></label>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.angle">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">90°</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.distance">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">150</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.innerRadius">Inner Radius:</label>
                <input type="range" id="fov-inner-radius" min="0" max="200" value="0" style="flex: 1;">
                <span id="fov-inner-radius-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.rotation">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0°</span>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;" data-lang="zone.fill">Fill</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.color">Color:</label>
                  <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.opacity">Opacity:</label>
                  <input type="range" id="fov-opacity" min="5" max="80" value="20" style="flex: 1;">
                  <span id="fov-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">20%</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.gradient">Gradient:</label>
                  <label class="toggle-switch"><input type="checkbox" id="fov-gradient"><span class="toggle-slider"></span></label>
                  <span style="color: var(--text-soft); font-size: 12px; margin-left: 8px;" data-lang="zone.fadeTowardEdge">Fade toward edge</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;" data-lang="zone.border">Border</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.color">Color:</label>
                  <input type="color" id="fov-border-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.width">Width:</label>
                  <input type="range" id="fov-border-width" min="0" max="10" value="2" style="flex: 1;">
                  <span id="fov-border-width-value" style="min-width: 40px; text-align: right; color: var(--text-main);">2</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.style">Style:</label>
                  <select id="fov-border-style" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="solid" data-lang="ui.options.solid">Solid</option>
                    <option value="dashed" data-lang="ui.options.dashed">Dashed</option>
                    <option value="dotted" data-lang="ui.options.dotted">Dotted</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.opacity">Opacity:</label>
                  <input type="range" id="fov-border-opacity" min="0" max="100" value="100" style="flex: 1;">
                  <span id="fov-border-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">100%</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;" data-lang="zone.label">Label</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.text">Text:</label>
                  <input type="text" id="fov-label" placeholder="e.g. Detection Zone" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);" data-lang="zone.labelPlaceholder" data-lang-attr="placeholder">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.position">Position:</label>
                  <select id="fov-label-position" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="center" data-lang="ui.options.center">Center</option>
                    <option value="edge" data-lang="zone.edge">Edge</option>
                    <option value="outside" data-lang="zone.outside">Outside</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.fontSize">Font Size:</label>
                  <input type="range" id="fov-label-size" min="8" max="32" value="14" style="flex: 1;">
                  <span id="fov-label-size-value" style="min-width: 40px; text-align: right; color: var(--text-main);">14px</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.fontColor">Font Color:</label>
                  <input type="color" id="fov-label-color" value="#ffffff" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.bold">Bold:</label>
                  <label class="toggle-switch"><input type="checkbox" id="fov-label-bold"><span class="toggle-slider"></span></label>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.background">Background:</label>
                  <label class="toggle-switch"><input type="checkbox" id="fov-label-bg"><span class="toggle-slider"></span></label>
                  <input type="color" id="fov-label-bg-color" value="#000000" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; margin-left: 8px;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.offsetX">Offset X:</label>
                  <input type="range" id="fov-label-offset-x" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-x-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.offsetY">Offset Y:</label>
                  <input type="range" id="fov-label-offset-y" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-y-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;" data-lang="zone.animation">Animation</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.animate">Animate:</label>
                  <label class="toggle-switch"><input type="checkbox" id="fov-animate"><span class="toggle-slider"></span></label>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.type">Type:</label>
                  <select id="fov-animation-type" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="sweep" data-lang="ui.labels.sweepPan">Sweep (Pan)</option>
                    <option value="pulse" data-lang="ui.labels.pulseBreathe">Pulse (Breathe)</option>
                    <option value="rings" data-lang="ui.labels.ringsEmanate">Rings (Emanate)</option>
                    <option value="spin" data-lang="ui.labels.spinRotate">Spin (Rotate)</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.sweep">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120°</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;" data-lang="zone.speed">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section"...
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;" data-lang="nodePanel.connections">Connections (<span id="node-connections-count">0</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label data-lang="ui.labels.size">Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size" data-lang="ui.buttons.reset">Reset</button>
          </div>
          <div class="size-controls">
            <label data-lang="ui.labels.rotation">Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
            <button id="reset-rotation" data-lang="ui.buttons.reset">Reset</button>
          </div>
          <details class="style-section">
            <summary data-lang="nodePanel.styling">Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label data-lang="nodePanel.screen">Screen:</label>
                <select id="style-scope">
                  <option value="all" data-lang="ui.tabs.all">All</option>
                  <option value="desktop" data-lang="help.tabs.desktop">Desktop</option>
                  <option value="tablet" data-lang="nodePanel.tablet">Tablet</option>
                  <option value="mobile" data-lang="help.tabs.mobile">Mobile</option>
                  <option value="fold" data-lang="nodePanel.fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label data-lang="ui.labels.category">Category:</label>
                <select id="shape-category-select">
                  <option value="basic" data-lang="shapes.categories.basic">Basic Shapes</option>
                  <option value="computers" data-lang="shapes.categories.computers">Computers & Devices</option>
                  <option value="network" data-lang="shapes.categories.network">Network Equipment</option>
                  <option value="cloud" data-lang="shapes.categories.cloud">Cloud & Services</option>
                  <option value="security" data-lang="shapes.categories.security">Security & Monitoring</option>
                  <option value="smarthome" data-lang="shapes.categories.smarthome">Smart Home</option>
                  <option value="sports" data-lang="shapes.categories.sports">Sports</option>
                  <option value="rack" data-lang="shapes.categories.rack">Rack Equipment</option>
                </select>
              </div>
              <div class="style-row">
                <label data-lang="ui.labels.shape">Shape:</label>
                <select id="shape-select"></select>
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.fillColor">Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.borderColor">Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label data-lang="ui.labels.titleColor">Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.titleFont">Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif" data-lang="nodePanel.systemUI"> System UI </option>
                  <option value="monospace" data-lang="ui.fonts.monospace">Monospace</option>
                  <option value="serif" data-lang="nodePanel.serif">Serif</option>
                  <option value="cursive" data-lang="nodePanel.cursive">Cursive</option>
                  <option value="'Courier New', monospace" data-lang="nodePanel.courier"> Courier </option>
                  <option value="Arial, sans-serif" data-lang="ui.fonts.arial">Arial</option>
                  <option value="'Times New Roman', serif" data-lang="nodePanel.times"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label data-lang="ui.labels.titleSize">Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.subColor">Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.subFont">Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif" data-lang="nodePanel.systemUI"> System UI </option>
                  <option value="monospace" data-lang="ui.fonts.monospace">Monospace</option>
                  <option value="serif" data-lang="nodePanel.serif">Serif</option>
                  <option value="cursive" data-lang="nodePanel.cursive">Cursive</option>
                  <option value="'Courier New', monospace" data-lang="nodePanel.courier"> Courier </option>
                  <option value="Arial, sans-serif" data-lang="ui.fonts.arial">Arial</option>
                  <option value="'Times New Roman', serif" data-lang="nodePanel.times"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label data-lang="nodePanel.subSize">Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
                <div class="style-row">
                  <label data-lang="nodePanel.nameY">Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label data-lang="nodePanel.nameX">Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label data-lang="nodePanel.ipY">IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label data-lang="nodePanel.ipX">IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);" data-lang="nodePanel.resetStyles">Reset Styles</button>
            </div>
          </details>
          <div class="section-label" data-lang="ui.labels.notes">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." data-lang="ui.placeholders.enterNote" data-lang-attr="placeholder" style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;" data-lang="ui.buttons.add">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;" data-lang="ui.buttons.deleteNode">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title" data-lang="edgePanel.customLine">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label data-lang="ui.labels.width">Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.color">Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.style">Line Style:</label>
            <select id="edge-line-style">
  <option value="solid" data-lang="ui.options.solid">Solid</option>
  <option value="dashed" data-lang="ui.options.dashed">Dashed</option>
  <option value="dotted" data-lang="ui.options.dotted">Dotted</option>
  <option value="wall" data-lang="drawToolbar.wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.routing">Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal" data-lang="ui.options.orthogonal">Orthogonal (90°)</option>
              <option value="curved" data-lang="ui.options.curved">Curved</option>
              <option value="straight" data-lang="ui.options.straight">Straight</option>
            </select>
          </div>
          <div class="style-row" id="waypoints-row" style="display: none;">
            <label id="waypoints-label" data-lang="ui.labels.waypoints">Waypoints</label>
            <button id="clear-waypoints-btn" style="padding: 6px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;color: var(--text-main);" data-lang="ui.buttons.clearAll">Clear All</button>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.direction">Direction:</label>
            <select id="edge-direction">
              <option value="none" data-lang="topologyToolbar.noArrows">No arrows</option>
              <option value="forward" data-lang="topologyToolbar.forward">→ Forward</option>
              <option value="backward" data-lang="topologyToolbar.backward">← Backward</option>
              <option value="both" data-lang="topologyToolbar.bidirectional">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="edgePanel.animate">Animate:</label>
            <label class="toggle-switch"><input type="checkbox" id="edge-animate"><span class="toggle-slider"></span></label>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.style">Style:</label>
            <select id="edge-animation-style">
              <option value="" data-lang="ui.options.default">Default</option>
              <option value="arrows" data-lang="ui.options.flowingArrows">Flowing Arrows</option>
              <option value="dots" data-lang="ui.options.dotArrows">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.animationSpeed">Speed:</label>
            <select id="edge-animation-speed">
              <option value="" data-lang="ui.options.default">Default</option>
              <option value="0.5" data-lang="ui.options.veryFast">Very Fast</option>
              <option value="1" data-lang="ui.options.fast">Fast</option>
              <option value="1.5" data-lang="ui.options.normal">Normal</option>
              <option value="2.5" data-lang="ui.options.slow">Slow</option>
              <option value="4" data-lang="ui.options.verySlow">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label data-lang="ui.labels.fromPort">From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" data-lang="ui.placeholders.fromPort" data-lang-attr="placeholder" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label data-lang="ui.labels.toPort">To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" data-lang="ui.placeholders.toPort" data-lang-attr="placeholder" style="flex: 1;">
          </div>
          <div class="section-label" data-lang="ui.labels.lineNotes">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." data-lang="ui.placeholders.enterNote" data-lang-attr="placeholder" style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;" data-lang="ui.buttons.add">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;" data-lang="ui.buttons.delete">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title" data-lang="rectPanel.zone">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label data-lang="rectPanel.fillColor">Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label data-lang="rectPanel.borderColor">Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label data-lang="rectPanel.borderWidth">Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.style">Style:</label>
            <select id="rect-style-select">
              <option value="filled" data-lang="drawToolbar.filled">Filled</option>
              <option value="outlined" data-lang="drawToolbar.outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="rectPanel.lineStyle">Line Style:</label>
            <select id="rect-line-style">
  <option value="solid" data-lang="ui.options.solid">Solid</option>
  <option value="dashed" data-lang="ui.options.dashed">Dashed</option>
  <option value="dotted" data-lang="ui.options.dotted">Dotted</option>
  <option value="wall" data-lang="drawToolbar.wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.rotation">Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <div class="section-label" data-lang="ui.labels.zoneNotes">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." data-lang="ui.placeholders.enterNote" data-lang-attr="placeholder" style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;" data-lang="ui.buttons.add">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;" data-lang="ui.buttons.delete">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title" data-lang="textPanel.textElement">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label data-lang="textPanel.content">Content:</label>
            <textarea id="text-content" placeholder="Enter text..." data-lang="ui.placeholders.enterText" data-lang-attr="placeholder" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label data-lang="textPanel.fontSizeLabel">Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label data-lang="textPanel.colorLabel">Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label data-lang="textPanel.fontWeight">Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal" data-lang="ui.options.normal">Normal</option>
              <option value="bold" data-lang="textPanel.bold">Bold</option>
              <option value="600" data-lang="textPanel.semiBold">Semi-Bold</option>
              <option value="300" data-lang="textPanel.light">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="textPanel.fontStyle">Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal" data-lang="ui.options.normal">Normal</option>
              <option value="italic" data-lang="textPanel.italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="textPanel.textAlign">Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start" data-lang="ui.options.left">Left</option>
              <option value="middle" data-lang="ui.options.center">Center</option>
              <option value="end" data-lang="ui.options.right">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="textPanel.textDecoration">Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none" data-lang="ui.options.none">None</option>
              <option value="underline" data-lang="textPanel.underline">Underline</option>
              <option value="line-through" data-lang="textPanel.strikeThrough">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.background">Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <div style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <label class="toggle-switch"><input type="checkbox" id="text-bg-enabled"><span class="toggle-slider"></span></label>
            <span style="font-size: 13px;" data-lang="textPanel.enable">Enable</span>
            </div>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.opacity">Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label data-lang="ui.labels.rotation">Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;" data-lang="textPanel.deleteText"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary data-lang="ui.sections.pageLayout">Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;" data-lang="pageLayoutHelp.dragToResize">Drag to Resize:</strong>
              • <strong data-lang="pageLayoutHelp.header">Header:</strong> <span data-lang="pageLayoutHelp.headerDesc">Drag the bottom edge of the header bar</span><br>
              • <strong data-lang="pageLayoutHelp.sidebar">Sidebar:</strong> <span data-lang="pageLayoutHelp.sidebarDesc">Drag the left edge of the sidebar panel</span><br>
              • <strong data-lang="pageLayoutHelp.mobile">Mobile:</strong> <span data-lang="pageLayoutHelp.mobileDesc">Drag the top edge of the footer panel</span><br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;" data-lang="pageLayoutHelp.hoverNote">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">{
  "nodeData": {},
  "edgeData": {
    "list": []
  },
  "rectData": {
    "list": []
  },
  "textData": {
    "list": []
  },
  "edgeLegend": {},
  "zoneLegend": {},
  "zonePresets": {},
  "nodePositions": {},
  "nodeSizes": {},
  "nodeStyles": {},
  "page": {
    "title": "The One File",
    "background": "",
    "topbarBg": "rgba(9, 12, 20, 0.9)",
    "topbarBorder": "#1f2533",
    "panel": "#0b0e13",
    "panelAlt": "#10141b",
    "accent": "#4fd1c5",
    "sidebarBg": "#10141b",
    "btnBg": "#0b0e13",
    "btnText": "#e2e8f0",
    "tagFill": "#1e293b",
    "tagText": "#e2e8f0",
    "tagBorder": "#475569",
    "inputBg": "#0b0e13",
    "inputText": "#e2e8f0",
    "inputBorder": "#1f2937",
    "inputFont": "Inter, system-ui, sans-serif",
    "inputFontSize": 14,
    "toolbarBg": "#0f172a",
    "toolbarBorder": "#1f2937",
    "toolbarText": "#94a3b8",
    "toolbarBtnBg": "#0b0e13",
    "toolbarBtnText": "#e2e8f0",
    "minimapDots": "#94a3b8",
    "canvasHintEnabled": true,
    "canvasHintText": "",
    "canvasHintBg": "#0f172a",
    "canvasHintColor": "#94a3b8",
    "danger": "#f56565",
    "textMain": "#e2e8f0",
    "textSoft": "#94a3b8",
    "topbarHeight": 103,
    "sidebarWidth": 350,
    "mobileFooterHeight": 40,
    "sidebarCollapsed": false,
    "nodeFill": "#1e293b",
    "nodeStroke": "#475569",
    "nodeTitle": "#e2e8f0",
    "nodeSub": "#94a3b8",
    "nodeTitleSize": 41,
    "nodeSubSize": 27,
    "nodeFont": "monospace",
    "defaultEdge": "#475569",
    "selectionHandle": "#f59e0b",
    "selectionHandleSize": 8,
    "groupIndicator": "#4fd1c5",
    "canvasGradientTop": "#1e2532",
    "canvasGradientBottom": "#050608",
    "canvasBorder": "#475569",
    "canvasGrid": "#475569",
    "canvasGridSize": 50,
    "rackFrameFill": "#0f172a",
    "rackFrameStroke": "#4fd1c5",
    "rackLineColor": "#475569",
    "rackTextColor": "#4fd1c5",
    "viewOnly": false
  },
  "canvas": {
    "zoom": 1,
    "panX": 0,
    "panY": 0
  },
  "savedTopologyView": {
    "zoom": 0.9325110211947125,
    "panX": -563.7108933103631,
    "panY": -561.6887674556383
  },
  "documentTabs": [
    {
      "id": "main",
      "name": "Main Topology",
      "nodes": {},
      "edges": {
        "list": []
      },
      "positions": {},
      "sizes": {},
      "styles": {},
      "legend": {},
      "rects": {
        "list": []
      },
      "texts": {
        "list": []
      },
      "pageState": {
        "title": "The One File",
        "background": "",
        "topbarBg": "rgba(9, 12, 20, 0.9)",
        "topbarBorder": "#1f2533",
        "panel": "#0b0e13",
        "panelAlt": "#10141b",
        "accent": "#4fd1c5",
        "sidebarBg": "#10141b",
        "btnBg": "#0b0e13",
        "btnText": "#e2e8f0",
        "tagFill": "#1e293b",
        "tagText": "#e2e8f0",
        "tagBorder": "#475569",
        "inputBg": "#0b0e13",
        "inputText": "#e2e8f0",
        "inputBorder": "#1f2937",
        "inputFont": "Inter, system-ui, sans-serif",
        "inputFontSize": 14,
        "toolbarBg": "#0f172a",
        "toolbarBorder": "#1f2937",
        "toolbarText": "#94a3b8",
        "toolbarBtnBg": "#0b0e13",
        "toolbarBtnText": "#e2e8f0",
        "minimapDots": "#94a3b8",
        "canvasHintEnabled": true,
        "canvasHintText": "",
        "canvasHintBg": "#0f172a",
        "canvasHintColor": "#94a3b8",
        "danger": "#f56565",
        "textMain": "#e2e8f0",
        "textSoft": "#94a3b8",
        "topbarHeight": 103,
        "sidebarWidth": 350,
        "mobileFooterHeight": 40,
        "sidebarCollapsed": false,
        "nodeFill": "#1e293b",
        "nodeStroke": "#475569",
        "nodeTitle": "#e2e8f0",
        "nodeSub": "#94a3b8",
        "nodeTitleSize": 41,
        "nodeSubSize": 27,
        "nodeFont": "monospace",
        "defaultEdge": "#475569",
        "selectionHandle": "#f59e0b",
        "selectionHandleSize": 8,
        "groupIndicator": "#4fd1c5",
        "canvasGradientTop": "#1e2532",
        "canvasGradientBottom": "#050608",
        "canvasBorder": "#475569",
        "canvasGrid": "#475569",
        "canvasGridSize": 50,
        "rackFrameFill": "#0f172a",
        "rackFrameStroke": "#4fd1c5",
        "rackLineColor": "#475569",
        "rackTextColor": "#4fd1c5",
        "viewOnly": false
      }
    }
  ],
  "currentTabIndex": 0,
  "encryptedSections": {},
  "auditLog": []
}</script>
    <script id="lang-json" type="application/json">{
  "_meta": {
    "name": "English",
    "code": "en",
    "version": "1.0",
    "rtl": false,
    "edition": "core"
  },
  "modes": {
    "network": { "name": "Network Topology", "node": "Node", "nodes": "Nodes", "connection": "Connection", "connections": "Connections", "add": "Add Node", "addRack": "Add Rack", "rack": "Rack", "racks": "Racks", "subtitle": "IP / Subtitle", "subtitlePlaceholder": "e.g. 192.168.1.100", "tags": "Tags", "tagsPlaceholder": "e.g. Docker, nginx, WG: vpn", "rackSubtitle": "IP / Network Range", "rackSubtitlePlaceholder": "e.g. 192.168.1.0/24", "rackTags": "Tags", "rackTagsPlaceholder": "e.g. Production, Data Center 1" },
    "mindmap": { "name": "Mind Map", "node": "Idea", "nodes": "Ideas", "connection": "Link", "connections": "Links", "add": "Add Idea", "addRack": "Add Folder", "rack": "Folder", "racks": "Folders", "subtitle": "Description", "subtitlePlaceholder": "e.g. Main concept", "tags": "Keywords", "tagsPlaceholder": "e.g. important, research, todo", "rackSubtitle": "Description", "rackSubtitlePlaceholder": "e.g. Folder description", "rackTags": "Keywords", "rackTagsPlaceholder": "e.g. category, priority" },
    "sports": { "name": "Sports Playbook", "node": "Player", "nodes": "Players", "connection": "Route", "connections": "Routes", "add": "Add Player", "addRack": "Add Folder", "rack": "Folder", "racks": "Folders", "subtitle": "Position / Number", "subtitlePlaceholder": "e.g. QB, #12", "tags": "Attributes", "tagsPlaceholder": "e.g. offense, starter, captain", "rackSubtitle": "Description", "rackSubtitlePlaceholder": "e.g. Formation name", "rackTags": "Attributes", "rackTagsPlaceholder": "e.g. offense, defense" },
    "smarthome": { "name": "Smart Home", "node": "Device", "nodes": "Devices", "connection": "Connection", "connections": "Connections", "add": "Add Device", "addRack": "Add Room View", "rack": "Room View", "racks": "Room Views", "subtitle": "Model / Location", "subtitlePlaceholder": "e.g. Nest Thermostat, Living Room", "tags": "Groups", "tagsPlaceholder": "e.g. lighting, security, automation", "rackSubtitle": "Description", "rackSubtitlePlaceholder": "e.g. Room description", "rackTags": "Groups", "rackTagsPlaceholder": "e.g. upstairs, main floor" },
    "floorplan": { "name": "Floor Plan", "node": "Element", "nodes": "Elements", "connection": "Connection", "connections": "Connections", "add": "Add Element", "addRack": "Add Room View", "rack": "Room View", "racks": "Room Views", "subtitle": "Label / Dimensions", "subtitlePlaceholder": "e.g. 12x14 ft", "tags": "Categories", "tagsPlaceholder": "e.g. furniture, fixture, wall", "rackSubtitle": "Description", "rackSubtitlePlaceholder": "e.g. Room dimensions", "rackTags": "Categories", "rackTagsPlaceholder": "e.g. bedroom, bathroom" }
  },
  "canvas": {
    "grid": "Standard Grid",
    "dots": "Dot Grid",
    "blueprint": "Blueprint Grid",
    "basketball": "Basketball Court",
    "football": "Football Field",
    "soccer": "Soccer Pitch",
    "hockey": "Hockey Rink",
    "baseball": "Baseball Diamond",
    "tennis": "Tennis Court",
    "none": "No Grid"
  },
  "shapes": {
    "categories": {
      "basic": "Basic Shapes",
      "computers": "Computers & Devices",
      "network": "Network Equipment",
      "cloud": "Cloud & Services",
      "security": "Security & Monitoring",
      "smarthome": "Smart Home",
      "sports": "Sports",
      "rack": "Rack Equipment"
    },
    "items": {
      "circle": "Circle", "square": "Square", "rectangle": "Rectangle", "triangle": "Triangle",
      "hexagon": "Hexagon", "diamond": "Diamond", "star": "Star", "stop-sign": "Stop Sign",
      "octagon": "Octagon", "pentagon": "Pentagon", "cross": "Cross", "rounded-square": "Rounded Square",
      "pill": "Pill", "parallelogram": "Parallelogram", "trapezoid": "Trapezoid",
      "server": "Server", "pc": "PC / Desktop", "laptop": "Laptop", "phone": "Phone / Mobile",
      "printer": "Printer", "pi": "Raspberry Pi", "sensor": "Sensor / IoT",
      "router": "Router", "switch": "Switch", "firewall": "Firewall", "access-point": "Access Point",
      "load-balancer": "Load Balancer", "gateway": "Gateway", "vpn": "VPN / Tunnel", "nas": "NAS / Storage",
      "cloud": "Cloud", "database": "Database", "docker": "Docker", "container": "Container",
      "vm": "Virtual Machine", "kubernetes": "Kubernetes", "api": "API / Endpoint",
      "queue": "Queue / Message", "lambda": "Lambda / Function", "bucket": "Bucket / S3",
      "shield": "Shield", "camera": "Camera / CCTV", "monitor": "Monitor / Dashboard",
      "thermostat": "Thermostat", "doorbell": "Video Doorbell", "smart-lock": "Smart Lock",
      "smart-bulb": "Smart Bulb", "smart-plug": "Smart Plug", "smart-speaker": "Smart Speaker",
      "smart-tv": "Smart TV", "hub": "Smart Hub", "smoke-detector": "Smoke Detector",
      "motion-sensor": "Motion Sensor", "garage": "Garage Door", "sprinkler": "Sprinkler", "vacuum": "Robot Vacuum",
      "basketball-ball": "Basketball", "football-ball": "Football", "soccer-ball": "Soccer Ball",
      "hockey-puck": "Hockey Puck", "baseball-ball": "Baseball", "tennis-ball": "Tennis Ball",
      "volleyball": "Volleyball", "rugby-ball": "Rugby Ball", "golf-ball": "Golf Ball",
      "frisbee": "Frisbee", "cricket-ball": "Cricket Ball", "lacrosse-stick": "Lacrosse Stick",
      "golf-flag": "Golf Hole Flag",
      "tactical-x": "X (Defender)", "tactical-o": "O (Offensive)",
      "tactical-star": "Star (Key Player)",
      "patch-panel": "Patch Panel", "ups": "UPS", "pdu": "PDU", "rack-shelf": "Shelf",
      "blank-panel": "Blank Panel", "cable-management": "Cable Management", "kvm": "KVM"
    }
  },
  "ui": {
    "defaults": {
      "newNode": "New {node}",
      "newRack": "New {rack}",
      "newText": "New Text"
    },
    "buttons": {
      "save": "Save", "cancel": "Cancel", "delete": "Delete", "close": "Close",
      "add": "Add", "edit": "Edit", "undo": "Undo", "redo": "Redo",
      "import": "Import", "export": "Export", "settings": "Settings",
      "startMapping": "Start Mapping", "skip": "Skip", "apply": "Apply",
      "clearAll": "Clear All", "reset": "Reset", "saveChanges": "Save Changes",
      "addNode": "Add {node}", "addRack": "Add {rack}", "editNode": "Edit {node}",
      "deleteNode": "Delete {node}", "exportLang": "Export Language File",
      "importLang": "Import Language File", "resetLang": "Reset to English",
      "editStrings": "Edit Strings", "applyRoutingAll": "Apply Routing to All Connections",
      "saveHtml": "Save HTML", "saveFile": "Save File", "printBW": "Print B&W", "printColor": "Print Color",
      "exportJson": "Export JSON", "exportCsv": "Export CSV", "exportMd": "Export Markdown",
      "exportPng": "Export PNG", "exportSvg": "Export SVG", "exportVideo": "Export Video",
      "importJson": "Import JSON", "importMd": "Import Markdown",
      "exportHelp": "Export Help", "importHelp": "Import Help",
      "layers": "Layers", "notes": "Notes", "auditLog": "Audit Log", "portMap": "Port Map",
      "hideAll": "Hide All", "showAll": "Show All", "clearLog": "Clear Log",
      "addNote": "+ Add Note", "addTab": "+ Add Tab", "addTag": "+ Add Tag", "encrypt": "Encrypt", "decrypt": "Decrypt",
      "recording": "Recording", "play": "Play", "pause": "Pause", "stop": "Stop",
      "drawMode": "Draw", "textMode": "Text", "rectMode": "Rect", "freeDrawMode": "Draw",
      "zoomIn": "Zoom In", "zoomOut": "Zoom Out", "fitView": "Fit View", "resetView": "Reset View",
      "group": "Group", "ungroup": "Ungroup", "bringToFront": "Bring to Front", "sendToBack": "Send to Back",
      "duplicate": "Duplicate", "selectAll": "Select All", "deselectAll": "Deselect All",
      "copyStyle": "Copy Style", "pasteStyle": "Paste Style",
      "clearHistory": "Clear History", "createSnapshot": "Create Snapshot",
      "del": "Del", "done": "Done"
    },
    "labels": {
      "name": "Name", "ip": "IP / Subtitle", "tags": "Tags", "category": "Category",
      "shape": "Shape", "icon": "Icon / Shape", "theme": "Theme", "mode": "Mode",
      "canvasStyle": "Canvas Style", "themePreset": "Theme Preset",
      "mainBackground": "Main Background", "accentColor": "Accent Color",
      "primaryText": "Primary Text", "secondaryText": "Secondary Text",
      "viewOnly": "View Only (disable editing)", "sidebar": "Sidebar / Mobile Footer",
      "modalBg": "Modal Window Background", "dangerButtons": "Danger Buttons",
      "tagFill": "Tag(s) Fill", "tagText": "Tag(s) Text", "tagBorder": "Tag(s) Border",
      "background": "Background", "border": "Border", "buttonFill": "Button Fill",
      "buttonText": "Button Text", "gridLines": "Grid Lines", "gridSize": "Grid Size",
      "showGrid": "Show Grid", "bgTop": "Background Top", "bgBottom": "Background Bottom",
      "solidBg": "Solid Background", "frameFill": "Frame Fill", "frameBorder": "Frame Border",
      "uLabels": "U Labels", "text": "Text", "minimapDots": "Minimap Dots",
      "fill": "Fill", "titleColor": "Title Color", "titleSize": "Title Size",
      "subtitleColor": "Subtitle Color", "subtitleSize": "Subtitle Size", "font": "Font",
      "defaultColor": "Default Color", "defaultRouting": "Default Routing",
      "animationStyle": "Animation Style", "animateDirections": "Animate Directions",
      "animationSpeed": "Animation Speed", "allAnimations": "All Animations",
      "sweepPan": "Sweep (Pan)", "pulseBreathe": "Pulse (Breathe)", "ringsEmanate": "Rings (Emanate)",
      "spinRotate": "Spin (Rotate)", "connectionsFlow": "Connections (Flow)",
      "cameras": "Cameras", "doorbells": "Doorbells", "motionSensors": "Motion Sensors",
      "smokeDetectors": "Smoke Detectors", "wifiApRouter": "WiFi/AP/Router",
      "sensorsIot": "Sensors/IoT", "sprinklers": "Sprinklers",
      "allZones": "All Zones", "resizeHandleColor": "Resize Handle Color",
      "resizeHandleSize": "Resize Handle Size", "groupedIconOutline": "Grouped Icon Outline",
      "multiselectFill": "Multiselect Fill Color (Desktop)",
      "multiselectFillOpacity": "Multiselect Fill Opacity (Desktop)",
      "multiselectBorder": "Multiselect Border Color (Desktop)",
      "multiselectBorderWidth": "Multiselect Border Width (Desktop)",
      "multiselectBorderStyle": "Multiselect Border Style (Desktop)",
      "fontSize": "Font Size", "enabled": "Enabled", "textColor": "Text Color",
      "customText": "Custom Text (HTML)", "language": "Language", "currentLanguage": "Current:",
      "tagsComma": "Tags (comma separated)", "networkRange": "IP / Network Range (optional)",
      "layer": "Layer", "mac": "MAC Address", "vendor": "Vendor", "model": "Model",
      "serialNumber": "Serial Number", "firmware": "Firmware", "location": "Location",
      "owner": "Owner", "purchaseDate": "Purchase Date", "warranty": "Warranty",
      "notes": "Notes", "lineNotes": "Line Notes", "zoneNotes": "Zone Notes",
      "color": "Color", "width": "Width", "style": "Style", "routing": "Routing",
      "direction": "Direction", "label": "Label", "labelPosition": "Label Position",
      "fromPort": "From Port", "toPort": "To Port", "waypoints": "Waypoints", "bandwidth": "Bandwidth",
      "latency": "Latency", "protocol": "Protocol", "vlan": "VLAN",
      "rackCapacity": "Rack Capacity", "rackPosition": "Rack Position (U)",
      "size": "Size", "sizeHeight": "Height (U)", "opacity": "Opacity",
      "rotation": "Rotation", "zIndex": "Z-Index", "locked": "Locked",
      "visible": "Visible", "animated": "Animated", "animationType": "Animation Type",
      "zoneAngle": "Zone Angle", "zoneRange": "Zone Range", "zoneColor": "Zone Color",
      "zoneOpacity": "Zone Opacity", "showZone": "Show Zone",
      "pageLayout": "Page Layout", "pageWidth": "Page Width", "pageHeight": "Page Height",
      "orientation": "Orientation", "landscape": "Landscape", "portrait": "Portrait",
      "margin": "Margin", "padding": "Padding", "scale": "Scale",
      "timestamp": "Timestamp", "action": "Action", "details": "Details",
      "fromDevice": "From Device", "toDevice": "To Device", "description": "Description"
    },
    "sections": {
      "mappingModeTheme": "Mapping Mode & Theme", "viewOnlyMode": "View Only Mode",
      "moreThemeOptions": "More Theme Options", "topBar": "Top Bar",
      "mainCanvas": "Main Canvas", "rackCanvas": "Rack Canvas", "canvasToolbars": "Canvas Toolbars",
      "nodes": "Nodes", "connections": "Connections", "animationsZones": "Animations & Zones",
      "groupsEditing": "Groups & Editing", "inputsDropdowns": "Inputs & Dropdowns",
      "welcomeMessage": "Welcome Message", "dangerZone": "Danger Zone",
      "byType": "By Type", "byCategory": "By Category", "zoneSettings": "Zone (Animation Cone) Settings",
      "pageLayout": "Page Layout", "nodeDetails": "Node Details", "connectionDetails": "Connection Details",
      "appearance": "Appearance", "position": "Position", "advanced": "Advanced",
      "metadata": "Metadata", "networkInfo": "Network Info", "deviceInfo": "Device Info"
    },
    "modals": {
      "settings": "Settings", "addNode": "Add New {node}", "addRack": "Add New {rack}",
      "editNode": "Edit {node}", "editRack": "Edit {rack}", "confirmDelete": "Confirm Delete",
      "languageEditor": "Language Editor", "welcome": "Welcome",
      "layerVisibility": "Layer Visibility", "notes": "Notes", "auditLog": "Audit Log",
      "portMap": "Port Map", "export": "Export", "import": "Import",
      "clearAllNodes": "Clear All Nodes", "recording": "Recording", "recordings": "Recordings",
      "saveInfo": "Save Info", "howToSave": "How to Save", "keyboardShortcuts": "Keyboard Shortcuts",
      "importExport": "Import/Export", "help": "Help", "tabs": "Tabs", "versionHistory": "Version History",
      "error": "Error", "rackPlacementError": "Rack Placement Error"
    },
    "placeholders": {
      "nodeName": "e.g. web-server", "nodeIp": "e.g. 192.168.1.100",
      "tags": "e.g. Docker, nginx, WG: vpn", "rackName": "e.g. Rack-A, DC1-R01",
      "rackIp": "e.g. 192.168.1.0/24", "rackTags": "e.g. Production, Data Center 1",
      "search": "Search...", "searchStrings": "Search strings...",
      "leaveEmpty": "Leave empty for default", "enterNote": "Enter note...",
      "filterAudit": "Filter audit log...", "filterNodes": "Filter nodes...",
      "newTabName": "New tab name...",
      "fromPort": "e.g. eth0, gi0/1", "toPort": "e.g. eth1, gi0/2", "enterText": "Enter text..."
    },
    "tooltips": {
      "addNode": "Add new {node}", "addRack": "Add new {rack}",
      "undo": "Undo (Ctrl+Z)", "redo": "Redo (Ctrl+Y)",
      "settings": "Settings", "saveTheme": "Save current theme", "deleteTheme": "Delete theme",
      "toggleLayers": "Toggle layer visibility", "manageNotes": "Manage encrypted notes",
      "viewAuditLog": "View audit log", "viewPortMap": "View port map",
      "zoomIn": "Zoom in", "zoomOut": "Zoom out", "fitView": "Fit all to view",
      "resetView": "Reset zoom and pan", "toggleMinimap": "Toggle minimap",
      "toggleLegend": "Toggle legend", "toggleToolbar": "Toggle toolbar"
    },
    "options": {
      "orthogonal": "Orthogonal (90°)", "curved": "Curved", "straight": "Straight",
      "flowingArrows": "Flowing Arrows", "dotArrows": "Dot Arrows",
      "allDirections": "All Directions", "forwardOnly": "Forward Only",
      "backwardOnly": "Backward Only", "bidirectionalOnly": "Bidirectional Only",
      "veryFast": "Very Fast", "fast": "Fast", "normal": "Normal", "slow": "Slow", "verySlow": "Very Slow",
      "dashed": "Dashed", "dotted": "Dotted", "solid": "Solid",
      "default": "Default", "custom": "Custom", "customColors": "Custom Colors",
      "none": "None", "auto": "Auto", "manual": "Manual",
      "top": "Top", "bottom": "Bottom", "left": "Left", "right": "Right", "center": "Center",
      "forward": "Forward", "backward": "Backward", "both": "Both"
    },
    "stats": {
      "nodesConnections": "{nodeCount} {nodes} • {edgeCount} {connections}"
    },
    "tabs": {
      "all": "All", "uiGeneral": "UI/General", "howToSave": "How to Save",
      "keyboardShortcuts": "Keyboard Shortcuts", "importExport": "Import/Export"
    },
    "layers": {
      "network": {
        "layer1": "Physical Layer", "layer2": "Logical Layer",
        "layer3": "Security Layer", "layer4": "Application Layer"
      },
      "sports": {
        "layer1": "Players", "layer2": "Equipment",
        "layer3": "Coaching/Strategy", "layer4": "Officials"
      },
      "smarthome": {
        "layer1": "Devices", "layer2": "Security",
        "layer3": "Climate", "layer4": "Entertainment"
      },
      "floorplan": {
        "layer1": "Furniture", "layer2": "Fixtures",
        "layer3": "Utilities", "layer4": "People/Workstations"
      },
      "mindmap": {
        "layer1": "Ideas", "layer2": "Tasks",
        "layer3": "Notes", "layer4": "Links"
      }
    },
    "rackSizes": {
      "42u": "42U (Standard Full Rack)", "48u": "48U (Large Rack)",
      "24u": "24U (Half Rack)", "12u": "12U (Small/Wall Mount)", "6u": "6U (Mini Rack)"
    },
    "auditTypes": {
      "all": "All Events", "create": "Create", "update": "Update", "delete": "Delete",
      "import": "Import", "export": "Export", "layer": "Layer Changes"
    },
    "fonts": {
      "inter": "Inter", "arial": "Arial", "helvetica": "Helvetica",
      "georgia": "Georgia", "monospace": "Monospace"
    }
  },
  "messages": {
    "confirmClearAll": "This will permanently delete everything on the canvas. Continue?",
    "confirmDelete": "Are you sure you want to delete this {node}?",
    "confirmDeleteMultiple": "Delete {count} selected items?",
    "confirmImport": "This will replace all current data. Continue?",
    "importSuccess": "Imported successfully",
    "exportSuccess": "File exported successfully",
    "invalidFile": "Invalid file format",
    "noSelection": "Select at least one {node} first",
    "langImportSuccess": "Language file imported successfully",
    "langResetSuccess": "Language reset to English",
    "langExportSuccess": "Language file exported",
    "invalidLangFile": "Invalid language file structure",
    "setSolidBgNote": "Set solid background to override gradient.",
    "dangerZoneNote": "Permanently delete everything on the canvas.",
    "viewOnlyNote": "When enabled, all editing of the canvas is disabled. Pan and zoom still work.",
    "welcomeHint": "Double click canvas to add {nodes}.<br>Drag from {node} edge to connect.<br>Right-click for more options.",
    "clearAllWarning": "This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure?",
    "clearEverything": "Clear Everything",
    "layerToggleNote": "Toggle which layers are visible on the canvas",
    "notesEncryptionNote": "Notes can also be stored with AES 256 encryption",
    "howToSaveNote": "Browsers cannot overwrite local files. Click Save File to download an updated HTML with all changes. Replace your old file to keep edits. An automatic backup is also saved to your browser's local storage and will prompt for recovery if you close without saving.",
    "decryptionNote": "Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!",
    "noNodesYet": "No {nodes} yet. Double click canvas or use sidebar to add.",
    "selectRecording": "Select a recording to export.",
    "pleaseWait": "This may take a moment, please wait...",
    "recoverWork": "Recover unsaved work from {date}?",
    "replaceCurrentData": "This will replace current data. Continue?",
    "invalidDataFile": "Invalid data file. Missing required fields.",
    "noStringsFound": "No strings found",
    "manageTopologies": "Manage multiple topologies",
    "snapshotLimit": "Limit: Snapshots",
    "trackChanges": "Track all changes made to your topology",
    "portMapDesc": "All connections with port assignments",
    "manageRecordings": "Manage recorded movement sequences",
    "rackViewHint": "Viewing: {name} | Double click empty space to exit",
    "slotCollisionWarning": "Warning: {count} slot collision(s) detected"
  },
  "themes": {
    "default": "Default", "slate": "Slate", "graphite": "Graphite", "frost": "Frost (Light)",
    "synthwave": "Synthwave", "terminal": "Terminal", "dracula": "Dracula",
    "cobalt": "Cobalt", "solarized": "Solarized", "brainwave": "Brainwave",
    "neonMint": "Neon Mint", "velvetDusk": "Velvet Dusk", "sunburst": "Sunburst"
  },
  "themeGroups": {
    "corporate": "Corporate", "homelab": "Homelab", "dev": "Dev", "mindMap": "Mind Map", "myThemes": "My Themes"
  },
  "sidebar": {
    "addNode": "+ {node}", "addRack": "+ {rack}",
    "nodePanel": "{node} Details", "edgePanel": "{connection} Details",
    "properties": "Properties", "style": "Style", "actions": "Actions"
  },
  "topbar": {
    "untitledTopology": "Untitled Topology", "saveHtml": "Save HTML",
    "export": "Export", "import": "Import",
    "backToTopology": "← Back to Topology", "tabs": "Tabs", "snapshots": "Snapshots",
    "audit": "Audit", "ports": "Ports"
  },
  "toolbar": {
    "legend": "Legend", "legendMini": "Connection & Zone Legend", "minimap": "Minimap", "minimapMini": "Map", "draw": "Draw Tools", "drawMini": "Draw",
    "topology": "Topology Tools", "topologyMini": "Add Connection"
  },
  "help": {
    "title": "Help",
    "tabs": {
      "general": "General", "desktop": "Desktop", "mobile": "Mobile", "formats": "Import/Export", "recording": "Recording"
    },
    "general": {
      "addNodes": "Add Nodes:", "addNodesDesc": "Click \"+ Node\" or \"+ Rack\" in the top menu",
      "connectNodes": "Connect Nodes:", "connectNodesDesc": "Select a node, then use \"Add Connection\" in the panel",
      "moveNodes": "Move Nodes:", "moveNodesDesc": "Drag nodes to reposition them",
      "enterRackView": "Enter Rack View:", "enterRackViewDesc": "Double click on desktop or Long press on mobile",
      "multiSelect": "Multi Select:", "multiSelectDesc": "Right click (desktop) or double tap (mobile)",
      "panCanvas": "Pan Canvas:", "panCanvasDesc": "Drag empty space or hold Space + drag",
      "zoom": "Zoom:", "zoomDesc": "Scroll wheel or pinch gesture",
      "freeDraw": "Free Draw:", "freeDrawDesc": "Use draw toolbar for drawing lines, boxes/zones, and text",
      "savingEncryption": "Saving & Encryption",
      "savingNote": "Browsers cannot overwrite local files. Click Save File to download an updated HTML with all changes. Replace your old file to keep edits. An automatic backup is also saved to your browser's local storage and will prompt for recovery if you close without saving.",
      "encryptionNote": "Encryption of data:", "encryptionDesc": "Check \"Encrypt\" before saving to password protect your data. Beware! No recovery possible without password!!",
      "decryptionNote": "Decryption of data:", "decryptionDesc": "Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!"
    },
    "desktop": {
      "navigation": "Navigation", "management": "Management",
      "arrowKeys": "Arrow Keys", "moveSelected1px": "Move selected 1px",
      "shiftArrows": "Shift + Arrows", "moveSelected10px": "Move selected 10px",
      "tabShiftTab": "Tab / Shift+Tab", "cycleNodes": "Cycle through nodes",
      "fKey": "F", "focusSelected": "Focus on selected",
      "spaceDrag": "Space + Drag", "panCanvas": "Pan canvas",
      "lKey": "L", "lockUnlock": "Lock/unlock selected",
      "gKey": "G", "groupUngroup": "Group/ungroup selected",
      "ctrlCV": "Ctrl+C / Ctrl+V", "copyPaste": "Copy / Paste",
      "ctrlD": "Ctrl+D", "duplicate": "Duplicate",
      "ctrlA": "Ctrl+A", "selectAll": "Select all",
      "deleteKey": "Delete", "deleteSelected": "Delete selected",
      "escapeKey": "Escape", "clearSelection": "Clear selection",
      "ctrlZY": "Ctrl+Z / Ctrl+Y", "undoRedo": "Undo / Redo",
      "rightClick": "Right Click", "multiSelectToggle": "Multi select toggle",
      "dblClickRack": "Double click rack", "enterRackView": "Enter rack view",
      "dblClickConnection": "Double click connection", "addWaypoint": "Add waypoint",
      "dblClickEmpty": "Double click empty (in rack)", "exitRackView": "Exit rack view"
    },
    "mobile": {
      "basicGestures": "Basic Gestures", "rackView": "Rack View",
      "tapNode": "Tap node", "selectOpenProperties": "Select & open properties",
      "tapEmpty": "Tap empty", "deselectAll": "Deselect all",
      "dragNode": "Drag node", "moveNode": "Move node",
      "dragEmpty": "Drag empty", "panCanvas": "Pan canvas",
      "pinch": "Pinch", "zoomInOut": "Zoom in/out",
      "doubleTapNode": "Double tap node", "addRemoveSelection": "Add/remove from selection",
      "longPressRack": "Long press rack", "enterRackView": "Enter rack view",
      "longPressConnection": "Long press connection", "addWaypoint": "Add waypoint",
      "doubleTapEmpty": "Double tap empty", "exitRackView": "Exit rack view"
    },
    "formats": {
      "exportHelp": "Export Help", "importHelp": "Import Help",
      "html": "HTML", "htmlDesc": "Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this", "htmlImportDesc": "Import data from another saved HTML file. Extracts and restores all topology data from a previously exported file.",
      "json": "JSON", "jsonExportDesc": "Full backup. Editable in your favorite text editor", "jsonImportDesc": "Replaces all data",
      "markdown": "Markdown", "markdownExportDesc": "Full backup. Editable in your favorite text editor", "markdownImportDesc": "Replaces all data",
      "csv": "CSV", "csvExportDesc": "Full backup in header, nodes in spreadsheet rows", "csvImportDesc": "Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.",
      "png": "PNG", "pngDesc": "Standard image of current canvas tab",
      "svg": "SVG", "svgDesc": "Vector image, scalable and editable image of current canvas tab"
    },
    "recording": {
      "title": "Recording",
      "overview": "Records your tab activity and creates visual documentation, tutorials, plays and/or demonstrations of your mapping changes.",
      "howItWorks": "How It Works",
      "capturesCanvas": "Records the tab area in real time as you create, edit and work",
      "fullInteraction": "Continue adding nodes, creating connections, dragging elements, and making any changes while recording",
      "savedInFile": "Recordings are saved within your data file for later playback",
      "exportVideo": "Recordings can be exported as a video file (WebM format) for sharing",
      "controls": "Controls",
      "recordBtn": "Record", "recordBtnDesc": "Start recording the canvas",
      "playBtn": "Play", "playBtnDesc": "Play back a saved recording",
      "stopBtn": "Stop", "stopBtnDesc": "Stop recording or playback",
      "pauseBtn": "Pause", "pauseBtnDesc": "Pause playback",
      "speed": "Speed", "speedDesc": "Adjust playback speed (0.5x, 1x, 2x, 4x)",
      "loop": "Loop", "loopDesc": "Toggle continuous loop playback"
    }
  },
  "pageLayoutHelp": {
    "dragToResize": "Drag to Resize:",
    "header": "Header:", "headerDesc": "Drag the bottom edge of the header bar",
    "sidebar": "Sidebar:", "sidebarDesc": "Drag the left edge of the sidebar panel",
    "mobile": "Mobile:", "mobileDesc": "Drag the top edge of the footer panel",
    "hoverNote": "Hover over panel edges to see resize handles"
  },
  "confirmModal": {
    "confirm": "Confirm",
    "deleteLineQuestion": "Are you sure you want to delete this line?"
  },
  "editModal": {
    "editTitle": "Edit Title",
    "editName": "Edit Name",
    "editIpSubtitle": "Edit IP/Subtitle",
    "editTag": "Edit Tag",
    "editMacAddress": "Edit MAC Address",
    "addTags": "Add Tag(s) : comma separated",
    "editRackUnit": "Edit Rack Unit",
    "editUHeight": "Edit U Height",
    "rackPlacementError": "Rack Placement Error"
  },
  "drawToolbar": {
    "filled": "Filled", "outlined": "Outlined",
    "solid": "Solid", "dashed": "Dashed", "dotted": "Dotted", "wall": "Wall",
    "noArrows": "No arrows", "arrowRight": "→ Right", "arrowLeft": "← Left", "arrowBoth": "↔ Both",
    "undoLastPoint": "Undo last point"
  },
  "topologyToolbar": {
    "addLineTo": "Add line to:",
    "noArrows": "No arrows", "forward": "→ Forward", "backward": "← Backward", "bidirectional": "↔ Bidirectional"
  },
  "edgePanel": {
    "customLine": "Custom line",
    "animate": "Animate"
  },
  "rectPanel": {
    "zone": "Zone", "fillColor": "Fill Color:", "borderColor": "Border Color:", "borderWidth": "Border Width:",
    "lineStyle": "Line Style:", "deleteZone": "Delete Zone"
  },
  "textPanel": {
    "textElement": "Text Element", "content": "Content:", "fontSizeLabel": "Font Size:", "colorLabel": "Color:",
    "fontWeight": "Font Weight:", "bold": "Bold", "semiBold": "Semi-Bold", "light": "Light",
    "fontStyle": "Font Style:", "italic": "Italic",
    "textAlign": "Text Align:", "textDecoration": "Text Decoration:", "underline": "Underline", "strikeThrough": "Strike Through",
    "enable": "Enable", "deleteText": "Delete Text"
  },
  "tabsModal": {
    "manageTopologies": "Manage multiple topologies",
    "mainTopology": "Main Topology",
    "nodes": "nodes", "connections": "connections",
    "newTabPlaceholder": "New tab name...",
    "addTab": "+ Add Tab"
  },
  "auditModal": {
    "auditLogTitle": "Audit Log",
    "allEvents": "All Events", "create": "Create", "update": "Update", "delete": "Delete",
    "importEvent": "Import", "exportEvent": "Export", "layerChanges": "Layer Changes",
    "noEvents": "No audit events recorded yet"
  },
  "portMapModal": {
    "portMapTitle": "Port Map",
    "exportCsv": "Export CSV"
  },
  "secretEditor": {
    "editNote": "Edit Note",
    "enterSensitiveInfo": "Enter sensitive information here...",
    "encryptNote": "Encrypt Note",
    "noNotesYet": "No notes yet"
  },
  "mobileExport": {
    "pngImage": "PNG Image", "svgVector": "SVG Vector", "jsonFullBackup": "JSON (Full Backup)",
    "markdownExport": "Markdown", "csvExport": "CSV"
  },
  "mobileImport": {
    "html": "HTML", "jsonImport": "JSON", "markdownImport": "Markdown"
  },
  "recording": {
    "startRecording": "Start recording", "stop": "Stop", "playRecording": "Play recording", "pause": "Pause",
    "playbackSpeed": "Playback speed", "loop": "Loop", "manageRecordings": "Manage recordings",
    "playbackPosition": "Playback position", "exportVideo": "Export Video",
    "selectOrCreate": "Select a recording or create a new one",
    "newRecordingPlaceholder": "New recording name...",
    "recording": "Recording"
  },
  "welcome": {
    "title": "Welcome to The One File",
    "subtitle": "What are you mapping today?",
    "chooseMode": "Choose your mode:",
    "chooseCanvas": "Choose canvas style:",
    "chooseTheme": "Choose a theme:",
    "customColors": "Customize colors:",
    "startMapping": "Start Mapping",
    "skip": "Skip",
    "canvasStyle": "Canvas Style",
    "theme": "Theme",
    "colorCustomization": "Color Customization",
    "canvas": {
      "grid": "Standard Grid", "dots": "Dot Grid",
      "blueprint": "Blueprint Grid", "none": "No Grid"
    },
    "modes": {
      "network": "Network Topology", "networkDesc": "Servers, routers, switches",
      "mindmap": "Mind Map", "mindmapDesc": "Ideas, concepts, brainstorming",
      "sports": "Sports Playbook", "sportsDesc": "Plays, formations, positions",
      "smarthome": "Smart Home", "smarthomeDesc": "IoT devices, automation",
      "floorplan": "Floor Plan / Blueprint", "floorplanDesc": "Rooms, layouts, physical spaces"
    },
    "colors": {
      "mainBg": "Top Bar Background", "accent": "Accent",
      "primaryText": "Primary Text", "secondaryText": "Secondary Text",
      "sidebarPanel": "Main Background", "modalWindows": "Modal Background",
      "dangerButtons": "Grid Color", "mobileFooter": "Sidebar Background",
      "moreStyles": "More styles available in main settings panel"
    }
  },
  "bulkToolbar": {
    "selected": "Selected:",
    "alignLeft": "⬅ Left", "alignRight": "➡ Right", "alignTop": "⬆ Top", "alignBottom": "⬇ Bottom",
    "alignLeftShort": "Align Left", "alignRightShort": "Align Right", "alignTopShort": "Align Top", "alignBottomShort": "Align Bottom",
    "distributeH": "↔ Distribute H", "distributeV": "↕ Distribute V",
    "distributeHShort": "Distribute H", "distributeVShort": "Distribute V",
    "clone": "📋 Clone", "cloneAll": "Clone All",
    "copyZone": "📡 Copy Zone", "pasteZone": "📡 Paste Zone", "toggleZones": "📡 Toggle Zones",
    "copyZoneShort": "Copy Zone", "pasteZoneShort": "Paste Zone", "toggleZonesShort": "Toggle Zones",
    "lockToggle": "Lock Toggle", "groupToggle": "Group Toggle",
    "deleteAll": "Delete All", "clearSelection": "Clear Selection",
    "coverageZones": "Coverage Zones",
    "nodesSelected": "Nodes Selected"
  },
  "canvasHints": {
    "scrollZoom": "Scroll to zoom",
    "dragPan": "Drag to pan",
    "rightClickClone": "Right click to clone and align",
    "rightClickMulti": "Right click to select multiple",
    "shiftMarquee": "Hold Shift + drag mouse for marquee selection",
    "power": "You have the power",
    "timeNow": "Your time is NOW!"
  },
  "legend": {
    "connectionLegend": "Connection Legend"
  },
  "nodePanel": {
    "connections": "Connections",
    "styling": "Styling",
    "screen": "Screen:",
    "tablet": "Tablet", "fold": "Fold",
    "fillColor": "Fill Color:", "borderColor": "Border Color:",
    "titleFont": "Title Font:", "subColor": "Sub Color:", "subFont": "Sub Font:", "subSize": "Sub Size:",
    "systemUI": "System UI", "serif": "Serif", "cursive": "Cursive", "courier": "Courier", "times": "Times",
    "textPosition": "Text Position",
    "nameY": "Name Y:", "nameX": "Name X:", "ipY": "IP Y:", "ipX": "IP X:",
    "resetStyles": "Reset Styles",
    "nodesInRack": "Nodes in Rack",
    "uHeight": "U Height:",
    "layer": "Layer:",
    "assignedRack": "Assigned Rack:",
    "rackCapacity": "Rack Capacity:",
    "physical": "Physical",
    "logical": "Logical",
    "security": "Security",
    "application": "Application",
    "mac": "MAC:",
    "rackUnit": "Rack Unit:"
  },
  "langEditor": {
    "tabs": {
      "all": "All", "modes": "Modes", "network": "Network", "mindMap": "Mind Map",
      "sports": "Sports", "smartHome": "Smart Home", "floorPlan": "Floor Plan",
      "ui": "UI", "shapes": "Shapes", "messages": "Messages"
    },
    "searchPlaceholder": "Search strings..."
  },
  "auditLog": {
    "allEvents": "All Events", "nodeOperations": "Node Operations",
    "connections": "Connections", "styleChanges": "Style Changes",
    "rackOperations": "Rack Operations", "layerChanges": "Layer Changes"
  },
  "portMap": {
    "searchPlaceholder": "Search devices or ports...",
    "allConnections": "All Connections", "withPorts": "With Ports Only",
    "missingPorts": "Missing Ports", "noConnections": "No connections found"
  },
  "notes": {
    "noNotes": "No notes yet",
    "namePlaceholder": "Note name (e.g., 'Root Passwords')...",
    "editNote": "Edit Note",
    "contentPlaceholder": "Enter sensitive information here...",
    "encryptNote": "Encrypt Note",
    "newNoteTitle": "New note: {name}",
    "editNoteTitle": "Edit note: {name}"
  },
  "mobileExport": {
    "pngImage": "PNG Image", "svgVector": "SVG Vector",
    "jsonBackup": "JSON (Full Backup)", "markdown": "Markdown",
    "csv": "CSV", "printBW": "Print B&W", "printColor": "Print Color", "exportHelp": "Export Help"
  },
  "mobileImport": {
    "html": "HTML", "json": "JSON", "markdown": "Markdown", "csv": "CSV", "importHelp": "Import Help"
  },
  "recordings": {
    "noRecordings": "No recordings yet. Press Record to start.",
    "exportVideo": "Export Video"
  },
  "rack": {
    "capacity42": "42U (Standard Full Rack)",
    "capacity48": "48U (Large Rack)",
    "capacity24": "24U (Half Rack)",
    "capacity12": "12U (Small/Wall Mount)",
    "capacity6": "6U (Mini Rack)"
  },
  "zone": {
    "coverageZone": "Coverage Zone",
    "preset": "Preset:",
    "applyPreset": "-- Apply Preset --",
    "presets": {
      "securityCam": "Security Camera",
      "ptzCam": "PTZ Camera",
      "motionDetector": "Motion Detector",
      "wifi": "WiFi",
      "wifiExtender": "WiFi Extender",
      "smokeAlarm": "Smoke Alarm",
      "sprinklerArc": "Sprinkler Arc"
    },
    "showZone": "Show Zone:",
    "angle": "Angle:",
    "distance": "Distance:",
    "innerRadius": "Inner Radius:",
    "rotation": "Rotation:",
    "fill": "Fill",
    "border": "Border",
    "color": "Color:",
    "opacity": "Opacity:",
    "gradient": "Gradient:",
    "fadeTowardEdge": "Fade toward edge",
    "width": "Width:",
    "style": "Style:",
    "label": "Label",
    "text": "Text:",
    "labelPlaceholder": "e.g. Detection Zone",
    "position": "Position:",
    "edge": "Edge",
    "outside": "Outside",
    "fontSize": "Font Size:",
    "fontColor": "Font Color:",
    "bold": "Bold:",
    "background": "Background:",
    "offsetX": "Offset X:",
    "offsetY": "Offset Y:",
    "animation": "Animation",
    "animate": "Animate:",
    "type": "Type:",
    "sweep": "Sweep:",
    "speed": "Speed:"
  },
  "tooltips": {
    "renameTab": "Rename tab",
    "deleteTab": "Delete tab",
    "whySave": "Why save?",
    "hideDrawToolbar": "Hide draw toolbar",
    "drawCustomLine": "Draw custom line",
    "drawZone": "Draw zone",
    "addText": "Add text",
    "zoneStyle": "Zone style",
    "lineColor": "Line color",
    "lineStyle": "Line style",
    "arrowDirection": "Arrow direction",
    "hideAddLineToolbar": "Hide add line toolbar",
    "lineDirection": "Line direction",
    "lineRouting": "Line routing",
    "clearSelection": "Clear selection",
    "hideMapZoom": "Hide map & zoom",
    "zoomIn": "Zoom in",
    "zoomOut": "Zoom out",
    "fitToView": "Fit to view",
    "resetView": "Reset view",
    "saveAsPreset": "Save as preset",
    "copyZoneStyle": "Copy zone style",
    "pasteZoneStyle": "Paste zone style",
    "deleteVersion": "Delete this version",
    "editNote": "Edit note",
    "deleteNote": "Delete note",
    "saveCurrentTheme": "Save current theme",
    "deleteTheme": "Delete theme",
    "clearAllNodes": "Clear all {nodes}",
    "addNewNode": "Add new {node}",
    "addNewRack": "Add new {rack}",
    "searchNodes": "Search by name, IP, MAC, role, or tag",
    "manageTabs": "Manage document tabs",
    "viewVersionHistory": "View version history",
    "exportTopology": "Export topology",
    "importTopology": "Import topology",
    "undoLastPoint": "Undo last point",
    "exitRackView": "Exit {rack} view and return to topology",
    "alignLeft": "Align left",
    "alignRight": "Align right",
    "alignTop": "Align top",
    "alignBottom": "Align bottom",
    "distributeH": "Distribute horizontally",
    "distributeV": "Distribute vertically",
    "cloneSelected": "Clone selected",
    "copyZone": "Copy zone style",
    "pasteZone": "Paste zone style",
    "toggleZones": "Toggle zones on selected",
    "deleteSelected": "Delete selected",
    "goToConnection": "Go to {connection}"
  },
  "dialogs": {
    "recoverWork": "Recover unsaved work from {date}?\n({nodeCount} nodes{tabInfo})\n\nClick OK to recover, Cancel to start fresh.",
    "replaceData": "This will replace current data. Continue?",
    "enableZoneFirst": "Enable the zone first before saving as preset",
    "enterPresetName": "Enter preset name:",
    "presetSaved": "Preset saved: {name}",
    "selectNodeFirst": "Select at least one node first",
    "zoneStyleCopied": "Zone style copied from first selected node",
    "selectNodesFirst": "Select nodes first",
    "copyZoneStyleFirst": "Copy a zone style first",
    "zoneStylePasted": "Zone style pasted to {count} node(s)",
    "zonesToggled": "Toggled zones on {count} node(s) to {state}",
    "enterDecryptPassword": "This file is encrypted. Enter password to decrypt:\n(Attempt {attempt} of {max})",
    "decryptionCancelled": "Decryption cancelled. The file will not be loaded.",
    "incorrectPassword": "Incorrect password. Please try again.",
    "maxAttemptsReached": "Maximum attempts reached. The file will not be loaded.",
    "editLegendLabel": "Edit legend label:",
    "enterPort": "Port on {nodeName}:",
    "portAlreadyUsed": "Warning: Port \"{port}\" is already used on {nodeName}. Use anyway?",
    "zoneStyleCopiedShort": "Zone style copied!",
    "drawingDisabledInRack": "Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.",
    "applyRoutingToAll": "Apply \"{routing}\" routing to all {count} connections?",
    "invalidDataFile": "Invalid data file. Missing required fields.",
    "enterEncryptPassword": "Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and it's not recoverable!)",
    "encryptionCancelled": "Encryption cancelled. File not saved.",
    "confirmEncryptPassword": "Confirm your password:",
    "passwordsDoNotMatch": "Passwords do not match. File not saved.",
    "encryptionFailed": "Encryption failed: {error}",
    "restoreVersion": "Restore version from {date}?\n\nYour current work will be lost unless you save first.",
    "deleteVersionConfirm": "Delete this version from history?",
    "clearVersionHistory": "Clear all version history?\n\nThis cannot be undone.",
    "enterSnapshotDescription": "Enter a description for this snapshot:",
    "enterTabName": "Please enter a tab name",
    "noAuditEntries": "No audit entries to export",
    "enterDecryptPasswordFor": "Enter password to decrypt \"{name}\":",
    "decryptionFailed": "Failed to decrypt. Wrong password?",
    "on": "ON",
    "off": "OFF",
    "ok": "OK",
    "cancel": "Cancel",
    "yes": "Yes",
    "no": "No",
    "confirm": "Confirm",
    "alert": "Alert",
    "prompt": "Input Required",
    "invalidDataFile": "Invalid data file. Missing required fields.",
    "importDataFailed": "Failed to import data: {error}",
    "encryptionCancelledNotSaved": "Encryption cancelled. File not saved.",
    "passwordsMismatchNotSaved": "Passwords do not match. File not saved.",
    "encryptionFailedError": "Encryption failed: {error}",
    "enterTabName": "Please enter a tab name",
    "cannotDeleteLastTab": "Cannot delete the last tab",
    "noAuditEntriesToExport": "No audit entries to export",
    "enterNoteName": "Please enter a note name",
    "noteAlreadyExists": "A note with this name already exists",
    "passwordsMismatch": "Passwords do not match",
    "enterRackName": "Please enter a {rack} name.",
    "enterNodeName": "Please enter a {node} name.",
    "screenshotFailed": "Screenshot failed. Please try again.",
    "csvNoDataRows": "CSV file has no data rows",
    "csvNeedsNameColumn": "CSV must have a \"name\" column",
    "fullRestoreComplete": "Full restore complete from CSV backup",
    "importedNodesCount": "Successfully imported {count} {nodes}",
    "importCsvFailed": "Failed to import CSV: {error}",
    "noValidTopologyInMarkdown": "No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.",
    "markdownImportSuccess": "Successfully imported:\n- {nodeCount} {nodes}\n- {edgeCount} {connections}\n- {rectCount} zones\n- {textCount} text labels",
    "jsonImportSuccess": "Successfully imported:\n- {nodeCount} nodes\n- {edgeCount} connections\n- {rectCount} zones\n- {textCount} text labels",
    "importMarkdownFailed": "Failed to import Markdown: {error}",
    "noRecordingAvailable": "No recording available. Press Record to create one.",
    "selectRecordingToDelete": "Select a recording to delete.",
    "selectRecordingToExport": "Select a recording to export.",
    "recordingImported": "Imported: {name}",
    "importRecordingFailed": "Failed to import recording: {error}",
    "selectRecordingForVideo": "Select a recording to export as video.",
    "deleteTab": "Delete tab \"{name}\"?",
    "themeExists": "A theme named \"{name}\" already exists. Replace it?",
    "deleteTheme": "Delete theme \"{name}\"?",
    "clearAuditLog": "Clear all audit log entries?\n\nThis cannot be undone.",
    "deleteNote": "Delete note \"{name}\"?",
    "deleteRecording": "Delete \"{name}\"?",
    "confirmImportJson": "This will replace all current data with the imported data.\n\nImporting:\n- {nodeCount} nodes\n- {edgeCount} connections\n- {tabCount} tab(s)\n\nContinue?",
    "confirmImportHtml": "Import data from HTML file?\n\n- {nodeCount} nodes\n- {edgeCount} connections\n- {tabCount} tab(s)\n\nThis will REPLACE all current data.",
    "invalidHtmlFile": "This HTML file does not contain valid topology data.",
    "htmlImportSuccess": "Successfully imported {nodeCount} nodes and {edgeCount} connections from HTML.",
    "confirmImportCsvFull": "This CSV contains a full backup.\n\n- {nodeCount} nodes in CSV data\n- {tabCount} tab(s) in backup\n- {edgeCount} connections in backup\n\nClick OK for FULL RESTORE (replace all data)\nClick Cancel to just ADD the {csvNodeCount} nodes",
    "confirmImportCsvAdd": "Import {count} nodes from CSV?\n\n{settingsNote}\n\nNote: CSV does not include connections, zones, or text labels.",
    "csvSettingsRestore": "This will ADD nodes and RESTORE settings/theme.",
    "csvAddOnly": "This will ADD nodes to your existing topology.",
    "confirmImportMarkdown": "Import Markdown topology?\n\n- {nodeCount} nodes\n- {edgeCount} connections\n- {rectCount} zones\n- {textCount} text labels\n\nThis will REPLACE all current data.",
    "enterNewTabName": "Enter new name:",
    "saveThemeName": "Enter a name for this theme:",
    "defaultThemeName": "My Theme {number}",
    "enterEncryptPasswordFor": "Enter password to encrypt \"{name}\":",
    "confirmPasswordFor": "Confirm password:",
    "deleteNodeConfirm": "Delete {node} \"{name}\"?",
    "deleteLineConfirm": "Delete this line?",
    "deleteLineNote": "Delete this line note?",
    "deleteRackWithNodes": "Delete {rack} \"{name}\"?\n\nThis will also delete {count} {node}(s) inside:\n• {nodeList}",
    "deleteEmptyRack": "Delete {rack} \"{name}\"? (empty {rack})",
    "deleteNodeWithConnections": "Delete {node} \"{name}\" and all its {connections}?",
    "rackCapacityExceeded": "Device requires U{startU}-U{endU} but {rack} only has {capacity}U capacity. Device would exceed {rack} by {excess}U.",
    "invalidRackPosition": "Invalid {rack} position. U position must be at least 1."
  },
  "emptyStates": {
    "noStringsFound": "No strings found",
    "noNodesAssigned": "No nodes assigned",
    "noConnections": "No connections",
    "noVersionHistory": "No version history yet. Versions are saved automatically when you save the file.",
    "noAuditEntries": "No audit entries yet",
    "noNotesYet": "No notes yet",
    "noConnectionsFound": "No connections found",
    "noRecordingsYet": "No recordings yet. Press Record to start.",
    "generatingVideo": "Generating Video..."
  },
  "legends": {
    "legend": "Legend",
    "zoneLegend": "Zone Legend",
    "lineLegend": "Line Legend",
    "coverageZone": "Coverage Zone",
    "defaultLineLabel": "you can edit me too"
  }
}</script>
    <script>
      const DEFAULT_LANG = JSON.parse(document.getElementById("lang-json").textContent);
      let LANG = JSON.parse(JSON.stringify(DEFAULT_LANG));
      let CUSTOM_LANG = null;

      function t(key, replacements = {}) {
        const mode = (typeof PAGE_STATE !== 'undefined' && PAGE_STATE.mappingMode) || 'network';
        const modeLabels = LANG.modes[mode] || LANG.modes.network;
        let text = key.split('.').reduce((obj, k) => obj?.[k], LANG);
        if (text === undefined || text === null || typeof text === 'object') return key;
        text = text.replace(/\{node\}/g, modeLabels.node);
        text = text.replace(/\{nodes\}/g, modeLabels.nodes);
        text = text.replace(/\{connection\}/g, modeLabels.connection);
        text = text.replace(/\{connections\}/g, modeLabels.connections);
        text = text.replace(/\{rack\}/g, modeLabels.rack);
        text = text.replace(/\{racks\}/g, modeLabels.racks);
        for (const [k, v] of Object.entries(replacements)) {
          text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), v);
        }
        return text;
      }

      function setNestedValue(obj, key, value) {
        const keys = key.split('.');
        let current = obj;
        for (let i = 0; i < keys.length - 1; i++) {
          if (!current[keys[i]]) current[keys[i]] = {};
          current = current[keys[i]];
        }
        current[keys[keys.length - 1]] = value;
      }

      function deepMerge(target, source) {
        const result = JSON.parse(JSON.stringify(target));
        for (const key of Object.keys(source)) {
          if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
            result[key] = deepMerge(result[key] || {}, source[key]);
          } else {
            result[key] = source[key];
          }
        }
        return result;
      }

      function flattenLangObject(obj, prefix = '') {
        const result = [];
        for (const [key, value] of Object.entries(obj)) {
          if (key === '_meta') continue;
          const fullKey = prefix ? `${prefix}.${key}` : key;
          if (typeof value === 'object' && value !== null) {
            result.push(...flattenLangObject(value, fullKey));
          } else {
            result.push({ key: fullKey, value: String(value), category: fullKey.split('.')[0] });
          }
        }
        return result;
      }

      function applyLanguage() {
        const isRTL = LANG._meta?.rtl === true;
        document.documentElement.dir = isRTL ? 'rtl' : 'ltr';
        document.documentElement.classList.toggle('rtl', isRTL);

        document.querySelectorAll('[data-lang]').forEach(el => {
          const key = el.dataset.lang;
          const attr = el.dataset.langAttr || 'textContent';
          const translated = t(key);
          if (attr === 'placeholder') {
            el.placeholder = translated;
          } else if (attr === 'title') {
            el.title = translated;
          } else if (attr === 'innerHTML') {
            el.innerHTML = translated;
          } else if (attr === 'label') {
            el.label = translated;
          } else {
            el.textContent = translated;
          }
        });
        document.querySelectorAll('[data-lang-text]').forEach(el => {
          el.textContent = t(el.dataset.langText);
        });
        document.querySelectorAll('[data-lang-placeholder]').forEach(el => {
          el.placeholder = t(el.dataset.langPlaceholder);
        });
        document.querySelectorAll('[data-lang-label]').forEach(el => {
          el.label = t(el.dataset.langLabel);
        });
        if (typeof applyMappingModeLabels === 'function') {
          applyMappingModeLabels();
        }
        if (typeof updateLayerLabels === 'function') {
          updateLayerLabels();
        }
      }

      function saveLanguageToStorage() {
        if (CUSTOM_LANG) {
          localStorage.setItem('theOneFileCustomLang', JSON.stringify(CUSTOM_LANG));
        } else {
          localStorage.removeItem('theOneFileCustomLang');
        }
      }

      function loadLanguageFromStorage() {
        const stored = localStorage.getItem('theOneFileCustomLang');
        if (stored) {
          try {
            CUSTOM_LANG = JSON.parse(stored);
            LANG = deepMerge(DEFAULT_LANG, CUSTOM_LANG);
          } catch (e) {
            console.warn('Failed to load custom language:', e);
          }
        }
      }

      function exportLanguageFile() {
        const langToExport = CUSTOM_LANG || LANG;
        const blob = new Blob([JSON.stringify(langToExport, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `language-${langToExport._meta?.code || 'custom'}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }

      function importLanguageFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const imported = JSON.parse(e.target.result);
            if (!imported._meta && !imported.modes && !imported.ui) {
              throw new Error('Invalid language file structure');
            }
            const currentEdition = DEFAULT_LANG._meta?.edition || 'core';
            const importedEdition = imported._meta?.edition;
            if (importedEdition && importedEdition !== currentEdition) {
              throw new Error(`Edition mismatch: This language file is for "${importedEdition}" edition but you are using "${currentEdition}" edition`);
            }
            CUSTOM_LANG = imported;
            LANG = deepMerge(DEFAULT_LANG, imported);
            applyLanguage();
            saveLanguageToStorage();
            showAlert(t('messages.langImportSuccess'));
          } catch (err) {
            showAlert(t('messages.invalidLangFile') + ': ' + err.message);
          }
        };
        reader.readAsText(file);
      }

      function resetToDefaultLanguage() {
        LANG = JSON.parse(JSON.stringify(DEFAULT_LANG));
        CUSTOM_LANG = null;
        localStorage.removeItem('theOneFileCustomLang');
        applyLanguage();
        updateCurrentLangDisplay();
        showAlert(t('messages.langResetSuccess'));
      }

      function updateCurrentLangDisplay() {
        const langNameEl = document.getElementById('current-lang-name');
        if (langNameEl) {
          langNameEl.textContent = LANG._meta?.name || 'English';
          if (CUSTOM_LANG) {
            langNameEl.textContent += ' (Custom)';
          }
        }
      }

      function escapeHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      }

      let langEditorStrings = [];
      let langEditorFilter = 'all';
      let langEditorSearch = '';

      function openLanguageEditor() {
        langEditorStrings = flattenLangObject(LANG);
        langEditorFilter = 'all';
        langEditorSearch = '';
        renderLangEditorList();

        document.querySelectorAll('.lang-editor-tabs .lang-tab').forEach(tab => {
          tab.onclick = () => {
            document.querySelectorAll('.lang-editor-tabs .lang-tab').forEach(t => {
              t.style.background = 'var(--btn-bg)';
              t.style.color = 'var(--btn-text)';
              t.classList.remove('active');
            });
            tab.style.background = 'var(--accent)';
            tab.style.color = 'var(--bg)';
            tab.classList.add('active');
            langEditorFilter = tab.dataset.filter;
            renderLangEditorList();
          };
        });
        const searchInput = document.getElementById('lang-search');
        if (searchInput) {
          searchInput.value = '';
          searchInput.oninput = () => {
            langEditorSearch = searchInput.value.toLowerCase();
            renderLangEditorList();
          };
        }
        document.getElementById('language-editor-modal').style.display = 'flex';
      }

      function renderLangEditorList() {
        const list = document.querySelector('.lang-editor-list');
        if (!list) return;

        const filtered = langEditorStrings.filter(s => {
          if (langEditorFilter !== 'all') {
            if (!s.key.startsWith(langEditorFilter)) return false;
          }
          if (langEditorSearch) {
            const searchLower = langEditorSearch.toLowerCase();
            if (!s.key.toLowerCase().includes(searchLower) &&
                !s.value.toLowerCase().includes(searchLower)) {
              return false;
            }
          }
          return true;
        });

        if (filtered.length === 0) {
          list.innerHTML = '<div style="padding:20px;text-align:center;color:var(--text-soft);">' + t("emptyStates.noStringsFound") + '</div>';
          return;
        }

        list.innerHTML = filtered.map(s => `
          <div style="display:flex;gap:12px;padding:8px 12px;border-bottom:1px solid var(--topbar-border);align-items:center;">
            <span style="flex:0 0 280px;font-size:11px;color:var(--text-soft);font-family:monospace;word-break:break-all;">${escapeHtml(s.key)}</span>
            <input type="text" class="lang-value" data-key="${escapeHtml(s.key)}" value="${escapeHtml(s.value)}"
              style="flex:1;padding:6px 10px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;font-size:13px;">
          </div>
        `).join('');
      }

      function closeLanguageEditor() {
        document.getElementById('language-editor-modal').style.display = 'none';
      }

      function saveLangEdits() {
        const inputs = document.querySelectorAll('.lang-editor-list .lang-value');
        let hasChanges = false;

        inputs.forEach(input => {
          const key = input.dataset.key;
          const newValue = input.value;

          const original = langEditorStrings.find(s => s.key === key);
          if (original && original.value !== newValue) {
            setNestedValue(LANG, key, newValue);
            original.value = newValue;
            hasChanges = true;
          }
        });

        if (hasChanges) {
          CUSTOM_LANG = JSON.parse(JSON.stringify(LANG));
          saveLanguageToStorage();
          applyLanguage();
          updateCurrentLangDisplay();
        }

        closeLanguageEditor();
      }

      const LABELS = {
        get mappingModes() { return LANG.modes; },
        get canvasTemplates() {
          const result = {};
          for (const [k, v] of Object.entries(LANG.canvas)) {
            result[k] = { name: v };
          }
          return result;
        },
        get defaultShapeCategories() {
          return {
            network: LANG.shapes.categories.network,
            mindmap: LANG.shapes.categories.basic,
            sports: LANG.shapes.categories.basic,
            smarthome: LANG.shapes.categories.smarthome,
            floorplan: LANG.shapes.categories.basic
          };
        }
      };
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);

      const SHAPE_CATEGORIES = {
        basic: [
          { value: 'circle', label: 'Circle' },
          { value: 'square', label: 'Square' },
          { value: 'rectangle', label: 'Rectangle' },
          { value: 'triangle', label: 'Triangle' },
          { value: 'hexagon', label: 'Hexagon' },
          { value: 'diamond', label: 'Diamond' },
          { value: 'star', label: 'Star' },
          { value: 'stop-sign', label: 'Stop Sign' },
          { value: 'octagon', label: 'Octagon' },
          { value: 'pentagon', label: 'Pentagon' },
          { value: 'cross', label: 'Cross' },
          { value: 'rounded-square', label: 'Rounded Square' },
          { value: 'pill', label: 'Pill' },
          { value: 'parallelogram', label: 'Parallelogram' },
          { value: 'trapezoid', label: 'Trapezoid' }
        ],
        computers: [
          { value: 'server', label: 'Server' },
          { value: 'pc', label: 'PC / Desktop' },
          { value: 'laptop', label: 'Laptop' },
          { value: 'phone', label: 'Phone / Mobile' },
          { value: 'printer', label: 'Printer' },
          { value: 'pi', label: 'Raspberry Pi' },
          { value: 'sensor', label: 'Sensor / IoT' }
        ],
        network: [
          { value: 'router', label: 'Router' },
          { value: 'switch', label: 'Switch' },
          { value: 'firewall', label: 'Firewall' },
          { value: 'access-point', label: 'Access Point' },
          { value: 'load-balancer', label: 'Load Balancer' },
          { value: 'gateway', label: 'Gateway' },
          { value: 'vpn', label: 'VPN / Tunnel' },
          { value: 'nas', label: 'NAS / Storage' }
        ],
        cloud: [
          { value: 'cloud', label: 'Cloud' },
          { value: 'database', label: 'Database' },
          { value: 'docker', label: 'Docker' },
          { value: 'container', label: 'Container' },
          { value: 'vm', label: 'Virtual Machine' },
          { value: 'kubernetes', label: 'Kubernetes' },
          { value: 'api', label: 'API / Endpoint' },
          { value: 'queue', label: 'Queue / Message' },
          { value: 'lambda', label: 'Lambda / Function' },
          { value: 'bucket', label: 'Bucket / S3' }
        ],
        security: [
          { value: 'shield', label: 'Shield' },
          { value: 'camera', label: 'Camera / CCTV' },
          { value: 'monitor', label: 'Monitor / Dashboard' }
        ],
        smarthome: [
          { value: 'thermostat', label: 'Thermostat' },
          { value: 'doorbell', label: 'Video Doorbell' },
          { value: 'smart-lock', label: 'Smart Lock' },
          { value: 'smart-bulb', label: 'Smart Bulb' },
          { value: 'smart-plug', label: 'Smart Plug' },
          { value: 'smart-speaker', label: 'Smart Speaker' },
          { value: 'smart-tv', label: 'Smart TV' },
          { value: 'hub', label: 'Smart Hub' },
          { value: 'smoke-detector', label: 'Smoke Detector' },
          { value: 'motion-sensor', label: 'Motion Sensor' },
          { value: 'garage', label: 'Garage Door' },
          { value: 'sprinkler', label: 'Sprinkler' },
          { value: 'vacuum', label: 'Robot Vacuum' }
        ],
        sports: [
          { value: 'basketball-ball', label: 'Basketball' },
          { value: 'football-ball', label: 'Football' },
          { value: 'soccer-ball', label: 'Soccer Ball' },
          { value: 'hockey-puck', label: 'Hockey Puck' },
          { value: 'baseball-ball', label: 'Baseball' },
          { value: 'tennis-ball', label: 'Tennis Ball' },
          { value: 'volleyball', label: 'Volleyball' },
          { value: 'rugby-ball', label: 'Rugby Ball' },
          { value: 'golf-ball', label: 'Golf Ball' },
          { value: 'frisbee', label: 'Frisbee' },
          { value: 'cricket-ball', label: 'Cricket Ball' },
          { value: 'lacrosse-stick', label: 'Lacrosse Stick' },
          { value: 'golf-flag', label: 'Golf Hole Flag' },
          { value: 'tactical-x', label: 'X (Defender)' },
          { value: 'tactical-o', label: 'O (Offensive)' },
          { value: 'tactical-star', label: 'Star (Key Player)' }
        ],
        rack: [
          { value: 'patch-panel', label: 'Patch Panel' },
          { value: 'ups', label: 'UPS' },
          { value: 'pdu', label: 'PDU' },
          { value: 'rack-shelf', label: 'Shelf' },
          { value: 'blank-panel', label: 'Blank Panel' },
          { value: 'cable-management', label: 'Cable Management' },
          { value: 'kvm', label: 'KVM' }
        ]
      };

      const CANVAS_OPTIONS = {
        network: [
          { value: 'grid', label: 'Standard Grid' },
          { value: 'dots', label: 'Dot Grid' },
          { value: 'blueprint', label: 'Blueprint Grid' },
          { value: 'none', label: 'No Grid' }
        ],
        mindmap: [],
        sports: [
          { value: 'basketball', label: 'Basketball Court' },
          { value: 'football', label: 'Football Field' },
          { value: 'soccer', label: 'Soccer Pitch' },
          { value: 'hockey', label: 'Hockey Rink' },
          { value: 'baseball', label: 'Baseball Diamond' },
          { value: 'tennis', label: 'Tennis Court' }
        ],
        smarthome: [
          { value: 'blueprint', label: 'Blueprint Grid' },
          { value: 'grid', label: 'Standard Grid' },
          { value: 'dots', label: 'Dot Grid' },
          { value: 'none', label: 'No Grid' }
        ],
        floorplan: [] 
      };

      const MODE_DEFAULT_CATEGORIES = {
        network: 'network',
        mindmap: 'basic',
        sports: 'sports',
        smarthome: 'smarthome',
        floorplan: 'basic'
      };

      function findCategoryForShape(shape) {
        if (!shape) return MODE_DEFAULT_CATEGORIES[PAGE_STATE.mappingMode || 'network'] || 'basic';
        for (const [category, shapes] of Object.entries(SHAPE_CATEGORIES)) {
          if (shapes.some(s => s.value === shape)) {
            return category;
          }
        }
        return MODE_DEFAULT_CATEGORIES[PAGE_STATE.mappingMode || 'network'] || 'basic';
      }

      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["layer1", "layer2", "layer3", "layer4"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       if (window.DEMO_MODE) return;
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         zoneLegend: ZONE_LEGEND,
         zonePresets: ZONE_PRESETS,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
		 recordings: RECORDING_STATE.recordings,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       if (window.DEMO_MODE) return null;
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       if (window.DEMO_MODE) return;
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         const hasPageState = saved.page && Object.keys(saved.page).length > 0;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1 || hasPageState)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || await showConfirm(t("dialogs.recoverWork", { date: savedDate, nodeCount: savedNodeCount, tabInfo: tabInfo }))) {
           if (!hasCurrentData || await showConfirm(t("dialogs.replaceData"))) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
			ZONE_LEGEND = saved.zoneLegend || {};
            ZONE_PRESETS = saved.zonePresets || {};
            loadCustomPresets();
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.recordings) {
              RECORDING_STATE.recordings = saved.recordings;
              RECORDING_STATE.currentRecording = saved.recordings[0] || null;
            }
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
            Object.values(NODE_DATA).forEach(node => {
              if (!node.tags) node.tags = [];
              if (!node.notes) node.notes = [];
              if (!node.layer || layerMap[node.layer]) node.layer = layerMap[node.layer] || 'layer1';
            });
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = t("toolbar.legendMini");
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = t("toolbar.minimapMini");
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = t("toolbar.drawMini");
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = t("toolbar.topologyMini");
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       canvasGridEnabled: true,
       rackFrameFill: "#0f172a",
       rackGridEnabled: true,
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
	   mappingMode: "network",
	   canvasTemplate: "grid",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  let ZONES_VISIBLE = true;
	  let RECORDING_STATE = {
	    isRecording: false,
	    isPlaying: false,
	    isPaused: false,
	    currentRecording: null,
	    recordings: [],
	    startTime: 0,
	    frames: [],
	    playbackIndex: 0,
	    playbackSpeed: 1,
	    loopPlayback: false,
	    captureInterval: null,
	    playbackTimer: null,
	    CAPTURE_FPS: 10,
	    videoRecorder: null,
	    videoChunks: [],
	    videoCanvas: null,
	    videoCtx: null,
	    videoAnimFrame: null,
	    isVideoRecording: false
	  };
	  
		const ANIM_SETTINGS = {
		  masterAnim: true,
		  masterZones: true,
		  animTypes: { sweep: true, pulse: true, rings: true, spin: true, connections: true },
		  animCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true, connections: true },
		  zoneCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true }
		};
		
function getShapeCategory(shape) {
  const map = {
    "camera": "camera", "cctv": "camera", "ptz-cam": "camera",
    "doorbell": "doorbell",
    "motion-sensor": "motion", "motion-detect": "motion",
    "smoke-detector": "smoke", "smoke-alarm": "smoke",
    "access-point": "wifi", "wifi": "wifi", "router": "wifi", "wifi-strong": "wifi", "wifi-weak": "wifi",
    "sensor": "sensor", "iot": "sensor",
    "sprinkler": "sprinkler", "sprinkler-arc": "sprinkler"
  };
  return map[shape] || null;
}
function isAnimationAllowed(shape, animType) {
  if (!ANIM_SETTINGS.masterAnim) return false;
  if (!ANIM_SETTINGS.animTypes[animType]) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.animCategories[cat]) return false;
  return true;
}
function isZoneAllowed(shape) {
  if (!ANIM_SETTINGS.masterZones) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.zoneCategories[cat]) return false;
  return true;
}
function applyAnimZoneSettings() {
  document.querySelectorAll(".fov-group").forEach(g => {
    const nodeEl = g.closest("g[data-node-id]");
    if (!nodeEl) return;
    const nodeId = nodeEl.dataset.nodeId;
    const node = NODE_DATA[nodeId];
    if (!node) return;
    const cat = getShapeCategory(node.shape);
    const zoneVisible = ANIM_SETTINGS.masterZones && (!cat || ANIM_SETTINGS.zoneCategories[cat]);
    g.style.display = zoneVisible ? "" : "none";
    if (zoneVisible && node.fovAnimate) {
      const animType = node.fovAnimationType || "sweep";
      const animAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes[animType] && (!cat || ANIM_SETTINGS.animCategories[cat]);
      g.style.animationPlayState = animAllowed ? "running" : "paused";
      g.querySelectorAll("circle").forEach(c => c.style.animationPlayState = animAllowed ? "running" : "paused");
    }
  });
  const connAnimAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes.connections && ANIM_SETTINGS.animCategories.connections;
  document.querySelectorAll(".edge-arrow-forward, .edge-arrow-backward").forEach(a => {
    a.style.animationPlayState = connAnimAllowed ? "running" : "paused";
  });
}
let ZONE_LEGEND = {};
let ZONE_PRESETS = {};
let copiedZoneStyle = null;
	  function hasCoverageZone(shape) {
		  const supportedShapes = [
			"camera", "cctv", "doorbell",
			"motion-sensor", "smoke-detector",
			"access-point", "wifi", "router",
			"sensor", "iot", "sprinkler"
		  ];
		  return supportedShapes.includes(shape);
		}

		function getCoverageDefaults(shape) {
		  const defaults = {
			"camera": { angle: 90, distance: 150, animationType: "sweep" },
			"cctv": { angle: 90, distance: 150, animationType: "sweep" },
			"doorbell": { angle: 120, distance: 100, animationType: "sweep" },
			"motion-sensor": { angle: 120, distance: 100, animationType: "pulse" },
			"smoke-detector": { angle: 360, distance: 80, animationType: "pulse" },
			"access-point": { angle: 360, distance: 200, animationType: "rings" },
			"wifi": { angle: 360, distance: 200, animationType: "rings" },
			"router": { angle: 360, distance: 200, animationType: "rings" },
			"sensor": { angle: 90, distance: 100, animationType: "pulse" },
			"iot": { angle: 90, distance: 100, animationType: "pulse" },
			"sprinkler": { angle: 90, distance: 120, animationType: "spin" }
		  };
		  return defaults[shape] || { angle: 90, distance: 150, animationType: "sweep" };
		}
		function toggleAllZones() {
  ANIM_SETTINGS.masterZones = !ANIM_SETTINGS.masterZones;
  const masterCheckbox = document.getElementById("zone-master");
  if (masterCheckbox) masterCheckbox.checked = ANIM_SETTINGS.masterZones;
  applyAnimZoneSettings();
}

function copyZoneStyle(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  copiedZoneStyle = {
    fovEnabled: node.fovEnabled,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovRotation: node.fovRotation,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovLabel: node.fovLabel,
    fovLabelPosition: node.fovLabelPosition,
    fovLabelSize: node.fovLabelSize,
    fovLabelColor: node.fovLabelColor,
    fovLabelBold: node.fovLabelBold,
    fovLabelBg: node.fovLabelBg,
    fovLabelBgColor: node.fovLabelBgColor,
    fovLabelOffsetX: node.fovLabelOffsetX,
    fovLabelOffsetY: node.fovLabelOffsetY,
    fovAnimate: node.fovAnimate,
    fovAnimationType: node.fovAnimationType,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
}

function pasteZoneStyle(nodeId) {
  if (!copiedZoneStyle) return;
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  pushUndo("paste zone style");
  Object.assign(node, copiedZoneStyle);
  updateFovCone(nodeId);
  if (currentNodeId === nodeId) {
    claimTheImmortal(nodeId);
  }
}

function applyZonePreset(preset) {
  if (!currentNodeId) return;
  const presets = {
    "security-cam": { fovAngle: 90, fovDistance: 150, fovColor: "#f59e0b", fovOpacity: 20, fovAnimationType: "sweep", fovAnimate: false },
    "ptz-cam": { fovAngle: 60, fovDistance: 200, fovColor: "#f59e0b", fovOpacity: 25, fovAnimationType: "sweep", fovAnimate: true, fovSweep: 180, fovSpeed: 8 },
    "motion-detect": { fovAngle: 120, fovDistance: 100, fovColor: "#10b981", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: true, fovSpeed: 3 },
    "wifi-strong": { fovAngle: 360, fovDistance: 150, fovColor: "#3b82f6", fovOpacity: 10, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 4 },
    "wifi-weak": { fovAngle: 360, fovDistance: 250, fovColor: "#3b82f6", fovOpacity: 8, fovGradient: true, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 5 },
    "smoke-alarm": { fovAngle: 360, fovDistance: 80, fovColor: "#ef4444", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: false },
    "sprinkler-arc": { fovAngle: 90, fovDistance: 120, fovColor: "#06b6d4", fovOpacity: 20, fovAnimationType: "spin", fovAnimate: true, fovSpeed: 6 }
  };
  const allPresets = { ...presets, ...ZONE_PRESETS };
  const settings = allPresets[preset];
  if (!settings) return;
  
  pushUndo("apply zone preset");
  const node = NODE_DATA[currentNodeId];
  node.fovEnabled = true;
  Object.assign(node, settings);
  updateFovCone(currentNodeId);
  claimTheImmortal(currentNodeId);
}

function saveCustomZonePreset() {
  if (!currentNodeId) return;
  const node = NODE_DATA[currentNodeId];
  if (!node.fovEnabled) {
    showAlert(t("dialogs.enableZoneFirst"));
    return;
  }
  showPrompt(t("dialogs.enterPresetName"), "").then(name => {
    if (!name || !name.trim()) return;

    const presetId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    ZONE_PRESETS[presetId] = {
      fovAngle: node.fovAngle,
      fovDistance: node.fovDistance,
      fovInnerRadius: node.fovInnerRadius,
      fovColor: node.fovColor,
      fovOpacity: node.fovOpacity,
      fovGradient: node.fovGradient,
      fovBorderColor: node.fovBorderColor,
      fovBorderWidth: node.fovBorderWidth,
      fovBorderStyle: node.fovBorderStyle,
      fovBorderOpacity: node.fovBorderOpacity,
      fovAnimationType: node.fovAnimationType,
      fovAnimate: node.fovAnimate,
      fovSweep: node.fovSweep,
      fovSpeed: node.fovSpeed
    };
    const select = document.getElementById("fov-preset");
    if (select && !select.querySelector(`option[value="${presetId}"]`)) {
      const opt = document.createElement("option");
      opt.value = presetId;
      opt.textContent = name.trim() + " (Custom)";
      select.appendChild(opt);
    }
    showAlert(t("dialogs.presetSaved", { name: name.trim() }));
  });
}

function bulkCopyZoneStyle() {
  if (selectedNodes.size === 0) {
    showAlert(t("dialogs.selectNodeFirst"));
    return;
  }
  const firstId = [...selectedNodes][0];
  if (copyZoneStyle(firstId)) {
    showAlert(t("dialogs.zoneStyleCopied"));
  }
}

function bulkPasteZoneStyle() {
  if (selectedNodes.size === 0) {
    showAlert(t("dialogs.selectNodesFirst"));
    return;
  }
  if (!copiedZoneStyle) {
    showAlert(t("dialogs.copyZoneStyleFirst"));
    return;
  }
  pushUndo("bulk paste zone style");
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      Object.assign(node, copiedZoneStyle);
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  showAlert(t("dialogs.zoneStylePasted", { count }));
}

function bulkToggleZones() {
  if (selectedNodes.size === 0) {
    showAlert(t("dialogs.selectNodesFirst"));
    return;
  }
  pushUndo("bulk toggle zones");
  const firstNode = NODE_DATA[[...selectedNodes][0]];
  const newState = !(firstNode?.fovEnabled);
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      node.fovEnabled = newState;
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  showAlert(t("dialogs.zonesToggled", { count, state: newState ? t("dialogs.on") : t("dialogs.off") }));
}

function loadCustomPresets() {
  const select = document.getElementById("fov-preset");
  if (!select) return;
  Object.keys(ZONE_PRESETS).forEach(id => {
    if (!select.querySelector(`option[value="${id}"]`)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id.replace(/-/g, " ") + " ★";
      select.appendChild(opt);
    }
  });
}

function updateZoneLegend() {
  const container = document.getElementById("edge-legend");
  if (!container) return;
  container.querySelectorAll(".zone-legend-item").forEach(el => el.remove());
  container.querySelectorAll(".zone-legend-title").forEach(el => el.remove());
  const zoneColors = new Set();
  Object.values(NODE_DATA).forEach(node => {
    if (hasCoverageZone(node.shape) && node.fovEnabled && node.fovColor) {
      zoneColors.add(node.fovColor);
    }
  });
  
  if (zoneColors.size === 0) return;
  const zoneTitle = document.createElement("div");
  zoneTitle.className = "legend-title zone-legend-title";
  zoneTitle.textContent = t("legends.zoneLegend");
  zoneTitle.style.marginTop = "12px";
  zoneTitle.style.paddingTop = "8px";
  zoneTitle.style.borderTop = "1px solid var(--edge-main)";
  container.appendChild(zoneTitle);
  zoneColors.forEach(color => {
    if (!ZONE_LEGEND[color]) {
      ZONE_LEGEND[color] = t("legends.coverageZone");
    }
    const item = document.createElement("div");
    item.className = "legend-item zone-legend-item";
    item.addEventListener("mousedown", (e) => e.stopPropagation());
    item.addEventListener("click", (e) => e.stopPropagation());
    
    const swatch = document.createElement("span");
    swatch.className = "legend-swatch";
    swatch.style.backgroundColor = color;
    swatch.style.opacity = "0.5";
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", (e) => {
      e.stopPropagation();
      const nodeWithColor = Object.entries(NODE_DATA).find(([id, n]) => 
        hasCoverageZone(n.shape) && n.fovEnabled && n.fovColor === color
      );
      if (nodeWithColor) {
        claimTheImmortal(nodeWithColor[0]);
      }
    });
    
    const label = document.createElement("span");
    label.className = "legend-label";
    label.textContent = ZONE_LEGEND[color];
    label.contentEditable = true;
    label.addEventListener("focus", () => label.classList.add("editing"));
    label.addEventListener("blur", () => {
      label.classList.remove("editing");
      ZONE_LEGEND[color] = label.textContent.trim() || "Coverage Zone";
    });
    label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        label.blur();
      }
    });
    
    item.append(swatch, label);
    container.appendChild(item);
  });
  
  updateLegendVisibility();
}
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          const nodeIpEl = document.getElementById("node-ip");
          const modeLabels = LANG.modes[PAGE_STATE.mappingMode] || LANG.modes.network;
          if (data.ip) {
            nodeIpEl.textContent = data.ip;
            nodeIpEl.style.opacity = "1";
          } else {
            nodeIpEl.textContent = "Click to add " + modeLabels.subtitle;
            nodeIpEl.style.opacity = "0.5";
          }
			const fovSection = document.getElementById("fov-section");
			if (fovSection) {
			  if (hasCoverageZone(data.shape)) {
				const defaults = getCoverageDefaults(data.shape);
				fovSection.style.display = "block";
				document.getElementById("fov-enabled").checked = data.fovEnabled || false;
				document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
				document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
				document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
				document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
				document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
				document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
				document.getElementById("fov-rotation").value = data.fovRotation || 0;
				document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
				document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
				document.getElementById("fov-gradient").checked = data.fovGradient || false;
				document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
				document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
				document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
				document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
				document.getElementById("fov-label").value = data.fovLabel || "";
				document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
				document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
				document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
				document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
				document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
				document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
				document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
				document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
				document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
				document.getElementById("fov-animate").checked = data.fovAnimate || false;
				document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
				document.getElementById("fov-sweep").value = data.fovSweep || 120;
				document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
				document.getElementById("fov-speed").value = data.fovSpeed || 4;
				document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
			  } else {
				fovSection.style.display = "none";
			  }
			}
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge, .minimap-wall, .minimap-rect").forEach(el => el.remove());
  const frag = document.createDocumentFragment();
  const ns = "http://www.w3.org/2000/svg";
  const dotColor = PAGE_STATE.minimapDots || "#94a3b8";

  if (RECT_DATA && RECT_DATA.list && currentView.mode !== "rack") {
    RECT_DATA.list.forEach((rect) => {
      if (rect.lineStyle === "wall") {
        const wallRect = document.createElementNS(ns, "rect");
        wallRect.setAttribute("x", rect.x);
        wallRect.setAttribute("y", rect.y);
        wallRect.setAttribute("width", rect.width);
        wallRect.setAttribute("height", rect.height);
        wallRect.style.fill = rect.color || "#666";
        wallRect.style.fillOpacity = "0.6";
        wallRect.style.stroke = rect.borderColor || rect.color || "#666";
        wallRect.style.strokeWidth = "4";
        wallRect.classList.add("minimap-wall");
        frag.appendChild(wallRect);
      }
    });
  }

  EDGE_DATA.list.forEach((edge) => {
    if (edge.type === "custom") {
      if (Array.isArray(edge.points) && edge.points.length >= 2) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", edge.points.map(p => `${p.x},${p.y}`).join(" "));
        polyline.classList.add("minimap-edge");
        frag.appendChild(polyline);
      }
      return;
    }
    const fromNode = NODE_DATA[edge.from];
    const toNode = NODE_DATA[edge.to];
    if (!fromNode || !toNode) return;
    if (currentView.mode === "rack") {
      if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
    } else {
      if (fromNode.assignedRack || toNode.assignedRack) return;
    }
    const p1 = savedPositions[edge.from];
    const p2 = savedPositions[edge.to];
    if (!p1 || !p2) return;
    const routing = edge.routing || PAGE_STATE.defaultEdgeRouting || "curved";
    
    if (routing === "orthogonal") {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const polyline = document.createElementNS(ns, "polyline");
      let points;
      if (Math.abs(dx) > Math.abs(dy)) {
        const midX = p1.x + dx / 2;
        points = `${p1.x},${p1.y} ${midX},${p1.y} ${midX},${p2.y} ${p2.x},${p2.y}`;
      } else {
        const midY = p1.y + dy / 2;
        points = `${p1.x},${p1.y} ${p1.x},${midY} ${p2.x},${midY} ${p2.x},${p2.y}`;
      }
      polyline.setAttribute("points", points);
      polyline.classList.add("minimap-edge");
      frag.appendChild(polyline);
    } else {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);
      line.classList.add("minimap-edge");
      frag.appendChild(line);
    }
  });

  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode === "rack") {
      if (node.assignedRack !== currentView.rackId) return;
    } else {
      if (node.assignedRack) return;
    }
    const nodeSize = savedSizes[id] || 55;
    const s = nodeSize * 0.5;
    
    if (node.isRack) {
      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", pos.x - s);
      rect.setAttribute("y", pos.y - s);
      rect.setAttribute("width", s * 2);
      rect.setAttribute("height", s * 2);
      rect.style.fill = dotColor;
      rect.classList.add("minimap-node");
      frag.appendChild(rect);
    } else if (hasCoverageZone(node.shape)) {
      const diamond = document.createElementNS(ns, "polygon");
      const points = `${pos.x},${pos.y - s} ${pos.x + s},${pos.y} ${pos.x},${pos.y + s} ${pos.x - s},${pos.y}`;
      diamond.setAttribute("points", points);
      diamond.style.fill = "none";
      diamond.style.stroke = dotColor;
      diamond.style.strokeWidth = "6";
      diamond.classList.add("minimap-node");
      frag.appendChild(diamond);
    } else {
      const circle = document.createElementNS(ns, "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", s);
      circle.style.fill = dotColor;
      circle.classList.add("minimap-node");
      frag.appendChild(circle);
    }
  });

  minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-1").checked) activeLayers.add("layer1");
       if (document.getElementById("layer-2").checked) activeLayers.add("layer2");
       if (document.getElementById("layer-3").checked) activeLayers.add("layer3");
       if (document.getElementById("layer-4").checked) activeLayers.add("layer4");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       let nodeLayer = node.layer || "layer1";
       const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
       if (layerMap[nodeLayer]) nodeLayer = layerMap[nodeLayer];
       return activeLayers.has(nodeLayer);
      }
      function updateLayerLabels() {
       const mode = PAGE_STATE.mappingMode || 'network';
       const layers = LANG.ui?.layers?.[mode] || LANG.ui?.layers?.network;
       if (layers) {
        const label1 = document.getElementById('layer-1-label');
        const label2 = document.getElementById('layer-2-label');
        const label3 = document.getElementById('layer-3-label');
        const label4 = document.getElementById('layer-4-label');
        if (label1) label1.textContent = layers.layer1 || 'Layer 1';
        if (label2) label2.textContent = layers.layer2 || 'Layer 2';
        if (label3) label3.textContent = layers.layer3 || 'Layer 3';
        if (label4) label4.textContent = layers.layer4 || 'Layer 4';
        const opt1 = document.getElementById('node-layer-opt1');
        const opt2 = document.getElementById('node-layer-opt2');
        const opt3 = document.getElementById('node-layer-opt3');
        const opt4 = document.getElementById('node-layer-opt4');
        if (opt1) opt1.textContent = layers.layer1 || 'Layer 1';
        if (opt2) opt2.textContent = layers.layer2 || 'Layer 2';
        if (opt3) opt3.textContent = layers.layer3 || 'Layer 3';
        if (opt4) opt4.textContent = layers.layer4 || 'Layer 4';
       }
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) {
        backBtn.style.display = "inline-block";
        const modeLabels = {
         'network': 'Topology',
         'sports': 'Sports',
         'smart-home': 'Smart Home',
         'floor-plan': 'Floor Plan'
        };
        const currentMode = PAGE_STATE.mappingMode || 'network';
        backBtn.textContent = '← Back to ' + (modeLabels[currentMode] || 'Topology');
       }
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = t("messages.rackViewHint", { name: NODE_DATA[rackId]?.name || t("modes.network.rack") });
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function checkRackSlotCollisions(rackId) {
       const collisions = [];
       const nodesInRack = Object.entries(NODE_DATA).filter(([id, node]) => node.assignedRack === rackId && !node.isRack);
       for (let i = 0; i < nodesInRack.length; i++) {
        const [id1, node1] = nodesInRack[i];
        const unit1 = parseInt(node1.rackUnit) || 1;
        const height1 = parseInt(node1.uHeight) || 1;
        const start1 = unit1;
        const end1 = unit1 + height1 - 1;
        for (let j = i + 1; j < nodesInRack.length; j++) {
         const [id2, node2] = nodesInRack[j];
         const unit2 = parseInt(node2.rackUnit) || 1;
         const height2 = parseInt(node2.uHeight) || 1;
         const start2 = unit2;
         const end2 = unit2 + height2 - 1;
         if (start1 <= end2 && start2 <= end1) {
          collisions.push({ node1: id1, node2: id2, name1: node1.name, name2: node2.name, slots1: `U${start1}-U${end1}`, slots2: `U${start2}-U${end2}` });
         }
        }
       }
       return collisions;
      }
      function validateRackPlacement(nodeId, rackId, proposedUnit, uHeight) {
       const rackCapacity = getRackCapacity(rackId);
       const endUnit = proposedUnit + uHeight - 1;
       if (endUnit > rackCapacity) {
        return { valid: false, message: t("dialogs.rackCapacityExceeded", { startU: proposedUnit, endU: endUnit, capacity: rackCapacity, excess: endUnit - rackCapacity }) };
       }
       if (proposedUnit < 1) {
        return { valid: false, message: t("dialogs.invalidRackPosition") };
       }
       return { valid: true };
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">' + t("ui.options.none") + '</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       const mappingModeSelect = document.getElementById("mapping-mode-select");
       if (mappingModeSelect) mappingModeSelect.value = PAGE_STATE.mappingMode || "network";
       const canvasStyleSelect = document.getElementById("canvas-style-select");
       if (canvasStyleSelect && PAGE_STATE.canvasTemplate) {
         canvasStyleSelect.value = PAGE_STATE.canvasTemplate;
       }
	   
       const mindmapBgColor = document.getElementById("mindmap-bg-color");
       if (mindmapBgColor && PAGE_STATE.background) {
         mindmapBgColor.value = PAGE_STATE.background;
       }
       if (typeof applyMappingModeLabels === "function") applyMappingModeLabels();
       if (typeof applyLanguage === "function") applyLanguage();
       if (typeof updateCanvasStyleOptions === "function") updateCanvasStyleOptions();
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = await showPrompt(t("dialogs.enterDecryptPassword", { attempt: attempts + 1, max: maxAttempts }));
           if (!password) {
            showAlert(t("dialogs.decryptionCancelled"));
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             showAlert(t("dialogs.incorrectPassword"));
            } else {
             showAlert(t("dialogs.maxAttemptsReached"));
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       if (initialState.recordings && Array.isArray(initialState.recordings)) {
        RECORDING_STATE.recordings = initialState.recordings;
        RECORDING_STATE.currentRecording = initialState.recordings[0] || null;
       }
       loadLanguageFromStorage();
       applyLanguage();
       updateCurrentLangDisplay();
       const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
       Object.values(NODE_DATA).forEach(node => {
         if (!node.tags) node.tags = [];
         if (!node.notes) node.notes = [];
         if (!node.layer || layerMap[node.layer]) node.layer = layerMap[node.layer] || 'layer1';
       });
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery().then(recovered => {
          if (recovered) return;
          if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0) return;
          if (PAGE_STATE.background && PAGE_STATE.background !== "") return;
          if (typeof showWelcomeModal === 'function') showWelcomeModal();
        });
       }
       startAutosave();
      })();

      function showWelcomeModal() {
       const modal = document.getElementById('welcome-modal');
       if (!modal) return;
       modal.classList.add('active');

       let selectedMode = 'network';
       const canvasRow = document.getElementById('welcome-canvas-row');
       const canvasSelect = document.getElementById('welcome-canvas-select');
       const canvasPreview = document.getElementById('welcome-canvas-preview');
       const themeSelect = document.getElementById('welcome-theme-select');
       const bgColor = document.getElementById('welcome-bg-color');
       const accentColor = document.getElementById('welcome-accent-color');
       const textColor = document.getElementById('welcome-text-color');
       const textSoftColor = document.getElementById('welcome-text-soft-color');
       const panelColor = document.getElementById('welcome-panel-color');
       const modalColor = document.getElementById('welcome-modal-color');
       const dangerColor = document.getElementById('welcome-danger-color');
       const mobileFooterColor = document.getElementById('welcome-mobile-footer-color');
       const tagFillColor = document.getElementById('welcome-tag-fill-color');
       const tagTextColor = document.getElementById('welcome-tag-text-color');
       const tagBorderColor = document.getElementById('welcome-tag-border-color');

       function renderWelcomeCanvasPreview() {
        if (!canvasPreview) return;
        const template = canvasSelect ? canvasSelect.value : 'grid';
        const previewBg = bgColor ? bgColor.value : '#0b0e13';
        const gridColor = '#475569';
        canvasPreview.style.background = previewBg;
        canvasPreview.innerHTML = '';

        if (template === 'none') return;

        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.setAttribute('viewBox', '0 0 300 60');
        svg.style.display = 'block';

        if (template === 'grid') {
         for (let x = 0; x <= 300; x += 20) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x); line.setAttribute('y1', 0);
          line.setAttribute('x2', x); line.setAttribute('y2', 60);
          line.setAttribute('stroke', gridColor + '33');
          line.setAttribute('stroke-width', x % 100 === 0 ? '1.5' : '0.5');
          svg.appendChild(line);
         }
         for (let y = 0; y <= 60; y += 20) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', 0); line.setAttribute('y1', y);
          line.setAttribute('x2', 300); line.setAttribute('y2', y);
          line.setAttribute('stroke', gridColor + '33');
          line.setAttribute('stroke-width', y % 100 === 0 ? '1.5' : '0.5');
          svg.appendChild(line);
         }
        } else if (template === 'dots') {
         for (let x = 10; x <= 290; x += 20) {
          for (let y = 10; y <= 50; y += 20) {
           const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
           dot.setAttribute('cx', x); dot.setAttribute('cy', y); dot.setAttribute('r', 1.5);
           dot.setAttribute('fill', gridColor + '66');
           svg.appendChild(dot);
          }
         }
        } else if (template === 'blueprint') {
         for (let x = 0; x <= 300; x += 10) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x); line.setAttribute('y1', 0);
          line.setAttribute('x2', x); line.setAttribute('y2', 60);
          line.setAttribute('stroke', x % 40 === 0 ? gridColor + '66' : gridColor + '33');
          line.setAttribute('stroke-width', x % 40 === 0 ? '1' : '0.3');
          svg.appendChild(line);
         }
         for (let y = 0; y <= 60; y += 10) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', 0); line.setAttribute('y1', y);
          line.setAttribute('x2', 300); line.setAttribute('y2', y);
          line.setAttribute('stroke', y % 40 === 0 ? gridColor + '66' : gridColor + '33');
          line.setAttribute('stroke-width', y % 40 === 0 ? '1' : '0.3');
          svg.appendChild(line);
         }
        } else if (template === 'basketball') {
         const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         rect.setAttribute('x', 20); rect.setAttribute('y', 10);
         rect.setAttribute('width', 260); rect.setAttribute('height', 40);
         rect.setAttribute('fill', '#cd853f22'); rect.setAttribute('stroke', gridColor + '66');
         rect.setAttribute('stroke-width', '2');
         svg.appendChild(rect);
         const center = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         center.setAttribute('x1', 150); center.setAttribute('y1', 10);
         center.setAttribute('x2', 150); center.setAttribute('y2', 50);
         center.setAttribute('stroke', gridColor + '66'); center.setAttribute('stroke-width', '1.5');
         svg.appendChild(center);
         const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
         circle.setAttribute('cx', 150); circle.setAttribute('cy', 30); circle.setAttribute('r', 10);
         circle.setAttribute('fill', 'none'); circle.setAttribute('stroke', gridColor + '66');
         svg.appendChild(circle);
        } else if (template === 'football') {
         const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         rect.setAttribute('x', 20); rect.setAttribute('y', 10);
         rect.setAttribute('width', 260); rect.setAttribute('height', 40);
         rect.setAttribute('fill', '#22803322'); rect.setAttribute('stroke', '#ffffff44');
         rect.setAttribute('stroke-width', '2');
         svg.appendChild(rect);
         for (let x = 46; x <= 254; x += 26) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', x); line.setAttribute('y1', 10);
          line.setAttribute('x2', x); line.setAttribute('y2', 50);
          line.setAttribute('stroke', '#ffffff44'); line.setAttribute('stroke-width', '1');
          svg.appendChild(line);
         }
        } else if (template === 'soccer') {
         const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         rect.setAttribute('x', 20); rect.setAttribute('y', 10);
         rect.setAttribute('width', 260); rect.setAttribute('height', 40);
         rect.setAttribute('fill', '#1a802022'); rect.setAttribute('stroke', '#ffffff55');
         rect.setAttribute('stroke-width', '2');
         svg.appendChild(rect);
         const center = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         center.setAttribute('x1', 150); center.setAttribute('y1', 10);
         center.setAttribute('x2', 150); center.setAttribute('y2', 50);
         center.setAttribute('stroke', '#ffffff44'); center.setAttribute('stroke-width', '1');
         svg.appendChild(center);
         const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
         circle.setAttribute('cx', 150); circle.setAttribute('cy', 30); circle.setAttribute('r', 8);
         circle.setAttribute('fill', 'none'); circle.setAttribute('stroke', '#ffffff44');
         svg.appendChild(circle);
        } else if (template === 'hockey') {
         const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         rect.setAttribute('x', 20); rect.setAttribute('y', 10);
         rect.setAttribute('width', 260); rect.setAttribute('height', 40);
         rect.setAttribute('rx', 10); rect.setAttribute('ry', 10);
         rect.setAttribute('fill', '#e8f4f844'); rect.setAttribute('stroke', '#ff000066');
         rect.setAttribute('stroke-width', '2');
         svg.appendChild(rect);
         const center = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         center.setAttribute('x1', 150); center.setAttribute('y1', 10);
         center.setAttribute('x2', 150); center.setAttribute('y2', 50);
         center.setAttribute('stroke', '#ff000055'); center.setAttribute('stroke-width', '2');
         svg.appendChild(center);
         const blueL = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         blueL.setAttribute('x1', 95); blueL.setAttribute('y1', 10);
         blueL.setAttribute('x2', 95); blueL.setAttribute('y2', 50);
         blueL.setAttribute('stroke', '#0066ff55'); blueL.setAttribute('stroke-width', '2');
         svg.appendChild(blueL);
         const blueR = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         blueR.setAttribute('x1', 205); blueR.setAttribute('y1', 10);
         blueR.setAttribute('x2', 205); blueR.setAttribute('y2', 50);
         blueR.setAttribute('stroke', '#0066ff55'); blueR.setAttribute('stroke-width', '2');
         svg.appendChild(blueR);
        } else if (template === 'baseball') {
         const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
         diamond.setAttribute('points', '150,15 185,30 150,45 115,30');
         diamond.setAttribute('fill', '#cd853f22'); diamond.setAttribute('stroke', '#ffffff55');
         diamond.setAttribute('stroke-width', '1.5');
         svg.appendChild(diamond);
         const arc = document.createElementNS('http://www.w3.org/2000/svg', 'path');
         arc.setAttribute('d', 'M 60,50 Q 150,5 240,50');
         arc.setAttribute('fill', '#22803322'); arc.setAttribute('stroke', '#ffffff44');
         arc.setAttribute('stroke-width', '1');
         svg.appendChild(arc);
        } else if (template === 'tennis') {
         const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         rect.setAttribute('x', 30); rect.setAttribute('y', 10);
         rect.setAttribute('width', 240); rect.setAttribute('height', 40);
         rect.setAttribute('fill', '#0066aa22'); rect.setAttribute('stroke', '#ffffff66');
         rect.setAttribute('stroke-width', '2');
         svg.appendChild(rect);
         const net = document.createElementNS('http://www.w3.org/2000/svg', 'line');
         net.setAttribute('x1', 150); net.setAttribute('y1', 10);
         net.setAttribute('x2', 150); net.setAttribute('y2', 50);
         net.setAttribute('stroke', '#ffffff88'); net.setAttribute('stroke-width', '1');
         svg.appendChild(net);
         const svcL = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         svcL.setAttribute('x', 70); svcL.setAttribute('y', 18);
         svcL.setAttribute('width', 80); svcL.setAttribute('height', 24);
         svcL.setAttribute('fill', 'none'); svcL.setAttribute('stroke', '#ffffff44');
         svg.appendChild(svcL);
         const svcR = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
         svcR.setAttribute('x', 150); svcR.setAttribute('y', 18);
         svcR.setAttribute('width', 80); svcR.setAttribute('height', 24);
         svcR.setAttribute('fill', 'none'); svcR.setAttribute('stroke', '#ffffff44');
         svg.appendChild(svcR);
        }
        canvasPreview.appendChild(svg);
       }

       function updateWelcomeCanvasOptions(mode) {
        if (!canvasSelect || !canvasRow) return;
        const options = CANVAS_OPTIONS[mode] || CANVAS_OPTIONS.network;
        const previewRow = document.getElementById('welcome-canvas-preview');
        const colorDetails = modal.querySelector('details');
        if (mode === 'mindmap') {
         canvasRow.style.display = 'none';
         if (previewRow) previewRow.style.display = 'none';
         if (colorDetails) colorDetails.open = true;
        } else if (mode === 'floorplan') {
         canvasRow.style.display = 'none';
         if (previewRow) {
          previewRow.style.display = 'block';
          const networkOptions = CANVAS_OPTIONS.network;
          canvasSelect.innerHTML = networkOptions.map(o => `<option value="${o.value}">${o.label}</option>`).join('');
          canvasSelect.value = 'blueprint';
          renderWelcomeCanvasPreview();
         }
         if (colorDetails) colorDetails.open = false;
        } else if (options.length > 0) {
         canvasRow.style.display = 'flex';
         if (previewRow) previewRow.style.display = 'block';
         canvasSelect.innerHTML = options.map(o => `<option value="${o.value}">${o.label}</option>`).join('');
         renderWelcomeCanvasPreview();
         if (colorDetails) colorDetails.open = false;
        }
       }

       modal.querySelectorAll('.welcome-mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
         selectedMode = btn.dataset.mode;
         modal.querySelectorAll('.welcome-mode-btn').forEach(b => {
          b.style.borderColor = 'var(--edge-main)';
         });
         btn.style.borderColor = 'var(--accent)';
         updateWelcomeCanvasOptions(selectedMode);
         PAGE_STATE.mappingMode = selectedMode;
         applyMappingModeLabels();
         updateLayerLabels();
         applyLanguage();
         displayTabs();
         if (selectedMode === 'mindmap') {
          PAGE_STATE.canvasTemplate = 'none';
          PAGE_STATE.canvasGridEnabled = false;
         } else if (selectedMode === 'floorplan') {
          PAGE_STATE.canvasTemplate = 'blueprint';
          PAGE_STATE.canvasGridEnabled = true;
         } else if (canvasSelect) {
          PAGE_STATE.canvasTemplate = canvasSelect.value;
          PAGE_STATE.canvasGridEnabled = canvasSelect.value !== 'none';
         }
         forgeTheTopology();
        });
        btn.addEventListener('mouseenter', () => {
         if (btn.style.borderColor !== 'var(--accent)') {
          btn.style.background = 'var(--panel)';
         }
        });
        btn.addEventListener('mouseleave', () => {
         btn.style.background = 'var(--panel-alt)';
        });
       });

       if (canvasSelect) {
        canvasSelect.addEventListener('change', () => {
         renderWelcomeCanvasPreview();
         PAGE_STATE.canvasTemplate = canvasSelect.value;
         PAGE_STATE.canvasGridEnabled = canvasSelect.value !== 'none';
         forgeTheTopology();
        });
       }

       if (themeSelect) {
        themeSelect.addEventListener('change', () => {
         const presetKey = themeSelect.value;
         const colorDetails = modal.querySelector('details');
         if (presetKey === '') {
          if (colorDetails) colorDetails.open = true;
          return;
         }
         if (typeof THEME_PRESETS === 'undefined') return;
         const p = THEME_PRESETS[presetKey];
         if (!p) return;
         Object.assign(PAGE_STATE, p);
         document.body.style.background = p.panel;
         document.documentElement.style.setProperty('--bg', p.panel);
         document.documentElement.style.setProperty('--panel', p.panel);
         document.documentElement.style.setProperty('--panel-alt', p.panelAlt);
         document.documentElement.style.setProperty('--accent', p.accent);
         document.documentElement.style.setProperty('--danger', p.danger);
         document.documentElement.style.setProperty('--text-main', p.textMain);
         document.documentElement.style.setProperty('--text-soft', p.textSoft);
         document.documentElement.style.setProperty('--modal-bg', p.panelAlt);
         document.documentElement.style.setProperty('--tag-bg', p.tagFill);
         document.documentElement.style.setProperty('--tag-text', p.tagText);
         document.documentElement.style.setProperty('--tag-border', p.tagBorder);
         if (bgColor) bgColor.value = p.panel;
         if (accentColor) accentColor.value = p.accent;
         if (textColor) textColor.value = p.textMain;
         if (textSoftColor) textSoftColor.value = p.textSoft;
         if (panelColor) panelColor.value = p.panel;
         if (modalColor) modalColor.value = p.panelAlt;
         if (dangerColor) dangerColor.value = p.canvasGrid || '#475569';
         if (tagFillColor) tagFillColor.value = p.tagFill;
         if (tagTextColor) tagTextColor.value = p.tagText;
         if (tagBorderColor) tagBorderColor.value = p.tagBorder;
         PAGE_STATE.background = p.panel;
         renderWelcomeCanvasPreview();
         wieldThePower();
        });
       }

       function setupColorPicker(picker, cssVar, pageStateKey) {
        if (!picker) return;
        picker.addEventListener('input', (e) => {
         document.documentElement.style.setProperty(cssVar, e.target.value);
         if (pageStateKey) PAGE_STATE[pageStateKey] = e.target.value;
         if (cssVar === '--bg' || pageStateKey === 'background') {
          document.body.style.background = e.target.value;
          renderWelcomeCanvasPreview();
         }
        });
       }

       setupColorPicker(bgColor, '--bg', 'background');
       setupColorPicker(accentColor, '--accent', 'accent');
       setupColorPicker(textColor, '--text-main', 'textMain');
       setupColorPicker(textSoftColor, '--text-soft', 'textSoft');
       setupColorPicker(panelColor, '--panel', 'panel');
       setupColorPicker(modalColor, '--panel-alt', 'panelAlt');
       if (dangerColor) {
        dangerColor.addEventListener('input', (e) => {
         PAGE_STATE.canvasGrid = e.target.value;
         if (typeof forgeTheTopology === 'function') forgeTheTopology();
         renderWelcomeCanvasPreview();
        });
       }
       setupColorPicker(mobileFooterColor, '--sidebar-bg', 'sidebarBg');
       setupColorPicker(tagFillColor, '--tag-bg', 'tagFill');
       setupColorPicker(tagTextColor, '--tag-text', 'tagText');
       setupColorPicker(tagBorderColor, '--tag-border', 'tagBorder');

       renderWelcomeCanvasPreview();

       const startBtn = document.getElementById('welcome-start-btn');
       if (startBtn) {
        startBtn.addEventListener('click', () => {
         PAGE_STATE.mappingMode = selectedMode;
         const modeSelect = document.getElementById('mapping-mode-select');
         if (modeSelect) modeSelect.value = selectedMode;

         if (selectedMode === 'mindmap') {
          PAGE_STATE.canvasTemplate = 'none';
          PAGE_STATE.canvasGridEnabled = false;
         } else if (selectedMode === 'floorplan') {
          PAGE_STATE.canvasTemplate = 'blueprint';
         } else if (canvasSelect) {
          PAGE_STATE.canvasTemplate = canvasSelect.value;
          PAGE_STATE.canvasGridEnabled = canvasSelect.value !== 'none';
         }

         if (bgColor) {
          PAGE_STATE.background = bgColor.value;
          document.body.style.background = bgColor.value;
          const el = document.getElementById('panel-color');
          if (el) el.value = bgColor.value;
         }
         if (accentColor) {
          PAGE_STATE.accent = accentColor.value;
          const el = document.getElementById('accent-color');
          if (el) el.value = accentColor.value;
         }

         if (typeof updateCanvasStyleOptions === 'function') updateCanvasStyleOptions();
         if (typeof applyMappingModeLabels === 'function') applyMappingModeLabels();
         if (typeof updateLayerLabels === 'function') updateLayerLabels();

         const catSelect = document.getElementById('shape-category-select');
         if (catSelect) {
          catSelect.value = MODE_DEFAULT_CATEGORIES[selectedMode] || 'network';
          if (typeof populateShapeSelect === 'function') populateShapeSelect();
         }

         modal.classList.remove('active');
         wieldThePower();
         forgeTheTopology();
        });
       }

       const skipBtn = document.getElementById('welcome-skip-btn');
       if (skipBtn) {
        skipBtn.addEventListener('click', () => {
         modal.classList.remove('active');
        });
       }

       modal.addEventListener('click', (e) => {
        if (e.target === modal) {
         modal.classList.remove('active');
        }
       });
      }
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }

       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72°";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size * 0.15);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 1);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.3);
        g.appendChild(body);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("r", size);
        g.appendChild(body);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       if (shape === "basketball-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        const hLine = document.createElementNS(ns, "line");
        hLine.setAttribute("x1", -size);
        hLine.setAttribute("y1", 0);
        hLine.setAttribute("x2", size);
        hLine.setAttribute("y2", 0);
        hLine.style.stroke = "currentColor";
        hLine.style.strokeWidth = "2";
        hLine.style.opacity = "0.5";
        g.appendChild(hLine);
        const vLine = document.createElementNS(ns, "line");
        vLine.setAttribute("x1", 0);
        vLine.setAttribute("y1", -size);
        vLine.setAttribute("x2", 0);
        vLine.setAttribute("y2", size);
        vLine.style.stroke = "currentColor";
        vLine.style.strokeWidth = "2";
        vLine.style.opacity = "0.5";
        g.appendChild(vLine);
        const curve1 = document.createElementNS(ns, "path");
        curve1.setAttribute("d", `M ${-size * 0.5} ${-size} Q ${-size * 0.8} 0 ${-size * 0.5} ${size}`);
        curve1.style.fill = "none";
        curve1.style.stroke = "currentColor";
        curve1.style.strokeWidth = "2";
        curve1.style.opacity = "0.5";
        g.appendChild(curve1);
        const curve2 = document.createElementNS(ns, "path");
        curve2.setAttribute("d", `M ${size * 0.5} ${-size} Q ${size * 0.8} 0 ${size * 0.5} ${size}`);
        curve2.style.fill = "none";
        curve2.style.stroke = "currentColor";
        curve2.style.strokeWidth = "2";
        curve2.style.opacity = "0.5";
        g.appendChild(curve2);
        return g;
       }
       if (shape === "football-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "ellipse");
        ball.setAttribute("rx", size * 1.3);
        ball.setAttribute("ry", size * 0.7);
        g.appendChild(ball);
        const laces = document.createElementNS(ns, "line");
        laces.setAttribute("x1", -size * 0.4);
        laces.setAttribute("y1", 0);
        laces.setAttribute("x2", size * 0.4);
        laces.setAttribute("y2", 0);
        laces.style.stroke = "currentColor";
        laces.style.strokeWidth = "3";
        laces.style.opacity = "0.5";
        g.appendChild(laces);
        for (let i = -2; i <= 2; i++) {
         const stitch = document.createElementNS(ns, "line");
         stitch.setAttribute("x1", i * size * 0.15);
         stitch.setAttribute("y1", -size * 0.15);
         stitch.setAttribute("x2", i * size * 0.15);
         stitch.setAttribute("y2", size * 0.15);
         stitch.style.stroke = "currentColor";
         stitch.style.strokeWidth = "2";
         stitch.style.opacity = "0.5";
         g.appendChild(stitch);
        }
        return g;
       }
       if (shape === "soccer-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        const pentagon = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size * 0.4, Math.sin(a) * size * 0.4]);
        }
        pentagon.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        pentagon.style.fill = "currentColor";
        pentagon.style.opacity = "0.5";
        g.appendChild(pentagon);
        return g;
       }
       if (shape === "hockey-puck") {
        const g = document.createElementNS(ns, "g");
        const side = document.createElementNS(ns, "ellipse");
        side.setAttribute("rx", size);
        side.setAttribute("ry", size * 0.3);
        side.setAttribute("cy", size * 0.15);
        side.style.opacity = "0.7";
        g.appendChild(side);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("rx", size);
        top.setAttribute("ry", size * 0.3);
        top.setAttribute("cy", -size * 0.15);
        g.appendChild(top);
        return g;
       }
       if (shape === "baseball-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        const stitch1 = document.createElementNS(ns, "path");
        stitch1.setAttribute("d", `M ${-size * 0.7} ${-size * 0.5} Q ${-size * 0.3} ${-size * 0.8} 0 ${-size * 0.9} Q ${size * 0.3} ${-size * 0.8} ${size * 0.7} ${-size * 0.5}`);
        stitch1.style.fill = "none";
        stitch1.style.stroke = "currentColor";
        stitch1.style.strokeWidth = "2";
        stitch1.style.opacity = "0.5";
        g.appendChild(stitch1);
        const stitch2 = document.createElementNS(ns, "path");
        stitch2.setAttribute("d", `M ${-size * 0.7} ${size * 0.5} Q ${-size * 0.3} ${size * 0.8} 0 ${size * 0.9} Q ${size * 0.3} ${size * 0.8} ${size * 0.7} ${size * 0.5}`);
        stitch2.style.fill = "none";
        stitch2.style.stroke = "currentColor";
        stitch2.style.strokeWidth = "2";
        stitch2.style.opacity = "0.5";
        g.appendChild(stitch2);
        return g;
       }
       if (shape === "tennis-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        const curve1 = document.createElementNS(ns, "path");
        curve1.setAttribute("d", `M ${-size * 0.2} ${-size} Q ${-size * 0.8} 0 ${-size * 0.2} ${size}`);
        curve1.style.fill = "none";
        curve1.style.stroke = "currentColor";
        curve1.style.strokeWidth = "3";
        curve1.style.opacity = "0.5";
        g.appendChild(curve1);
        const curve2 = document.createElementNS(ns, "path");
        curve2.setAttribute("d", `M ${size * 0.2} ${-size} Q ${size * 0.8} 0 ${size * 0.2} ${size}`);
        curve2.style.fill = "none";
        curve2.style.stroke = "currentColor";
        curve2.style.strokeWidth = "3";
        curve2.style.opacity = "0.5";
        g.appendChild(curve2);
        return g;
       }
       if (shape === "volleyball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        for (let i = 0; i < 3; i++) {
         const curve = document.createElementNS(ns, "path");
         const angle = (Math.PI * 2 / 3) * i;
         const x1 = Math.cos(angle) * size;
         const y1 = Math.sin(angle) * size;
         const x2 = Math.cos(angle + Math.PI) * size;
         const y2 = Math.sin(angle + Math.PI) * size;
         curve.setAttribute("d", `M ${x1} ${y1} Q 0 0 ${x2} ${y2}`);
         curve.style.fill = "none";
         curve.style.stroke = "currentColor";
         curve.style.strokeWidth = "2";
         curve.style.opacity = "0.5";
         g.appendChild(curve);
        }
        return g;
       }
       if (shape === "rugby-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "ellipse");
        ball.setAttribute("rx", size * 1.4);
        ball.setAttribute("ry", size * 0.6);
        g.appendChild(ball);
        const stripe = document.createElementNS(ns, "line");
        stripe.setAttribute("x1", 0);
        stripe.setAttribute("y1", -size * 0.6);
        stripe.setAttribute("x2", 0);
        stripe.setAttribute("y2", size * 0.6);
        stripe.style.stroke = "currentColor";
        stripe.style.strokeWidth = "3";
        stripe.style.opacity = "0.5";
        g.appendChild(stripe);
        return g;
       }
       if (shape === "golf-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        for (let row = -2; row <= 2; row++) {
         for (let col = -2; col <= 2; col++) {
          if (Math.abs(row) + Math.abs(col) <= 2) {
           const dimple = document.createElementNS(ns, "circle");
           dimple.setAttribute("cx", col * size * 0.3);
           dimple.setAttribute("cy", row * size * 0.3);
           dimple.setAttribute("r", size * 0.08);
           dimple.style.fill = "currentColor";
           dimple.style.opacity = "0.3";
           g.appendChild(dimple);
          }
         }
        }
        return g;
       }
       if (shape === "frisbee") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("rx", size * 1.2);
        outer.setAttribute("ry", size * 0.4);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("rx", size * 0.7);
        inner.setAttribute("ry", size * 0.25);
        inner.style.fill = "currentColor";
        inner.style.opacity = "0.5";
        g.appendChild(inner);
        return g;
       }
       if (shape === "cricket-ball") {
        const g = document.createElementNS(ns, "g");
        const ball = document.createElementNS(ns, "circle");
        ball.setAttribute("r", size);
        g.appendChild(ball);
        const seam = document.createElementNS(ns, "ellipse");
        seam.setAttribute("rx", size * 0.9);
        seam.setAttribute("ry", size * 0.15);
        seam.style.fill = "none";
        seam.style.stroke = "currentColor";
        seam.style.strokeWidth = "3";
        seam.style.opacity = "0.5";
        g.appendChild(seam);
        return g;
       }
       if (shape === "lacrosse-stick") {
        const g = document.createElementNS(ns, "g");
        const handle = document.createElementNS(ns, "rect");
        handle.setAttribute("x", -size * 0.1);
        handle.setAttribute("y", -size * 0.2);
        handle.setAttribute("width", size * 0.2);
        handle.setAttribute("height", size * 1.5);
        handle.setAttribute("rx", 2);
        g.appendChild(handle);
        const head = document.createElementNS(ns, "ellipse");
        head.setAttribute("cy", -size * 0.6);
        head.setAttribute("rx", size * 0.5);
        head.setAttribute("ry", size * 0.7);
        head.style.fill = "none";
        head.style.stroke = "currentColor";
        head.style.strokeWidth = size * 0.15;
        head.style.opacity = "0.7";
        g.appendChild(head);
        const net = document.createElementNS(ns, "ellipse");
        net.setAttribute("cy", -size * 0.5);
        net.setAttribute("rx", size * 0.35);
        net.setAttribute("ry", size * 0.5);
        net.style.fill = "currentColor";
        net.style.opacity = "0.3";
        g.appendChild(net);
        return g;
       }
       if (shape === "golf-flag") {
        const g = document.createElementNS(ns, "g");
        const hole = document.createElementNS(ns, "ellipse");
        hole.setAttribute("cy", size * 0.7);
        hole.setAttribute("rx", size * 0.5);
        hole.setAttribute("ry", size * 0.15);
        hole.style.opacity = "0.5";
        g.appendChild(hole);
        const pole = document.createElementNS(ns, "line");
        pole.setAttribute("x1", 0);
        pole.setAttribute("y1", size * 0.7);
        pole.setAttribute("x2", 0);
        pole.setAttribute("y2", -size);
        pole.style.stroke = "currentColor";
        pole.style.strokeWidth = "3";
        pole.style.opacity = "0.6";
        g.appendChild(pole);
        const flag = document.createElementNS(ns, "polygon");
        flag.setAttribute("points", `0,${-size} ${size * 0.8},${-size * 0.7} 0,${-size * 0.4}`);
        g.appendChild(flag);
        return g;
       }
       if (shape === "tactical-x") {
        const g = document.createElementNS(ns, "g");
        const line1 = document.createElementNS(ns, "line");
        line1.setAttribute("x1", -size * 0.7);
        line1.setAttribute("y1", -size * 0.7);
        line1.setAttribute("x2", size * 0.7);
        line1.setAttribute("y2", size * 0.7);
        line1.style.stroke = "currentColor";
        line1.style.strokeWidth = size * 0.3;
        line1.style.strokeLinecap = "round";
        g.appendChild(line1);
        const line2 = document.createElementNS(ns, "line");
        line2.setAttribute("x1", size * 0.7);
        line2.setAttribute("y1", -size * 0.7);
        line2.setAttribute("x2", -size * 0.7);
        line2.setAttribute("y2", size * 0.7);
        line2.style.stroke = "currentColor";
        line2.style.strokeWidth = size * 0.3;
        line2.style.strokeLinecap = "round";
        g.appendChild(line2);
        return g;
       }
       if (shape === "tactical-o") {
        const g = document.createElementNS(ns, "g");
        const circle = document.createElementNS(ns, "circle");
        circle.setAttribute("r", size * 0.7);
        circle.style.fill = "none";
        circle.style.stroke = "currentColor";
        circle.style.strokeWidth = size * 0.3;
        g.appendChild(circle);
        return g;
       }
       if (shape === "tactical-star") {
        const g = document.createElementNS(ns, "g");
        const outer = size * 0.9;
        const inner = size * 0.4;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        const star = document.createElementNS(ns, "polygon");
        star.setAttribute("points", pts.trim());
        g.appendChild(star);
        return g;
       }
       if (shape === "patch-panel") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 2);
        g.appendChild(body);
        for (let i = 0; i < 12; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.25 + i * size * 0.22);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.18);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "currentColor";
         port.style.opacity = "0.4";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "ups") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.6);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 1.2);
        screen.setAttribute("height", size * 0.5);
        screen.setAttribute("rx", 2);
        screen.style.fill = "currentColor";
        screen.style.opacity = "0.4";
        g.appendChild(screen);
        const battery = document.createElementNS(ns, "rect");
        battery.setAttribute("x", -size * 0.4);
        battery.setAttribute("y", -size * 0.55);
        battery.setAttribute("width", size * 0.8);
        battery.setAttribute("height", size * 0.2);
        battery.style.fill = "#4ade80";
        g.appendChild(battery);
        for (let i = 0; i < 3; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.4 + i * size * 0.4);
         led.setAttribute("cy", size * 0.2);
         led.setAttribute("r", size * 0.08);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        const outlet = document.createElementNS(ns, "rect");
        outlet.setAttribute("x", -size * 0.7);
        outlet.setAttribute("y", size * 0.5);
        outlet.setAttribute("width", size * 1.4);
        outlet.setAttribute("height", size * 0.3);
        outlet.setAttribute("rx", 2);
        outlet.style.fill = "currentColor";
        outlet.style.opacity = "0.4";
        g.appendChild(outlet);
        return g;
       }
       if (shape === "pdu") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.4);
        body.setAttribute("y", -size * 1.2);
        body.setAttribute("width", size * 0.8);
        body.setAttribute("height", size * 2.4);
        body.setAttribute("rx", 3);
        g.appendChild(body);
        for (let i = 0; i < 6; i++) {
         const outlet = document.createElementNS(ns, "rect");
         outlet.setAttribute("x", -size * 0.25);
         outlet.setAttribute("y", -size + i * size * 0.35);
         outlet.setAttribute("width", size * 0.5);
         outlet.setAttribute("height", size * 0.25);
         outlet.setAttribute("rx", 2);
         outlet.style.fill = "currentColor";
         outlet.style.opacity = "0.4";
         g.appendChild(outlet);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cy", -size * 1.05);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "rack-shelf") {
        const g = document.createElementNS(ns, "g");
        const shelf = document.createElementNS(ns, "rect");
        shelf.setAttribute("x", -size * 1.3);
        shelf.setAttribute("y", -size * 0.15);
        shelf.setAttribute("width", size * 2.6);
        shelf.setAttribute("height", size * 0.3);
        shelf.setAttribute("rx", 2);
        g.appendChild(shelf);
        const lip = document.createElementNS(ns, "rect");
        lip.setAttribute("x", -size * 1.3);
        lip.setAttribute("y", size * 0.15);
        lip.setAttribute("width", size * 2.6);
        lip.setAttribute("height", size * 0.15);
        lip.style.opacity = "0.7";
        g.appendChild(lip);
        const ear1 = document.createElementNS(ns, "rect");
        ear1.setAttribute("x", -size * 1.4);
        ear1.setAttribute("y", -size * 0.2);
        ear1.setAttribute("width", size * 0.1);
        ear1.setAttribute("height", size * 0.4);
        g.appendChild(ear1);
        const ear2 = document.createElementNS(ns, "rect");
        ear2.setAttribute("x", size * 1.3);
        ear2.setAttribute("y", -size * 0.2);
        ear2.setAttribute("width", size * 0.1);
        ear2.setAttribute("height", size * 0.4);
        g.appendChild(ear2);
        return g;
       }
       if (shape === "blank-panel") {
        const g = document.createElementNS(ns, "g");
        const panel = document.createElementNS(ns, "rect");
        panel.setAttribute("x", -size * 1.4);
        panel.setAttribute("y", -size * 0.25);
        panel.setAttribute("width", size * 2.8);
        panel.setAttribute("height", size * 0.5);
        panel.setAttribute("rx", 2);
        g.appendChild(panel);
        const vent1 = document.createElementNS(ns, "rect");
        vent1.setAttribute("x", -size * 0.8);
        vent1.setAttribute("y", -size * 0.1);
        vent1.setAttribute("width", size * 0.5);
        vent1.setAttribute("height", size * 0.04);
        vent1.style.fill = "currentColor";
        vent1.style.opacity = "0.4";
        g.appendChild(vent1);
        const vent2 = document.createElementNS(ns, "rect");
        vent2.setAttribute("x", -size * 0.8);
        vent2.setAttribute("y", size * 0.02);
        vent2.setAttribute("width", size * 0.5);
        vent2.setAttribute("height", size * 0.04);
        vent2.style.fill = "currentColor";
        vent2.style.opacity = "0.4";
        g.appendChild(vent2);
        const vent3 = document.createElementNS(ns, "rect");
        vent3.setAttribute("x", size * 0.3);
        vent3.setAttribute("y", -size * 0.1);
        vent3.setAttribute("width", size * 0.5);
        vent3.setAttribute("height", size * 0.04);
        vent3.style.fill = "currentColor";
        vent3.style.opacity = "0.4";
        g.appendChild(vent3);
        const vent4 = document.createElementNS(ns, "rect");
        vent4.setAttribute("x", size * 0.3);
        vent4.setAttribute("y", size * 0.02);
        vent4.setAttribute("width", size * 0.5);
        vent4.setAttribute("height", size * 0.04);
        vent4.style.fill = "currentColor";
        vent4.style.opacity = "0.4";
        g.appendChild(vent4);
        return g;
       }
       if (shape === "cable-management") {
        const g = document.createElementNS(ns, "g");
        const panel = document.createElementNS(ns, "rect");
        panel.setAttribute("x", -size * 1.4);
        panel.setAttribute("y", -size * 0.3);
        panel.setAttribute("width", size * 2.8);
        panel.setAttribute("height", size * 0.6);
        panel.setAttribute("rx", 2);
        g.appendChild(panel);
        for (let i = 0; i < 5; i++) {
         const ring = document.createElementNS(ns, "ellipse");
         ring.setAttribute("cx", -size + i * size * 0.5);
         ring.setAttribute("rx", size * 0.12);
         ring.setAttribute("ry", size * 0.18);
         ring.style.fill = "none";
         ring.style.stroke = "currentColor";
         ring.style.strokeWidth = size * 0.08;
         ring.style.opacity = "0.5";
         g.appendChild(ring);
        }
        return g;
       }
       if (shape === "kvm") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 3);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.9);
        screen.setAttribute("y", -size * 0.25);
        screen.setAttribute("width", size * 0.8);
        screen.setAttribute("height", size * 0.5);
        screen.setAttribute("rx", 2);
        screen.style.fill = "currentColor";
        screen.style.opacity = "0.4";
        g.appendChild(screen);
        for (let i = 0; i < 4; i++) {
         const btn = document.createElementNS(ns, "rect");
         btn.setAttribute("x", size * 0.1 + i * size * 0.25);
         btn.setAttribute("y", -size * 0.15);
         btn.setAttribute("width", size * 0.18);
         btn.setAttribute("height", size * 0.3);
         btn.setAttribute("rx", 2);
         btn.style.fill = "currentColor";
         btn.style.opacity = "0.5";
         g.appendChild(btn);
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", size * 0.19 + i * size * 0.25);
         led.setAttribute("cy", -size * 0.25);
         led.setAttribute("r", size * 0.04);
         led.style.fill = i === 0 ? "#4ade80" : "currentColor";
         led.style.opacity = i === 0 ? "1" : "0.3";
         g.appendChild(led);
        }
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = t("legends.lineLegend");
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = t("legends.defaultLineLabel");
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", async (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = await showPrompt(t("dialogs.editLegendLabel"), currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || t("legends.defaultLineLabel");
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
function updateFovCone(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return;
  
  const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
  if (!nodeGroup) return;
  const existingFov = nodeGroup.querySelector(".fov-group");
  if (existingFov) existingFov.remove();
  if (!hasCoverageZone(node.shape) || !node.fovEnabled) return;
  
  const ns = "http://www.w3.org/2000/svg";
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${nodeId}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${nodeId})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const fovLabelOffsetX = node.fovLabelOffsetX || 0;
    const fovLabelOffsetY = node.fovLabelOffsetY || 0;
    const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
    const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${nodeId}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {

      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
}
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const flowArrowBig = document.createElementNS(ns, "path");
       flowArrowBig.id = "flow-arrow-big";
       flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
       defs.appendChild(flowArrowBig);
       const flowArrowSmall = document.createElementNS(ns, "path");
       flowArrowSmall.id = "flow-arrow-small";
       flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
       defs.appendChild(flowArrowSmall);
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
defs.appendChild(markerBackward);
const wallPattern = document.createElementNS(ns, "pattern");
wallPattern.id = "wall-hatch";
wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
wallPattern.setAttribute("width", "8");
wallPattern.setAttribute("height", "8");
wallPattern.setAttribute("patternTransform", "rotate(45)");
const wallLine = document.createElementNS(ns, "line");
wallLine.setAttribute("x1", "0");
wallLine.setAttribute("y1", "0");
wallLine.setAttribute("x2", "0");
wallLine.setAttribute("y2", "8");
wallLine.setAttribute("stroke", "#666");
wallLine.setAttribute("stroke-width", "2");
wallPattern.appendChild(wallLine);
defs.appendChild(wallPattern);

svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       const currentMappingModeForCanvas = PAGE_STATE.mappingMode || 'network';
      const shouldDrawCanvasTemplate = currentView.mode !== "rack" || currentMappingModeForCanvas !== 'network';
      if (shouldDrawCanvasTemplate && PAGE_STATE.canvasGridEnabled !== false) {
 const template = PAGE_STATE.canvasTemplate || "grid";
 if (template === "grid") {
  const gridGroup = document.createElementNS(ns, "g");
  gridGroup.id = "canvas-grid";
  const gridSize = PAGE_STATE.canvasGridSize || 50;
  const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
  const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
  for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
   const line = document.createElementNS(ns, "line");
   line.setAttribute("x1", x);
   line.setAttribute("y1", CANVAS_PADDING);
   line.setAttribute("x2", x);
   line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
   line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
   line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
   gridGroup.appendChild(line);
  }
  for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
   const line = document.createElementNS(ns, "line");
   line.setAttribute("x1", CANVAS_PADDING);
   line.setAttribute("y1", y);
   line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
   line.setAttribute("y2", y);
   line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
   line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
   gridGroup.appendChild(line);
  }
  svg.appendChild(gridGroup);
 } else if (template !== "none") {
  const templateGroup = renderCanvasTemplate(svg, ns, template, CANVAS_WIDTH, CANVAS_HEIGHT, CANVAS_PADDING, PAGE_STATE.canvasTemplateColor);
  if (templateGroup) svg.appendChild(templateGroup);
 }
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const currentMappingMode = PAGE_STATE.mappingMode || 'network';
        const showUSlotRack = currentMappingMode === 'network';
        if (showUSlotRack) {
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
 const y = RACK_START_Y + u * rackUHeight;
 if (PAGE_STATE.rackGridEnabled !== false) {
 const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
 }
 if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        const collisions = checkRackSlotCollisions(currentView.rackId);
        if (collisions.length > 0) {
         const occupiedSlots = {};
         Object.entries(NODE_DATA).forEach(([id, node]) => {
          if (node.assignedRack === currentView.rackId && !node.isRack) {
           const unit = parseInt(node.rackUnit) || 1;
           const height = parseInt(node.uHeight) || 1;
           for (let u = unit; u < unit + height; u++) {
            if (!occupiedSlots[u]) occupiedSlots[u] = [];
            occupiedSlots[u].push(id);
           }
          }
         });
         Object.entries(occupiedSlots).forEach(([slot, nodeIds]) => {
          if (nodeIds.length > 1) {
           const slotNum = parseInt(slot);
           const y = RACK_START_Y + (rackCapacity - slotNum) * rackUHeight;
           const warningRect = document.createElementNS(ns, "rect");
           warningRect.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
           warningRect.setAttribute("y", y);
           warningRect.setAttribute("width", RACK_WIDTH);
           warningRect.setAttribute("height", rackUHeight);
           warningRect.style.fill = "#dc2626";
           warningRect.style.fillOpacity = "0.3";
           warningRect.style.stroke = "#dc2626";
           warningRect.style.strokeWidth = "2";
           warningRect.style.strokeDasharray = "5,5";
           rackGroup.appendChild(warningRect);
          }
         });
         const warningText = document.createElementNS(ns, "text");
         warningText.setAttribute("x", RACK_START_X);
         warningText.setAttribute("y", RACK_START_Y - 30);
         warningText.setAttribute("text-anchor", "middle");
         warningText.style.fill = "#dc2626";
         warningText.style.fontSize = "14px";
         warningText.style.fontWeight = "bold";
         warningText.textContent = t("messages.slotCollisionWarning", { count: collisions.length });
         rackGroup.appendChild(warningText);
        }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const waypoints = edge.waypoints || [];
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (waypoints.length > 0) {
             const allPoints = [p1, ...waypoints, p2];
             for (let i = 1; i < allPoints.length; i++) {
               const prev = allPoints[i - 1];
               const curr = allPoints[i];
               const dx = curr.x - prev.x;
               const dy = curr.y - prev.y;
               if (Math.abs(dx) > Math.abs(dy)) {
                 const midX = prev.x + dx / 2;
                 segments.push({ edgeId: edge.id, x1: prev.x, y1: prev.y, x2: midX, y2: prev.y, idx: edgeIndex });
                 segments.push({ edgeId: edge.id, x1: midX, y1: prev.y, x2: midX, y2: curr.y, idx: edgeIndex });
                 segments.push({ edgeId: edge.id, x1: midX, y1: curr.y, x2: curr.x, y2: curr.y, idx: edgeIndex });
               } else {
                 const midY = prev.y + dy / 2;
                 segments.push({ edgeId: edge.id, x1: prev.x, y1: prev.y, x2: prev.x, y2: midY, idx: edgeIndex });
                 segments.push({ edgeId: edge.id, x1: prev.x, y1: midY, x2: curr.x, y2: midY, idx: edgeIndex });
                 segments.push({ edgeId: edge.id, x1: curr.x, y1: midY, x2: curr.x, y2: curr.y, idx: edgeIndex });
               }
             }
           } else {
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             if (Math.abs(dx) > Math.abs(dy)) {
               const midX = p1.x + dx / 2 + offset;
               segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
               segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
               segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
             } else {
               const midY = p1.y + dy / 2 + offset;
               segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
               segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
               segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
             }
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (currentView.mode === "rack") {
         if (!fromNode || !toNode || fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
        } else {
         if (fromNode?.assignedRack || toNode?.assignedRack) return;
        }
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
if (lineStyle === "dashed") {
 poly.style.strokeDasharray = "10,5";
} else if (lineStyle === "dotted") {
 poly.style.strokeDasharray = "2,4";
} else if (lineStyle === "wall") {
 poly.style.stroke = "url(#wall-hatch)";
 poly.style.strokeWidth = (edge.width || 4) * 3;
 poly.style.strokeDasharray = "none";
} else {
 poly.style.strokeDasharray = "none";
}
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
         if (shouldAnimate) {
          poly.style.opacity = "0.25";
          const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (direction === "forward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (direction === "backward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        const waypoints = edge.waypoints || [];
        let pathD;
        if (waypoints.length > 0) {
         const allPoints = [p1, ...waypoints, p2];
         if (routing === "straight") {
          pathD = `M ${allPoints[0].x} ${allPoints[0].y}`;
          for (let i = 1; i < allPoints.length; i++) {
           pathD += ` L ${allPoints[i].x} ${allPoints[i].y}`;
          }
         } else if (routing === "orthogonal") {
          const GAP = 10;
          const edgeGaps = orthoGaps[edge.id] || [];
          const segs = [];
          for (let i = 1; i < allPoints.length; i++) {
           const prev = allPoints[i - 1];
           const curr = allPoints[i];
           const dx = curr.x - prev.x;
           const dy = curr.y - prev.y;
           if (Math.abs(dx) > Math.abs(dy)) {
            const midX = prev.x + dx / 2;
            segs.push({ x1: prev.x, y1: prev.y, x2: midX, y2: prev.y });
            segs.push({ x1: midX, y1: prev.y, x2: midX, y2: curr.y });
            segs.push({ x1: midX, y1: curr.y, x2: curr.x, y2: curr.y });
           } else {
            const midY = prev.y + dy / 2;
            segs.push({ x1: prev.x, y1: prev.y, x2: prev.x, y2: midY });
            segs.push({ x1: prev.x, y1: midY, x2: curr.x, y2: midY });
            segs.push({ x1: curr.x, y1: midY, x2: curr.x, y2: curr.y });
           }
          }
          pathD = `M ${allPoints[0].x} ${allPoints[0].y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          if (allPoints.length === 2) {
           pathD = `M ${allPoints[0].x} ${allPoints[0].y} L ${allPoints[1].x} ${allPoints[1].y}`;
          } else if (allPoints.length === 3) {
           pathD = `M ${allPoints[0].x} ${allPoints[0].y} Q ${allPoints[1].x} ${allPoints[1].y} ${allPoints[2].x} ${allPoints[2].y}`;
          } else {
           pathD = `M ${allPoints[0].x} ${allPoints[0].y}`;
           for (let i = 1; i < allPoints.length - 1; i++) {
            const prev = allPoints[i - 1];
            const curr = allPoints[i];
            const next = allPoints[i + 1];
            const cpX = curr.x;
            const cpY = curr.y;
            const endX = (curr.x + next.x) / 2;
            const endY = (curr.y + next.y) / 2;
            if (i === 1) {
             pathD += ` Q ${cpX} ${cpY} ${endX} ${endY}`;
            } else {
             pathD += ` T ${endX} ${endY}`;
            }
           }
           const last = allPoints[allPoints.length - 1];
           const secondLast = allPoints[allPoints.length - 2];
           pathD += ` Q ${secondLast.x} ${secondLast.y} ${last.x} ${last.y}`;
          }
         }
        } else if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];

         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const edgeDirection = edge.direction || "none";
        const edgeLineStyle = edge.lineStyle || "solid";
        if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
        else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
        if (edgeDirection === "forward") {
         path.setAttribute("marker-end", "url(#arrow-forward)");
        } else if (edgeDirection === "backward") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
        } else if (edgeDirection === "both") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
         path.setAttribute("marker-end", "url(#arrow-forward)");
        }
        const animDir = PAGE_STATE.animationDirection || "all";
        const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
        if (shouldAnimate) {
         path.style.opacity = "0.25";
         const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
         const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
         const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
         const arrowCount = 3;
         const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
         if (edgeDirection === "forward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
           arrow.classList.add("edge-arrow-forward");
           svg.appendChild(arrow);
          }
         }
         if (edgeDirection === "backward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
           arrow.classList.add("edge-arrow-backward");
           svg.appendChild(arrow);
          }
         }
        }
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
        if (currentEdgeId === edge.id && !isViewOnly()) {
         const waypoints = edge.waypoints || [];
         waypoints.forEach((wp, idx) => {
          const c = document.createElementNS(ns, "circle");
          c.classList.add("waypoint-handle");
          c.setAttribute("cx", wp.x);
          c.setAttribute("cy", wp.y);
          c.setAttribute("r", 8);
          c.style.fill = "#3b82f6";
          c.style.stroke = "#fff";
          c.style.strokeWidth = "2";
          c.style.cursor = "grab";
          c.addEventListener("mousedown", (e) => {
           if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           pushUndo("move waypoint");
           let dragging = true;
           const svgEl = svg;
           c.style.cursor = "grabbing";
           const moveHandler = (ev) => {
            if (!dragging) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            edge.waypoints[idx].x = svgP.x;
            edge.waypoints[idx].y = svgP.y;
            forgeTheTopology();
           };
           const upHandler = () => {
            dragging = false;
            c.style.cursor = "grab";
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
          });
          let waypointMoved = false;
          c.addEventListener("touchstart", (e) => {
           if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           waypointMoved = false;
           pushUndo("move waypoint");
           let dragging = true;
           const svgEl = svg;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            waypointMoved = true;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            edge.waypoints[idx].x = svgP.x;
            edge.waypoints[idx].y = svgP.y;
            forgeTheTopology();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchUpHandler);
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, { passive: false });
          c.addEventListener("contextmenu", (e) => {
           if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           pushUndo("delete waypoint");
           edge.waypoints.splice(idx, 1);
           forgeTheTopology();
          });
          let lastTap = 0;
          c.addEventListener("touchend", (e) => {
           if (waypointMoved) {
            waypointMoved = false;
            lastTap = 0;
            return;
           }
           const now = Date.now();
           if (now - lastTap < 300) {
            if (isViewOnly()) return;
            e.preventDefault();
            pushUndo("delete waypoint");
            edge.waypoints.splice(idx, 1);
            forgeTheTopology();
           }
           lastTap = now;
          });

          svg.appendChild(c);
         });
        }
        pathHit.addEventListener("dblclick", (e) => {
         if (isViewOnly()) return;
         e.stopPropagation();
         const svgEl = svg;
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         pushUndo("add waypoint");
         if (!edge.waypoints) edge.waypoints = [];
         const newWp = { x: svgP.x, y: svgP.y };
         if (edge.waypoints.length === 0) {
          edge.waypoints.push(newWp);
         } else {
          const allPts = [p1, ...edge.waypoints, p2];
          let bestIdx = 0;
          let bestDist = Infinity;
          for (let i = 0; i < allPts.length - 1; i++) {
           const segMidX = (allPts[i].x + allPts[i + 1].x) / 2;
           const segMidY = (allPts[i].y + allPts[i + 1].y) / 2;
           const dist = Math.hypot(svgP.x - segMidX, svgP.y - segMidY);
           if (dist < bestDist) {
            bestDist = dist;
            bestIdx = i;
           }
          }
          edge.waypoints.splice(bestIdx, 0, newWp);
         }
         selectTheConnection(edge.id);
         forgeTheTopology();
        });
        let longPressTimer = null;
        let longPressTriggered = false;
        pathHit.addEventListener("touchstart", (e) => {
         if (isViewOnly() || !e.touches[0]) return;
         longPressTriggered = false;
         const touch = e.touches[0];
         const startX = touch.clientX;
         const startY = touch.clientY;
         longPressTimer = setTimeout(() => {
          longPressTriggered = true;
          if (navigator.vibrate) navigator.vibrate(50);
          const svgEl = svg;
          const pt = svgEl.createSVGPoint();
          pt.x = startX;
          pt.y = startY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          pushUndo("add waypoint");
          if (!edge.waypoints) edge.waypoints = [];
          const newWp = { x: svgP.x, y: svgP.y };
          if (edge.waypoints.length === 0) {
           edge.waypoints.push(newWp);
          } else {
           const allPts = [p1, ...edge.waypoints, p2];
           let bestIdx = 0;
           let bestDist = Infinity;
           for (let i = 0; i < allPts.length - 1; i++) {
            const segMidX = (allPts[i].x + allPts[i + 1].x) / 2;
            const segMidY = (allPts[i].y + allPts[i + 1].y) / 2;
            const dist = Math.hypot(svgP.x - segMidX, svgP.y - segMidY);
            if (dist < bestDist) {
             bestDist = dist;
             bestIdx = i;
            }
           }
           edge.waypoints.splice(bestIdx, 0, newWp);
          }
          selectTheConnection(edge.id);
          forgeTheTopology();
         }, 500);
        }, { passive: true });
        pathHit.addEventListener("touchmove", () => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
        }, { passive: true });
        pathHit.addEventListener("touchend", () => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
        }, { passive: true });
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        const nodeRotation = NODE_DATA[id].rotation || 0;
        g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r - 5 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r + 20 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
if (hasCoverageZone(node.shape) && node.fovEnabled) {
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${id}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${id})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const labelX = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance;
    const labelY = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${id}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {
      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  g.appendChild(fovGroup);
}
        g.append(hitArea, shapeEl, label);
        if (NODE_DATA[id].ip && NODE_DATA[id].ip !== "0.0.0.0") g.appendChild(sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const currentMappingMode = PAGE_STATE.mappingMode || 'network';
      if (currentMappingMode === 'network') {
      const draggedX = savedPositions[id]?.x || pos.x;
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      const rackLeft = RACK_START_X - RACK_WIDTH / 2;
      const rackRight = RACK_START_X + RACK_WIDTH / 2;
      const rackTop = RACK_START_Y;
      const rackBottom = RACK_START_Y + rackCapacity * rackUHeight;
      if (draggedX >= rackLeft && draggedX <= rackRight && draggedY >= rackTop && draggedY <= rackBottom) {
        let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
        newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
        const uHeight = parseInt(NODE_DATA[id].uHeight) || 1;
        const validation = validateRackPlacement(id, currentView.rackId, newUnit, uHeight);
        if (!validation.valid) {
         showErrorModal(t("editModal.rackPlacementError"), validation.message);
         forgeTheTopology();
         return;
        }
        NODE_DATA[id].rackUnit = newUnit;
      }
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         });
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedX = pos.x;
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const currentMappingMode = PAGE_STATE.mappingMode || 'network';
      if (currentMappingMode === 'network') {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      const rackLeft = RACK_START_X - RACK_WIDTH / 2;
      const rackRight = RACK_START_X + RACK_WIDTH / 2;
      const rackTop = RACK_START_Y;
      const rackBottom = RACK_START_Y + rackCapacity * rackUHeight;
      if (draggedX >= rackLeft && draggedX <= rackRight && draggedY >= rackTop && draggedY <= rackBottom) {
        let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
        newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
        const uHeight = parseInt(NODE_DATA[id].uHeight) || 1;
        const validation = validateRackPlacement(id, currentView.rackId, newUnit, uHeight);
        if (!validation.valid) {
         showErrorModal(t("editModal.rackPlacementError"), validation.message);
         forgeTheTopology();
         return;
        }
        NODE_DATA[id].rackUnit = newUnit;
      }
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner, idx) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
                 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateZoneLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function showErrorModal(title, message) {
       const modal = document.getElementById("error-modal");
       const titleEl = document.getElementById("error-modal-title");
       const messageEl = document.getElementById("error-modal-message");
       const okBtn = document.getElementById("error-modal-ok");
       titleEl.textContent = title || t("ui.modals.error");
       messageEl.textContent = message;
       modal.classList.add("active");
       const cleanup = () => {
        modal.classList.remove("active");
        okBtn.removeEventListener("click", handleOk);
        modal.removeEventListener("click", bgHandler);
       };
       const handleOk = () => { cleanup(); };
       const bgHandler = (e) => { if (e.target === modal) cleanup(); };
       okBtn.addEventListener("click", handleOk);
       modal.addEventListener("click", bgHandler);
      }
      function showAlert(message, title) {
       return new Promise((resolve) => {
        const modal = document.getElementById("dialog-modal");
        const titleEl = document.getElementById("dialog-modal-title");
        const messageEl = document.getElementById("dialog-modal-message");
        const inputEl = document.getElementById("dialog-modal-input");
        const okBtn = document.getElementById("dialog-modal-ok");
        const cancelBtn = document.getElementById("dialog-modal-cancel");
        titleEl.textContent = title || t("dialogs.alert");
        messageEl.textContent = message;
        inputEl.style.display = "none";
        cancelBtn.style.display = "none";
        okBtn.textContent = t("dialogs.ok");
        modal.classList.add("active");
        const cleanup = () => {
         modal.classList.remove("active");
         okBtn.removeEventListener("click", handleOk);
         modal.removeEventListener("click", bgHandler);
        };
        const handleOk = () => { cleanup(); resolve(true); };
        const bgHandler = (e) => { if (e.target === modal) { cleanup(); resolve(true); } };
        okBtn.addEventListener("click", handleOk);
        modal.addEventListener("click", bgHandler);
       });
      }
      function showConfirm(message, title) {
       return new Promise((resolve) => {
        const modal = document.getElementById("dialog-modal");
        const titleEl = document.getElementById("dialog-modal-title");
        const messageEl = document.getElementById("dialog-modal-message");
        const inputEl = document.getElementById("dialog-modal-input");
        const okBtn = document.getElementById("dialog-modal-ok");
        const cancelBtn = document.getElementById("dialog-modal-cancel");
        titleEl.textContent = title || t("dialogs.confirm");
        messageEl.textContent = message;
        inputEl.style.display = "none";
        cancelBtn.style.display = "";
        okBtn.textContent = t("dialogs.ok");
        cancelBtn.textContent = t("dialogs.cancel");
        modal.classList.add("active");
        const cleanup = () => {
         modal.classList.remove("active");
         okBtn.removeEventListener("click", handleOk);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleOk = () => { cleanup(); resolve(true); };
        const handleCancel = () => { cleanup(); resolve(false); };
        const bgHandler = (e) => { if (e.target === modal) handleCancel(); };
        okBtn.addEventListener("click", handleOk);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       });
      }
      function showPrompt(message, defaultValue, title) {
       return new Promise((resolve) => {
        const modal = document.getElementById("dialog-modal");
        const titleEl = document.getElementById("dialog-modal-title");
        const messageEl = document.getElementById("dialog-modal-message");
        const inputEl = document.getElementById("dialog-modal-input");
        const okBtn = document.getElementById("dialog-modal-ok");
        const cancelBtn = document.getElementById("dialog-modal-cancel");
        titleEl.textContent = title || t("dialogs.prompt");
        messageEl.textContent = message;
        inputEl.style.display = "";
        inputEl.value = defaultValue || "";
        cancelBtn.style.display = "";
        okBtn.textContent = t("dialogs.ok");
        cancelBtn.textContent = t("dialogs.cancel");
        modal.classList.add("active");
        inputEl.focus();
        inputEl.select();
        const cleanup = () => {
         modal.classList.remove("active");
         okBtn.removeEventListener("click", handleOk);
         cancelBtn.removeEventListener("click", handleCancel);
         inputEl.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleOk = () => { cleanup(); resolve(inputEl.value); };
        const handleCancel = () => { cleanup(); resolve(null); };
        const handleEnter = (e) => { if (e.key === "Enter") handleOk(); };
        const bgHandler = (e) => { if (e.target === modal) handleCancel(); };
        okBtn.addEventListener("click", handleOk);
        cancelBtn.addEventListener("click", handleCancel);
        inputEl.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       });
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal(t("editModal.editTitle"), PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         });
       });
      }
      function editNodeName(id) {
       showEditModal(t("editModal.editName"), NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       const labels = LANG.modes[PAGE_STATE.mappingMode] || LANG.modes.network;
       showEditModal("Edit " + labels.subtitle, NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         const nodeIpEl = document.getElementById("node-ip");
         if (newIp) {
           nodeIpEl.textContent = newIp;
           nodeIpEl.style.opacity = "1";
         } else {
           nodeIpEl.textContent = "Click to add " + labels.subtitle;
           nodeIpEl.style.opacity = "0.5";
         }
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       const nodeIpEl2 = document.getElementById("node-ip");
       const modeLabels2 = LANG.modes[PAGE_STATE.mappingMode] || LANG.modes.network;
       if (data.ip) {
         nodeIpEl2.textContent = data.ip;
         nodeIpEl2.style.opacity = "1";
       } else {
         nodeIpEl2.textContent = "Click to add " + modeLabels2.subtitle;
         nodeIpEl2.style.opacity = "0.5";
       }
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (hasCoverageZone(data.shape)) {
    const defaults = getCoverageDefaults(data.shape);
    fovSection.style.display = "block";
    document.getElementById("fov-enabled").checked = data.fovEnabled || false;
    document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
    document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
    document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
    document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
    document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
    document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
    document.getElementById("fov-rotation").value = data.fovRotation || 0;
    document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
    document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
    document.getElementById("fov-opacity").value = data.fovOpacity || 20;
    document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
    document.getElementById("fov-gradient").checked = data.fovGradient || false;
    document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
    document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
    document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
    document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
    document.getElementById("fov-label").value = data.fovLabel || "";
    document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
    document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
    document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
    document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
    document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
    document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
    document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
    document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
    document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
    document.getElementById("fov-animate").checked = data.fovAnimate || false;
    document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
    document.getElementById("fov-sweep").value = data.fovSweep || 120;
    document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
    document.getElementById("fov-speed").value = data.fovSpeed || 4;
    document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
  } else {
    fovSection.style.display = "none";
  }
}
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "layer1";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">' + t("emptyStates.noNodesAssigned") + '</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList && connectionsCount) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = async () => { if (localPort) { selectTheConnection(e.id); } else { const nodeName = NODE_DATA[id]?.name || id; const newVal = await showPrompt(t("dialogs.enterPort", { nodeName: nodeName }), ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !await showConfirm(t("dialogs.portAlreadyUsed", { port: newVal, nodeName: nodeName }))) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = async () => { if (remotePort) { selectTheConnection(e.id); } else { const newVal = await showPrompt(t("dialogs.enterPort", { nodeName: remoteName }), ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !await showConfirm(t("dialogs.portAlreadyUsed", { port: newVal, nodeName: remoteName }))) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">' + t("emptyStates.noConnections") + '</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage zone");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-angle").oninput = function() {
  document.getElementById("fov-angle-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-distance").oninput = function() {
  document.getElementById("fov-distance-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-inner-radius").oninput = function() {
  document.getElementById("fov-inner-radius-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovInnerRadius = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-rotation").oninput = function() {
  document.getElementById("fov-rotation-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage color");
  NODE_DATA[currentNodeId].fovColor = this.value;
  updateFovCone(currentNodeId);
  updateZoneLegend();
};
document.getElementById("fov-opacity").oninput = function() {
  document.getElementById("fov-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-gradient").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage gradient");
  NODE_DATA[currentNodeId].fovGradient = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border color");
  NODE_DATA[currentNodeId].fovBorderColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-width").oninput = function() {
  document.getElementById("fov-border-width-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderWidth = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-style").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border style");
  NODE_DATA[currentNodeId].fovBorderStyle = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-opacity").oninput = function() {
  document.getElementById("fov-border-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabel = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-position").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelPosition = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-size").oninput = function() {
  document.getElementById("fov-label-size-value").textContent = this.value + "px";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelSize = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bold").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBold = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBg = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBgColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-x").oninput = function() {
  document.getElementById("fov-label-offset-x-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetX = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-y").oninput = function() {
  document.getElementById("fov-label-offset-y-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetY = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-preset").addEventListener("change", function() {
  if (this.value) {
    applyZonePreset(this.value);
    this.value = "";
  }
});
document.getElementById("fov-save-preset").addEventListener("click", saveCustomZonePreset);
document.getElementById("fov-copy-style").addEventListener("click", function() {
  if (currentNodeId && copyZoneStyle(currentNodeId)) {
    showAlert(t("dialogs.zoneStyleCopiedShort"));
  }
});
document.getElementById("fov-paste-style").addEventListener("click", function() {
  if (currentNodeId && pasteZoneStyle(currentNodeId)) {
    claimTheImmortal(currentNodeId);
  }
});
document.getElementById("bulk-zone-copy").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle").addEventListener("click", bulkToggleZones);
document.getElementById("bulk-zone-copy-mobile").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste-mobile").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle-mobile").addEventListener("click", bulkToggleZones);
document.getElementById("fov-animate").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage animation");
  NODE_DATA[currentNodeId].fovAnimate = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-animation-type").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change animation type");
  NODE_DATA[currentNodeId].fovAnimationType = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-sweep").oninput = function() {
  document.getElementById("fov-sweep-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-speed").oninput = function() {
  document.getElementById("fov-speed-value").textContent = this.value + "s";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
  updateFovCone(currentNodeId);
};
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const currentRotation = NODE_DATA[id].rotation || 0;
       document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
       document.getElementById("rotation-value").value = currentRotation;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
       const catSelect = document.getElementById("shape-category-select");
       const nodeShape = data.shape || "circle";
       const shapeCategory = findCategoryForShape(nodeShape);
       if (catSelect) {
         catSelect.value = shapeCategory;
         populateShapeSelect(nodeShape);
       }
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        if (typeof tag !== 'string') return;
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal(t("editModal.editTag"), tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = t("ui.buttons.addTag");
       addTagBtn.addEventListener("click", () => {
        showEditModal(t("editModal.addTags"), "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         });
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          });
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       const waypointsRow = document.getElementById("waypoints-row");
       const waypoints = edge.waypoints || [];
       if (edge.type !== "custom" && waypoints.length > 0) {
        waypointsRow.style.display = "flex";
        document.getElementById("waypoints-label").textContent = `${t("ui.labels.waypoints")} (${waypoints.length}):`;
       } else {
        waypointsRow.style.display = "none";
       }
       document.getElementById("edge-animate").checked = edge.animate === true;
       document.getElementById("edge-animation-style").value = edge.animationStyle || "";
       document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal(t("dialogs.deleteLineNote"), () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       hint.style.cursor = "pointer";
       let hintDismissed = false;
       const dismissHint = () => { hintDismissed = true; hint.classList.remove("visible"); };
       hint.addEventListener("click", dismissHint);
       hint.addEventListener("touchend", (e) => { e.preventDefault(); dismissHint(); });
       setTimeout(() => {
        if (hintDismissed) return;
        hint.classList.add("visible");
        setTimeout(() => { if (!hintDismissed) hint.classList.remove("visible"); }, 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        });
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        });
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        });
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        });
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        });
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize - 5);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize + 20);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize - 5);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize + 20);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      const rotationSlider = document.getElementById("rotation-slider");
      const rotationInput = document.getElementById("rotation-value");
      const resetRotationBtn = document.getElementById("reset-rotation");
      rotationSlider.addEventListener("input", () => {
        const newRotation = parseInt(rotationSlider.value, 10);
        rotationInput.value = newRotation;
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      rotationInput.addEventListener("input", () => {
        const newRotation = parseInt(rotationInput.value, 10) || 0;
        rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      resetRotationBtn.addEventListener("click", () => {
        pushUndo("reset rotation");
        NODE_DATA[currentNodeId].rotation = 0;
        rotationSlider.value = 0;
        rotationInput.value = 0;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
        }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animate").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animate");
       edge.animate = e.target.checked;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animation speed");
       edge.animationSpeed = e.target.value || "";
       if (PAGE_STATE.animateConnections && edge.animate !== false) forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
	  document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId);
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        });
      });
      document.getElementById("clear-waypoints-btn").addEventListener("click", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
       if (!edge || !edge.waypoints || edge.waypoints.length === 0) return;
       pushUndo("clear waypoints");
       edge.waypoints = [];
       selectTheConnection(currentEdgeId);
       forgeTheTopology();
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
        waypoints: [],
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else if (lineStyle === "wall") {
  freeDrawPolylineEl.style.stroke = "url(#wall-hatch)";
  freeDrawPolylineEl.style.strokeWidth = "12";
  freeDrawPolylineEl.style.strokeDasharray = "none"; 
  } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler);
           document.removeEventListener("touchend", touchUpHandler);
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         });
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = t("ui.buttons.done");
       drawToggleBtn.classList.add("done-btn-active");
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       drawToggleBtn.classList.remove("done-btn-active");
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        showAlert(t("dialogs.drawingDisabledInRack"));
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       });
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = t("ui.buttons.done");
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         showAlert(t("dialogs.drawingDisabledInRack"));
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         finishRectDraw();
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         finishRectDraw();
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = t("ui.buttons.done");
       textToggleBtn.classList.add("done-btn-active");
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.classList.remove("done-btn-active");
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        showAlert(t("dialogs.drawingDisabledInRack"));
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: t("ui.defaults.newText"),
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       finishTextMode();
       forgeTheTopology();
       showTextPanel(newId);
       const textInput = document.getElementById("text-content");
       if (textInput) {
        textInput.focus();
        textInput.select();
       }
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
       document.getElementById("text-rotation-val").value = textItem.rotation || 0;
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-rotation").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          textItem.rotation = parseInt(e.target.value) || 0;
          document.getElementById("text-rotation-val").value = textItem.rotation;
          forgeTheTopology();
        }
      });
      document.getElementById("text-rotation-val").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          const val = parseInt(e.target.value) || 0;
          textItem.rotation = val;
          document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
          forgeTheTopology();
        }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("add-line-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
	   document.getElementById("anim-master").addEventListener("change", e => { ANIM_SETTINGS.masterAnim = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-sweep").addEventListener("change", e => { ANIM_SETTINGS.animTypes.sweep = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-pulse").addEventListener("change", e => { ANIM_SETTINGS.animTypes.pulse = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-rings").addEventListener("change", e => { ANIM_SETTINGS.animTypes.rings = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-spin").addEventListener("change", e => { ANIM_SETTINGS.animTypes.spin = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-connections").addEventListener("change", e => { ANIM_SETTINGS.animTypes.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.animCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.animCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.animCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.animCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.animCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-connections").addEventListener("change", e => { ANIM_SETTINGS.animCategories.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-master").addEventListener("change", e => { ANIM_SETTINGS.masterZones = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });

      document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
      document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
      document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;

      document.getElementById("animation-style-select").addEventListener("change", (e) => {
       PAGE_STATE.animationStyle = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-direction-select").addEventListener("change", (e) => {
       PAGE_STATE.animationDirection = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-speed-select").addEventListener("change", (e) => {
       PAGE_STATE.animationSpeed = parseFloat(e.target.value);
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
	   document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
	   document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       rebuildThemeDropdown();
       updateDeleteButton();
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" },
  brainwave: { panel:"#1a1625",panelAlt:"#2d2640",sidebarBg:"#12101c",btnBg:"#2d2640",btnText:"#e8dff5",accent:"#9d4edd",danger:"#ff6b9d",textMain:"#e8dff5",textSoft:"#a89cc8",topbarBg:"#12101c",topbarBorder:"#5a189a",nodeFill:"#240046",nodeStroke:"#7b2cbf",nodeTitle:"#e0aaff",nodeSub:"#c77dff",defaultEdge:"#9d4edd",canvasGradientTop:"#1a1625",canvasGradientBottom:"#0d0a14",tagFill:"#3c096c",tagText:"#e0aaff",tagBorder:"#9d4edd",inputBg:"#12101c",inputText:"#e8dff5",inputBorder:"#5a189a",toolbarBg:"#7b2cbf",toolbarBorder:"#9d4edd",toolbarText:"#ffffff",toolbarBtnBg:"#9d4edd",toolbarBtnText:"#ffffff",selectionHandle:"#ff9e00",groupIndicator:"#00f5d4",minimapDots:"#9d4edd",canvasHintBg:"#1a1625",canvasHintColor:"#a89cc8",canvasBorder:"#5a189a",canvasGrid:"#2d2640",rackFrameFill:"#1a1625",rackFrameStroke:"#9d4edd",rackLineColor:"#5a189a",rackTextColor:"#e0aaff" },
  neonMint: { panel:"#0d1117",panelAlt:"#161b22",sidebarBg:"#010409",btnBg:"#161b22",btnText:"#7ee8c7",accent:"#00ffc8",danger:"#ff6b6b",textMain:"#7ee8c7",textSoft:"#3fb68a",topbarBg:"#010409",topbarBorder:"#00ffc8",nodeFill:"#0d1f17",nodeStroke:"#00ffc8",nodeTitle:"#7ee8c7",nodeSub:"#3fb68a",defaultEdge:"#00d9a7",canvasGradientTop:"#0d1117",canvasGradientBottom:"#010409",tagFill:"#0d2818",tagText:"#00ffc8",tagBorder:"#00d9a7",inputBg:"#010409",inputText:"#7ee8c7",inputBorder:"#1a4d3a",toolbarBg:"#00a67e",toolbarBorder:"#00ffc8",toolbarText:"#010409",toolbarBtnBg:"#00ffc8",toolbarBtnText:"#010409",selectionHandle:"#ffd000",groupIndicator:"#ff79c6",minimapDots:"#00ffc8",canvasHintBg:"#0d1117",canvasHintColor:"#3fb68a",canvasBorder:"#1a4d3a",canvasGrid:"#0a2920",rackFrameFill:"#0d1117",rackFrameStroke:"#00ffc8",rackLineColor:"#1a4d3a",rackTextColor:"#00ffc8" },
  velvetDusk: { panel:"#1f1d2e",panelAlt:"#26233a",sidebarBg:"#191724",btnBg:"#26233a",btnText:"#e0def4",accent:"#eb6f92",danger:"#eb6f92",textMain:"#e0def4",textSoft:"#908caa",topbarBg:"#191724",topbarBorder:"#524f67",nodeFill:"#26233a",nodeStroke:"#c4a7e7",nodeTitle:"#e0def4",nodeSub:"#9ccfd8",defaultEdge:"#ebbcba",canvasGradientTop:"#1f1d2e",canvasGradientBottom:"#191724",tagFill:"#31283d",tagText:"#f6c177",tagBorder:"#c4a7e7",inputBg:"#191724",inputText:"#e0def4",inputBorder:"#524f67",toolbarBg:"#c4a7e7",toolbarBorder:"#eb6f92",toolbarText:"#191724",toolbarBtnBg:"#eb6f92",toolbarBtnText:"#191724",selectionHandle:"#f6c177",groupIndicator:"#31748f",minimapDots:"#c4a7e7",canvasHintBg:"#1f1d2e",canvasHintColor:"#908caa",canvasBorder:"#524f67",canvasGrid:"#312e45",rackFrameFill:"#1f1d2e",rackFrameStroke:"#c4a7e7",rackLineColor:"#524f67",rackTextColor:"#9ccfd8" },
  sunburst: { panel:"#fff7ed",panelAlt:"#ffedd5",sidebarBg:"#fffbf7",btnBg:"#ffedd5",btnText:"#9a3412",accent:"#f97316",danger:"#dc2626",textMain:"#431407",textSoft:"#9a3412",topbarBg:"#ea580c",topbarBorder:"#c2410c",nodeFill:"#fff7ed",nodeStroke:"#fb923c",nodeTitle:"#431407",nodeSub:"#9a3412",defaultEdge:"#fdba74",canvasGradientTop:"#fff7ed",canvasGradientBottom:"#fffbf7",tagFill:"#fed7aa",tagText:"#c2410c",tagBorder:"#f97316",inputBg:"#fffbf7",inputText:"#431407",inputBorder:"#fed7aa",toolbarBg:"#f97316",toolbarBorder:"#ea580c",toolbarText:"#ffffff",toolbarBtnBg:"#fb923c",toolbarBtnText:"#431407",selectionHandle:"#0891b2",groupIndicator:"#059669",minimapDots:"#f97316",canvasHintBg:"#fff7ed",canvasHintColor:"#9a3412",canvasBorder:"#fed7aa",canvasGrid:"#fdba74",rackFrameFill:"#fff7ed",rackFrameStroke:"#f97316",rackLineColor:"#fed7aa",rackTextColor:"#c2410c" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", async () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!await showConfirm(t("dialogs.applyRoutingToAll", { routing: routing, count: EDGE_DATA.list.length }))) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       document.getElementById("add-line-color").value = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
	  document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.canvasGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.rackGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         showAlert(t("dialogs.invalidDataFile"));
         return;
        }
        if (!await showConfirm(t("dialogs.confirmImportJson", { nodeCount: Object.keys(data.nodeData).length, edgeCount: data.edgeData.list?.length || 0, tabCount: data.documentTabs?.length || 1 }))) {
         e.target.value = "";
         return;
        }
		pushUndo('import json');
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        if (data.customLanguage) {
          CUSTOM_LANG = data.customLanguage;
          LANG = deepMerge(DEFAULT_LANG, CUSTOM_LANG);
          saveLanguageToStorage();
          applyLanguage();
          updateCurrentLangDisplay();
        }
        const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
          if (!node.layer || layerMap[node.layer]) node.layer = layerMap[node.layer] || 'layer1';
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
        const nodeCount = Object.keys(data.nodeData).length;
        const edgeCount = data.edgeData.list?.length || 0;
        const rectCount = data.rectData?.list?.length || 0;
        const textCount = data.textData?.list?.length || 0;
		logAuditEvent("import", `Imported JSON: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        showAlert(t("dialogs.jsonImportSuccess", { nodeCount, edgeCount, rectCount, textCount }));
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        showAlert(t("dialogs.importDataFailed", { error: err.message }));
        e.target.value = "";
       }
      });
      document.getElementById("import-lang-file").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        importLanguageFile(file);
        e.target.value = "";
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
		savedStyleSets: savedStyleSets,
		recordings: RECORDING_STATE.recordings,
        customLanguage: CUSTOM_LANG || null,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = await showPrompt(t("dialogs.enterEncryptPassword"));
        if (!password) {
         showAlert(t("dialogs.encryptionCancelledNotSaved"));
         return;
        }
        const confirmPassword = await showPrompt(t("dialogs.confirmEncryptPassword"));
        if (password !== confirmPassword) {
         showAlert(t("dialogs.passwordsMismatchNotSaved"));
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         showAlert(t("dialogs.encryptionFailedError", { error: e.message }));
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal(t("editModal.editMacAddress"), currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = t("editModal.editRackUnit");
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = t("editModal.editUHeight");
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
		NODE_DATA[newId] = {
		 shape: source.shape,
		 name: newName,
		 ip: source.ip,
		 role: source.role,
		 tags: [...source.tags],
		 notes: [...source.notes],
		 mac: source.mac || "",
		 rackUnit: source.rackUnit || "",
		 uHeight: source.uHeight || "1",
		 layer: source.layer || "layer1",
		 assignedRack: source.assignedRack || "",
		 rackCapacity: source.rackCapacity || "42",
		 isRack: source.isRack || false,
fovEnabled: source.fovEnabled || false,
 fovAngle: source.fovAngle || 90,
 fovDistance: source.fovDistance || 150,
 fovInnerRadius: source.fovInnerRadius || 0,
 fovRotation: source.fovRotation || 0,
 fovColor: source.fovColor || "#f59e0b",
 fovOpacity: source.fovOpacity || 20,
 fovGradient: source.fovGradient || false,
 fovBorderColor: source.fovBorderColor || "#f59e0b",
 fovBorderWidth: source.fovBorderWidth ?? 2,
 fovBorderStyle: source.fovBorderStyle || "solid",
 fovBorderOpacity: source.fovBorderOpacity ?? 100,
 fovLabel: source.fovLabel || "",
 fovLabelPosition: source.fovLabelPosition || "center",
 fovLabelSize: source.fovLabelSize || 14,
 fovLabelColor: source.fovLabelColor || "#ffffff",
 fovLabelBold: source.fovLabelBold || false,
 fovLabelBg: source.fovLabelBg || false,
 fovLabelBgColor: source.fovLabelBgColor || "#000000",
 fovLabelOffsetX: source.fovLabelOffsetX || 0,
 fovLabelOffsetY: source.fovLabelOffsetY || 0,
 fovAnimate: source.fovAnimate || false,
 fovAnimationType: source.fovAnimationType || "sweep",
 fovSweep: source.fovSweep || 120,
 fovSpeed: source.fovSpeed || 4
		};
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(t("dialogs.deleteNodeConfirm", { name: NODE_DATA[currentNodeId].name }), () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal(t("dialogs.deleteLineConfirm"), () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">' + t("emptyStates.noVersionHistory") + '</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${t("ui.stats.nodesConnections", { nodeCount, edgeCount })}</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" data-lang="tooltips.deleteVersion" data-lang-attr="title">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      async function restoreRollbackVersion(index) {
        if (!await showConfirm(t("dialogs.restoreVersion", { date: new Date(rollbackVersions[index].timestamp).toLocaleString() }))) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      async function deleteRollbackVersion(index) {
        if (!await showConfirm(t("dialogs.deleteVersionConfirm"))) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      async function clearRollbackHistory() {
        if (!await showConfirm(t("dialogs.clearVersionHistory"))) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      async function createManualSnapshot() {
        const description = await showPrompt(t("dialogs.enterSnapshotDescription"), "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
        const hasData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
        const hasPageState = newTab.pageState !== null && newTab.pageState !== undefined;
        if (!hasData && !hasPageState) {
          if (typeof showWelcomeModal === 'function') showWelcomeModal();
        }
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          showAlert(t("dialogs.enterTabName"));
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      async function renameTab(index) {
        const tab = documentTabs[index];
        const newName = await showPrompt(t("dialogs.enterNewTabName"), tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      async function deleteTab(index) {
        if (documentTabs.length === 1) {
          showAlert(t("dialogs.cannotDeleteLastTab"));
          return;
        }
        if (!await showConfirm(t("dialogs.deleteTab", { name: documentTabs[index].name }))) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      async function saveCurrentTheme() {
        const name = await showPrompt(t("dialogs.saveThemeName"), t("dialogs.defaultThemeName", { number: savedStyleSets.length + 1 }));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!await showConfirm(t("dialogs.themeExists", { name: name }))) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      async function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!await showConfirm(t("dialogs.deleteTheme", { name: savedStyleSets[index].name }))) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
		btn.style.display = "block";
		btn.disabled = !select.value.startsWith("mytheme-");
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          const tabMode = tab.pageState?.mappingMode || (isActive ? PAGE_STATE.mappingMode : 'network') || 'network';
          const modeLabel = LANG.modes[tabMode]?.name || tabMode;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${t("ui.stats.nodesConnections", { nodeCount, edgeCount })} · ${modeLabel}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" data-lang="tooltips.renameTab" data-lang-attr="title">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" data-lang="tooltips.deleteTab" data-lang-attr="title">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">' + t("emptyStates.noAuditEntries") + '</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      async function clearAuditLog() {
        if (!await showConfirm(t("dialogs.clearAuditLog"))) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          showAlert(t("dialogs.noAuditEntriesToExport"));
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          showAlert(t("dialogs.enterNoteName"));
          return;
        }
        if (encryptedSections[name]) {
          showAlert(t("dialogs.noteAlreadyExists"));
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = t("notes.newNoteTitle", { name });
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      async function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = await showPrompt(t("dialogs.enterDecryptPasswordFor", { name: name }));
          if (!password) return;
          try {
            const decrypted = await decryptData(section.data, password);
            document.getElementById("secret-editor-title").textContent = t("notes.editNoteTitle", { name });
            document.getElementById("secret-editor-content").value = decrypted;
            document.getElementById("secrets-modal").classList.remove("active");
            document.getElementById("secret-editor-modal").classList.add("active");
          } catch (e) {
            showAlert(t("dialogs.decryptionFailed"));
          }
        } else {
          document.getElementById("secret-editor-title").textContent = t("notes.editNoteTitle", { name });
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = await showPrompt(t("dialogs.enterEncryptPasswordFor", { name: currentSecretName }));
          if (!password) return;
          const confirmPassword = await showPrompt(t("dialogs.confirmPasswordFor"));
          if (password !== confirmPassword) {
            showAlert(t("dialogs.passwordsMismatch"));
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            showAlert(t("dialogs.encryptionFailedError", { error: e.message }));
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      async function deleteSecret(name) {
        if (!await showConfirm(t("dialogs.deleteNote", { name: name }))) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">' + t("emptyStates.noNotesYet") + '</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" data-lang="tooltips.editNote" data-lang-attr="title">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" data-lang="tooltips.deleteNote" data-lang-attr="title">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: t("ui.defaults.newNode"),
          ip: "",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "layer1",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: t("ui.defaults.newRack"),
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "layer1",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["1", "2", "3", "4"].forEach(num => {
       const checkbox = document.getElementById(`layer-${num}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">' + t("emptyStates.noConnectionsFound") + '</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" data-lang="tooltips.goToConnection" data-lang-attr="title">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = async function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = await showPrompt(t("dialogs.enterPort", { nodeName: nodeName }), currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !await showConfirm(t("dialogs.portAlreadyUsed", { port: newVal, nodeName: nodeName }))) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["1", "2", "3", "4"].forEach(num => {
       const checkbox = document.getElementById(`layer-${num}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         showAlert(t("dialogs.enterRackName"));
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "layer1",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        showAlert(t("dialogs.enterNodeName"));
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "layer1",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "layer1";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       });
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile") || key.startsWith("theOneFile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        CUSTOM_LANG = null;
        LANG = JSON.parse(JSON.stringify(DEFAULT_LANG));
        applyLanguage();
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = t("ui.buttons.deleteNode");
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = t("dialogs.deleteRackWithNodes", { name: nodeData.name, count: nodesInsideRack.length, nodeList: nodesInsideRack.join('\n• ') });
         } else {
          confirmMessage = t("dialogs.deleteEmptyRack", { name: nodeData.name });
         }
        } else {
         confirmMessage = t("dialogs.deleteNodeWithConnections", { name: nodeData?.name || currentNodeId });
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        showAlert(t("dialogs.screenshotFailed"));
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function printTopologyColor() {
	  const svg = document.getElementById("map");
	  if (!svg) { window.print(); return; }
	  const svgClone = svg.cloneNode(true);
	  const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
	  const [x, y, width, height] = viewBox;
	  svgClone.setAttribute("width", width);
	  svgClone.setAttribute("height", height);
	  svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
	  const wrapper = document.createElement("div");
	  wrapper.style.position = "absolute";
	  wrapper.style.left = "-9999px";
	  wrapper.appendChild(svgClone);
	  document.body.appendChild(wrapper);
	  function inlineStyles(original, clone) {
		const elements = original.querySelectorAll("*");
		const clonedElements = clone.querySelectorAll("*");
		const rootStyles = getComputedStyle(document.documentElement);
		const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
		const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
		bgRect.setAttribute("x", x);
		bgRect.setAttribute("y", y);
		bgRect.setAttribute("width", width);
		bgRect.setAttribute("height", height);
		bgRect.setAttribute("fill", bgColor);
		clone.insertBefore(bgRect, clone.firstChild);
		elements.forEach((el, index) => {
		  const clonedEl = clonedElements[index];
		  if (!clonedEl) return;
		  const computedStyle = getComputedStyle(el);
		  const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end"];
		  svgProps.forEach((prop) => {
			const value = computedStyle.getPropertyValue(prop);
			if (value && value !== "none" && value !== "normal") {
			  clonedEl.style[prop] = value;
			}
		  });
		  clonedEl.removeAttribute("class");
		});
	  }
	  inlineStyles(svg, svgClone);
	  const svgData = new XMLSerializer().serializeToString(svgClone);
	  document.body.removeChild(wrapper);
	  const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
	  const url = URL.createObjectURL(svgBlob);
	  const img = new Image();
	  img.onload = function() {
		const canvas = document.createElement("canvas");
		canvas.width = width;
		canvas.height = height;
		const ctx = canvas.getContext("2d");
		ctx.drawImage(img, 0, 0);
		const dataUrl = canvas.toDataURL("image/png");
		URL.revokeObjectURL(url);
		const printWindow = window.open("", "_blank");
		printWindow.document.write(`
		  <html><head><title>Print Topology</title>
		  <style>@media print { @page { size: landscape; margin: 0; } body { margin: 0; } img { width: 100vw; height: 100vh; object-fit: contain; } }</style>
		  </head><body><img src="${dataUrl}" onload="window.print(); window.close();"></body></html>
		`);
		printWindow.document.close();
	  };
	  img.onerror = function() {
		console.error("Failed to load SVG image for print");
		showAlert(t("dialogs.screenshotFailed"));
		URL.revokeObjectURL(url);
	  };
	  img.src = url;
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'layer1',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { showAlert(t("dialogs.csvNoDataRows")); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { showAlert(t("dialogs.csvNeedsNameColumn")); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = await showConfirm(
        t("dialogs.confirmImportCsvFull", {
          nodeCount: nodes.length,
          tabCount: config.documentTabs?.length || 1,
          edgeCount: config.edgeData?.list?.length || 0,
          csvNodeCount: nodes.length
        })
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      const settingsNote = hasConfig ? t("dialogs.csvSettingsRestore") : t("dialogs.csvAddOnly");
      if (!await showConfirm(t("dialogs.confirmImportCsvAdd", { count: nodes.length, settingsNote: settingsNote }))) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
        if (!node.layer || layerMap[node.layer]) node.layer = layerMap[node.layer] || 'layer1';
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      showAlert(t("dialogs.fullRestoreComplete"));
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState || config.page);
		  if (config.canvasView || config.canvas) {
			canvasState.zoom = (config.canvasView || config.canvas).zoom || 1;
			canvasState.panX = (config.canvasView || config.canvas).panX || 0;
			canvasState.panY = (config.canvasView || config.canvas).panY || 0;
		  }
		  if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'layer1', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		showAlert(t("dialogs.importedNodesCount", { count: nodes.length }));
	  } catch (err) {
		console.error('CSV import error:', err);
		showAlert(t("dialogs.importCsvFailed", { error: err.message }));
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'layer1'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
		document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
		  const file = e.target.files[0];
		  if (!file) return;
		  e.target.value = '';
		  try {
    const text = (await file.text()).replace(/\r\n?/g, '\n');
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      showAlert(t("dialogs.noValidTopologyInMarkdown"));
      return;
    }
    if (!await showConfirm(t("dialogs.confirmImportMarkdown", { nodeCount: nodeCount, edgeCount: edgeCount, rectCount: rectCount, textCount: textCount }))) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'layer1', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [], waypoints: edge.waypoints || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    showAlert(t("dialogs.markdownImportSuccess", { nodeCount, edgeCount, rectCount, textCount }));
     } catch (err) {
    console.error('Markdown import error:', err);
    showAlert(t("dialogs.importMarkdownFailed", { error: err.message }));
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('import-html-file')?.addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const parser = new DOMParser();
		const doc = parser.parseFromString(text, 'text/html');
		const stateScript = doc.getElementById('topology-state');
		if (!stateScript) {
		  showAlert(t("dialogs.invalidHtmlFile"));
		  return;
		}
		const data = JSON.parse(stateScript.textContent);
		if (!data.nodeData || !data.edgeData) {
		  showAlert(t("dialogs.invalidHtmlFile"));
		  return;
		}
		const nodeCount = Object.keys(data.nodeData).length;
		const edgeCount = data.edgeData.list?.length || 0;
		const tabCount = data.documentTabs?.length || 1;
		if (!await showConfirm(t("dialogs.confirmImportHtml", { nodeCount, edgeCount, tabCount }))) {
		  return;
		}
		pushUndo('import html');
		NODE_DATA = data.nodeData || {};
		EDGE_DATA = data.edgeData || { list: [] };
		EDGE_LEGEND = data.edgeLegend || {};
		RECT_DATA = data.rectData || { list: [] };
		TEXT_DATA = data.textData || { list: [] };
		savedPositions = data.nodePositions || {};
		savedSizes = data.nodeSizes || {};
		savedStyles = data.nodeStyles || {};
		if (data.page) {
		  PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
		  wieldThePower();
		}
		if (data.canvas) {
		  canvasState.zoom = data.canvas.zoom || 1;
		  canvasState.panX = data.canvas.panX || 0;
		  canvasState.panY = data.canvas.panY || 0;
		}
		if (data.page?.title) {
		  document.title = data.page.title;
		  document.querySelector(".editable-page-title").textContent = data.page.title;
		}
		if (data.savedStyleSets) {
		  savedStyleSets = data.savedStyleSets;
		}
		if (data.documentTabs) {
		  documentTabs = data.documentTabs;
		  currentTabIndex = data.currentTabIndex || 0;
		}
		if (data.savedTopologyView) {
		  savedTopologyView = data.savedTopologyView;
		}
		if (data.encryptedSections) {
		  encryptedSections = data.encryptedSections;
		}
		if (data.auditLog && Array.isArray(data.auditLog)) {
		  auditLog = data.auditLog;
		  try {
			localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
		  } catch (err) {
			console.warn("Failed to sync audit log to localStorage:", err);
		  }
		}
		if (data.customLanguage) {
		  CUSTOM_LANG = data.customLanguage;
		  LANG = deepMerge(DEFAULT_LANG, CUSTOM_LANG);
		  saveLanguageToStorage();
		  applyLanguage();
		  updateCurrentLangDisplay();
		}
		const layerMap = { "physical": "layer1", "logical": "layer2", "security": "layer3", "application": "layer4" };
		Object.values(NODE_DATA).forEach(node => {
		  if (!node.tags) node.tags = [];
		  if (!node.notes) node.notes = [];
		  if (!node.layer || layerMap[node.layer]) node.layer = layerMap[node.layer] || 'layer1';
		});
		EDGE_DATA.list.forEach(edge => {
		  if (!edge.notes) edge.notes = [];
		});
		forgeTheTopology();
		if (typeof forgeTheLegend === 'function') forgeTheLegend();
		logAuditEvent("import", `Imported HTML: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
		updateViewBox();
		const nodeIds = Object.keys(NODE_DATA);
		if (nodeIds.length > 0) {
		  claimTheImmortal(nodeIds[0]);
		} else {
		  document.getElementById("node-panel").style.display = "none";
		  document.getElementById("edge-panel").style.display = "none";
		  document.getElementById("topology-toolbar").style.display = "none";
		}
		showAlert(t("dialogs.htmlImportSuccess", { nodeCount, edgeCount }));
	  } catch (err) {
		console.error("HTML import error:", err);
		showAlert(t("dialogs.invalidHtmlFile"));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});

	function renderCanvasTemplate(svg, ns, template, width, height, padding, templateColor) {
	  const color = (templateColor || PAGE_STATE.canvasGrid || "#475569") + "66";
	  const majorColor = (templateColor || PAGE_STATE.canvasGrid || "#475569") + "99";
	  const w = width - padding * 2;
	  const h = height - padding * 2;
	  const cx = padding + w / 2;
	  const cy = padding + h / 2;
	  const templateGroup = document.createElementNS(ns, "g");
	  templateGroup.id = "canvas-template";

	  switch (template) {
	    case "dots": {
	      const spacing = PAGE_STATE.canvasGridSize || 50;
	      for (let x = padding; x <= width - padding; x += spacing) {
	        for (let y = padding; y <= height - padding; y += spacing) {
	          const dot = document.createElementNS(ns, "circle");
	          dot.setAttribute("cx", x);
	          dot.setAttribute("cy", y);
	          dot.setAttribute("r", 2);
	          dot.setAttribute("fill", color);
	          templateGroup.appendChild(dot);
	        }
	      }
	      break;
	    }
	    case "blueprint": {
	      const spacing = 25;
	      const majorSpacing = 100;
	      for (let x = padding; x <= width - padding; x += spacing) {
	        const line = document.createElementNS(ns, "line");
	        line.setAttribute("x1", x);
	        line.setAttribute("y1", padding);
	        line.setAttribute("x2", x);
	        line.setAttribute("y2", height - padding);
	        line.setAttribute("stroke", (x - padding) % majorSpacing === 0 ? majorColor : color);
	        line.setAttribute("stroke-width", (x - padding) % majorSpacing === 0 ? "1.5" : "0.5");
	        templateGroup.appendChild(line);
	      }
	      for (let y = padding; y <= height - padding; y += spacing) {
	        const line = document.createElementNS(ns, "line");
	        line.setAttribute("x1", padding);
	        line.setAttribute("y1", y);
	        line.setAttribute("x2", width - padding);
	        line.setAttribute("y2", y);
	        line.setAttribute("stroke", (y - padding) % majorSpacing === 0 ? majorColor : color);
	        line.setAttribute("stroke-width", (y - padding) % majorSpacing === 0 ? "1.5" : "0.5");
	        templateGroup.appendChild(line);
	      }

	      const border = document.createElementNS(ns, "rect");
	      border.setAttribute("x", padding + 20);
	      border.setAttribute("y", padding + 20);
	      border.setAttribute("width", w - 40);
	      border.setAttribute("height", h - 40);
	      border.setAttribute("fill", "none");
	      border.setAttribute("stroke", majorColor);
	      border.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(border);
	      break;
	    }
	    case "basketball": {
	      const courtW = Math.min(w * 0.9, h * 0.9 * 1.88);
	      const courtH = courtW / 1.88;
	      const courtX = cx - courtW / 2;
	      const courtY = cy - courtH / 2;
	      const court = document.createElementNS(ns, "rect");
	      court.setAttribute("x", courtX);
	      court.setAttribute("y", courtY);
	      court.setAttribute("width", courtW);
	      court.setAttribute("height", courtH);
	      court.setAttribute("fill", "none");
	      court.setAttribute("stroke", majorColor);
	      court.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(court);
	      const centerCircle = document.createElementNS(ns, "circle");
	      centerCircle.setAttribute("cx", cx);
	      centerCircle.setAttribute("cy", cy);
	      centerCircle.setAttribute("r", courtH * 0.12);
	      centerCircle.setAttribute("fill", "none");
	      centerCircle.setAttribute("stroke", color);
	      centerCircle.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerCircle);
	      const centerLine = document.createElementNS(ns, "line");
	      centerLine.setAttribute("x1", cx);
	      centerLine.setAttribute("y1", courtY);
	      centerLine.setAttribute("x2", cx);
	      centerLine.setAttribute("y2", courtY + courtH);
	      centerLine.setAttribute("stroke", color);
	      centerLine.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerLine);
	      const keyW = courtW * 0.19;
	      const keyH = courtH * 0.38;
	      [courtX, courtX + courtW - keyW].forEach(kx => {
	        const key = document.createElementNS(ns, "rect");
	        key.setAttribute("x", kx);
	        key.setAttribute("y", cy - keyH / 2);
	        key.setAttribute("width", keyW);
	        key.setAttribute("height", keyH);
	        key.setAttribute("fill", "none");
	        key.setAttribute("stroke", color);
	        key.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(key);
	        const ftCircle = document.createElementNS(ns, "circle");
	        ftCircle.setAttribute("cx", kx === courtX ? kx + keyW : kx);
	        ftCircle.setAttribute("cy", cy);
	        ftCircle.setAttribute("r", keyH * 0.32);
	        ftCircle.setAttribute("fill", "none");
	        ftCircle.setAttribute("stroke", color);
	        ftCircle.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(ftCircle);
	      });
	      const arcRadius = courtH * 0.48;
	      const leftArc = document.createElementNS(ns, "path");
	      const leftArcX = courtX + courtW * 0.055;
	      leftArc.setAttribute("d", `M ${courtX} ${courtY + courtH * 0.06} L ${courtX} ${cy - arcRadius} A ${arcRadius} ${arcRadius} 0 0 1 ${courtX} ${cy + arcRadius} L ${courtX} ${courtY + courtH * 0.94}`);
	      leftArc.setAttribute("fill", "none");
	      leftArc.setAttribute("stroke", color);
	      leftArc.setAttribute("stroke-width", "2");
	      const leftCenterX = courtX + courtW * 0.055;
	      leftArc.setAttribute("d", `M ${courtX} ${courtY + courtH * 0.06} L ${leftCenterX} ${cy - arcRadius} A ${arcRadius} ${arcRadius} 0 0 1 ${leftCenterX} ${cy + arcRadius} L ${courtX} ${courtY + courtH * 0.94}`);
	      templateGroup.appendChild(leftArc);
	      const rightArc = document.createElementNS(ns, "path");
	      const rightCenterX = courtX + courtW * 0.945;
	      rightArc.setAttribute("d", `M ${courtX + courtW} ${courtY + courtH * 0.06} L ${rightCenterX} ${cy - arcRadius} A ${arcRadius} ${arcRadius} 0 0 0 ${rightCenterX} ${cy + arcRadius} L ${courtX + courtW} ${courtY + courtH * 0.94}`);
	      rightArc.setAttribute("fill", "none");
	      rightArc.setAttribute("stroke", color);
	      rightArc.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(rightArc);
	      break;
	    }
	    case "football": {
	      const fieldW = Math.min(w * 0.9, h * 0.9 * 2.25);
	      const fieldH = fieldW / 2.25;
	      const fieldX = cx - fieldW / 2;
	      const fieldY = cy - fieldH / 2;
	      const field = document.createElementNS(ns, "rect");
	      field.setAttribute("x", fieldX);
	      field.setAttribute("y", fieldY);
	      field.setAttribute("width", fieldW);
	      field.setAttribute("height", fieldH);
	      field.setAttribute("fill", "none");
	      field.setAttribute("stroke", majorColor);
	      field.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(field);
	      const endZoneW = fieldW / 12;
	      [fieldX, fieldX + fieldW - endZoneW].forEach(ex => {
	        const ez = document.createElementNS(ns, "rect");
	        ez.setAttribute("x", ex);
	        ez.setAttribute("y", fieldY);
	        ez.setAttribute("width", endZoneW);
	        ez.setAttribute("height", fieldH);
	        ez.setAttribute("fill", color);
	        ez.setAttribute("fill-opacity", "0.2");
	        ez.setAttribute("stroke", color);
	        ez.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(ez);
	      });
	      const playFieldW = fieldW - 2 * endZoneW;
	      for (let i = 1; i < 10; i++) {
	        const x = fieldX + endZoneW + (playFieldW * i / 10);
	        const line = document.createElementNS(ns, "line");
	        line.setAttribute("x1", x);
	        line.setAttribute("y1", fieldY);
	        line.setAttribute("x2", x);
	        line.setAttribute("y2", fieldY + fieldH);
	        line.setAttribute("stroke", color);
	        line.setAttribute("stroke-width", i === 5 ? "3" : "1.5");
	        templateGroup.appendChild(line);
	      }
	      const hashY1 = fieldY + fieldH * 0.3;
	      const hashY2 = fieldY + fieldH * 0.7;
	      for (let i = 0; i <= 100; i += 5) {
	        const x = fieldX + endZoneW + (playFieldW * i / 100);
	        [hashY1, hashY2].forEach(hy => {
	          const hash = document.createElementNS(ns, "line");
	          hash.setAttribute("x1", x - 5);
	          hash.setAttribute("y1", hy);
	          hash.setAttribute("x2", x + 5);
	          hash.setAttribute("y2", hy);
	          hash.setAttribute("stroke", color);
	          hash.setAttribute("stroke-width", "1");
	          templateGroup.appendChild(hash);
	        });
	      }
	      break;
	    }
	    case "soccer": {
	      const pitchW = Math.min(w * 0.9, h * 0.9 * 1.54);
	      const pitchH = pitchW / 1.54;
	      const pitchX = cx - pitchW / 2;
	      const pitchY = cy - pitchH / 2;
	      const pitch = document.createElementNS(ns, "rect");
	      pitch.setAttribute("x", pitchX);
	      pitch.setAttribute("y", pitchY);
	      pitch.setAttribute("width", pitchW);
	      pitch.setAttribute("height", pitchH);
	      pitch.setAttribute("fill", "none");
	      pitch.setAttribute("stroke", majorColor);
	      pitch.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(pitch);
	      const centerLine = document.createElementNS(ns, "line");
	      centerLine.setAttribute("x1", cx);
	      centerLine.setAttribute("y1", pitchY);
	      centerLine.setAttribute("x2", cx);
	      centerLine.setAttribute("y2", pitchY + pitchH);
	      centerLine.setAttribute("stroke", color);
	      centerLine.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerLine);
	      const centerCircle = document.createElementNS(ns, "circle");
	      centerCircle.setAttribute("cx", cx);
	      centerCircle.setAttribute("cy", cy);
	      centerCircle.setAttribute("r", pitchH * 0.14);
	      centerCircle.setAttribute("fill", "none");
	      centerCircle.setAttribute("stroke", color);
	      centerCircle.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerCircle);
	      const penW = pitchW * 0.157;
	      const penH = pitchH * 0.62;
	      [pitchX, pitchX + pitchW - penW].forEach(px => {
	        const pen = document.createElementNS(ns, "rect");
	        pen.setAttribute("x", px);
	        pen.setAttribute("y", cy - penH / 2);
	        pen.setAttribute("width", penW);
	        pen.setAttribute("height", penH);
	        pen.setAttribute("fill", "none");
	        pen.setAttribute("stroke", color);
	        pen.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(pen);
	        const goalW = penW * 0.35;
	        const goalH = penH * 0.45;
	        const goal = document.createElementNS(ns, "rect");
	        goal.setAttribute("x", px === pitchX ? px : px + penW - goalW);
	        goal.setAttribute("y", cy - goalH / 2);
	        goal.setAttribute("width", goalW);
	        goal.setAttribute("height", goalH);
	        goal.setAttribute("fill", "none");
	        goal.setAttribute("stroke", color);
	        goal.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(goal);
	      });
	      break;
	    }
	    case "hockey": {
	      const rinkW = Math.min(w * 0.9, h * 0.9 * 2.35);
	      const rinkH = rinkW / 2.35;
	      const rinkX = cx - rinkW / 2;
	      const rinkY = cy - rinkH / 2;
	      const cornerR = rinkH * 0.33;
	      const rink = document.createElementNS(ns, "rect");
	      rink.setAttribute("x", rinkX);
	      rink.setAttribute("y", rinkY);
	      rink.setAttribute("width", rinkW);
	      rink.setAttribute("height", rinkH);
	      rink.setAttribute("rx", cornerR);
	      rink.setAttribute("fill", "none");
	      rink.setAttribute("stroke", majorColor);
	      rink.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(rink);
	      const centerLine = document.createElementNS(ns, "line");
	      centerLine.setAttribute("x1", cx);
	      centerLine.setAttribute("y1", rinkY);
	      centerLine.setAttribute("x2", cx);
	      centerLine.setAttribute("y2", rinkY + rinkH);
	      centerLine.setAttribute("stroke", "#cc3333" + "99");
	      centerLine.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(centerLine);
	      const blueLineOffset = rinkW * 0.25;
	      [cx - blueLineOffset, cx + blueLineOffset].forEach(bx => {
	        const blueLine = document.createElementNS(ns, "line");
	        blueLine.setAttribute("x1", bx);
	        blueLine.setAttribute("y1", rinkY);
	        blueLine.setAttribute("x2", bx);
	        blueLine.setAttribute("y2", rinkY + rinkH);
	        blueLine.setAttribute("stroke", "#3366cc" + "99");
	        blueLine.setAttribute("stroke-width", "3");
	        templateGroup.appendChild(blueLine);
	      });
	      const centerCircle = document.createElementNS(ns, "circle");
	      centerCircle.setAttribute("cx", cx);
	      centerCircle.setAttribute("cy", cy);
	      centerCircle.setAttribute("r", rinkH * 0.18);
	      centerCircle.setAttribute("fill", "none");
	      centerCircle.setAttribute("stroke", "#3366cc" + "99");
	      centerCircle.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerCircle);
	      const faceoffR = rinkH * 0.18;
	      const faceoffPositions = [
	        [rinkX + rinkW * 0.15, cy - rinkH * 0.25],
	        [rinkX + rinkW * 0.15, cy + rinkH * 0.25],
	        [rinkX + rinkW * 0.85, cy - rinkH * 0.25],
	        [rinkX + rinkW * 0.85, cy + rinkH * 0.25]
	      ];
	      faceoffPositions.forEach(([fx, fy]) => {
	        const circle = document.createElementNS(ns, "circle");
	        circle.setAttribute("cx", fx);
	        circle.setAttribute("cy", fy);
	        circle.setAttribute("r", faceoffR);
	        circle.setAttribute("fill", "none");
	        circle.setAttribute("stroke", "#cc3333" + "99");
	        circle.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(circle);
	      });
	      [rinkX + rinkW * 0.045, rinkX + rinkW * 0.955].forEach((gx, i) => {
	        const crease = document.createElementNS(ns, "path");
	        const creaseR = rinkH * 0.08;
	        if (i === 0) {
	          crease.setAttribute("d", `M ${gx} ${cy - creaseR} A ${creaseR} ${creaseR} 0 0 1 ${gx} ${cy + creaseR}`);
	        } else {
	          crease.setAttribute("d", `M ${gx} ${cy - creaseR} A ${creaseR} ${creaseR} 0 0 0 ${gx} ${cy + creaseR}`);
	        }
	        crease.setAttribute("fill", "#3366cc" + "33");
	        crease.setAttribute("stroke", "#cc3333" + "99");
	        crease.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(crease);
	      });
	      break;
	    }
	    case "baseball": {
	      const diamondSize = Math.min(w * 0.7, h * 0.7);
	      const baseX = cx;
	      const baseY = cy + diamondSize * 0.3;
	      const baseDistance = diamondSize * 0.35;
	      const diamond = document.createElementNS(ns, "polygon");
	      const homeX = baseX, homeY = baseY;
	      const firstX = baseX + baseDistance, firstY = baseY - baseDistance;
	      const secondX = baseX, secondY = baseY - baseDistance * 2;
	      const thirdX = baseX - baseDistance, thirdY = baseY - baseDistance;
	      diamond.setAttribute("points", `${homeX},${homeY} ${firstX},${firstY} ${secondX},${secondY} ${thirdX},${thirdY}`);
	      diamond.setAttribute("fill", "none");
	      diamond.setAttribute("stroke", color);
	      diamond.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(diamond);
	      [[homeX, homeY], [firstX, firstY], [secondX, secondY], [thirdX, thirdY]].forEach(([bx, by], i) => {
	        const base = document.createElementNS(ns, "rect");
	        const baseSize = i === 0 ? 15 : 12;
	        base.setAttribute("x", bx - baseSize / 2);
	        base.setAttribute("y", by - baseSize / 2);
	        base.setAttribute("width", baseSize);
	        base.setAttribute("height", baseSize);
	        base.setAttribute("transform", `rotate(45 ${bx} ${by})`);
	        base.setAttribute("fill", i === 0 ? majorColor : color);
	        base.setAttribute("stroke", majorColor);
	        base.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(base);
	      });
	      const moundX = baseX;
	      const moundY = baseY - baseDistance * 0.67;
	      const mound = document.createElementNS(ns, "circle");
	      mound.setAttribute("cx", moundX);
	      mound.setAttribute("cy", moundY);
	      mound.setAttribute("r", 20);
	      mound.setAttribute("fill", color);
	      mound.setAttribute("fill-opacity", "0.3");
	      mound.setAttribute("stroke", color);
	      mound.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(mound);
	      const outfieldR = diamondSize * 0.6;
	      const outfield = document.createElementNS(ns, "path");
	      outfield.setAttribute("d", `M ${baseX - outfieldR * 0.95} ${baseY - outfieldR * 0.3} A ${outfieldR} ${outfieldR} 0 0 1 ${baseX + outfieldR * 0.95} ${baseY - outfieldR * 0.3}`);
	      outfield.setAttribute("fill", "none");
	      outfield.setAttribute("stroke", color);
	      outfield.setAttribute("stroke-width", "2");
	      outfield.setAttribute("stroke-dasharray", "10,5");
	      templateGroup.appendChild(outfield);
	      const foulLength = diamondSize * 0.8;
	      [[-1, -1], [1, -1]].forEach(([dx, dy]) => {
	        const foul = document.createElementNS(ns, "line");
	        foul.setAttribute("x1", homeX);
	        foul.setAttribute("y1", homeY);
	        foul.setAttribute("x2", homeX + dx * foulLength);
	        foul.setAttribute("y2", homeY + dy * foulLength * 0.7);
	        foul.setAttribute("stroke", color);
	        foul.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(foul);
	      });
	      break;
	    }
	    case "tennis": {
	      const courtW = Math.min(w * 0.9, h * 0.9 * 2.17);
	      const courtH = courtW / 2.17;
	      const courtX = cx - courtW / 2;
	      const courtY = cy - courtH / 2;
	      const court = document.createElementNS(ns, "rect");
	      court.setAttribute("x", courtX);
	      court.setAttribute("y", courtY);
	      court.setAttribute("width", courtW);
	      court.setAttribute("height", courtH);
	      court.setAttribute("fill", "none");
	      court.setAttribute("stroke", majorColor);
	      court.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(court);
	      const singlesInset = courtH * 0.125;
	      const singles = document.createElementNS(ns, "rect");
	      singles.setAttribute("x", courtX);
	      singles.setAttribute("y", courtY + singlesInset);
	      singles.setAttribute("width", courtW);
	      singles.setAttribute("height", courtH - singlesInset * 2);
	      singles.setAttribute("fill", "none");
	      singles.setAttribute("stroke", color);
	      singles.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(singles);
	      const net = document.createElementNS(ns, "line");
	      net.setAttribute("x1", cx);
	      net.setAttribute("y1", courtY);
	      net.setAttribute("x2", cx);
	      net.setAttribute("y2", courtY + courtH);
	      net.setAttribute("stroke", majorColor);
	      net.setAttribute("stroke-width", "3");
	      templateGroup.appendChild(net);
	      const serviceW = courtW * 0.27;
	      const serviceH = (courtH - singlesInset * 2) / 2;
	      [courtX, courtX + courtW - serviceW].forEach(sx => {
	        const topBox = document.createElementNS(ns, "rect");
	        topBox.setAttribute("x", sx === courtX ? cx - serviceW : cx);
	        topBox.setAttribute("y", courtY + singlesInset);
	        topBox.setAttribute("width", serviceW);
	        topBox.setAttribute("height", serviceH);
	        topBox.setAttribute("fill", "none");
	        topBox.setAttribute("stroke", color);
	        topBox.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(topBox);
	        const botBox = document.createElementNS(ns, "rect");
	        botBox.setAttribute("x", sx === courtX ? cx - serviceW : cx);
	        botBox.setAttribute("y", cy);
	        botBox.setAttribute("width", serviceW);
	        botBox.setAttribute("height", serviceH);
	        botBox.setAttribute("fill", "none");
	        botBox.setAttribute("stroke", color);
	        botBox.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(botBox);
	      });
	      const centerService = document.createElementNS(ns, "line");
	      centerService.setAttribute("x1", cx - serviceW);
	      centerService.setAttribute("y1", cy);
	      centerService.setAttribute("x2", cx + serviceW);
	      centerService.setAttribute("y2", cy);
	      centerService.setAttribute("stroke", color);
	      centerService.setAttribute("stroke-width", "2");
	      templateGroup.appendChild(centerService);
	      [courtX, courtX + courtW].forEach(bx => {
	        const mark = document.createElementNS(ns, "line");
	        mark.setAttribute("x1", bx);
	        mark.setAttribute("y1", cy - 10);
	        mark.setAttribute("x2", bx);
	        mark.setAttribute("y2", cy + 10);
	        mark.setAttribute("stroke", color);
	        mark.setAttribute("stroke-width", "2");
	        templateGroup.appendChild(mark);
	      });
	      break;
	    }
	    case "none":
	    default:
	      break;
	  }
	  return templateGroup;
	}

	function formatRecordingTime(ms) {
	  const seconds = Math.floor(ms / 1000);
	  const minutes = Math.floor(seconds / 60);
	  const secs = seconds % 60;
	  return `${minutes}:${secs.toString().padStart(2, '0')}`;
	}

	function captureRecordingFrame() {
	  const frame = {
	    time: Date.now() - RECORDING_STATE.startTime,
	    positions: {},
	    waypoints: {}
	  };
	  Object.keys(savedPositions).forEach(id => {
	    frame.positions[id] = { x: savedPositions[id].x, y: savedPositions[id].y };
	  });
	  EDGE_DATA.list.forEach(edge => {
	    if (edge.waypoints && edge.waypoints.length > 0) {
	      frame.waypoints[edge.id] = edge.waypoints.map(wp => ({ x: wp.x, y: wp.y }));
	    }
	  });
	  RECORDING_STATE.frames.push(frame);
	  document.getElementById('recording-time').textContent = formatRecordingTime(frame.time);
	}

	function startRecording() {
	  if (RECORDING_STATE.isRecording) return;
	  RECORDING_STATE.isRecording = true;
	  RECORDING_STATE.frames = [];
	  RECORDING_STATE.startTime = Date.now();
	  captureRecordingFrame();
	  RECORDING_STATE.captureInterval = setInterval(captureRecordingFrame, 1000 / RECORDING_STATE.CAPTURE_FPS);
	  document.getElementById('record-btn').style.background = '#f56565';
	  document.getElementById('record-btn').style.color = 'white';
	  document.getElementById('recording-expanded').style.display = 'inline-flex';
	  document.getElementById('pause-btn').style.display = 'none';
	  logAuditEvent('recording', 'Started recording');
	}

	function stopRecording() {
	  if (!RECORDING_STATE.isRecording && !RECORDING_STATE.isPlaying) return;
	  const wasPlaying = RECORDING_STATE.isPlaying;
	  if (RECORDING_STATE.isRecording) {
	    clearInterval(RECORDING_STATE.captureInterval);
	    RECORDING_STATE.isRecording = false;
	    if (RECORDING_STATE.frames.length > 1) {
	      const recording = {
	        id: 'rec-' + Date.now(),
	        name: 'Recording ' + (RECORDING_STATE.recordings.length + 1),
	        created: new Date().toISOString(),
	        duration: RECORDING_STATE.frames[RECORDING_STATE.frames.length - 1].time,
	        frames: RECORDING_STATE.frames
	      };
	      RECORDING_STATE.recordings.push(recording);
	      RECORDING_STATE.currentRecording = recording;
	      logAuditEvent('recording', `Saved recording: ${recording.name} (${formatRecordingTime(recording.duration)})`);
	    }
	    document.getElementById('record-btn').style.background = 'var(--btn-bg)';
	    document.getElementById('record-btn').style.color = '#f56565';
	  }
	  if (RECORDING_STATE.isPlaying) {
	    clearTimeout(RECORDING_STATE.playbackTimer);
	    RECORDING_STATE.isPlaying = false;
	    RECORDING_STATE.isPaused = false;
	  }
	  if (wasPlaying) {
	    document.getElementById('recording-expanded').style.display = 'none';
	  }
	  document.getElementById('play-btn').style.display = 'inline-block';
	  document.getElementById('pause-btn').style.display = 'none';
	  document.getElementById('recording-time').textContent = '0:00';
	}

	function playRecording() {
	  if (!RECORDING_STATE.currentRecording || RECORDING_STATE.currentRecording.frames.length < 2) {
	    showAlert(t("dialogs.noRecordingAvailable"));
	    const expanded = document.getElementById('recording-expanded');
	    if (expanded) expanded.style.display = 'none';
	    return;
	  }
	  if (RECORDING_STATE.isPaused) {
	    RECORDING_STATE.isPaused = false;
	    RECORDING_STATE.isPlaying = true;
	    document.getElementById('play-btn').style.display = 'none';
	    document.getElementById('pause-btn').style.display = 'inline-block';
	    playNextFrame();
	    return;
	  }
	  RECORDING_STATE.isPlaying = true;
	  RECORDING_STATE.playbackIndex = 0;
	  document.getElementById('play-btn').style.display = 'none';
	  document.getElementById('pause-btn').style.display = 'inline-block';
	  document.getElementById('recording-expanded').style.display = 'inline-flex';
	  playNextFrame();
	}

	function pauseRecording() {
	  if (!RECORDING_STATE.isPlaying) return;
	  RECORDING_STATE.isPaused = true;
	  RECORDING_STATE.isPlaying = false;
	  clearTimeout(RECORDING_STATE.playbackTimer);
	  document.getElementById('play-btn').style.display = 'inline-block';
	  document.getElementById('pause-btn').style.display = 'none';
	}

	function playNextFrame() {
	  if (!RECORDING_STATE.isPlaying || !RECORDING_STATE.currentRecording) return;
	  const frames = RECORDING_STATE.currentRecording.frames;
	  if (RECORDING_STATE.playbackIndex >= frames.length) {
	    if (RECORDING_STATE.loopPlayback) {
	      RECORDING_STATE.playbackIndex = 0;
	    } else {
	      stopRecording();
	      return;
	    }
	  }
	  const frame = frames[RECORDING_STATE.playbackIndex];
	  Object.keys(frame.positions).forEach(id => {
	    if (savedPositions[id]) {
	      savedPositions[id].x = frame.positions[id].x;
	      savedPositions[id].y = frame.positions[id].y;
	    }
	  });
	  if (frame.waypoints) {
	    EDGE_DATA.list.forEach(edge => {
	      if (frame.waypoints[edge.id]) {
	        edge.waypoints = frame.waypoints[edge.id].map(wp => ({ x: wp.x, y: wp.y }));
	      } else {
	        edge.waypoints = [];
	      }
	    });
	  }
	  forgeTheTopology();
	  updateMinimap();
	  document.getElementById('recording-time').textContent = formatRecordingTime(frame.time);
	  const progress = (RECORDING_STATE.playbackIndex / (frames.length - 1)) * 100;
	  document.getElementById('playback-scrubber').value = progress;
	  RECORDING_STATE.playbackIndex++;
	  const nextFrame = frames[RECORDING_STATE.playbackIndex];
	  if (nextFrame) {
	    const delay = (nextFrame.time - frame.time) / RECORDING_STATE.playbackSpeed;
	    RECORDING_STATE.playbackTimer = setTimeout(playNextFrame, Math.max(16, delay));
	  } else if (RECORDING_STATE.loopPlayback) {
	    RECORDING_STATE.playbackTimer = setTimeout(playNextFrame, 100);
	  } else {
	    stopRecording();
	  }
	}

	function seekRecording(percent) {
	  if (!RECORDING_STATE.currentRecording) return;
	  const frames = RECORDING_STATE.currentRecording.frames;
	  const targetIndex = Math.floor((percent / 100) * (frames.length - 1));
	  RECORDING_STATE.playbackIndex = targetIndex;
	  const frame = frames[targetIndex];
	  if (frame) {
	    Object.keys(frame.positions).forEach(id => {
	      if (savedPositions[id]) {
	        savedPositions[id].x = frame.positions[id].x;
	        savedPositions[id].y = frame.positions[id].y;
	      }
	    });
	    if (frame.waypoints) {
	      EDGE_DATA.list.forEach(edge => {
	        if (frame.waypoints[edge.id]) {
	          edge.waypoints = frame.waypoints[edge.id].map(wp => ({ x: wp.x, y: wp.y }));
	        } else {
	          edge.waypoints = [];
	        }
	      });
	    }
	    forgeTheTopology();
	    updateMinimap();
	    document.getElementById('recording-time').textContent = formatRecordingTime(frame.time);
	  }
	}

	function renderRecordingsList() {
	  const list = document.getElementById('recordings-list');
	  if (RECORDING_STATE.recordings.length === 0) {
	    list.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">' + t("emptyStates.noRecordingsYet") + '</div>';
	    return;
	  }
	  list.innerHTML = RECORDING_STATE.recordings.map((rec, i) => `
	    <div style="display:flex;align-items:center;gap:10px;padding:10px;background:var(--panel);border-radius:6px;border:1px solid ${rec.id === RECORDING_STATE.currentRecording?.id ? 'var(--accent)' : 'var(--edge-main)'};">
	      <input type="radio" name="recording-select" value="${rec.id}" ${rec.id === RECORDING_STATE.currentRecording?.id ? 'checked' : ''} onchange="selectRecording('${rec.id}')">
	      <div style="flex:1;">
	        <input type="text" value="${rec.name}" style="background:transparent;border:none;color:var(--text-main);font-weight:600;width:100%;" onchange="renameRecording('${rec.id}', this.value)">
	        <div style="font-size:11px;color:var(--text-soft);">${formatRecordingTime(rec.duration)} | ${rec.frames.length} frames | ${new Date(rec.created).toLocaleDateString()}</div>
	      </div>
	      <button onclick="playSelectedRecording('${rec.id}')" style="padding:4px 8px;background:var(--btn-bg);border:1px solid var(--edge-main);border-radius:4px;cursor:pointer;">▶</button>
	    </div>
	  `).join('');
	}

	function selectRecording(id) {
	  RECORDING_STATE.currentRecording = RECORDING_STATE.recordings.find(r => r.id === id) || null;
	  renderRecordingsList();
	}

	function playSelectedRecording(id) {
	  selectRecording(id);
	  document.getElementById('recordings-modal').classList.remove('active');
	  playRecording();
	}

	function renameRecording(id, newName) {
	  const rec = RECORDING_STATE.recordings.find(r => r.id === id);
	  if (rec) rec.name = newName;
	}

	async function deleteSelectedRecording() {
	  if (!RECORDING_STATE.currentRecording) {
	    showAlert(t("dialogs.selectRecordingToDelete"));
	    return;
	  }
	  if (!await showConfirm(t("dialogs.deleteRecording", { name: RECORDING_STATE.currentRecording.name }))) return;
	  RECORDING_STATE.recordings = RECORDING_STATE.recordings.filter(r => r.id !== RECORDING_STATE.currentRecording.id);
	  RECORDING_STATE.currentRecording = RECORDING_STATE.recordings[0] || null;
	  renderRecordingsList();
	  logAuditEvent('recording', 'Deleted recording');
	}

	function exportRecordingJSON() {
	  if (!RECORDING_STATE.currentRecording) {
	    showAlert(t("dialogs.selectRecordingToExport"));
	    return;
	  }
	  const json = JSON.stringify(RECORDING_STATE.currentRecording, null, 2);
	  const blob = new Blob([json], { type: 'application/json' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = (RECORDING_STATE.currentRecording.name || 'recording').replace(/[^a-z0-9]/gi, '-') + '.json';
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported recording: ${RECORDING_STATE.currentRecording.name}`);
	}

	function importRecordingJSON(input) {
	  const file = input.files[0];
	  if (!file) return;
	  const reader = new FileReader();
	  reader.onload = (e) => {
	    try {
	      const rec = JSON.parse(e.target.result);
	      if (!rec.frames || !Array.isArray(rec.frames)) {
	        throw new Error('Invalid recording format');
	      }
	      rec.id = 'rec-' + Date.now();
	      rec.name = rec.name || 'Imported Recording';
	      RECORDING_STATE.recordings.push(rec);
	      RECORDING_STATE.currentRecording = rec;
	      renderRecordingsList();
	      logAuditEvent('import', `Imported recording: ${rec.name}`);
	      showAlert(t("dialogs.recordingImported", { name: rec.name }));
	    } catch (err) {
	      showAlert(t("dialogs.importRecordingFailed", { error: err.message }));
	    }
	  };
	  reader.readAsText(file);
	  input.value = '';
	}

	function updateCanvasStyleOptions() {
	  const mode = PAGE_STATE.mappingMode || 'network';
	  const canvasStyleRow = document.getElementById('canvas-style-row');
	  const canvasStyleSelect = document.getElementById('canvas-style-select');
	  const canvasGridCheckbox = document.getElementById('canvas-grid-enabled');

	  if (mode === 'mindmap') {
	    if (canvasStyleRow) canvasStyleRow.style.display = 'none';
	    PAGE_STATE.canvasTemplate = 'none';
	    PAGE_STATE.canvasGridEnabled = false;
	    if (canvasGridCheckbox) canvasGridCheckbox.checked = false;
	  } else if (mode === 'floorplan') {
	    if (canvasStyleRow) canvasStyleRow.style.display = 'none';
	    PAGE_STATE.canvasTemplate = 'blueprint';
	    PAGE_STATE.canvasGridEnabled = true;
	    if (canvasGridCheckbox) canvasGridCheckbox.checked = true;
	  } else {
	    if (canvasStyleRow) canvasStyleRow.style.display = 'contents';
	    const options = CANVAS_OPTIONS[mode] || CANVAS_OPTIONS.network;
	    if (canvasStyleSelect && options.length > 0) {
	      canvasStyleSelect.innerHTML = options.map(o =>
	        `<option value="${o.value}">${o.label}</option>`
	      ).join('');
	      const validValues = options.map(o => o.value);
	      if (!validValues.includes(PAGE_STATE.canvasTemplate)) {
	        PAGE_STATE.canvasTemplate = options[0]?.value || 'grid';
	      }
	      canvasStyleSelect.value = PAGE_STATE.canvasTemplate;
	      PAGE_STATE.canvasGridEnabled = PAGE_STATE.canvasTemplate !== 'none';
	      if (canvasGridCheckbox) canvasGridCheckbox.checked = PAGE_STATE.canvasGridEnabled;
	    }
	  }
	  forgeTheTopology();
	}

	function updateShapeCategoryOptions() {
	  const mode = PAGE_STATE.mappingMode || 'network';
	  const defaultCat = MODE_DEFAULT_CATEGORIES[mode] || 'network';
	  const catSelect = document.getElementById('shape-category-select');
	  if (catSelect && !catSelect.value) {
	    catSelect.value = defaultCat;
	  }
	  populateShapeSelect();
	}

	function populateShapeSelect(currentValue) {
	  const catSelect = document.getElementById('shape-category-select');
	  const shapeSelect = document.getElementById('shape-select');
	  if (!catSelect || !shapeSelect) return;

	  const category = catSelect.value || 'basic';
	  const shapes = SHAPE_CATEGORIES[category] || SHAPE_CATEGORIES.basic;

	  shapeSelect.innerHTML = shapes.map(s =>
	    `<option value="${s.value}">${s.label}</option>`
	  ).join('');

	  if (currentValue) {
	    const exists = shapes.some(s => s.value === currentValue);
	    if (exists) {
	      shapeSelect.value = currentValue;
	    }
	  }
	}

	document.getElementById('mapping-mode-select')?.addEventListener('change', (e) => {
	  PAGE_STATE.mappingMode = e.target.value;
	  updateCanvasStyleOptions();
	  applyMappingModeLabels();
	  updateLayerLabels();
	  const catSelect = document.getElementById('shape-category-select');
	  if (catSelect) {
	    catSelect.value = MODE_DEFAULT_CATEGORIES[e.target.value] || 'network';
	    populateShapeSelect();
	  }
	  wieldThePower();
	  displayTabs();
	});

	document.getElementById('canvas-style-select')?.addEventListener('change', (e) => {
	  PAGE_STATE.canvasTemplate = e.target.value;
	  PAGE_STATE.canvasGridEnabled = e.target.value !== 'none';
	  forgeTheTopology();
	});

	document.getElementById('shape-category-select')?.addEventListener('change', (e) => {
	  populateShapeSelect();
	});

	document.getElementById('shape-select')?.addEventListener('change', (e) => {
	  const shape = e.target.value || 'circle';
	  if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
	  pushUndo('change shape');
	  NODE_DATA[currentNodeId].shape = shape;
	  const fovSection = document.getElementById("fov-section");
	  if (fovSection) {
	    if (typeof hasCoverageZone === 'function' && hasCoverageZone(shape)) {
	      const defaults = getCoverageDefaults(shape);
	      fovSection.style.display = "block";
	      document.getElementById("fov-angle").value = defaults.angle;
	      document.getElementById("fov-angle-value").textContent = defaults.angle + "°";
	      document.getElementById("fov-distance").value = defaults.distance;
	      document.getElementById("fov-distance-value").textContent = defaults.distance;
	      document.getElementById("fov-animation-type").value = defaults.animationType;
	    } else {
	      fovSection.style.display = "none";
	    }
	  }
	  const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
	  if (nodeGroup) {
	    const oldShape = nodeGroup.querySelector(".node-circle");
	    if (oldShape) oldShape.remove();
	    const size = savedSizes[currentNodeId] || getDefaultSize();
	    const newShape = createNodeShape(currentNodeId, size);
	    nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
	  }
	});

	function applyMappingModeLabels() {
	  const mode = PAGE_STATE.mappingMode || 'network';
	  const labels = LANG.modes[mode] || LANG.modes.network;

	  const addNodeBtn = document.getElementById('add-node-btn');
	  const addRackBtn = document.getElementById('add-rack-btn');
	  if (addNodeBtn) addNodeBtn.textContent = '+ ' + labels.node;
	  if (addRackBtn) {
	    if (!labels.rack) {
	      addRackBtn.style.display = 'none';
	    } else {
	      addRackBtn.style.display = '';
	      addRackBtn.textContent = '+ ' + labels.rack;
	    }
	  }

	  const addNodeTitle = document.getElementById('add-node-title');
	  const addRackTitle = document.getElementById('add-rack-title');
	  if (addNodeTitle) addNodeTitle.textContent = t('ui.modals.addNode');
	  if (addRackTitle) addRackTitle.textContent = t('ui.modals.addRack');

	  const addNodeSave = document.getElementById('add-node-save');
	  const addRackSave = document.getElementById('add-rack-save');
	  if (addNodeSave) addNodeSave.textContent = t('ui.buttons.addNode');
	  if (addRackSave) addRackSave.textContent = t('ui.buttons.addRack');

	  const nodeIpLabel = document.getElementById('new-node-ip-label');
	  const nodeTagsLabel = document.getElementById('new-node-tags-label');
	  const nodeIpInput = document.getElementById('new-node-ip');
	  const nodeTagsInput = document.getElementById('new-node-tags');
	  if (nodeIpLabel && labels.subtitle) nodeIpLabel.textContent = labels.subtitle;
	  if (nodeTagsLabel && labels.tags) nodeTagsLabel.textContent = labels.tags + ' (comma separated)';
	  if (nodeIpInput && labels.subtitlePlaceholder) nodeIpInput.placeholder = labels.subtitlePlaceholder;
	  if (nodeTagsInput && labels.tagsPlaceholder) nodeTagsInput.placeholder = labels.tagsPlaceholder;

	  const rackNameLabel = document.getElementById('new-rack-name-label');
	  const rackIpLabel = document.getElementById('new-rack-ip-label');
	  const rackTagsLabel = document.getElementById('new-rack-tags-label');
	  const rackIpInput = document.getElementById('new-rack-ip');
	  const rackTagsInput = document.getElementById('new-rack-tags');
	  if (rackNameLabel && labels.rack) rackNameLabel.textContent = labels.rack + ' Name';
	  if (rackIpLabel && labels.rackSubtitle) rackIpLabel.textContent = labels.rackSubtitle;
	  if (rackTagsLabel && labels.rackTags) rackTagsLabel.textContent = labels.rackTags + ' (comma separated)';
	  if (rackIpInput && labels.rackSubtitlePlaceholder) rackIpInput.placeholder = labels.rackSubtitlePlaceholder;
	  if (rackTagsInput && labels.rackTagsPlaceholder) rackTagsInput.placeholder = labels.rackTagsPlaceholder;

	  const nodeCatSelect = document.getElementById('new-node-category');
	  const rackCatSelect = document.getElementById('new-rack-category');
	  const defaultCat = MODE_DEFAULT_CATEGORIES[mode] || 'network';
	  if (nodeCatSelect) {
	    nodeCatSelect.value = defaultCat;
	    if (typeof populateModalShapeSelect === 'function') populateModalShapeSelect('new-node-category', 'new-node-shape');
	  }
	  if (rackCatSelect) {
	    rackCatSelect.value = defaultCat;
	    if (typeof populateModalShapeSelect === 'function') populateModalShapeSelect('new-rack-category', 'new-rack-shape');
	  }

	  const isNetworkMode = mode === 'network';
	  const macRow = document.getElementById('mac-row');
	  const rackUnitRow = document.getElementById('rack-unit-row');
	  const assignedRackLabel = document.getElementById('assigned-rack-label');
	  if (macRow) macRow.style.display = isNetworkMode ? 'flex' : 'none';
	  if (rackUnitRow) rackUnitRow.style.display = isNetworkMode ? 'flex' : 'none';
	  if (assignedRackLabel && labels.rack) assignedRackLabel.textContent = 'Assigned ' + labels.rack + ':';
	}

	setTimeout(() => {
	  const catSelect = document.getElementById('shape-category-select');
	  if (catSelect) {
	    catSelect.value = MODE_DEFAULT_CATEGORIES[PAGE_STATE.mappingMode || 'network'] || 'network';
	    populateShapeSelect();
	  }
	  updateCanvasStyleOptions();
	}, 100);

	function startVideoRecording() {
	  if (RECORDING_STATE.isVideoRecording) return;

	  const svg = document.getElementById('map');
	  const svgRect = svg.getBoundingClientRect();
	  const width = Math.min(1280, svgRect.width);
	  const height = Math.round(width * svgRect.height / svgRect.width);

	  const canvas = document.createElement('canvas');
	  canvas.width = width;
	  canvas.height = height;
	  const ctx = canvas.getContext('2d');

	  RECORDING_STATE.videoCanvas = canvas;
	  RECORDING_STATE.videoCtx = ctx;
	  RECORDING_STATE.videoChunks = [];

	  const stream = canvas.captureStream(30);
	  const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
	                   MediaRecorder.isTypeSupported('video/webm;codecs=vp8') ? 'video/webm;codecs=vp8' :
	                   MediaRecorder.isTypeSupported('video/webm') ? 'video/webm' : 'video/mp4';

	  const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 10000000 });

	  recorder.ondataavailable = (e) => {
	    if (e.data.size > 0) {
	      RECORDING_STATE.videoChunks.push(e.data);
	    }
	  };

	  recorder.onstop = () => {
	    const blob = new Blob(RECORDING_STATE.videoChunks, { type: mimeType });
	    const url = URL.createObjectURL(blob);
	    const a = document.createElement('a');
	    a.href = url;
	    const ext = mimeType.includes('webm') ? 'webm' : 'mp4';
	    a.download = `topology-recording-${Date.now()}.${ext}`;
	    a.click();
	    URL.revokeObjectURL(url);
	    logAuditEvent('export', `Exported video recording`);
	  };

	  RECORDING_STATE.videoRecorder = recorder;
	  RECORDING_STATE.isVideoRecording = true;
	  recorder.start(100);

	  function renderFrame() {
	    if (!RECORDING_STATE.isVideoRecording) return;

	    const svg = document.getElementById('map');
	    const svgData = new XMLSerializer().serializeToString(svg);
	    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
	    const url = URL.createObjectURL(svgBlob);

	    const img = new Image();
	    img.onload = () => {
	      ctx.fillStyle = PAGE_STATE.background || '#050608';
	      ctx.fillRect(0, 0, width, height);
	      ctx.drawImage(img, 0, 0, width, height);
	      URL.revokeObjectURL(url);
	      if (RECORDING_STATE.isVideoRecording) {
	        RECORDING_STATE.videoAnimFrame = requestAnimationFrame(renderFrame);
	      }
	    };
	    img.onerror = () => {
	      URL.revokeObjectURL(url);
	      if (RECORDING_STATE.isVideoRecording) {
	        RECORDING_STATE.videoAnimFrame = requestAnimationFrame(renderFrame);
	      }
	    };
	    img.src = url;
	  }

	  renderFrame();

	  document.getElementById('record-btn').style.background = '#f56565';
	  document.getElementById('record-btn').style.color = 'white';
	  document.getElementById('stop-btn').style.display = 'inline-block';
	  logAuditEvent('recording', 'Started video recording');
	}

	function stopVideoRecording() {
	  if (!RECORDING_STATE.isVideoRecording) return;

	  RECORDING_STATE.isVideoRecording = false;
	  if (RECORDING_STATE.videoAnimFrame) {
	    cancelAnimationFrame(RECORDING_STATE.videoAnimFrame);
	  }
	  if (RECORDING_STATE.videoRecorder && RECORDING_STATE.videoRecorder.state !== 'inactive') {
	    RECORDING_STATE.videoRecorder.stop();
	  }

	  document.getElementById('record-btn').style.background = 'var(--btn-bg)';
	  document.getElementById('record-btn').style.color = '#f56565';
	  document.getElementById('stop-btn').style.display = 'none';
	  logAuditEvent('recording', 'Stopped video recording');
	}

	async function exportRecordingVideo() {
	  if (!RECORDING_STATE.currentRecording || RECORDING_STATE.currentRecording.frames.length < 2) {
	    showAlert(t("dialogs.selectRecordingForVideo"));
	    return;
	  }

	  const rec = RECORDING_STATE.currentRecording;
	  const frames = rec.frames;
	  const svg = document.getElementById('map');
	  const viewBox = svg.getAttribute('viewBox').split(' ').map(Number);
	  const width = 1920;
	  const height = Math.round(width * viewBox[3] / viewBox[2]);

	  const canvas = document.createElement('canvas');
	  canvas.width = width;
	  canvas.height = height;
	  const ctx = canvas.getContext('2d');

	  const progressDiv = document.createElement('div');
	  progressDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--panel);padding:20px 40px;border-radius:8px;border:1px solid var(--edge-main);z-index:99999999;text-align:center;';
	  progressDiv.innerHTML = '<div style="color:var(--text-main);margin-bottom:10px;">' + t("emptyStates.generatingVideo") + '</div><div id="video-progress" style="color:var(--accent);margin-bottom:8px;">0%</div><div style="color:var(--text-soft);font-size:12px;">' + t("messages.pleaseWait") + '</div>';
	  document.body.appendChild(progressDiv);

	  const stream = canvas.captureStream(30);
	  const mimeType = MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' :
	                   MediaRecorder.isTypeSupported('video/webm') ? 'video/webm' : 'video/mp4';
	  const chunks = [];
	  const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 10000000 });

	  recorder.ondataavailable = (e) => {
	    if (e.data.size > 0) chunks.push(e.data);
	  };

	  const recorderReady = new Promise(resolve => {
	    recorder.onstop = resolve;
	  });

	  recorder.start(100);

	  const originalPositions = JSON.parse(JSON.stringify(savedPositions));
	  const originalWaypoints = {};
	  EDGE_DATA.list.forEach(edge => {
	    originalWaypoints[edge.id] = edge.waypoints ? edge.waypoints.map(wp => ({ x: wp.x, y: wp.y })) : [];
	  });

	  for (let i = 0; i < frames.length; i++) {
	    const frame = frames[i];
	    Object.keys(frame.positions).forEach(id => {
	      if (savedPositions[id]) {
	        savedPositions[id].x = frame.positions[id].x;
	        savedPositions[id].y = frame.positions[id].y;
	      }
	    });
	    if (frame.waypoints) {
	      EDGE_DATA.list.forEach(edge => {
	        if (frame.waypoints[edge.id]) {
	          edge.waypoints = frame.waypoints[edge.id].map(wp => ({ x: wp.x, y: wp.y }));
	        } else {
	          edge.waypoints = [];
	        }
	      });
	    }
	    forgeTheTopology();

	    const svgData = new XMLSerializer().serializeToString(svg);
	    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
	    const url = URL.createObjectURL(svgBlob);

	    await new Promise((resolve) => {
	      const img = new Image();
	      img.onload = () => {
	        ctx.fillStyle = PAGE_STATE.panel || '#0b0e13';
	        ctx.fillRect(0, 0, width, height);
	        ctx.drawImage(img, 0, 0, width, height);
	        URL.revokeObjectURL(url);
	        document.getElementById('video-progress').textContent = Math.round((i / frames.length) * 100) + '%';
	        resolve();
	      };
	      img.onerror = () => {
	        URL.revokeObjectURL(url);
	        resolve();
	      };
	      img.src = url;
	    });

	    const frameDelay = i < frames.length - 1 ? (frames[i + 1].time - frame.time) : 100;
	    await new Promise(r => setTimeout(r, Math.max(33, frameDelay / 2)));
	  }

	  recorder.stop();
	  await recorderReady;

	  Object.keys(originalPositions).forEach(id => {
	    if (savedPositions[id]) {
	      savedPositions[id].x = originalPositions[id].x;
	      savedPositions[id].y = originalPositions[id].y;
	    }
	  });
	  EDGE_DATA.list.forEach(edge => {
	    if (originalWaypoints[edge.id]) {
	      edge.waypoints = originalWaypoints[edge.id].map(wp => ({ x: wp.x, y: wp.y }));
	    }
	  });
	  forgeTheTopology();

	  const blob = new Blob(chunks, { type: mimeType });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  const ext = mimeType.includes('webm') ? 'webm' : 'mp4';
	  a.download = (rec.name || 'recording').replace(/[^a-z0-9]/gi, '-') + '.' + ext;
	  a.click();
	  URL.revokeObjectURL(url);

	  progressDiv.remove();
	  logAuditEvent('export', `Exported video: ${rec.name}`);
	}

	function exportRecordingGIF() {
	  exportRecordingVideo();
	}

	document.getElementById('record-btn')?.addEventListener('click', () => {
	  const expanded = document.getElementById('recording-expanded');
	  if (expanded.style.display === 'none') {
	    expanded.style.display = 'inline-flex';
	  } else {
	    startRecording();
	  }
	});
	document.getElementById('stop-btn')?.addEventListener('click', stopRecording);
	document.getElementById('play-btn')?.addEventListener('click', () => {
	  const expanded = document.getElementById('recording-expanded');
	  if (expanded.style.display === 'none') {
	    expanded.style.display = 'inline-flex';
	  } else {
	    playRecording();
	  }
	});
	document.getElementById('pause-btn')?.addEventListener('click', pauseRecording);
	document.getElementById('playback-scrubber')?.addEventListener('input', (e) => {
	  seekRecording(parseFloat(e.target.value));
	});
	document.getElementById('playback-speed')?.addEventListener('change', (e) => {
	  RECORDING_STATE.playbackSpeed = parseFloat(e.target.value);
	});
	document.getElementById('loop-playback')?.addEventListener('change', (e) => {
	  RECORDING_STATE.loopPlayback = e.target.checked;
	});
	document.getElementById('recordings-btn')?.addEventListener('click', () => {
	  renderRecordingsList();
	  document.getElementById('recordings-modal').classList.add('active');
	});
	document.getElementById('recordings-modal-close')?.addEventListener('click', () => {
	  document.getElementById('recordings-modal').classList.remove('active');
	});
	document.getElementById('recordings-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'recordings-modal') e.target.classList.remove('active');
	});

	function populateModalShapeSelect(categorySelectId, shapeSelectId) {
	  const catSelect = document.getElementById(categorySelectId);
	  const shapeSelect = document.getElementById(shapeSelectId);
	  if (!catSelect || !shapeSelect) return;
	  const category = catSelect.value || 'network';
	  const shapes = SHAPE_CATEGORIES[category] || SHAPE_CATEGORIES.network;
	  shapeSelect.innerHTML = shapes.map(s => `<option value="${s.value}">${s.label}</option>`).join('');
	}

	document.getElementById('new-node-category')?.addEventListener('change', () => {
	  populateModalShapeSelect('new-node-category', 'new-node-shape');
	});
	document.getElementById('new-rack-category')?.addEventListener('change', () => {
	  populateModalShapeSelect('new-rack-category', 'new-rack-shape');
	});

	populateModalShapeSelect('new-node-category', 'new-node-shape');
	populateModalShapeSelect('new-rack-category', 'new-rack-shape');
    </script>
  </body>
</html>