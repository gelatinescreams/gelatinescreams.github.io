<!DOCTYPE html> 
 <html lang="en" style="--panel: #0b0e13; --panel-alt: #10141b; --accent: #4fd1c5; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 103px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #0f172a; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 41px; --node-sub-size: 27px; --node-font: monospace; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }

.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

@media print {
  @page {
    size: landscape;
    margin: 0.5cm;
  }
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: visible !important;
  }
  body * {
    visibility: hidden;
  }
  #canvas-viewport,
  #canvas-viewport *,
  #map,
  #map * {
    visibility: visible;
  }
  #canvas-viewport {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    overflow: visible !important;
  }
  #map {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: white !important;
    background-image: none !important;
  }
  #canvas-grid {
    display: none !important;
  }
  main, .topology-panel {
    display: block !important;
    position: static !important;
    overflow: visible !important;
  }

  #map circle[class*="node"],
  #map .node-shape,
  #map .node-group circle,
  #map .node-group rect,
  #map .node-group path,
  #map .node-group polygon {
    fill: white !important;
    stroke: #000 !important;
    stroke-width: 2px !important;
  }

  #map text {
    fill: #000 !important;
    stroke: none !important;
  }
  #map .edge,
  #map polyline,
  #map line:not([class*="grid"]) {
    stroke: #333 !important;
  }
  #map .rect-group rect {
    stroke: #333 !important;
  }
  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
  .draw-toolbar, .topology-toolbar, .legend-container,
  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
    display: none !important;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: none;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: block;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">üîí</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-data-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: none !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trusted Lan</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Secure Lan</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(71, 85, 105); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Main ISP</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Alternate ISP</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(168, 85, 247); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(14, 165, 233); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(34, 197, 94); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(148, 163, 184); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 191, 36); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(56, 189, 248); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(200, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
	  const now = performance.now();
	  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
	  lastMinimapRender = now;
	  
	  const minimapViewport = document.getElementById("minimap-viewport");
	  const minimapSvg = document.getElementById("minimap");
	  if (!minimapViewport || !minimapSvg) return;
	  const vb = getViewBox();
	  minimapViewport.setAttribute("x", vb.x);
	  minimapViewport.setAttribute("y", vb.y);
	  minimapViewport.setAttribute("width", vb.width);
	  minimapViewport.setAttribute("height", vb.height);
	  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
	  const frag = document.createDocumentFragment();
	  EDGE_DATA.list.forEach((edge) => {
	  if (edge.type === "custom") return;
	  const fromNode = NODE_DATA[edge.from];
	  const toNode = NODE_DATA[edge.to];
	  if (!fromNode || !toNode) return;
	  if (currentView.mode === "rack") {
		if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
	  } else {
		if (fromNode.assignedRack || toNode.assignedRack) return;
	  }
	  const p1 = savedPositions[edge.from];
	  const p2 = savedPositions[edge.to];
	  if (!p1 || !p2) return;
	  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	   line.setAttribute("x1", p1.x);
	   line.setAttribute("y1", p1.y);
	   line.setAttribute("x2", p2.x);
	   line.setAttribute("y2", p2.y);
	   line.classList.add("minimap-edge");
	   frag.appendChild(line);
	  });
	  Object.entries(savedPositions).forEach(([id, pos]) => {
	  const node = NODE_DATA[id];
	  if (!node) return;
	  if (currentView.mode === "rack") {
		if (node.assignedRack !== currentView.rackId) return;
	  } else {
		if (node.assignedRack) return;
	  }
	  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	   circle.setAttribute("cx", pos.x);
	   circle.setAttribute("cy", pos.y);
	   circle.setAttribute("r", 40);
	   circle.classList.add("minimap-node");
	  frag.appendChild(circle);
	   });
	   minimapSvg.insertBefore(frag, minimapViewport);	
	  }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack") {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   let pendingUndoState = null;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.dropdown').forEach(dropdown => {
    const btn = dropdown.querySelector('.dropdown-btn');
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!btn || !menu) return;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.dropdown-menu.open').forEach(m => {
        if (m !== menu) m.classList.remove('open');
      });
      menu.classList.toggle('open');
    });
  });
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
    }
  });
  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
      }, 100);
    });
  });
  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
function printTopology() {
  const svg = document.getElementById('map');
  if (!svg) { window.print(); return; }
  const originalViewBox = svg.getAttribute('viewBox');
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  let hasContent = false;
  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode !== 'rack' && node.assignedRack) return;
    const size = savedSizes[id] || 50;
    hasContent = true;
    minX = Math.min(minX, pos.x - size);
    minY = Math.min(minY, pos.y - size);
    maxX = Math.max(maxX, pos.x + size);
    maxY = Math.max(maxY, pos.y + size);
  });
  RECT_DATA.list.forEach(rect => {
    hasContent = true;
    minX = Math.min(minX, rect.x);
    minY = Math.min(minY, rect.y);
    maxX = Math.max(maxX, rect.x + rect.width);
    maxY = Math.max(maxY, rect.y + rect.height);
  });
  TEXT_DATA.list.forEach(text => {
    hasContent = true;
    minX = Math.min(minX, text.x - 100);
    minY = Math.min(minY, text.y - 50);
    maxX = Math.max(maxX, text.x + 300);
    maxY = Math.max(maxY, text.y + 50);
  });
  EDGE_DATA.list.forEach(edge => {
    if (edge.points && edge.points.length > 0) {
      edge.points.forEach(p => {
        hasContent = true;
        minX = Math.min(minX, p.x - 10);
        minY = Math.min(minY, p.y - 10);
        maxX = Math.max(maxX, p.x + 10);
        maxY = Math.max(maxY, p.y + 10);
      });
    }
  });
  if (!hasContent) { window.print(); return; }
  const padding = 100;
  minX -= padding; minY -= padding; maxX += padding; maxY += padding;
  const width = maxX - minX;
  const height = maxY - minY;
  const grid = document.getElementById('canvas-grid');
  const gridDisplay = grid ? grid.style.display : '';
  if (grid) grid.style.display = 'none';
  svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  const originalWidth = svg.style.width;
  const originalHeight = svg.style.height;
  svg.style.width = '100%';
  svg.style.height = '100%';
  setTimeout(() => {
    window.print();
    setTimeout(() => {
      svg.setAttribute('viewBox', originalViewBox);
      svg.style.width = originalWidth;
      svg.style.height = originalHeight;
      if (grid) grid.style.display = gridDisplay;
    }, 500);
  }, 100);
}
function exportJSONFile() {
  const data = captureTheQuickening();
  const jsonStr = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
  a.download = `${safeTitle}.json`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent("export", `Exported JSON: ${a.download}`);
}
function exportCSV() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
  csv += `# Exported from The One File on ${timestamp}\n`;
  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
  csv += headers.join(',') + '\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
    const row = [
      csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
      node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
      csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
      node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
      node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
      size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
    ];
    csv += row.join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}-nodes.csv`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported CSV: ${a.download}`);
}
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const str = String(val);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}
document.getElementById('import-csv-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    const lines = text.split(/\r?\n/);
    let config = null;
    let dataLines = [];
    let headers = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
        try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
        continue;
      }
      if (trimmed.startsWith('#')) continue;
      if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
      dataLines.push(trimmed);
    }
    if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
    const nameIdx = headers.indexOf('name');
    if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
    const nodes = dataLines.map(line => {
      const values = parseCSVLine(line);
      const node = {};
      headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
      return node;
    });
    const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add';
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `‚Ä¢ ${nodes.length} nodes in CSV data\n` +
        `‚Ä¢ ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `‚Ä¢ ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
    if (hasConfig) {
      Object.assign(PAGE_STATE, config.pageState);
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
      if (config.legend) Object.assign(EDGE_LEGEND, config.legend);
      wieldThePower();
    }
    let gridX = 200, gridY = 200;
    const spacing = 150;
    const perRow = Math.ceil(Math.sqrt(nodes.length));
    let gridIndex = 0;
    nodes.forEach((n) => {
      let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!baseId) baseId = 'node';
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
      NODE_DATA[nodeId] = {
        name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
        tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
        notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
        layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
        uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
        isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
      };
      const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      if (hasPosition) {
        savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
      } else {
        const row = Math.floor(gridIndex / perRow);
        const col = gridIndex % perRow;
        savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
        gridIndex++;
      }
      if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
      if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
    });
    forgeTheTopology();
    updateViewBox();
    logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
    alert(`Successfully imported ${nodes.length} nodes`);
  } catch (err) {
    console.error('CSV import error:', err);
    alert('Failed to import CSV: ' + err.message);
  }
});
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
    else { current += char; }
  }
  result.push(current);
  return result;
}

function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
  md += `## Legend\n\n`;
  if (Object.keys(EDGE_LEGEND).length > 0) {
    Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
  } else { md += `_No legend entries_\n`; }
  md += '\n## Nodes\n\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] || null;
    md += `### ${id}\n`;
    md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
    md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
    md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
    md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
    md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
    md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
    md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
    if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
    if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
    md += '\n';
  });
  md += `## Connections\n\n`;
  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
    EDGE_DATA.list.forEach(edge => {
      const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
      const toPort = edge.toPort ? ` (${edge.toPort})` : '';
      md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
      md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
      md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
      md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
      md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
      if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
      if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No connections_\n\n`; }
  md += `## Zones\n\n`;
  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
    RECT_DATA.list.forEach(rect => {
      md += `### ${rect.id}\n`;
      md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
      md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
      md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
      if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No zones_\n\n`; }
  md += `## Text Labels\n\n`;
  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
    TEXT_DATA.list.forEach(text => {
      md += `### ${text.id}\n`;
      md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
      md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
      md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
      md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
      md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
      md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
    });
  } else { md += `_No text labels_\n\n`; }
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.md`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported Markdown: ${a.download}`);
}

document.getElementById('import-markdown-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
      } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    edges.forEach(edge => {
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
  } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
  }
});

document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-export-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-import-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
});
document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
});	  
    </script>
</body></html>