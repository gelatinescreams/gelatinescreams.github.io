<!DOCTYPE html> 
 <html lang="en" style="--panel: #0b0e13; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #4fd1c5; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 103px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #0f172a; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 41px; --node-sub-size: 27px; --node-font: monospace; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File Corporate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }
	  #map circle[class*="node"],
	  #map .node-shape,
	  #map .node-group circle,
	  #map .node-group rect,
	  #map .node-group path,
	  #map .node-group polygon {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }
	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

  #map .rect-group rect {
    stroke: #333 !important;
  }
	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90°)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item active" onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item " onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File Corporate</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">🔒</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-json-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(16, 185, 129); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Trusted Lan</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(245, 158, 11); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Secure Lan</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(239, 68, 68); cursor: pointer;"></span><span class="legend-label" contenteditable="true">DMZ</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(71, 85, 105); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Main ISP</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(59, 130, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">Alternate ISP</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(139, 92, 246); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(6, 182, 212); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(168, 85, 247); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(14, 165, 233); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(34, 197, 94); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(148, 163, 184); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 191, 36); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(56, 189, 248); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(200, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="162.25942846156744 -131.59941950312611 4069.861183597212 3052.395887697909" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="162.25942846156744" y="-131.59941950312611" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90°)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
const frag = document.createDocumentFragment();

EDGE_DATA.list.forEach((edge) => {
  if (edge.type === "custom") return;
  const fromNode = NODE_DATA[edge.from];
  const toNode = NODE_DATA[edge.to];
  if (!fromNode || !toNode) return;
  if (currentView.mode === "rack") {
    if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
  } else {
    if (fromNode.assignedRack || toNode.assignedRack) return;
  }
  const p1 = savedPositions[edge.from];
  const p2 = savedPositions[edge.to];
  if (!p1 || !p2) return;
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", p1.x);
  line.setAttribute("y1", p1.y);
  line.setAttribute("x2", p2.x);
  line.setAttribute("y2", p2.y);
  line.classList.add("minimap-edge");
  frag.appendChild(line);
});

Object.entries(savedPositions).forEach(([id, pos]) => {
  const node = NODE_DATA[id];
  if (!node) return;
  if (currentView.mode === "rack") {
    if (node.assignedRack !== currentView.rackId) return;
  } else {
    if (node.assignedRack) return;
  }
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", pos.x);
  circle.setAttribute("cy", pos.y);
  circle.setAttribute("r", 40);
  circle.classList.add("minimap-node");
  frag.appendChild(circle);
});

minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
 const gridGroup = document.createElementNS(ns, "g");
 gridGroup.id = "canvas-grid";
 const gridSize = PAGE_STATE.canvasGridSize || 50;
 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", x);
  line.setAttribute("y1", CANVAS_PADDING);
  line.setAttribute("x2", x);
  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", CANVAS_PADDING);
  line.setAttribute("y1", y);
  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
  line.setAttribute("y2", y);
  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 svg.appendChild(gridGroup);
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        let pathD;
        if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
	   document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  let pendingUndoState = null;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `• ${nodes.length} nodes in CSV data\n` +
        `• ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `• ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState);
		  if (config.canvasView) {
			canvasState.zoom = config.canvasView.zoom || 1;
			canvasState.panX = config.canvasView.panX || 0;
			canvasState.panY = config.canvasView.panY || 0;
		  }
		  if (config.legend) Object.assign(EDGE_LEGEND, config.legend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		alert(`Successfully imported ${nodes.length} nodes`);
	  } catch (err) {
		console.error('CSV import error:', err);
		alert('Failed to import CSV: ' + err.message);
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    edges.forEach(edge => {
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
     } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});
    </script>
  
</body></html>