<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }

.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

@media print {
  @page {
    size: landscape;
    margin: 0.5cm;
  }
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: visible !important;
  }
  body * {
    visibility: hidden;
  }
  #canvas-viewport,
  #canvas-viewport *,
  #map,
  #map * {
    visibility: visible;
  }
  #canvas-viewport {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    overflow: visible !important;
  }
  #map {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: white !important;
    background-image: none !important;
  }
  #canvas-grid {
    display: none !important;
  }
  main, .topology-panel {
    display: block !important;
    position: static !important;
    overflow: visible !important;
  }

  #map circle[class*="node"],
  #map .node-shape,
  #map .node-group circle,
  #map .node-group rect,
  #map .node-group path,
  #map .node-group polygon {
    fill: white !important;
    stroke: #000 !important;
    stroke-width: 2px !important;
  }

  #map text {
    fill: #000 !important;
    stroke: none !important;
  }
  #map .edge,
  #map polyline,
  #map line:not([class*="grid"]) {
    stroke: #333 !important;
  }
  #map .rect-group rect {
    stroke: #333 !important;
  }
  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
  .draw-toolbar, .topology-toolbar, .legend-container,
  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
    display: none !important;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: none;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: block;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">üîí</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-data-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
	  const now = performance.now();
	  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
	  lastMinimapRender = now;
	  
	  const minimapViewport = document.getElementById("minimap-viewport");
	  const minimapSvg = document.getElementById("minimap");
	  if (!minimapViewport || !minimapSvg) return;
	  const vb = getViewBox();
	  minimapViewport.setAttribute("x", vb.x);
	  minimapViewport.setAttribute("y", vb.y);
	  minimapViewport.setAttribute("width", vb.width);
	  minimapViewport.setAttribute("height", vb.height);
	  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
	  const frag = document.createDocumentFragment();
	  EDGE_DATA.list.forEach((edge) => {
	  if (edge.type === "custom") return;
	  const fromNode = NODE_DATA[edge.from];
	  const toNode = NODE_DATA[edge.to];
	  if (!fromNode || !toNode) return;
	  if (currentView.mode === "rack") {
		if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
	  } else {
		if (fromNode.assignedRack || toNode.assignedRack) return;
	  }
	  const p1 = savedPositions[edge.from];
	  const p2 = savedPositions[edge.to];
	  if (!p1 || !p2) return;
	  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	   line.setAttribute("x1", p1.x);
	   line.setAttribute("y1", p1.y);
	   line.setAttribute("x2", p2.x);
	   line.setAttribute("y2", p2.y);
	   line.classList.add("minimap-edge");
	   frag.appendChild(line);
	  });
	  Object.entries(savedPositions).forEach(([id, pos]) => {
	  const node = NODE_DATA[id];
	  if (!node) return;
	  if (currentView.mode === "rack") {
		if (node.assignedRack !== currentView.rackId) return;
	  } else {
		if (node.assignedRack) return;
	  }
	  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	   circle.setAttribute("cx", pos.x);
	   circle.setAttribute("cy", pos.y);
	   circle.setAttribute("r", 40);
	   circle.classList.add("minimap-node");
	  frag.appendChild(circle);
	   });
	   minimapSvg.insertBefore(frag, minimapViewport);	
	  }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack") {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   let pendingUndoState = null;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.dropdown').forEach(dropdown => {
    const btn = dropdown.querySelector('.dropdown-btn');
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!btn || !menu) return;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.dropdown-menu.open').forEach(m => {
        if (m !== menu) m.classList.remove('open');
      });
      menu.classList.toggle('open');
    });
  });
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
    }
  });
  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
      }, 100);
    });
  });
  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
function printTopology() {
  const svg = document.getElementById('map');
  if (!svg) { window.print(); return; }
  const originalViewBox = svg.getAttribute('viewBox');
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  let hasContent = false;
  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode !== 'rack' && node.assignedRack) return;
    const size = savedSizes[id] || 50;
    hasContent = true;
    minX = Math.min(minX, pos.x - size);
    minY = Math.min(minY, pos.y - size);
    maxX = Math.max(maxX, pos.x + size);
    maxY = Math.max(maxY, pos.y + size);
  });
  RECT_DATA.list.forEach(rect => {
    hasContent = true;
    minX = Math.min(minX, rect.x);
    minY = Math.min(minY, rect.y);
    maxX = Math.max(maxX, rect.x + rect.width);
    maxY = Math.max(maxY, rect.y + rect.height);
  });
  TEXT_DATA.list.forEach(text => {
    hasContent = true;
    minX = Math.min(minX, text.x - 100);
    minY = Math.min(minY, text.y - 50);
    maxX = Math.max(maxX, text.x + 300);
    maxY = Math.max(maxY, text.y + 50);
  });
  EDGE_DATA.list.forEach(edge => {
    if (edge.points && edge.points.length > 0) {
      edge.points.forEach(p => {
        hasContent = true;
        minX = Math.min(minX, p.x - 10);
        minY = Math.min(minY, p.y - 10);
        maxX = Math.max(maxX, p.x + 10);
        maxY = Math.max(maxY, p.y + 10);
      });
    }
  });
  if (!hasContent) { window.print(); return; }
  const padding = 100;
  minX -= padding; minY -= padding; maxX += padding; maxY += padding;
  const width = maxX - minX;
  const height = maxY - minY;
  const grid = document.getElementById('canvas-grid');
  const gridDisplay = grid ? grid.style.display : '';
  if (grid) grid.style.display = 'none';
  svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  const originalWidth = svg.style.width;
  const originalHeight = svg.style.height;
  svg.style.width = '100%';
  svg.style.height = '100%';
  setTimeout(() => {
    window.print();
    setTimeout(() => {
      svg.setAttribute('viewBox', originalViewBox);
      svg.style.width = originalWidth;
      svg.style.height = originalHeight;
      if (grid) grid.style.display = gridDisplay;
    }, 500);
  }, 100);
}
function exportJSONFile() {
  const data = captureTheQuickening();
  const jsonStr = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
  a.download = `${safeTitle}.json`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent("export", `Exported JSON: ${a.download}`);
}
function exportCSV() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
  csv += `# Exported from The One File on ${timestamp}\n`;
  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
  csv += headers.join(',') + '\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
    const row = [
      csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
      node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
      csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
      node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
      node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
      size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
    ];
    csv += row.join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}-nodes.csv`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported CSV: ${a.download}`);
}
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const str = String(val);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}
document.getElementById('import-csv-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    const lines = text.split(/\r?\n/);
    let config = null;
    let dataLines = [];
    let headers = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
        try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
        continue;
      }
      if (trimmed.startsWith('#')) continue;
      if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
      dataLines.push(trimmed);
    }
    if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
    const nameIdx = headers.indexOf('name');
    if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
    const nodes = dataLines.map(line => {
      const values = parseCSVLine(line);
      const node = {};
      headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
      return node;
    });
    const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add';
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `‚Ä¢ ${nodes.length} nodes in CSV data\n` +
        `‚Ä¢ ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `‚Ä¢ ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
    if (hasConfig) {
      Object.assign(PAGE_STATE, config.pageState);
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
      if (config.legend) Object.assign(EDGE_LEGEND, config.legend);
      wieldThePower();
    }
    let gridX = 200, gridY = 200;
    const spacing = 150;
    const perRow = Math.ceil(Math.sqrt(nodes.length));
    let gridIndex = 0;
    nodes.forEach((n) => {
      let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!baseId) baseId = 'node';
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
      NODE_DATA[nodeId] = {
        name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
        tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
        notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
        layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
        uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
        isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
      };
      const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      if (hasPosition) {
        savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
      } else {
        const row = Math.floor(gridIndex / perRow);
        const col = gridIndex % perRow;
        savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
        gridIndex++;
      }
      if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
      if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
    });
    forgeTheTopology();
    updateViewBox();
    logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
    alert(`Successfully imported ${nodes.length} nodes`);
  } catch (err) {
    console.error('CSV import error:', err);
    alert('Failed to import CSV: ' + err.message);
  }
});
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
    else { current += char; }
  }
  result.push(current);
  return result;
}

function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
  md += `## Legend\n\n`;
  if (Object.keys(EDGE_LEGEND).length > 0) {
    Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
  } else { md += `_No legend entries_\n`; }
  md += '\n## Nodes\n\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] || null;
    md += `### ${id}\n`;
    md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
    md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
    md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
    md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
    md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
    md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
    md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
    if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
    if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
    md += '\n';
  });
  md += `## Connections\n\n`;
  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
    EDGE_DATA.list.forEach(edge => {
      const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
      const toPort = edge.toPort ? ` (${edge.toPort})` : '';
      md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
      md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
      md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
      md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
      md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
      if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
      if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No connections_\n\n`; }
  md += `## Zones\n\n`;
  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
    RECT_DATA.list.forEach(rect => {
      md += `### ${rect.id}\n`;
      md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
      md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
      md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
      if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No zones_\n\n`; }
  md += `## Text Labels\n\n`;
  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
    TEXT_DATA.list.forEach(text => {
      md += `### ${text.id}\n`;
      md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
      md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
      md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
      md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
      md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
      md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
    });
  } else { md += `_No text labels_\n\n`; }
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.md`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported Markdown: ${a.download}`);
}

document.getElementById('import-markdown-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
      } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    edges.forEach(edge => {
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
  } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
  }
});

document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-export-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-import-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
});
document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
});	  
    </script>
</body></html>