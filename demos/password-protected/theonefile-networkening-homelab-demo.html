<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
	  .toggle-switch{position:relative;display:inline-block;min-width:44px !important;height:24px;flex-shrink:0;vertical-align:middle;}
		.toggle-switch input{opacity:0;width:0;height:0;position:absolute;}
		.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#475569;transition:.25s;border-radius:24px;}
		.toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#e2e8f0;transition:.25s;border-radius:50%;}
		.toggle-switch input:checked+.toggle-slider{background:var(--accent);}
		.toggle-switch input:checked+.toggle-slider:before{transform:translateX(20px);}
		.anim-zone-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;}
		.anim-zone-row label{color:var(--text-main);font-size:14px;}
		.anim-zone-section{font-size:11px;color:var(--text-soft);margin:12px 0 6px;text-transform:uppercase;letter-spacing:0.05em;border-bottom:1px solid var(--edge-main);padding-bottom:4px;}
		.anim-zone-header{font-size:12px;color:var(--accent);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.05em;font-weight:600;}
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
	  .fov-group {
        transition: opacity 0.3s ease;
      }
      g[data-node-id]:not(:hover) .fov-group {
        opacity: 0.7;
      }
      g[data-node-id]:hover .fov-group {
        opacity: 1;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 8px;
      fill: none;
      }
      .minimap-wall {
      pointer-events: none;
      }
      .minimap-rect {
      pointer-events: none;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      pointer-events: auto;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
      .style-row {
      display: contents;
      }
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }

.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

@media print {
  @page {
    size: landscape;
    margin: 0.5cm;
  }
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: visible !important;
  }
  body * {
    visibility: hidden;
  }
  #canvas-viewport,
  #canvas-viewport *,
  #map,
  #map * {
    visibility: visible;
  }
  #canvas-viewport {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    overflow: visible !important;
  }
  #map {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: white !important;
    background-image: none !important;
  }
  #canvas-grid {
    display: none !important;
  }
  main, .topology-panel {
    display: block !important;
    position: static !important;
    overflow: visible !important;
  }

  #map .node-hit-area,
  #map .group-indicator,
  #map .lock-indicator,
  #map .ping-indicator,
  #map .fov-group,
  #map .edge-arrow-forward,
  #map .edge-arrow-backward {
    display: none !important;
  }

  #map .node-circle,
  #map .node-shape {
    fill: white !important;
    stroke: #000 !important;
    stroke-width: 2px !important;
  }

  #map .node-circle svg,
  #map .node-circle svg path,
  #map .node-circle svg circle,
  #map .node-circle svg rect,
  #map .node-circle svg polygon {
    fill: #000 !important;
    stroke: none !important;
  }

  #map text {
    fill: #000 !important;
    stroke: none !important;
  }
  #map .edge,
  #map polyline,
  #map line:not([class*="grid"]) {
    stroke: #333 !important;
  }
  #map .rect-group rect {
    stroke: #333 !important;
  }
  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
  .draw-toolbar, .topology-toolbar, .legend-container,
  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
    display: none !important;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                  <option value="defaulted">Default</option>
                  <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
              </div>
            </div>
			<div class="style-row">
			 <label>  
			  <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save Custom Theme</button>
			 </label>
			  <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding: 4px 8px; background: var(--danger); color: rgb(255, 255, 255); border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: block;" disabled="">Delete Custom Theme</button>
			</div>
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
			<div class="style-row">
              <label>Tag(s) Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Tag(s) Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Tag(s) Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="canvas-grid-enabled" checked="">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="rack-grid-enabled" checked="">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Animations &amp; Zones</summary>
          <div class="style-content">
            <div class="style-row"><label>All Animations</label><label class="toggle-switch"><input type="checkbox" id="anim-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Type</div>
            <div class="style-row"><label>Sweep (Pan)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-sweep" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Pulse (Breathe)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-pulse" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Rings (Emanate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-rings" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Spin (Rotate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-spin" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections (Flow)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:12px;color:var(--accent);text-transform:uppercase;letter-spacing:0.05em;font-weight:600;margin-top:16px;padding-top:12px;border-top:1px solid var(--edge-main);">Zone (Animation Cone) Setings</div>
            <div class="style-row"><label>All Zones</label><label class="toggle-switch"><input type="checkbox" id="zone-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
           <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">üîí</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-data-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <span style="border-left: 1px solid var(--edge-main); height: 20px; margin: 0 4px;"></span>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
            <option value="wall">Wall</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-zone-copy" title="Copy zone style">üì° Copy Zone</button>
          <button id="bulk-zone-paste" title="Paste zone style">üì° Paste Zone</button>
          <button id="bulk-zone-toggle" title="Toggle zones on selected">üì° Toggle Zones</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--edge-main);">
            <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em;">Coverage Zones</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
              <button id="bulk-zone-copy-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Copy Zone</span></button>
              <button id="bulk-zone-paste-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Paste Zone</span></button>
              <button id="bulk-zone-toggle-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Toggle Zones</span></button>
            </div>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint" style="cursor: pointer;"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-5.584863670202822 -99.90831573327841 4031.4509771376233 3023.5882328532175" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-5.584863670202822" y="-99.90831573327841" width="4031.4509771376233" height="3023.5882328532175"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">99%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Connection &amp; Zone Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Connection</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="fov-section" style="display: block; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Coverage Zone</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Preset:</label>
                <select id="fov-preset" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                  <option value="">-- Apply Preset --</option>
                  <option value="security-cam">Security Camera</option>
                  <option value="ptz-cam">PTZ Camera</option>
                  <option value="motion-detect">Motion Detector</option>
                  <option value="wifi-strong">WiFi</option>
                  <option value="wifi-extended">WiFi Extender</option>
                  <option value="smoke-alarm">Smoke Alarm</option>
                  <option value="sprinkler-arc">Sprinkler Arc</option>
                </select>
                <button id="fov-save-preset" title="Save as preset" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üíæ</button>
                <button id="fov-copy-style" title="Copy zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üìã</button>
                <button id="fov-paste-style" title="Paste zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üì•</button>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Show Zone:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">360¬∞</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">200</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Inner Radius:</label>
                <input type="range" id="fov-inner-radius" min="0" max="200" value="0" style="flex: 1;">
                <span id="fov-inner-radius-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0¬∞</span>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Fill</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-opacity" min="5" max="80" value="20" style="flex: 1;">
                  <span id="fov-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">20%</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Gradient:</label>
                  <input type="checkbox" id="fov-gradient" style="width: 18px; height: 18px; cursor: pointer;">
                  <span style="color: var(--text-soft); font-size: 12px; margin-left: 8px;">Fade toward edge</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Border</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-border-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Width:</label>
                  <input type="range" id="fov-border-width" min="0" max="10" value="2" style="flex: 1;">
                  <span id="fov-border-width-value" style="min-width: 40px; text-align: right; color: var(--text-main);">2</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Style:</label>
                  <select id="fov-border-style" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-border-opacity" min="0" max="100" value="100" style="flex: 1;">
                  <span id="fov-border-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">100%</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Label</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Text:</label>
                  <input type="text" id="fov-label" placeholder="e.g. Detection Zone" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Position:</label>
                  <select id="fov-label-position" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="center">Center</option>
                    <option value="edge">Edge</option>
                    <option value="outside">Outside</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Size:</label>
                  <input type="range" id="fov-label-size" min="8" max="32" value="14" style="flex: 1;">
                  <span id="fov-label-size-value" style="min-width: 40px; text-align: right; color: var(--text-main);">14px</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Color:</label>
                  <input type="color" id="fov-label-color" value="#ffffff" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Bold:</label>
                  <input type="checkbox" id="fov-label-bold" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Background:</label>
                  <input type="checkbox" id="fov-label-bg" style="width: 18px; height: 18px; cursor: pointer;">
                  <input type="color" id="fov-label-bg-color" value="#000000" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; margin-left: 8px;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset X:</label>
                  <input type="range" id="fov-label-offset-x" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-x-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset Y:</label>
                  <input type="range" id="fov-label-offset-y" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-y-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Animation</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Type:</label>
                  <select id="fov-animation-type" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="sweep">Sweep (Pan)</option>
                    <option value="pulse">Pulse (Breathe)</option>
                    <option value="rings">Rings (Emanate)</option>
                    <option value="spin">Spin (Rotate)</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120¬∞</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED:3e4ZzqusI4Tk2sZwB8tzMyOJHv/92nSDQmPBdzojtzQd1JfaWT5Vs+U0cTKR7NMNHe/XHw6oX6wSkyCm391k4mt9zPesPdkknZDb3ZLo5wDhPaEiwbsWSP/SBJfnqdIqKIySRjAlyeiXVBK8TO4X8N6Io9OxpJwE3MxHMDzl4dUluYSzwd69g37WFerH0CmOyaBLZ4vQ6/Od0w++1vBF8Q81M0VtpSAH0MEmPl0AGh48be3VedvsH7fsdejpR8wlBcQz7BZZawNeKQkIlD7j5k4hKUoZHvPPReRMXM8cAc0CosH9p6RMGDLX/HhCj5Nlfx1o9kEPkCUH6xl0nUjPCc6CgwGNxYiXvIUbAeraOXqjvYa+LnSs4TxkMERNPmaNWrmsUT4UexEMGj0JCXlO3ELMqy2OR/x7IIT6pLJ8I2WM2qytNTjts+oi3AEImKk0rDDggsgPfz2lAKmlc4EJkQGm6801brjNwpHM4Pqlm+XecCTnuOR2jfhbLjNhv6MC51noo3vZ6mIFa8p3ownVtkwG6oQCsbi1xVWqmZkz/X2Zah7Q8TYwmZZGHeaSThBH+iy1eIMgiElwTKl+8G8YZLSleAkvyn7wK9l+1moyDEjvsiIDJ9bgTytJbB/JgYFfez3FjKeLkDD9cqkky+wYeXGRri1nrP2wBVC89rUX0DgO0cZp9EKG55QwfYZ193EILNdqtUKWoorOqR5KRHv0L3PZFQf+LJ73znBxbCoc6yAeX59/C66nFjN6uz5oDIpkQokeQBVR+LNQIlRsuTy/3dqzbtJY+JplwyeqTbsSB0na1p8JeSWppGLuxns2FDEUY0ck8GRkn/QNCH7A20/kV/OSxZyPDtu4O/g/UnyMwNDB9exuBYbJm3sw0YUnZvLblTZGHAA3RWj2XpTlFZywZAnOr+kOLjoDWyYE7tjpexl+CoCQ01Q3zCCifBSuInNNuV457JG8er79plt2bl6zHStJk/ecTwuh8qggCsJiQjBR0dVi6YuGSVIk3QWFoC9oiwuaAyEUGBa0lKZS1oqYODsmndUAthEl5jnUr/rv4Tg3cAVQoY0/4RFD6+qciXU6KqSM5zwwHgHwnsi8l9ro8L6XP0bD1HiIOy51YsjD24GFyhjzpYEEplZ7KErPhv1LyvTZEAwtr6t1wRr09E7Fh2XcU6zYo+03i9QF7k9H/SvXn0y4r/NO2pbu7BRZqu7JP+gN5ZokekSL8ZLyvryS0ieLGSGI8X4N3YjgMXjBAQoeyKpmdFtqfitj6tVhxghJf5D2oiXbWT2CHB75xhGjow0e61/tYZQwNjRIBszETiFqII72obBgj7ZauALYa/BUHihOy5zxIShpDqgI9exsN2CR82Y5z4UGIHXxB3aEnvUZYwIbqmVuyfyR6gNTDjsJLRhALvjKYlmqxA6uB5TYYhNKh7LZpi/42FtdPUqlMV0x8t0dcezvZ4rFzekkzPU65NwWLRSDU5ihR46V8pmy3BJpAhwVrcHfT1NyGLhSXnRtAM0WfDYd+j9m1ojCDcoHXE2TigZ3Oa/dqmzDNnOsfRxIC4BgfUIrGItHhEZRsTr1J+mdpoJ5U/tlC/i9jpCg6Zg5g4a3aqHdJ9oL/KkidbtSUwn6gXY4ibuxqaEY0zhiZU37BccYOJ+4bUOrEOdbROk1AErhmbPZKgdJsa1DLYSzPWDmSfsYPiLiWxsCV88oslzz+xQQtJXsPqqr2h5WEuMCSGhna9ufQKGP5bT45xsYckDM5xEHGeMzHcxEkHj8CEzcno87/3QiacIcA2x0oTqA+zQIQGZw2VCnr1dlkmlKCVUtVHWiJ/AzbdGHSWhVpsUM7kQj2L7pjhB5t2+R/78Hyd3xkoTwNj2vTn3pXvKaWAIJ7qyyJXq/5A13rZZQE4ezSwH1fGdG7a0iyil4I7g/sUXJ3fxkxXGUS7am46FiZ05nGBF/9emLey5mDTgf9r73+2yd6LKpOaw3TlxIs9pPXyhlMUgkjyX1bp3AxV9+GjE8RmfMa591NQWMaO9yFTfDyFHpYUFGMMZcyPonaDX6jVeN8zrUM7r84blWMxN4456+b7G7BgdvfECOIsdfuegwdD6oUbypieDNHyzOk8lNusBWGNkXCCDvmHO61cKE1xthvWdOs2G5N0A7qDTgfCUcwIx0Xv4AUB7T1N97KyuAptLv5yCAPhSTjqQos+wYVulJwRLbGHjBVAPnkAjOBehTofc0CpEWB7zvijvGpn6Ajj6fqLZqmYCrhltKDmLRLLb8jeRLYujyE7u/F0HjlXYLVf/5cRlPPxrjfgIAtRmxzsLWfFDTAl8SYEe7hG4FjR1D4WxqSTouNvOGYjbeHZ2yUEjEUZzOKoO+6Tc3JXJCDVpcaZ21HNGSslJjvB5Ky8C35FO5YC7jg018TBfndgNLhrSymUkgFwK0Y1VS/FVQIObhqwBazP2FJ0x1G9gdKFPEYSxG1GNvfTiyGo2R8c/5Gk729Zic/Pc0VALY95rM5I+EF9kpwFqSsJZYoScqgVsWDM37H+qYw6SREPPnGg71sW4ghnadQVTUth+N8aBYIgCyETqF1O6pJlviq0qLkG6bPHW56K8OZRRIBrNStfK+BBqr5AyVxWyjq10nR0VuLT4MvG4HjfocJPu0hkLBmAYraG8kOLwJDM3XPpVtOZw+iE2OolQLwobNQkDlguQWnqmehyCtz8zUfpooekf0ZI+YBSCZWgRcmwJHpEfslZNEbMZQWNhN2P3oFFbF49VTSXU8M+8fcz1L6i+tYkaJ6HfK2WduZMmUDjyQAq1FBiDIaX4fzBezugVOir9U8CXWM0uYkYk7eWO41Y1wyYY5D7P56XGIU+JFqNFT8UAGbCoCMibP8nB6XCMRLMjQjVmTXmSIhJLUBT15Uyd7G1Q+SyyF4pyH0udBnPGeUbl0LOdDEVIzoaJXhliQ8RlzuThAH5zAsd/WdDv76pf56+cwpkXuytpfF8vSzNQPjun3Q6WF7QJsPSQUfX7KSsL+kdgCQul3pxCFi31hD0cpooD7IBr5G1Je0TZLTWD/dygHBmnkEPNiMQNho4QXLKMhr+Baz8WercEm8mYgXzDHfzeeOk8Ag3HEDTjc1u1DFAtvlEigiaZl/dH28DnizWJEpcOMUjV1Dv9P/e4qUwwAlV0r3iUrQVjMLwthbyJttwV1cW7sALyjEXR7cyTv0mAkBV4l7ub65E/yFW+TjcOarHW99qXDSuIOb18wVau8a4XAzfwQ58ojt73dnd7nVbiVVWU/vJMceeUB6p3QpqtHnO1ohTeDIh0aXRDRMTh1VFRWZgTw7sL268bKCiXXIeMv37Vhcw8IKhLaUDiGowytu7hF5kTdsIeEYyH+AwgOdYqR9PUnztGSIZwHjGO3uexiHcX1nBPyvroYrqFi+wWY+GWHkisL5J0qACoub7epyz/2Dx7HS6mX4Nq3wrcksQFDr9XlsOzr61y+qHgvUYMYIxKk67rgZOYmw6wF1REjYZtl3yBkw5Gzu2OmxU+KkVONycMTSg/5kqtdKG/X6mo4Sfa5jZoHkpVsVD6LYVn88OoTe1BGg+PKLz6+9XlONr9tUQke2Z6q6ZbOg5wdGDkEpBsCxbNmqWCqjbLN/ykPyWdypCnEh1DQQ/PrYpHzDEix78Aqgf6Mto63TXyKY4Oo8I3GH0Il25/I9o3MvluIcdSbaL1AYtMp96pIyRbPDz9+EbsiPCTgNZVEGdHMeFKkJ6b+g5gNRUJPwM1vMH2OwPn8Qh+p9F1fCjqLUdhYH3WXwzRCKdn0Bldtazzr57gyMnOJNJ68v7oAhbVP2KTBGZFS9Ad/2F5R/4F8l7YxVyZ1JaoBjWlTtqCl96XsbwPVV5FLaRiTYYOMrjnjZMCL2qFVJX2jQQjhejaWrgsjPDPOw5Dadc6/RJPsY7SdtG3rl+nmEfCwFP/SzGNAxaTICCZhiHRhOo57y6Ip0HEIOurcr4L/fmhsgMsHGbjjEBdcgoSi+WAPrUv59AWNws1Z++nS8O3yv2fyCAU+nNNZ7EyNYIRBLZ+NomxDT6y+ufRKVdIOKt8BEERrb4ZdBxDJWa0IwnKA5uC1Lwz/mEfn/+/JxuMeAXIrfM5YR2wj9e/tfZHs3mYON9lLXjtrB23LP/gdXrvHzHQMPN3zktLGGXVtkSRuiDtMNB7Qs+a0LFDvtMrDwzSXEN7kyl5gdqhwmHX+gAQdyB52A/8z4QwD6aKLl9djc0ggshlEXS3VcOOjM3FgRXP/NShSV4V48VxzcuvvLY2WuTdbdaXIJi+c+kStmcK68unS4dR9sxqMa83Pqlj404AJSu2LNPZ1+0aUz0Xe5oUnN+ueBFtJOvUPG/7HISBOELS42rbrKQrwg7YAQ5ZSlmpBSAB1HuwMN1VLjUjBI8kARKHZIBTHvidlcYnhcZK8EDKmY9fCmMVcTaiRUhZRFF19dW0VJjIl+TzAP3+CN0DC9WQVKnjFbuR/EbfOYreEcsb6QWyXYBYzyflqgDc0EPDtq0lOBguHsA6wbPQpI5SueYKe99Z0bWe7IYtoV567IOkHPJUsnXwrlYJFXn/6xTDjVknaXTAeOIi52bBBnpfkEFKzDlznnxub2nzt8wkGCmtNGDwvb6O8z25XXP+I4yTJhTO/cWUV9fNGZs/XaBaKGNXCPylApm/TRpfMWhocGfHLDARovP3GPRw1eoyJYRmmxe2L10AGCFRJl8K7cc1CwvzgU54U72LkVZB0ElBjrrZtiQtqui20B3Gen0NyFDu3IaTWCFnDrmdCNaMRwZ91rKOq5JAPjkGLpNd8c2oY2t47OP8QFvyz8VWenyrTo8/k4CNxsgld6SZDDnlvqy+kAS/gOGMXmFPnYab/MdL52WJKQLFyE/t33dhbUwZwaNa020Tqyasav/X0AVX2lv4K/7ZpE0P+6Jpi/PMMU/VQixwHN42slQCdVWjEufDUPMmhZis7hNln91hw3LZDq0+za9lHaUY/eXXqPpZL8+Fvgj4VmIZ+3D2vDy0mWNH8YSx7kO9TD5MKGEYKi70NoKP0DyyHjTz/so0i2/3WIh2BM1I7bsOzoWIxzMscrsFIuunbOcru2Eb1/EJ+f8a3DT8FA/X4/vLz7fKTQyju59QyxX6xVHt4r5ZZJtzWhP6BOCoR4Cjmgi6Hd4kyoo+XLg64MWmVDbr242JkGmnD1/eov3NEgLNeewS0GJ8piVpd4OKEapOjFsPaInrNueojmVQb7F6/hG+0xgf1XM2pbWxaEmYv1pYYEvFZsOtaUnxjKoWcyarSLeK9FpdjiTUppIH16IPWkFEsLlTlJiwHhWQLt5gBhRUiMoxetuSq7HMIShLbHXt+taFF6Zs9PaTLJk7NTaeei6OHYO+dAhLYxrxXWZxvgmJcOXo19H8g7cLMBCZ5ISkQsQmaPwkLe0Wjmp3del5AFbo+bRhmILF0I3zL5MoqPiyvB9Oa4tIJWUOcec++ROmwgmp2W67hpYLVXrmk01mG56h3hyG1ca27jZUWhlP9xyzVfvdVtSlY5fUbRGeSL5NVJOlcSVOVvS67ZtEEqQPY/It2omOkqV25mPhAEt2iwcoWSCOu3f5lwbxsNsEsdJixNG4G1RJViayMVhH2SxOIOkG477cbyM6nKkkdrjXlx26p2YDLgGSkmNoyojchMnvFPsPLBuB8yX9y7S8slA+t1AcLN+az/L9RjvcE41hjkJkU9ijUhvvO3FbPTDZdv9ai+3j7EvfRG/IaBVuZ5PbIH+yc9LvywjgVTwY+BHPxlI85fDw6jBOs1rrjkiJvM4F0BFYa8sqWdPK1nKBmPYtgL6yST7Aq7utEtoaKZTSN7qKBePBvstWDmB5ByZRYRKEGbraKx46N15PDwoCpjrNRkxs1tfMr6jTVglNClrbQuOpdCj9R70lDdyr5Of951uW+Ny/AD1ud4M+SG2kBUYFxqh1fpAuNySa6TE/LB1rcj1ZUvFsuHZda5hXwmbtWEYImfBwkAIm2z9oq8kkWLJ+eKTGs3GXFV555Ll2aBMMXGtaLRXS7Ioebd6uM1v4HPDmv3imReuCAOcZ/NL1X24XIb63x4vrJl7umZUeDhLnUArhYbePkrHwEZspiIhTY3ltLR1D1aV27EGNgBAyHaMzZ/A0BHu76YNfVrG8gTodw8wbkp41kHG7tKzAG2RrhsH2rSQ31/cQdkC75m/l6QVVI7dkrVpG2s2n78xPZTP/vzuPTUIXWyNAsPVXulsEaCsUNXpsu6VP/IGcKHU5OTQyHpCpXIxDv5NMYiRziIjbCPfpSql6m7zf+Yd5ZK5njtICypZkf/U72ggZhfpsRLWyb/a1AxJEQxo6WGXqjMVKsmR5mAGzgHRdRPGqwY1fjDmOi7g5VkXyj6vW4uCJuCaP70CMOnCz4elbTblsVHQu8WaaThljXepPNepc94OqKlr1dWCtUWL+GMmJ0wbHkqVtjrmgjCtInIb4ZGcQlhXkpheVwuYL6c4kAuP1ZxFBTTtfoTdk5bjGoy6Ma2HrZcTcdG1PT1SFFXsHtnJY8Ey+nAS10e7QnWGQaDNtFHD7wyRzPF5YxvApTmk8mGN8PKEwOl7ENr8G3hhm7+8w2TFccN8J/boNfvFD38GFeHWQsFJj5tF8hATvd3nvBwxdKMYXOjgJlrH6uqusY0FCRhoLvDilQ6jVLUYVXXq9PdVWmvldGloAAopND517msiNtngbKPaphJ1ceRZ0InrXllSWeUupg6E+BU4CgGhFVzNmfH+BJXDFdKxUI3OpFQ/ohen/AZr0SwgHxCpTE/5RKM51usTqR2nrUGlL2S/XW28NnXtesSSDFqoM6MaUQOYHINquimIpEgErY939ilsRNgld9Ep26iRpPm3jSH+LPzC0+mm8oHcNBxrqtXJrsznEIJFzoZSrPg7qUi/J6y6pJkQZalopudZ1G3PdWq/fsEatnzklOXiAboE8vT0/mUPUazlpW15ZeDW85wteRbNgTFcTourFVezSl8MiKZvPxiYpZviFVIN4lhgjZ+PA4NVSwoYT1KgcUc7haxkOcKLSaBd23h06zaLq4OLwrPT2klv2d7nwgtVP/igZtvuiN02x9mS6NvAW9tITNz4iQsfriwo+rsaWrX+xc13CB+MES7J8Vxha3zl7/wmxa7pU52dqe0ATKaHWLUbNreOVQEnhGWAYQDmfmI08oX6wXjI/7G/nC9KbNHWVWZR5/jp36sCeXpURL4j1SHCzkrK/6Ik5aQ3jpGgmyZYYSBW75VfRvfIyNh0uA3lSzQrAcEL0f7G0JkykRBwSyqGaGzsMXw81ZmPuTiMwuvZMFM0wjIRGwPF3pMZXxUrW4SFK86MifC94FlvTnFYAsR6AFeY5SJpnB4hRD1qEHemoJfCnRkuDkZ8GVP4sYJ/qaZV+BhbQVktWoNqPvf/yy/4gQjgGg2NlynD/hvcHtPZ1b4x/njWqXRhzXrNcfpKmKx8wTr1ycLuhoCUmduzankbEj0nfmebPM70/EBm9gkwon2IYh8VxStictu7+1DGiT2uNmSNBK0LhefqFaXRWYc3YWd8bUtAcOIpLd6Lv6ii/8FM9kVl9463HSSrwOiIeX11To4GOqyIXM5piPCvN9harCSbDwBQ5HJ8cIr13wg57bKVDTi+kyTvkj2zs/L5tQvUCqIJlHiaRt9g+57x00NYL2cJVmlQxOF85O/4MgaOLL4wITsHUgEnpJco7EKaDOQ4p1iVgS7/edTZ+5SvjaPTzBrwG0+A62+KYvpG5jpaivUK5T/SGnLg+2Zgelob9T+SyvYBNpEVpbOCkwGTovrrPKrOwhty1GQ4uahOfKaEKi+qwlf4nwSs33BXZBDIocw/1R/20iqdJDu77ZMe2bOGgBup/YQ3jcw3Si3WCEh9VYp1ViiLfgRqiUxVdnzBwIdqCWtrqLF8OINo7ewl3pvXBr6/9Bx6X4wGFCG9U8Zuw69nGvVLUmT8rmD09lVtu6O0WJcfJPdSl/+JpKQjGIQ5JAGZPpwFjMu4nnqrZE5n52HktCF2b/M3eMbGq93lEjXagNEdJMDbVz61nCXmeoyG1rO0DrH6ip+ZC+t1g8UJN7MLbvZys1uuO/0f27xmlHUPN7C5DYGHCaD8+QIPtQaMqU+sKnshYstkYgeuqUFnQ74mgLzQ53Jm34SvAZ3Amn6WfGts30x0B3DcoHz+IZBzGZ4u8JSxwM+hN/saMMAsfl5OvIftajcbRbbzBemDY5eQFjCe3Ss7tgE3wYw34iZUOyz3nyRMC8S2CDkWST86fCHArruz7oC2F3QbVai95JAWUPc9CVtspMtTOJ+WVfKqwDMx5xqrOqA12SyqagacgJ1EiLx2U3PKj2vN1ZQ+o00pHMzZ9dHeItpMQlqICzrR5D0DWIqEfpWse+gr7nYwCj2YzpZyj6LafOqGqsHHdpF4sHwTPhKl1q25MGZodBaq9R+4S3yCQWsm+Trw0w09J9w2ivANs4w4yO6lSL/YraUcpYINTF9s8FWBoRph18eK6DmKv6ezjDzTcwj9xHzWtRYYcrY7wcGhi3gTGjfJZxw6/3lgxb34Vmzxk8UYvDP71kIsDA+iyBSkUHIv/EDFumAUV48EeYxaVSkKxHd6Q/FNPBf4uGv6spPSR9Tg269u2/cDJanamL3j28cySVrN475oXi+HbBYrnPdCf4+RQFXlbxiOql0APYAkRWi/gJNd2AxaijrBcSrDEUxzyy/uY1EkoXGype21okNj2HzJhNnDhD0TlC+j5b8Wu2wHmpi5yrgDbdDYKE29p+P4b9G0DB3Oshbj/QgNUpK+fHEEZybwIyLClrqs+DLiAyBmYsqvCrW/hb9GfxTCFSqv8fi/ZO3A9cJStU+spCm8lIobbk5x3gchDxENBEztxCWxfp8gtC5Kg8Z6PasvK3x5M65NePU6G0uRAzA2BRa/yOBBR884BIrQsZIrPHm4KFgwD6hHbmXgQ4jwcgCBAvDZfLBGaGtzL3DdL84j3tf8tEeuTTtJZwEhD6KEWyYm2L0iAveCfkxkK7n35seAwpQVdM+FA3lRvKwEdGwoIFmIwNBNrpQrLo56Yt7wLLMCwFoRy/msxJjwv9+pOqYT88MVAAaKiUB7foYhBY6XKR5CK7cn51/O3M1vbP07+ainIhW6pfnkiavW7cyJc/BX1Gzob+zsGwYqujl7emqOsIgcHyHS8bGtgrQme1ABBNX2ZcICCi0YSjO0hVPJ5mSRRcHUdyUM0C4UFQ/7pl3Vfz35N2cdNrRgDHhFM1yJ3rdTGYQC/YcNfeRMvt61IZgE7N2YOoAXtLWRTUsnI/8CxjOCQtrQOTla+tJFA9RNfENfKjxYWgI4iTXD4c7eqBbWqtMRcOpCAA2Ba/SguTqeXw/TXY31CvXk9yW6JJpr03Wp5kwN0rF5ZkJpNzApX5e+Evs0nCJ4t1u9Y8wHd6evqGvqI8thLEQYaI1zyH3R18iJUHAKTk+Iag3pGzMI35mFzpforPOhR2M63dP2v+3I80jjFEFMKHfdJCC5Xss8LizWdm9KDJscpp/U35YgXDzbcU1hjoBF9piSw+rkm6j23C2n0QsXjg4LMeZAaLK6GFJ7x7jn+lev88A/1rT4EoYuR6mstH90abBQP5aTYu2FeuzU9n/nhH/PYAlVB/UOgZwYA/9SEbJzOfDCFarJvMEZIRI515Mb+Y0Vjk1dnjr4LjSRcXNDT33wzy71IpZtLRIXaoLDepCGVDNzzQf75D9McakkaQvrWdJE4ezt6CkZhvmxQt7kX3xADaWxNvQ9rHB3knvdfisdCZlEVByL5JbSr6DXLhyy33KMAqCwBrtEt8YDNDC0iIKBQsUiVDkPJT7jYBG59bYgbn/dtW3JiEapR/J8eTifRP/KN9BCMoqp7nDzE/ZRO5TPhFi76bx0THrvSN6luHb0WusGqTFc2IorGViym7Am2UOrtapvFgOWsuNEgCk3Naw34hFt5a07sDDBKRgEe44wYcSpzGVa+vHETK/YdLsHEMaE/FWRvhCJuQNBU/EdqHOm3l5lILBrVi4d1yd09NzHTAnOZgQIEzQRXnLDADm044kw9uRZd4P6Femk/szQwC644EHOckWY54PCzdSI8074v9TxI2AX4Zjc+BnoRxIJzjk6liVEz0eZiRLE+pKKqGHKRhavsR+KIlGLp1619mIOaFwfF8UdqKsEMte2/qgDDlcV+fomOcgK88IXHBkDQBIBhNhNHulGSm6stgzA5jlQMWJ8knGK+lJ9tDGqIx3dbjcOKjS0oxLPFiBIli2OuRfn2xdpGHOMdcJxJOV6fwAvGf6uhAO3ieR39NDliEnIbaOm+MWZyCMmfHJ0RZYU1473YsZz8p+1OcNkL9OLM7vEtXwaBQlF326u+F6/Mc5hUG4eUVazWRQ3A1kkprex3WP/KZmJUjf7yOLh2Q3Pjy4eewaTvUgfnN5I90Y/SvZfAqc1xBFbfLmmGzHTB5XSMwf9ZAFWKVqPFmVop2Rh1prWKL17QcYlWf5RtfYUfQKc3bcWYbeeTbUY8DcZrDYcpsBJMkDYqWrRGRyqnq8hE/+exM7y8oAq2m1wNiUXqKXoIKQUv7UveB59XuGAjXNWK0P8NIceLzHWQvhfDb0cJzUJfJa1JWr/O9wrfE8nh52O1bWXUd7Uh8sIP5lZzwWhlRbKQLoghVBFjlq6Kvos+wruKfUga28gtfTbRb5B29zC2/HK8cMS451rCOWavJE2dTHicOgu3YcdG7WLeEJ+n2JGmhge2/A+WREhjOnGeqiANYQV4SYZ908FxU+y6xkIAtJmW7WJKHhYgDYrYDmS0cliLPBaSQ1THw1D/WPOtAVvr1aLKnKVOvc7qco3i2XLZC1oSyew2YZmJ5CaJsu5U/muYYDVg7bWY3j66AZKf3ManIqngWoME9nHrqDTZfttvIMmqtyrjMCpR7a4oijGL3cL4BpOmnUznxrX//mIwvrKp6FWps8yWn0Y2TONBvOWD42PkqCHWhx6SZMWKOD67zWWExyKbsT806HIfzhh/8i7psDMQQPKb8v5I7jzA+vLq7NzQ/luqXtpPEf0hNQbbz+Ob7hz3SiFHmjOzalZkTP+ozUHhuOjGjHU+D6EEddXjJfZzGBZX8CyHoGOwc4csIQPMwmIq168cgCc1Pco38zFBV4N32YKEwLslQiZck9rFTnjDVi0v0HQL2o4sRCt+2VElx02/dq6SDzky9v5125JYBfFMm0b3pLjmdElIx6uUxv+miMdfCsJjUx/kai1QSr2zLPDArKvZVvS56aSyuRAUuYfitG8YXJlGQ2KDm9WXvHheiy+tiBbYOfd4bqNKVJzZ8GW3Eng0BrIJ6l5OBFdRT20rln0azq6i/g/8921qXjySQV1IUK+PVwsHe47g608vwi3ZbqL4VjqUjSOkayRHvjcYyPzsCFeT0aCel65P2Cn7Sh+Lu4qAZUiWXniZlrxM7B6ixX+X5ZFEEop3o06SsFd2qHqpjXPyXTqxPCT6LqBSIUNmCm0IC7J/TNJyicqPXCHx2L9d3uTFqWTxyhtXGS6ILlMKpXhbh48eIz1gf2cCamMOftIcNQ3cuq9KwWo4tLBDWLnCiUYGn+FgciPO0zxMYkm5DmpFoWmCzhjsmq/E0V7Y3koGqi8vYt/gLNgAt2XjEp2dcVQDlZeWqIJ5GuigNUd+faSgREnd/Lh+uf0Zi6iekCb5tJFYOSZDYp/xVVnxc1DA02+DF0CFdAMxCjujbqaQvDrqEGUtbro+WR4YZx7xqMQozkzOnHQfv98STg7u+AJrg/wxGnVDUofr69LpTPY9nomDiLjR2siDsT4/7802dXZGpuysWpck9e34IZo0xph58y9q3ReWbAcjyU2AdBuXBGzK102V3fdUUtJCwfPGSwapLKa1zBBxZ9waIzd9d4hStnamB/2iqtDf9moim2wgblKIKiYEB58Jj36vm4PVsBFU6haZCowBdcGbcPUxGrQo3PAsuTsSmszn8iv7moOnQFSkiQcyXlBxgGU8/uRlDxebe6a2pe7w7i5E7upf1aBuItuhnZAAXk+KWpSFiuh9XDcS/3ntVJLHK/ZusyiBsImGGrj3fAnBH4gxFFf6eOpV0UXT98aPProDqTYHnIaDfa+3v4tP74zdc9TG9aiNnJaEY7nJMAa9pFm8HbiGeJkTWLJmmuq4VcT6vgAWoGiR27K+bHX10EetlHRny4urHqB5qFhfsBpGPORNLkU7cN2yPn1hIksXEsd3SOOWf2Gn2s86TnsgzZAYGfUiRrkL7PM3PDaU4FEfdr0poUgd8aMrN9ZwmPS1qn/DHVZqZ1Is2DZl1jUEZ6Z0OMp1NUzDLm+GLTI3GOOYIwXYjLrTFEw+vKTa5myFc1+kGqFqBUfZgrehYZvtZkSG7oV5nZp1JvFKWFQMjZ80RTaJC4unbfo1p93bSPc+s9UCEioeGQpTt6dJ6Y3hEPf1lSJN3xr53D7qRq+zkrJMpINsPsNzvFaLBC9CvDUaY8qZCpKLDILCPGxs/R3eN+69dXVs6YdQVyIJS+FApojS6gzhogwwGdHPSY5Sum1DM1WTegnNUQqf8h1qTgz7mXQ7O2xFrNR5f4CDbIl+HNH7uA9A8xCY++19ag9vShElDBx38Kp13q3HkrGwNHFznFLEGb84ou2CGxBJgUU79F3SX62DSMDnCCT10LnfRSeZ/LZIGyM8dlFdKrBCu73ReCR04qWYJ/79DiFNiGVCEoJ0/TDTLAvxm4+tIPkF1oJTdtszpwKmVvJOM2GxhiipCvZxzLnSXZrN4uj1ejYj8/w5nyVfGJeQSncdBnBmRzm/4eAlzj2Rk4UTQg3rOGUT7IavwSAeghEKMB/wvYlVzLCxZmwi4BEVWs/vUFWMIu1/ljG4kOO0i4vnx7n96GW9THd41WAZLaaktA3fxnGGmhmJ8PXHXVoMiAK29n2xRjJhn2qIud9R+2a22nWK2xaEXiOlS0JehxiFkp5ae9kvkMZcXxf8vRpHUQWJwRaqxR71wqu9b8gMSgFvlMlU/dZ17SIX1760Qu6GIFhK0UZX4yp3lMNzaUdgj4lpsmCxB5EpgFWwsBamJhKOTz5f0OJy3Jd35PirmwU8ozQZendIWr4g5fdBTZa2F9hS33p8ft4EyN0ybJQOsjI0HuLF8djxmVL/XKdhrh+Vlt729CPWWVkmPGAMBW625o5vQDGG3CJ4kDEPWCvBN5+WD4RbvZ+TfVHn3n5iLDql2JsH/d/ArVWnEcW55rArlizmc//ulgwJZkSlLfd9yYmLV4/xkENvb7wwNPWIxoBgB4WzobmmrTEsXnMDDg651On23F3PPNO+0CLTG905Seb9SvlezY25eEErxSD3AgOsXBBbg8btOqvpoB6KbU20Wz53394Gq1JVq7XBrW1mSvvC1zsSDbdsW9cRcF3l4xdHTGDkDwsWGFMxXp1lVJnE5tkJU+8G/QIPNY6ywCNlvdLf4xg/rfzJp4Jx4g9a/UnzqzQaH+aH7kD0rVKWt6GrXt20hq01nTmoVdx+/ondMndH/1F8c8ul7FF76FTLM62s8dUbsJJCshmq9p4/8BfuhrxZYJkKGP2G+wVXLxIiSEgIFmQJHFYyhyrEUXPe/I/ag2TpSwzpXukxEMNUf3zT9OxSbbtrtPB7Us4+by5OfUnvyAxMv7QN4JeN/vOWM72zMedzg8Ss2PHwCP/xdyfssxP0+p16OzlyHBu4KQVWRKtZ5CSi3JvGO6c+JIef7asqJl8MURB1PpXbOjeiT5Mj/X7QL6KUA+ZiT69XVlhWNoKwja3ClTIf/w87zTUPx2pKWdS+T1RyuS5tyayS4Q94CJ87MX6OXGgPex6e1hkt3eujdp16TbzST9122Bkfs2BDvxq/CFJvdZKdwYHygVauJVmh9P/cFhez6qkzJnNjN7JfUaZEyXV0E2jJLQS1fwY4garPmNQZYB4ekD4PMJ1rFdtU2gTWA4oGcydBS/r1QmYwqLMNkuNJ2zwi+3afwSgTTB+Dpz+fBkvEMsvFtPkRNpXRVmYwfBVZ8fok0OyaXXIjcBtjexsHZ0Ud3UeVQP/R6vdvc1zWuwGCjZcxPVjjHgfWsYMZHoqjemYT0TqA7URmElbxVK81FNUelhMAJRSzjWBTV4o/H+1xGTat/G2qrN6sjY3+gQjkDdymmBP8fxkzLSl7sMH6EeoiayZa+kJtb1MhHhuu1TE7QfBrnsYZiwT6BT6VYtbecCS1/5R0ZoNvSgJz+ug0QyQjqnH6pj9A2DOZcy9xv29Tk+nB37RI78UIMJj/+3fiLOdblKKpaG4kq9jje+F2mRYNgB+HnfXJapzVLjgjk3i3QhJMDqvupxiogPZ3+Vafpd71z9ujyNYL8tqi2R9zojiEHxXTZPUV9a7c4pLA2+Yo9cydKu7XmB75q2pAXryzOTR3NU2wtum4+nlVWJYwAcymgbBpL57ZmAk+lBX+MgDTzGzQwCgT4JhEVeJzxjfz1QBtW6ZPZwiVqfmYX9jhHJtL1O+lUirlI9GW0inq/na/l1BU6tL7uzwocVNt++UhS+9/ssDc3a6eZa7o5zILwyIX6CIFU6pY3SoTz3DfcAKqHA25nRPckpYnZpWsa0MliOSI3X2i/EQozAev7679TlQgJPm+yqe3UxZD88FoaYjPv9aD3Xo6bvqIGdkH7jDPBrt4r8GDv0jsPj4V+Mu8rQsALSTs3/CQwfdgbttwNyPqOOiEnTV2ulcutDnh8rSadonpK0hILmUJuW5eZd9igXBx+THF697kfF3MrTnmTdWj4KXl1d+bZN1tjK72wuHuMgGRJtxuR1aoGrXYZgfNj3LmMOdCZePRHIod9IAlCXr2wNyK5ngmZ9BOtundaMdqpPGnrHPMSDgJ+oOJXsfgOoLsTIchqWBe/goPYslRZ9ge6t28LODYvvQybRABfz44h/hHzjnXCKKJ4yCWbO8QgbSWD0rawL3gfPiy1TsPlx8Q5+Gde20fsyH+sM9EFjlZUvreCEkrjzwQWL75sga5QC+ebBWvnMT9ndpTKo+zOq9uog+8VDih1wwosDTCDqPuS5HV6RisTqGlnPYq/mlzS/o0TZfumj6kdxzlRaSgPNipgIWNBlQ+hx3eO2qt4wf+a5AJvgQP3B1VIET4i4PRN0pBpgb/Yrs6wkDdXOGkKHReFkHo7TVeGUCAWR2sjl13gBRRikuHAAHniheYLS77M4WoGsxXTrJpX+1O6pxQV7Tof6ZtocqdutZujp1fsM+LxcLWvY/vNFN949KrqXO1OQpTlfe2RH8BPdF+X4IxicczeVVBK59QGiZCpTaD760eGuAWwpMMK6PECdZCszeX0KYWrEmjJSeABI1CMB9Qa+fAYZ4DJ9dTfakuA92dHq7ZdUkSkIy9rbhg0UFfPPJfDJMDGHGanhbJE/1TlzDdK/92Ha1hM4mGu810a4Gbab+smbq31YC8ab2beHRDCw25dcLKxB2JzxUyg8QZmPtieLqVT3Lxr+FbBjXwgU+Z5br74fa+mGtsdmNJEwww6LG4H5rG59iS1/td1qb2zIS1xC73Ryrwarwx3ag0Exrq5x4R+tIj+MT1hDHgHNtcNUs0u5hd7O5Ie4RZ+D9KCbesBT8hMUMhhNs1HKlrwDb46RGOIEqo8dRK5TVGM553dtbpRn4PSsmlVNfOApLTSLHJ7lFvweIWPzKk6ybZoE8nOk+xHi89bS8xvQdXzBoRgwyRtgZuVQeh1OSHAsYk4WE+JgrfqUrejHS13+zUjFZBFJn9YfQAdSNyW8+nfyGy1Imj29FLfooaE5HE9kTguf4FNL/rcPnuXDT4AO6RphGX/kP1qGrDTvYew4M3OiYtjAdaTRru/u69YYm1OFXQEboUJ/92zuOuHY6aBGNS1B+Pg8B2W7yp6veOjySsWaoGT8sEtHS3+oxKYaxFPCitjW5abzacpkfp4KiGMrm32s8bofcwxdsqaAsaG6FdNJxt6XXaeNhEr3A7DXZkPaiZu1RAvmY5AdhDWwtwAn/7YJN9RjHOpuogkGaEUhnOX/FGurbNBtc0lQjNJaEfIcRXLcZKbtU8Wg+OiLR6/dq79B+L+wTam6ZoodXdZcP2CquJFXh888o7bFg/ROtbvLyw5TyrVAaYuqtOGcX7JmolAYkaE1AJSrfOs4Ebfe8J1VfuWKBLIgpKDV9cv2ZOW+YypoXGsToNPHOI8w7skd4WWrxgAm+ByiJi87QktRqjAi4/oBhRMuWJbevtj1RdaM18JIomFCNcJDMp5YMdfkB2Yn/+azbBCrteiIDqykOB8NrL/58xua+KOzFkb8m3gTnDfMUy4mSkpQ5ujojQsmINyMYwmiK6RqCloUUWdWbZ6rlj8LKq3WyaGAFOuYQFwfyAPgFNSCNBhpBZIbMf9BWyht6+mflBZdFtjcES4LrL4x8Mv6S5NjLtVHIiYTOl7L+8iNG/zM7IXvBjfryXlIQM46zTAVcEDoe7ifBfy5L1olTMlZep672uJyCYCD6jgPtHizBgs6pWc4O04QIMqdx8rESJYOgp/BkmJJDtW9nVXH/SRx3FZhj/j3p07Ycx+oEofjD4ekKh9kK2EJyrsf1gsOWaMw6uCdtfFxhPZGEXOktd5+NjbSCzuTcSu9gqxHe0xGbB4z90J+M88xhXTML2lxCvmNAgCt/xLSIbSQpJhL9vXNcol3alikvJvBir7S52oq/FRwUUfcxBXR+0lh/QwwaAGiOzAyGj/FbSLqPsBr+bMePu+O/tnfGdIBX0GvIsOA0gORYqlb/gn3EXr3hSuuF0mE24Vvp1hnzxOnPFzZDyI1OvbSBYKpSxcjFhMOzeDAX3CD1OYuM15pFz6JlBVYd8ejWHBypHrxjkvWnQxzEIzzN/xV7mLHHXxbI7vlihPeygvbJXWPw/+Hp/tJ6g1ya09EXFX+JNDb81gNsy0pxxt3xFxZ6F269mV7naoGI46WUiEhIkmgEhKlNZGBH4ZmnN0AKAe6G2h1+M6ByQXqLJpCVgwBbgTpGIEt90Jhm2T/GPUnIunMs6YiZCRXUYHpMVq8Xg+jtZIMYIGCU7BVZd568RIoJn7mAPrNJFSO2etglEl4elSXobG3mUlFOyeQbUwSWncJ1DPidEYt491pL/sbQKLjx93JFYyAR2JBaVtZto5leFdNIa4XvHZtMvu2fFsfkaMqzpITs6YvmxRYUcUJb3/hysVbZrDbf98gxEWnxGd8vw3H7hK7Zd7TPMNG6yep9yFWFr+59nVfaPdnyikv8Ft3on7xkGWEIdeOdyI2htBlTOEObaECs1DlpKpH5zcTsUDf+AR8Ezi6Pq72iFmRfhh+L9hk5gVQSCmEBRD3Ge/VTi8NrQQdBX3jC5y937hldBzpRtfnlcQ2qSJm6deuFzU6Qs7yBawOs/Su7tbVqw62e/ok/Y9UVumoJ/mxtzpzgXB0g9xD5xqAaBna/jFgZ+hmyAQBFaO2QHH9uVO3ubFcofXCdVVGPyFJ3gTqx5KOGmIakpArVG3pl9zK9KI8Aw+692QZNi+mDGSJgqztQQjPztSQayMzwCbvSryChmWlbrr2/yrdt5U8eyvDu4r6u4GaejWTIWV/xMles6ehzglmiFZa5BCmnv6j+jd4hdILE6gECGuVwFzKEGNXrdB0Fuo2cOSavFp6m278Wn1OG1ai3KD8j6P0S/LiFeJ+a/YO4l5OT8IMjgm0dwIie4MLqmf+WG3dxK0koXxVxOG97vlCIkwy3gf9lj5RGkgLqZLvpua6aWJTcnb33oALvjFwDDbBZIEfA2BWdzIVOfubsTwVbPfYqimwqFwGm/thITa2/uuOQgr3Y2XxHqYgGmcIV1/VG2LmOsiYgQgAQR4Ev/7xp/aCO66iQCuzEA68VHF0J+wApYDRL/Oi041PGGXNdMMrZfczIue6hcj/x4cGTmmyZvESTyMFqviegOTCmNrHaFpdgsIOx0+wAvBR3CQqTGIYAVbERQ2DLqlNEjJDM37Txrcim1vsWIIsvENJSGkpw/AD8/miQSQi0mVvzoVI2573Kkc7wMdLNLpLuo+evvTWlFLl/b2VT35KrQoZm/4+8vIf3YSh1MYVij0WSSGhs1q+049Ub5be90tuXiGyzaFv+/aUOIer9u7QZiMwlS4E23T0/cJebgHtuYhJOo6LNI5tFV5WCrcfN047Iyms9SDRiMRe9qPV2VFvfo9euSWj92xyRovFWHC0Gp1rIWY4FYLfIdnnNIZ6vd3eM9JNNNC5V/m8q0dpNHkh64utbp4r5aEOSYCnHKl2ltZpAnQ3R9aj+4YRz2I7aY0AduiB+3GE/fsPIaCHRj47DNtI5TYXguJT9OveenMz4gxRh8fUB5JtJvV31r4BEWVFlBPWUBy1JqH4A9euiQvspnuRK00CFKx56+wY84IQB0vpkIeoXT6rKJsV9D+sdhXcCgAe9+Ha4bBs0+TxB4aRzsV46tpdr0rePBACzqi1Dg3XAQLzjnHKsy5eqWcVFzEHTxpXThu2wND9xh+L4/Fbo+leBEnCBnUL6jtvJ8Vgt9xYf5NrDhSnUxYtQTdpUZ3ILOrg4o0dUo3NVJK/ghDktiwVb2OZXQEIQiOn+fzmvKd8vn9J+DDjYqEcTpc3psrZ/WJxL/QHkm945bsFoTR3vFtR3+VHDcjjrZ/dbM4SAGv6g6PpLFACrhJL/5u3B+9+QWoT25fa8L4iRqYNYDvTujnOfQF0BCMU4hydQniq/mP5WXkf/6mAdg6jrfakg4T5cecMQlUAWiQaADUq10G53fhqHYJ6bbA788KA3H0MN9XllBbttRWReUTMPpSsUev6g6AnNd0O2IML7XXcQdPdk2hygQU+XXLq2yedNeUHBsSe1fAQKKm33rp7S+u+Sb6lNB2Cw8xzcSfEEO3pixfi9crduZbns2+vnE3CyCgz9G6qZMdOPjQSf9T3CGyE/a3TRi3QW6g+zFNvJ2Q8JK632NXURMey2zZSWxAulQ7nuhc1xy2MowxrliQrVjS4LHyFVI9xWZaEdMIfasglmC6FNNg1Mu5rI7KgDjWnehMzOexcT11nF2zNNMM9gpMpxoO4/qub9ZcMQEpS3RNCDZJEsaJ0UrsPpXfZmrCNS8TxFfQrLpq/frob4W22SKxU/gT1olUnK6SJcI0T0Gc6QMpJvooRTaLJcHtMQbRdHIyJznUk7I3VIPu0Iy59Rl99EjOWf3D+KFuxYhO6bSsW9oLih+I3oeAeQKmzcDnWbxsl80/rLemgGjLOMc1abl3z7q94Auo3/Ikb6OFWe854ZwPGITytIJfXX0iYJLa70n3pKbHnxm/D+ngmH3sde0M9UWWWH3tEF1YxxrwucbIKxPLqCtIV1o8F3mbRS3/+w25tJ8IVurmsraL4NUu0xvjyWKZeSH6qIziBgJNnPV6s4Yv/snhw4J4yflMBpmeM48JaE7CPwcyMhfZptYotNdAtuS+rspuzZwS5ossa17uO/UgHi1oABdNLKMx/NtXb0b0FroCF3PDzbtVwB5jDrtc7quT3QWt3XejQTFB7Fn/jJYcjpNSRTECkM9AmuHtz78WqHfAe191FbkK3zppYw9JHYosUw227uOHwUXPyJA3I7MwWAeAGRCPwU/W3JEHHq55IIj6jR/wFhVh03C+PnmkSb+Zkv5sq2yMROfQheAijiG0/XXgOBmAjrQlqtCFcyVkOemG26oEtkKch/OV7NSHU012ULHlq9GUVva+Qmh8A1Ty2HE6ebo/yb0bRRacno1WvcTcLTIUooDvtippk7oSeyrqMzv2GHcw0YKjD2+hSBOHGEZLNYD4SksVCWrTJ6GvWglLr4sgBaebMiHz4xYt2xGDoeI7Ca97ujzQmDs0QOemzNtiJivcrOxFCIH5kXf3k66QA9E1SFQJdYbJJ4cuZgbgm5jjLh8KUyKXf+W1ZgZ4P6BUB0iN9N0xODaQRVCbsjWUos/C1CJ5M5m5I3+gZSziI1W2NAQClx/L4Se7ZHbXvZkjts/mdKCKkd2PjvW5AFOl6fF4Va8duCDjNZLUgAUZrJeguiQvSC69R5LKU7/vJh76LdsOsAsXjpPpf1QyqDaAwJD/sigghfAeEmM9MeTLV6nzlUobRRps5/gMaHntaMzNy6yorZmFctTHFiv856O0JugqlQlYK3og2nkDte1mMiLJf7acrFQd0sUBwpkNSzs5Hnc5g+PwjIGkS+2NByTNsmyZHbROCx1DCmoCux3J+X3gdZ675ImvjtO5SpWbpqe/XavyG012ieQtcJI9g9akRI5dIvWhkOkjwDMlYi89vQrlCvBPE5IxR005NLC9uNAT+8uzApE29ZaJ1Kd5KlizRmWoDKhg2cmBdd30swHzrLPYhKrevU8HUj3Qw91gqsJYKqHoH/Qp7nFqAsKpIpNR7x6gQVNi2KBf0TsTD+/VwHDTuGwVbSj08RmMDMSTtXukIzKdtxoYfJlmojRDvwbgb0ANGej1inQ9S47Uh0sRb5V0FTSAAYrjNJQdeLRci7TTKtxPNcK48QdR9qirX6u6qxpRNbi856zMefdmlcAIbp3twR4Kg0lLAxWtkYs1LStJml5cp9G8Dm0lx3yQZLKZjFJ6XJPP5pQ0o7/MEEa54kjWdIWsVWDRg3m5WwjaFxqDhTXDA6wcFwyNEHHCY/0OAPnxQHIKlE6EiQ+5K8R5hQWv09T12EyXeEZDojDZ41tAh8Cx6ps+hvShcbyrfww3jSDxnKz2Q5CwxDb0Qvx/MHmrpAoNWliOTFNnct3oC7AEL+siYLKqX9oQPNdg/RBwbf+1AZPcXj3j9CyzDCveFmLFS0sWdASbWOcQIpRtNxw2x9PT+hXp55+1MEdkC+zsoSkUJHZrursLMyWETiR+PQXxams7W2Pn1iHc+UYQeHskF4ShgXhnTRWqbkbe1y8E5I/tckL+qhM4YDgxTxqrzX696CLvSE9rXDLdKCNF5bH3ckKPh3UdAJ6e9y7wEshLXhnewzcIlvUQ03k4Nr6xCPVNDi+a1VpeWggXptTMj3zldjhLzclsbRgAGrASfAx5likI+6Rh6rnXuBAFZjJwwulYSMpGN5r+2VBPsXy08h28XvWLFzOsChEQtTBfS+OCtkUPPzBfsMwRJZrOETGa5ZoKyFLINK1wQ8xjxYTKNlKaEMjRmt+1DNI5wLF3P7kot8PFtio0MzG20d3znCOpM+YSk9+1k3CEp860NEBbnpdQxUxrAkZB+RQMgz/Hle11k2daAXBAA1WERsiPwpkXdpfF3TH6w1CMa5RoZ4XWCVvCDqeijunOJH8wwsgT5hGckpvc7mSAz4wJSW9SwkH2peP/AZX/7zaZM7QM1wW4RIV4E6svROiIotAetuglXwmpqodbvEVtESxK/zf16NUTle9oVOJ0xRaYv/fu+hXcR7+Ur71eKQ5LdTEDVGcXZrG9VQG0Mp08UeVI0F2T2m1FD5WgYPfVh6Crm8n23PEUa+7hOv7R+fy2Od49kzxdEisl3JXYRgivxQSGLCF40vcGjznv7Px++gnR6TM0fqbhfR02jg5Ba3RKVtI20z1cBjCIsE4x2HsHV2NP+mSubzGT8yZT6MsSslBGpnEttXHTI6ZkLib+JX0/EAA3eK7ci77MEMErWcxWvkOvkg0R2AO8egJSTHc1xNrei9rcMFa3sVvN6A+JCXuxIb/D41f/iKzt6lzhQ6J1G/AAQjiyVnwj0sypFgxD5plk9Wor7Lk6NQ5r2d8Lbs4Be2siMnpOzPjXxR6pnf/bMEikeciASAphVpRqvR96lIdXy+0yZrorXMcEykAJ+n6jJsn4R80uja1wpCjIdoIc4O8GA414sOoR2EOtzGukAsNHaPxdOhQGgvDsuyJH53j9qK2FSNCLQWzvlCo2U+4zGbouOBJWjiDcrIeRTbw5DWIsBUvoYy+t66/ExPAb38YpX/kWpXL/AYwmbUFvYq7BvQ4UYKuA/pP3UiN4+vxc/Y45YWlJf5NFF/9AiY6KmPPK4705fEjrvvb1upVJ576NnaNJtz3wzDvNkd0/vV5Fc4MlcMFL0ebyFMF7j9y0qvFXcWHvmZepJiNXGcBqAR9DrJXLCNOOHKefX93PxObJRJexCPkIx5O9quOXgu/nxF1fwCqP60czJD4vdshIASM0x1anbiNFkJJ0ExBNawtQDjD9l1zCU3jIhkub/2wsuJ+Xg+WKgstDKguAXN2+iNhaxv5MeXI5EFfaizBZRV5rFRgcsmfXlg4hanAyeB5eh/NwqtLEE1UXh1Tvu5bfwEdnGfM4ks9SRiYwov+OUJNqAHxseY1OhrNY6BcItBRp2iSjMSufuIAPnBcgeVhieZujFaGTrRTwIy+fvqaGDJfVgajbIBMC1DpT1fWZMA5O07l/i+WD6k0RLAYETlOOq4WSNXCT6LWvw3bU3xLCuBUbpN9/s8loZE8NdPj8ZPNCNQYNPxSCGZL+oY+IHBvXZ/8ZRSMMZyRvxn7GZp4zKBpSOn1Ty9pgA5f0RYlkXoDlg+fYv5dN5bHG8cTvOGZ2iTYewjIAulMpAstCBD5f4d+6lNpWX6SVXHcsBFeDXYOxZp5Qxc5JeraG+4jSBHioWy25TlYgp2Bxyk7+9z1Oh6indDb2zPtpLZLiKjhVAF0LpuUAH/4to5HqQM/RVeVSmHdqYH4CnrtSXP1CPDA2/ocs/HohORW2VbLlf0VWIu/ANB8ZDl1a4M/mOiBbxLUTJ8evJyIvFWclKhDG0AaEVWvM4Bx59hbPxi3to7+Cm26+ji8by7tTxsx8Z1g3Ot93Yu9DVEX72Y8pszQzkJD1MLhU9HmlPeVo/8Nk1CcCvzmFhJNSckB+qXcQGO6T1Yjm6yXWWqzyKrU3/YZrkYBCMb8bb6cSV+EWF6tgBpkcXCS/HIk2AYy+Mw3McjExhr55TSY81iQ/0ebXNGhTB5LYLJoDiaLcbHQI7s3kPnOzNmAHKKE4+53LIVsglQDfwxDh9KJtCwb629uzdSGoztNaeX3FIvQkSWTcX82rFOKyEfShTKcFrikVGTNI4OZP9sQlosQpklJQK0yE350/0INOKm8gasgrgAlcDQoMcf3jbL2yy/QObBvRXsBLVJp/9/cBCUSP0kQbCMV0B17ccpomEFrblcj8njvw+1/Isc3qgNdWdlyjrIAhLiSxOUaFE9G4K/hgoLC+nA1vO3doAgdEcb9vzmluu6hsPLpmD/211ZL7/6gkJiIgvM4bswYon2BpNRTmf5gvbmd8UtMapyZ4ZN7zaESQY0wfcIMMpkXGGZVnGLoaWXwmm324YPoBIVtsYfb1XDp4BuyAelGgwaiMADlqjdCgPSaFqS54/wUHmV2tCP1MpiToZ6zeNVOD60aC6dz9fHtjoepx+/0x02Qev95jlnOUQmoVLhoQJyesHaee2ElFrJK0EY+lLON7SWpww3kMQHR/FrKHqPQ5YrK7tkhhvtnffyTc2u+ofItpaITBj/kaPGkND8ZIV5XyFEHinwqmQTJUhzsGcOZvO4fcpBva7xmhsudW8WLQ9UN6sEW0eK+9VjvbJpS4//0xvNzer+ViqKf8mOPDQI9MwUrckRSrWjTbG+Ac16DiRzW4TfvUKRGlUYZ0g37zWalpYsBLrFE4hoaIbtcgU8k0cNniU2SWT0MqTNdSY9TeSNmA8qoVfYIBiOtlYJiFI0AJvgggUhO1lWg0Bb8GujwPvKQ0Kj7Av+LZwQwixn0msypWXEy3swQJYGvZpTxYgNOCeb5BxzkEdnnbHc4tnqbp61d46Tty4hYBokyfdGAcmbVvBZPP1TZ6kmyf3emeuG8QMnA69LyKbYFYc1aLmTcunL3XUcFR1/ywY5JLyDGnfbdLlzeMB5242MizKU/+3XI/7VFI4QNfkRMnJe6DxUAOO6vOvOLqPgv1GKWSN1IpjknezkewKR7BqzajYDaV+MAowjbjYZ6CoxXhS7G3CBkD5Yp9ch8SV4vclta7NCDSj1HuYefcUJbsXhtfbHtc8FAs+0RavedLQBt/SoFARGE4/JkX5+0XPGRvfqDMye/41/Ruub8Dmay529GjI6XD3SDAKkSv5FWLa26zHbaX1TEhjq4xBPveWKng13UxVQKBuxOChP7H3bLTPAUDXkoLm0BzsWOXx6qD+Vav7NX6hY65Mjmgg0cJC+SJOSXOSv4mTHrhlOJGE5x0fLD4WLx64ve7o0X9vzzFpTdfob2SEAmfExdj7HUa/6j7UW98KMJUwPVD6RNKXV9gGikIaLGdlGOQcUK+8jIwy30xI76HYiQP9dS4/eU+pfZjjLywYH3lFwRKY1ttt0P+3AZ8GVmPEeMwsbcquFRo75Zm+UYD/7zZQCi511qQDfEFw7HL1nY423Tf3OGgvPmdCwiyu6Rn+9bWhVpSUUZ9mQQueIsWTostywMJO/akAT812XdEaehJh0PqY1j9rAoXVZoKFgEsQZMqy7ZEh1pfL+DdnRBxsDAA6q9L3d3Zwv7atFrdU+GXGMBkFXwygUYM+ZfMKQljnJ1a0pcUDkV3uFxMNBsL1epf6ErwaLCcTngI0TgXmwDKu3u5hUueazRcMSpmvo5TtGfCnjoMUq4P+Lcz6c5mFzWJkZPmAkyfIpLHBl9dNRxAh5JQnYiYuzoDNJJitxar50/sqne83PIoqw+JR+SB6KWM1GN8s21B9eIPW4yKVxQhuanrA1cBna5xQt7Fict94VyCnun2/094597kp6F708Tm2e/GbuTBK2nvbRqZW1xZ6HFoissoAqUp49z1AUQ0E6hnSpg+ysxXTGixZPwp3vfinwSCyT5VOjOtnj8oSpleOuDZDSN6aibr4Ayj7ukiuDc9anbAehyvXD6XOoJOtfmz+k9N7HaqJG6iaFeQr7Kznb9dVoUCN36ayFvpjfnT1RRVfAJg/uWuiyTr7aSN8aF0LPLqQ4VGeOEdVcJhZpkDvGebUrJHO9AZbu5bYQxkaz1Z7riu44RlaiCudc6DWLmxy6cYX2412y3HspnVc/peokbYOMcnvIWefdRCUQByjblVsMo04NiSOqNw10ggacCzVLI1dtY5zDclFfMybwnGVapbWvOsAVr02vIJ+bXWyhWr6SK76tlUkS3hOMgAA+Pl1m+8+Yg9Fzq3BAZ4mbVYAbATeb4TfZrs3j9dBF8DD5ZO9/0l6CA1K30E0i5XuDXUYG4Y4cipm+IuUkIdub3EOBweFESJBss4/SFPpXXoBQNXmu+k9mq3v5mKQt7hpjWejjfX6TRr4tcQ24WPJZoKtmPvz27Qn1EQPes59gVH19rUFhoxxKywJ9lpED3Jy8niftr1VH0nl+viKz3CDPaih0cR7jTxa/YkJoXj23GqgkAdUfc7fALNI6EaHMgPDq2JIrxCMp31MbPzECMQNHHHUjy+FwP7yKgsLyQMbEe3t51dzGftb7ApfMUtLwCSSuSSHDPZ+8ewjB9sJ+6eVkpPbtmVm8HshDZd969V3tEJhvFtPAcO9sWY+e+RI+KMj65R5LB35nJ18XpNy9+G8bKd2qr552yFDNKyZ9ZFSVCK4c25dewQ/HgmzE0ZWxAI8CEUSIWH9JHRVPK40SM974oEaIijKSBFERBLI1esV7eUVZmJpSbbbD8aoTTy0oRIJjN3mkTnN6lYSMsNFDiNey7z2UZXmC678Lv+VSO89Xset5aBZV/s4Gug9MnBr5PC/nWWIIQ9ml2Z7irtSf1M9jCYYh2CLX8GG1DanYvMEgxx+nFY/qWVQzc+BBH1oj4Y53WlhyfxYA9BRwG3lYrU5qn3uyLaLuIrpeWWA/fq1FvSgWAILPBINsIOyf0cwfOr6GlLQlQe0VUiAs2pnrYQeoU+Vh5oo6fE9r5TWyz1nYVV3F0Aoct8afb8gmairYMFW1PN3cOX8mFTNguJean+bEYXAyK+xKlcZCRkB9rir2OtHy5MrZBXqJN/3tYRbDy2h2LAegeeYJbK1214nwFYJD3V4UVpVGQ6xtFGlxuGnC7iTHv9Mn29MlYBze3e2oEhRslytgf7V8/xqYUlj/RhOpgKTxMkZOwMxH+HyqI/2YbpdUHDlAn9/EiMPZTMv/hizHG6AREPOZ4a6J6b9yNC9cgrQFk5t8LK/0/N3ykBFl8blgJnl4m1vae1ll1WfTGKIo5KVodKLOeMmPCsCr6BkBOKbA7vWDJCTHxWltl+ZbQx9XsbvHmb2KEY72+8ItzHZFXgZelaJn50O+Etx7B01cC5HbhhWtk2+1MEZJuJI0d5C7XB0/98LGtcGLPxO+QPvAEsFS0b9jDmv45Qt8xKQoG0iDRAscSDiX90EecJ9d/Q3REwfP90R0BTCxqHeKda4F3QgJzoTzQ3scBlhan4lk/ykh4fIThsBypGq5kv+J00iL1Ja+NAzA2JP2zn68xnL3Ue0I1PEdEgH1N+a5IuTnGcbWs0XonDa9Who2mmRqjBxuoiHq7gfODDolj+bLoUibmEWEiMa766PvsLtaBg4WoZ4RYStKUEaDeCH0onN6tfNWXKljCp1msH/B5mbas+Un9ku0JLk4WA71xtTN5gpUIp16ggy09RqhaKmhmPpLBHxaHQmwS4vlw3hj7tZQz7DROg8rXw44MsxxHqexZJyL2fzmmwobUxhYsuKeZtpo5i0QbK0x5ADFTRhGkv25MDXG7KrMAkTJFThi2q+10ZFmPCwrlK1Cma0q4OQrwheaERqzLcO4vN6ndkL3cOzOttqp9gKNI7H02cjuh/+z9nqs20U4zFjV/J4b+5w27cTaydfvfXtP8Neyvnf0wqDS31C7iFGlPH15Ptyhd239Op3z7P73Dbd9YmEPHCko9K/T2uoYR/DtWeyvmbmoLsegvLu2KjgQ142c9MRoYxe2/v9DQqyr19nNRwi1cmor5pMCEM7clCu+1zABPpIlL4UHTMtE5HQOiM/iiYhFzak6EpI33gj5No/VjudmgS23u1WAwJ1UfSYHSnPfTEtH1UKSFlOYdSglAwub7m+s9bPL17SXcN/VkoLMcN714FYbbyHm3oCLGoArUcfb93wOV4ZmmZZ4vKs1UyqGWyxqltrzV9l5wVyzLrcqZCXb+JNC8lV8t5f4XLPOlXn/WLUblRWWIQNLxrCeMYt+rJ+I43Q024M+q9ntL1mWIxmvSOBY6zNyphVWVoAiamJmmtg+NGGkAcdsW0+9qN7m5Qbv6igRp4nv4be3nzoK4a78gMQW14bHME47wSR3elJbVMSR2CTVe/g1wTMlpVCT+QuMGvA81/RqCDdy+Js8307zSKQkDKijI49cnwpPiYh+VO2AZSQWUXQQW/WACsbM/HM1YkNlSgIoDwBNvNgG8kLDluiV9XdxbL7T01ArJfaT+5eztXyu1Y375xeIPBH+8eHM9/q/1Lvr/TVf6NipSTNhUN/AwOm7Jd6oKlAP5cvppqw/HPiXQgJFx/mNObFvT2fGZDRsgabkWgq04hwoKj4M3jKbf/pL6Pev9uQaH4L0wx05Qj2c+9aTHLH7nfMzOATWuqDZKca5bkkKDdjKLxl2i2c3UpplRzknq52wn9mk6WC+xpUXOCy+KixtdRm1MwW9ODTXu4Fp3R78zxI5nLyltQRZdKPcEZFJZJ66O0++jZ5ZDO/Ac5YA1T5zFoRKz4ZPg5vIMt4myPXyIobIr7RoAOGuqUQiZJS1g+8GFuti6DCEJ09i6BYDtmADuPOAbbD9ILkB/MAk+JZNZRyVMkcw0vVUPAAjG0vwXTb/adXuwp0Z2kBCvQm6m76q4WLwKqHH7F+4duNqfvIFvbgctLvB+zdDALcl8F2la+a4bKwsPAg7Y/xreHgNlIZIF8Dn2t37FtT8GHpsIb45F+pdDYqL8EeNz2j87DB7JH/CP6X4uMCQdb9yyjnSSMqS0lVPil2zghXiHai87cMl1UD15ooB3i9Sz3ou1LUG5+/u/XX2BxIsX90jbgmd6aUoLerPVHXzPWgrgW66RBzs54UGWXpH0FZuN9SvDyK+XmU3P7oUDsB/lfY/fyWlTNfmzEpcS+UAmEs2vGurm5WnEQnC7E91bKe3GjkagUImAIbsvZ82z9/icMc6Dm9LHCSkU0ZA8ZeA3gA7WqoWcHCaeP2hIBcHy8gSKQ4ujSp9j6g4Tw79larvzGNbjDtYGQrSnHlNAQNFaR70+SeZ0J1mUD2R/p5rb+qMkgPNpInReUHa2kvli0ZE+msOVjhh7JpPmOLvMl2nOjq/Ne3xvFzWeT0zRonj4jsHHXUDce4b3XJGKa3urxe0Q6o5hY+iRq2KNDP8pebH+CHbakvNA0y36WGDcGZtAfGIMbAhC26Ul+3j+raBr4OednVydjpELp/3/Vp+bKw/8z5X99UaeqrWmlGvQY1eo8JM/JaTH9lYeZGnkHDjZfjUrB69D5LjeD24hdcPrsX7ZqXcRXtdJfU3rLDB4tam12ZDe81EuOsasHMp0cSVUlOj7xpscmMo8uNsBROS2PzDPbIpsV1b7zlfQZ4ANfCzWOAf0MXqm3ZulBm5j2Lc902awg1F5AruT+t/8Nk2wUge3oe/G51+4Xx+2qrJ1oPk3pPMZogQvQpesTHCl7+JZ3JXtulK8a/sRtl6OtUIrG2zoB5MbziAGYORHwjjh1tKT132oEl2IICIh8q65ubzxFMsjqw20x4iJFkRQH9g/I3QkEzL/kHckvaJM8+gpzEiKhsvCxElx2JijcUm8Zko6sSiRGXVZamoq5l/SZAERrT+N4ZG6curo/AKc+NmNCZ6XcPwiTL36tNReOVK1nMSpznC11c0sZtGopqO7zh/5H6nZxHDJmFgeiKjCrQ8Cqzf4iYWrfxqgmFDKalj49gkpJRAGF1F347S1gg+CVXQWG8nP28YXdzo4VCjHYTUdQAd3wS7+ygNU3owQb4SxLnu04yEIY13X68Pbz6xSp95m+1ESiOccwf2U9ckyOyPlVKn6Cpgt74vhR4yfwzvxaj9tK3uJ8nwniYaFgnVducFqKJxd/3eelksYYi8OCueWvUSz+1TJF7XyZRmbmQaL1gtQpSFFQcNqPZ+1ts+uxmUAC5h3kMpLYzAUI0Fa3JRoTNUs9/Ee0iyBR4EIBQv32RADDgRzl71L6CQQIGX5mFwFL67LR3cO7cAUg3LOBh8G6fq9KKeShIxlO+gKFMlXjLeUcBa/rDzXI/eQshR5ZyyESBVKOeo9SIefozRfhb4Askk9tS6LkJfYYz/TwQhQAzymFzZ2o0rGUjMqhWophjIuRme1Bz90HK4Zmqyke52+GulbRogBxoYBb6+47dbqDuTLyJuUuEBhO3fTGzVSpeKY9R7OKJY5dFKcBszHVPBQqAY6MDKMeaDQE09NaDNVO+7CBOeZ1FyHiCFkonnacJ4mSNYHAPzYhQHvPziKUaE7O10IbFEwV1G/zxZyJVXtooO4D5x+oIq1QwJ/wp54Q8hYYFn8OHNL181DeFbC20eDe5rM6SyTcg9oArjzg9U4rl2kfD4iMDYM2cOVVGktli/6xOPWEfftTnsfmjD7s2VT5UPmxzkN6JCkuV8Dvt+Yipk0j1PLQeZxu+mH11A/Cv+FxF8Qe0h+C6fq4jH56rvbPIVuRGw0ZExqayQnNhki4s4wPTOFG3RUAxmTvCFTLu9/FhtKAsmPxP0cdewoJUF56+9TLVr2iiBKuxC2de65Dc/w4F6EZ/uUGMclp1ITry8CZKCH+cl9OAQKroAF7jlNiDB8bO6keoQ642AgDnW9fz3nLN+QN4BKEy1+ysyLQzZYof+LnwMuaqhQ6Q1BjYU0rsnIT8JXHfTcLSz25/arVwX6kY2whnfIgQ//qQcRQ99O9C5B8fPrL9VG5u1K6sPw/8L5FtSJyroehxuGxsttncZZuEQckJ5wC3g9TriHa53HMP/li1pDdq/mlbAjtJrp+UoA0HcZ+607ywugZfj+ugTnqAo2i6Ehg+IAzYUWNdN8/jdXpOcZj2aaQWJzzib0S5wp5tthkQ/c49aqtxJngiYf+4QIV2SqsBrW3Rd5sVt1v9fAlLVSdFcIDD9HdVuU+VTyfg9ehA4cVBGpmgcY97wvx/yB4gftSdwCZ5/f3TDsA9XY4oSY4Oye1dGFrvCa2BMo6ypWCodNtbR95elcwqgivotWdJexy5yiMQSNDfviVrfoPbwpFmLQxgWrMsKlwmJvj/2UQlybdjlLNW4N2xbWpsBH3O/oLEDX4pBctZxY5DOpBdq8Bp8LPfEuFQu97EylUAgdSceeDPQx7BripGIIlMHtqawlRVHRFu2mCHYE19ltYaxdudhLjJqni8qZhTVrwOBh+xkVCHNU5OxSpX8GqX0z66HNwtpY1kciMUREU+blDnMrgqlTY+HuF/jO8tc3wkuzMj3hIi6MCbdU2en01tzbgLFMDFdWLr6II3tOccxq7F0Rz73LystpikAUehfoapJ/Yos8dDJ4lLad4KQyPp/rntrTl/NrHWHiDf7Dvzg+mEpRt7qyEsKUDYr5OXSw4/F9MGky4NvKKByNG1djF64qeXnUUyWBvZgpLNAP2EjIL9i6ujBdy8mvtnKqAF8Dm73TWnR9rgdFBql7GiwBOzVxoPeyYOWrS9OyYdB7ZHZRX85U31CUnX+CTcO4o9J39bojO6yAa2tEMkjs72AhtKApkwITg+EVummoGnQUazBuCGUZJEL10UN7aTf3GcLQiLUooFdaAA+WX56W0qsX8og6UawonOvSvr+epoRstTE1W4MpPWu5VNTb6V2plqLFVjAdq78Cu3QYSO3cpcOoaQ9YaK8419fOHKLhmZlSsGvMJ3H952EeEV2ORWE85i2xKAk4JfWyF2NHdsZkQA2fwdMKZhDEeNEUShU8abWKSoVQ5yevylQ9jhujLsNv1Gb+7qwZedLhH2dDaTEmveAZLqUfpmrLbhOR0mTZO2FwJhl2zXRFDwqtqGn6Ev/X3cARJhmoizAJ61z960sf77VxBJj54SfN+qt9U2H3zRXpf6MVTw4oscqRkOEDaRg3UKW7EB3mGMpKl8Qcuq1e/WuWzZEXZx0T7yCx8CvDTmH4pUyFC2ANIBJbfCDnpeV4aAJbzIdDrze6S5uQKpXH0aUaGmJPoCl5M9xTk9zwfeInWq6Pne7kt9sanfws0AmUj1U8U8xd4M140T9r2r3Eab7bZkryYRpIL0pxGKuTe+8Ts1YM4bSJXvC/5wOv2Tnsy8SjHyfD6k8BVBqlJLNsvXuwp7JcYJ6+JwerJ4UHKiw4xq9Bk9QjrOacs/ZKPQWgsOUaXj/3I0UMMZm2ImC9imx6+bXqU28C+xslMv3kRFuwB2/QttAKtsVnKczjlGu8kV5TndUpyuAvJvS3e9FJR9KczdEcvQb9xdL+BqFPM0lyYnSd7PpOzXfXgJlAbjaakRzoxHbw8yyXp4VN/3ctBC9buy2xd/KUxcQcyy7nhInl60Azbx0KHKsl245Q8H7r8lVC+xJtySeUxGByOedXnwPIgPE30Z98VhQxHzKehzNe/z/7ZNaeW7855GRiHYNL4gL4cJCgMp2Cfp4FN0bhs6knOAPJxdZ00v8IczuU2Nbr1a5oa1Ut7urJlhfcZESrNxP1aYHOrXgNJCQDN240phIRbguc8xgiY6OHRjL0M9u46BFVdmZ7iJ7r/cscE3s0Hqwef4iDCRlBVg4Igc/CGFyidDeD3ug08GNEuaLQO14TBnea5ge6OELQmg1OLcf+tJw/obAkep1Gvh8kIk80VaY7cDVqJIFOuV/t0kJs2g4HEPIOQqzUBHEUqj7sKHrAI0p+MDWXsq39yZ/lyMPQmxR73tl9pfXwJjXnYGD2d7ur3wmp8qOAXlCBY/9S6ccKraUTq2bAE/i3r+fUTUDRYKrWhGjzEN80rMidfI2t7sp6S+uqpwnMjNwyhnPdXkLuXZaKZWMZdGHclvW6R3CRaS5r8fXXzpHa2wnXb3PbD1O7awLV5TMjZeIonvOqlcWhtd3nQNou82tYfZ7Z0CpEZg3DTJ0DZsKQUZwmNI86dKhDbscNUDkscuzHbVdEhk5I8umPEz9i45hztnQsGthuDgSKr5aSsznXq1Lx9KyyCBVFu/Xct35B7I7s7N/BETLsqcfW3qHTjhcuyEtqVwjCaGlRY+WNj2tewhKs29Wgk4dd2txGw6ghCzIvth4Q6x7tHWFTmR4Dq+KwGkdh7vyVrNvlk6y52DAvW1im40zbh+EVHHf3SMiMSLnrwvs1TMm+OnlI8RFseJQnsk0pNM/6UH/geVCQMRUnwMTWcxBN2q57HfjDTYMmaGDXr2zpzV/y4FN72kUO+Nc615tjU2/Bd7wel6in8eEF6ywHgvwecUq5NutOiWvvUpi5yaV9yWQqPG2qaZPomeC290pTxLp6H7btht2MHL8bKxs2mhfelKYXMb6GISPExQzoLiNyxzo/PvesYBO2KcOQTW2GidVhrbU5B1AaPtC4LplrL9bIj8B0PZnLVxwPlCq1xdLl5ok11AdaFk5uRSbsqWW+qMiej58Ap2IJNGCr0kPoIpOIUPO1yO0O7mpsiJ4OBzCLPtLzdmR9q+tJrCmWPuUikaWVq0aCu2Fjsk8teJIQWnZDNCNxNwN2TzHHHVdaP/9MpWbQHHiuOKAspVxujol7zkieSaxSVlFaZxyNiMOUmKIx7w/FfycPVPxhiVjgyancREB55DW5Qe0is1nWBRE2kdD6eCywiXEMmZAYvePtK9GM1CP2DYGRLYRanDCN8D2eZgBV3vwgjzt4FFihm3QM9BdUTyf6Zra9+91Mt5SgdgelFbhQ+6jxkBd8NSwJp8PYDN92ba3IIhI7Trroa7SbwnSrqm9VWMSIzVXkwCzXhY41mrcbV3zYNuFkWZSLHB3XYOtqCnaCidxh0Zxpt9WHi8wWo6jdZs0Ow+S8Lunw4aMm4jJ/baPhPGjcMftW67UqB/jBvyAgc9/NZbjGqmGLPvCbuXNEwZxMmWH7Ds8Iq8aAguXfCLHjLxPSViYPjdv60R8oSgV2wI/5ElL2CGoHwmF+JgmNOlS1KGzc1NUTfA2FFvzWSawrs4JITZXfy980m8QXcMmpGKOj9E2+k5fzSda0b2/fw/ovq6KFzJkWBswpom8F5I3/fDGzOIdWbybPzrAGXQlngDZkMBFQF7BqlfMg/YxocGdsBhVGG6Ch4ItTofyg/YhkbqKIqKyjfkn1KLY1zorE/2S6xJs/zbBE9HEDWpRWO/UAYS3JO7QX7Fd76qaFRES0cJaz/1+ua4Fu3MFWpmzCDVznN2K8/Acw/4j9Ops+YqwrISo27WEYBsEIDqhz4NXoBLTws2/QPNcS17iqwoIWPYPpNMTD+wjXEK5S4LQn2fw0rgpXtPLMwPxvV0KsW0txYaTecTjgBfYAlTrl1KUnNZb4JERhaBhMkU8G69oPCUCZTaDK8jxLZEOltE7doebBnz3hCka0dFeYgZhevle4Eq2OQdBGU4RCbyYzgQJ4wB+bWc+UV0RaZlah2+vTlx5fGpvK5qIb0vAOrp0Vkz3Kydfkky72Z1E+hVChqN3dC0W7An2AMybev11+trNS5w59jyHEI8COv2Cuwmm15lUajJd+8cFbLh7DgbCxUT47x/eyn2BWNn8G/MuxNat5YnJiH6ZrxPPEPRFtVd0wJw9VfdTRGY37xPgIYTvMiWqdhbIU2/3ZDYHpAcolHkh9yCjcaPVSgJ1LzEkySx8if3EyrI6bY/tdrl7KzPq+dLPPSRaecWl9Xmnj6/RX9o48+IyhVs3qp3egyvpmHGHQCnOcmiGEfTWJhbn+NEzNbhKvRFr+rSOs+3gzYpwXJ3OBHNH5b2Jwr5e6c1l7cM7Robr9AIbtpGxVHfCl+t4f8bTvoYf9MDTG73r+CJcSfiIjsZUAr3QfRXQNfgBsEp573ly/QHqwVeCl0yN5xgMqRUekpYDPjo9qAmKhHKZ4pLlN+1memd0saLrSOJlUlOGjE1MJKW5o6USghfFTstNpK/kQD8BCiK8tWWOT+x1owL0Kh05XiHfzkdl+KxU37GzC7md0vmpdnIW+jJt7nl99maSTm7lfqa2QiYeqZpYwtTRqWUNjWYun4H9nzhfyhxWDevxoVVn5tknz2EmLHGNc8LQGenwujszHiFuLvuMB/W61aRbx5DS0JC7hZVIv2pg1nY2rR/UqNOWtxlE7nrBqIoYBjzmvjQS9jamJzxZ2kd4Lw6RW/uEKCcrEGol/lXsJBhNcajHDH7qc6FBp6AKTQuEeZe3o34x1ZMPVM8ebfwvwyDle+Ob9eGfTL2Tnwv7fRDPiatZ3ROGpyr0/8jVZrIijc3+gLzeIgX5qS8jTcxZiMG5bLMjmhFOKmloEJX08vEvpYQ4pimPHc2Czo9c5Wnbm0bpRvciNujmpiklSoY3IB6Cgo/fiLuLf40JPGtbpLiTDiznuKYcmStddRIpMH9lqEL38E3SsvGhBT+UC0yb4m46pDp4ZEWRP5wBkFVIO/IaEnfp7s01y7Wn32Bm+w096depjQlmz8IVzOFHZt/27Q8ED5VQO2IlzUFdA30kSRb+xJqeWd1FC7sJAHROJzpr1IvfZ8v37rd0Pguj8CRAS16Mrk4Pp1hKpEnUiyBV9Rp078JrbtCPyMAVm0w7wsGZoRqjD/5HM0/tTm3fHx8Rg/Bzjt+4ZbEMdBJj5pPb/J4rEVA9g989+HHbHAGFjv1RcwQZgAIOqx2bt3jVR6470RYg5cwkxJEtzax6RcUosOJ7gs/kiM0/A4MFF8Rck5Vd34ksmnDXp87VkmEKZril3LgNvs76ChfvY8UKWc3HaTYQ2we+k55krFL4QRGj9mWo3YTvPMEOsou6zusjf5G5icdpCtMsqzbBotPhW0O/LnTLmKNC4wBU55ymTl5USndFgGDXbCNDOe3xNgAuOSwg1wwQ8dg+je9oft3nalRvtSI7reOqy8v+mvVJYMzdj+Oeb4yxgcqWyLB4K1R2XLO+ShwVcdU9ZSJEXdSkg1O54i5XwZs0LrjN1X2r3W3JQkLcEYSeG6Ho7SamB4vgO5lwFwqU/d1IsjyMfz38vMUX9i6wDl96JGlCcJssDH3rxP3wbm/EvVBllChF32jAp/JA4cCfvqW9/nlEYpE5uDjbaamSlR+jjhBZU3oiu5gIoDLX/hw9owuc+L7XPP8FEn9ZQi0U/MAS6RPKj3wkmXhiIeaKpmFi23TxZIroYmaVlGacF3zKFAlmaaPjlvNB+yBCFZ/7rCL1ofWak+w43fLRuIF3+PzF/Tg+CL3aepckkmnqkHpUTfJmbCAthTsH5IyZD/SiuOH83J6t3BPvwS5LS1Kxs/iqLmLUAklPJc5GtUzOot/TY17gd9EtZRyfY9RSS3WFNJY6RQHiyO4qFQaPtchWibj2CcnK6oMwWImIZqsIF9Io+FgEzETZLyRs1I3kAghuHl6PUtPtUl6nImu8N4UibGez7zRjiquuyRLlmBzPoivSShyUDEKigu7aDJaz8VeAP6xaqVBPCoIxh/6hlslRuOpWwFh4u5aZpftISbrcNg9/vCTMCr0vz2QD9BHF2XeZ4GUC22zu5uhgZqWYUwe7deAHIQnvhmXZpSHZjrRXHrwvpJrKW3ZHA0Lzbty7SJ4tscjaia7pey3DfPYs5tEqoEpJxYQJnn79AjO00q21IFa1CM63CaxgwheiuIz2E2HKCfbuxeD0sbwNS9rJTTIVHFHhSrkyN7t54eu3tb/dk/s3FMkKiSH5XDZT4Dp1Vxs1jzt6ct9vxfyh/mgWEkeKTzrVIknFU4jMwmjvWffZzb9TFmuQHeOV2V790J4Gz2BQ7R2Qdf5Y2Q2bP4FSOQvsHcDGznZpCDmTHbuXczSsa2KFBNyJ5aypgoYXUu9IwabpZ3xI+zgIepffbAcQEFjzE4WyUx8PHe/JIM1apX9ACau0hYE0DO/4Tq2WXI5lnK11eB2Ic94Rh69wN2FWM2VsxV1jln8ysbVLYdBDRp6lDMd7u8o5OvsCesU7y0KD85pNkk3+r6BMZjZMislFWl92DRJ3wAkwtwjMunGVk6AMHqyrCb5nIZorBmCh7qoKKAJE3cxciYfD9NBvFC7Jjjj9GfKgYwQ9UjM+12Kwtiil3FFqV5b8HYlyZ/HEI3dgqWAEC7E7vJHmHEpuiH1awkSqYqs/kjkxTOq9AbQzDN6w2ef4zjGYHGX5mRcbxi4VYGXheoOsp/yuAGRc6h4Cc5ydExhmNEGq/Zda5penOgb0nX3Ltrx0pkrraFQOOrqJwXtw8YNzFuMS6ZM6/7Ri/yDvVBTMvC3ino3MZjnP6QC/xaYf6LgUt4jo0FfDFmCnvRIXxIdynueWGLwxB8I8mIk/B9GdTzOrmP8pD7aj3/5Z3YAO396NAqzD9kRjhpJ/UmTo0Fp7QL57sZ6vHvVh+Pi4/6k/CFGQSgsDO/NrF2Dh6NZJGe0MZzukBlinEenau70MkRsZvsiuw86BYf1hripBphkf+6QIn4dkAak4zHKBltY49dMWOiTdPGVo14nu+WJ0Rh/4mgIFrXGp0tKo7uocCepbkwUWHK0cs4c0qfGuwn8kC3qoIWshT+9Lfc1i6k/nfz7atQSZlJXlnR/Mxuoc8NCKJIda8637qnyvPmULBWmvaG61sdOh0L13n7LUeBdJYCOLtwlYbrdJyAHxBtcG554qyQMYXsb7DtHD4VFjZ681hUwExeFQMISZOoCGs4DveGL6W1im8g9xUMbWTSnEhX3vysUu5xDbAc1b7mJ5LZoQtES3RHfHRkdCZSFe5NHTTmjhKruKh96lGLwKDT+JRsnBerGxrognbRBixmSvhTjldoJpmOPoklCSzmC5Fl9s4nTT3fCistHh815tFFv2jjUkkxLcyNqrb5l+FGW8Eq80vkiv7dwYZkw4YZKauWDzzZhVCla8sPuoLd04msCMZEE/OqdBp4CIZPTWGyD8dxTwEl0XlfmgJMgvWxiotblNhIEwPwrAbJsReZWeaAlIpyqa+3n2JE7iXIYm6pwMEgx+5fD4QLmfN8Bv8FYxkeKk6gcUw7Z67jxB48Q/3RXUUuJ+IDKTEgIQFvsz0IkhezTr4DsydSJ00871s1+qKbsl0zVQDkscwCqvmsWd11FfDAVOwiPC70rTJkJR4SQtZBzxEJSr5xPFQ6Pg+15tPcz+tsj/cXHWrTBjeo41nDLjAT2lg7B4c7EH4AW0GWqINgxvthMGEowFDaDIk8patzbiJy2syIY+3Xgsw59TYpeR0fSoWUBaz/kb65QTrffsVbul/677RK3hWOSAOhAglB5auc4AQDYRqoPg6Msv+VYKhA6fvwY2nQ398RsYms5xkFvHNmk9j1EsHuLLApAb4MUQx8jra54HlQ17MzjZX7OEgWdYQ9WTSZ8cbtKIRbFoBuk6R32t08bbuSi1DBcK3ZN7pPAq4c5riY/larpAKfTJcsD8r0yd2xejc/oCw/6sQBxbxmlC4tWN+MNrnmQYnm13zmb5WuCkPIyr+vCsXpWY4Q+HATusdGKA3/7C6kApFqG79jlwXxrddKgL4RLNOBrY9LF8YJ6K8stYfDGgNkogBj0S4G+BxxQH90bGvE7AfGvcsrGi42ZSunABu1fbjDFcZpg0i/3ro9tAB9eux/sVL6+jv77O+GrImunIyJfH9dgRA1IWPTkyCK0S4fEYofWytFZKKOTgcirntmRmXvW9vKM1vN1ajzeIvHjED9qiXtn8+9rUIRvnzJI08edeWoKXViB9hfBe7t68qALlOF+JNOsZxEnqpWPXMuqLkTRqno04RW+V/VV+Wq9RkVEmdSy15jsBMTH/23xI41N89VxfY7AjPE/HNN3AwVTIby9BYN0UHMYXe93/zDpconfSnudUYs2sAs91ec3gcJfFv0e+yDPLNmLruPbgFbu8sl92wAQAMg04BftueAVEmfC3uLuwWjfkaKd4A1/fPEeE/eESX8RLUrD5bx/v1trud7BEs2PN/fgYEADvmnjaqHJ59GNHh/xWmaE87XCdvZig0lyN1VL1MV9lyLPlMHWMjQCsG6vOw05z7bzvaz8e4v4ccH+krsG+tLm0xauhfQKmt1oof7nzT2URF9ttQAhcE6fZ/BR6Yj0xS9gHxSeGLGsDV0rejAjNbJA49grtY9u2uihROwlOk1BihMm+G+1Xpv3hlBWZakeLRf0nXTRw1Ln296LGSeWX2YpY7/DwvFRzcZiAYUgiyadhcu6Kz2f+A1s6REQ77xhqUYBtY1+Dj/XFNHNBpTX2JQ/rORNbZ59cv9cCSI/2bUr/kd+z+XTXYsEZi1NQsR0d6XJb+/0uXGELDDEx39bk7m+diDJaaGNElH/b/zrF3KV2YQ+BjJ0SqZlB9yzWgpr2U4XIA8RJedE6PKkI1T2xqcVTaRKIvMMxEGUEHk2KXJD93q0uXGqveOXMomx60T7diZLLGD3gdSMRuxDosc0n3yRRaL7lQeh4/Xqf0tRy9BV6Zo4DduOi7wRM3ax0ll7yk9PwM+AczXTitN1v2M+I9TkcWzXHDpElBfICCkJgMW22p4M4m81chWu4PMGzL/XxDvdbZHTh+2h6PJzzKB0YJMDjhMFj+PHx988w3BofjtWGQDj3QQuW9vtTGxN9Vp10lfNasH+LaNYS4Hm9eCF/d2lP+Er9TdyiVJwkjSXMFqopisNPu2a7/aAOihJTpMxZjWbCzfBVJb5Z4gxhyK8uq91KElMV49kEr2Esz88BIFnc4VVLfo1BMCvxqVfhk6UV8yOvzzVjBGLVUJlN56P2XF0AfJbIGTeE9xjhyFE8EiGPNxQPWK4rQR26QGbjGPVSAFlAuOsQr7XeYAYthwyZ4p9+Tr6gW6GxODTKnKji9OTQCyoy0Vaz1vg9kfAbTWlmm7Ll+qWXwo2n9n2pC6DBXNOWGQN2K7uWhKlwqB7frPqxzltwEZaQ19rALWvN9uokch54pMHBrtiEBb+q6SFkKQHkxaAsk3tBmJKlICtxiL3zvUF3bZEuR8QMuNaNSJxgzWdruZXX4v+69XAnCb4ARK9IAUIZcc841i7Nyqa/TGpqW281LEfh4qbduQdbLz6fTYPAQAv6x5C6Sa67Fv1/xC4WgY5L5ljeSKsPCqmnOAEZ6V1S91na6ab+om+gdKAfpOeUNTFLvQkv2wAwBPDQiXxPHYA50+8uYHlrvIgXKOUbva12AfjZn72TMYiZTZBXddU/39awa2QMdIv6DSLCU6eco3ZvXoD2TJ72fvLTug3tOrV1bGzjcqyvpIPhKkJGPMhX6+sgP/pprKtlj/94ZHWVZaqOcA++xRu0BKZl+5smKgAKKo0qOOhIvH8n3tujOHKwTYHNZPbYgB4igm2Vz3dPP+f3/sPVa5zW5+0tJaJsrVUkE4yOHo3n9jnGHOo7YPRB+f4Dc24Zu0/WuhjZ5i789AchGtQ3iVp4mD4Iua/5DdftGoZVc30VOL34T+Yhc/+VihmzKusljSvo1/SsyLxPzGzTnRrBJpkRJzp9o6E3+jCF7BZGH6Do4DC5w+dU39fOdzGTZ0m17Kbz7ZxV4iUeShZYcmaG0wMAx454cnUwtNS0rQC7YeeuKXfrukOSWClv4OTaFdXYEKHGGxGl0hPQQXOegTmd8pkqj8x2BTxYszqYlQJ5Ixtz66GuMoKvn82Xj/4sqHOR6kCTLRXaO3eoyw+Y2mcj6+UbRBevqfj51J/2WRGTWQhmRd7WkJGuVH+E6PjrADNh5y5d9u6YBlcUGG1nDPzgvt4fDInL7DqDfkrW/1wjqVIomC5di7q/vOSrJJBnxIiX8D8WeQdSLtwHwFm7NYbHl5EnFw82tqhaaLDKDMWK6eTyR8Y7NIFqX/QZkwKpVRkFrZyViYr+vP52Zydhv9HmSCwv/fbXW3jj/pbDEDjkuM54R6ldDrrwTvaFkBEFGOa2z2YsxxI8wm+aeUdnp+p3fL4fkZTqfx/DIfIuzQ7Q46T2cwoVI9gKfT2KJ5pzQ3OlthsnHY8+5/kYXrDcXjqoGqyrilchUGitll+ufC1QNOjqcdHbO5u0kmr5M/3Hq6GM/XWeQyNN8HWI+4nKvNxNq0aMJFUd+/By/JgQyUBH9mzROP+nkUnzvgP+chv2gN8X/Wqt2waZ/smG8MPy+CzqSTinOUu90nLtVygU4r9KghS+bTQDn1m6jOvE8o2/jcO8iehMGXB12W7iS8UArDfeqFG0T1LolkSQmIbShn/JGawyZ+zCMx2ke4A1gDGEBjefZBTs5/jC6bZGkGVA71Qp1N4mPHdt6jpYknH/a8UTjzdKAw9r2oYSNv4fmFOMuCDgECk4ivx5R1BcjtFSW5UhUPG0Twiy8lzSzUy0kqwgM7jRwrO/+OjMjkI0iNu/k8rjbZzMkSbCPaR7NtOhKirKk4lPZKyZ/ghfJaJUj+eK6hCh0Zy+jKS30nm3s7Uo1jLbvuuTcxE73RQsnuAvkGsHijRpGInpK1gCPAmzfBFwj9Agv6z2sDzD0Aaz+AeJTcUvKMqQ6EnN9yj8EU31LnF8u0Pzt1hKne9f+bBaW3iM75JEUXrhLiMBbgICuB6HQDSUBkS/WWCx16jJgl3++pfU2XCBy/AYXbggbNwXUxNm+T/EsqGLk2UOyQOeVYKUn4BNrjyBGLBtdadxilQAMasu5YZGopMjZUieHKaIK9eK9tBQvj4IUMDQUGZs9JI2w+l4WPfUM09f0WxB1zZVMm2llGfjq9umQw4m1J0/bybi2OJIAR7PSUwTgZoW9sDswe260sLXOoNsTqskMkH8Xl9rBclDtjk0oGBtqKvHQo0hHkmpCkOkT/NTxZVa7OGzRQALqC++EIxrhIUrR1QjuhsbiOKB57FCk/0IlAB4JS72t+EVFCHQoDGk6ZV+X+CVYcSuKyTA6b/v9G7hi0g3aewGJXJ/JIAAaQBIcsSKfvjgh2AO/BGQ7n3JmCpu/mTkGJk5FOZKK2iA0sGUce+/XO9Y8tp2dcx00VuYGkoouLGmiKSPBUhCwLFaPoOzSD7WMg2sDwBFctLB7q0lM28UlUXjD4veAnFl/DmnpjybLpeSCp4J38YNBPt9mU3CkCobpbiNA29ajDTDKl6qu77BtVaU2yoJ3XJz459aOvCogBUNqVZrQ1cOP2tWhNvEVT9aQFgc9eZhQQUzp6xYp+/iiwjkfMRD4ffblydbZkEnlzD0PsLgAHWPMBcv3GOWeCOiCNRT45FC22XGIj6jGabomoktyRdX4r8YjVepb45Oqn4n12NAVEVDvx/qlksx12ebKs8mFm4h2xNKgV6RxHECsVIbduTFxXb4aOe5rny060Rx3Gl9lPVzK3Bi2WFBwrT2twddASQdJBl3Mt62JKnyQOqMewi/Y/8mHlQhB5Lbxf28fn5clvLqUaLuofB7hmGoKHXbo4FozeWvxAY8o+ibBQQPkRtpFLZnHLW5QMi5Ht6udLMLAo0wYMIPttMhJ09ukgPw9coljri0tYWgGHYxcgE/RB/N1IEY7L+fPVJMk9nE+5ei+7EkS6fIZxW2g9vHRu9ftQdEYrGNkTLXrcMekMPlWcauUCeMZkrZ8ubN2ERFU/dysPwP+/jEh+oSvQi7C84eaMFxLZg4+5ZTeBLwrax2OF9JGGt30wqXSLXiW0B8TYEyw3Nj/Rhq8vXujPcXSGaUubU16aC6ld14v3kDBUDXYMzt4c987s4B4zjfzgh2MEE6g1YgWnbul1iHe7IK+q28VkTUaJPq5vuPwEmdhjQWel8dr72eumVOXJZyukBssOLJ0rMOwX0bEbZ1MRFiCZwrHEZn+zAbkDWpHZIw5B4hApOYdT7HyPRSInYKhsXkdcldWMJsQJ8e1mrqFixNEtlegMr4zzupA7ZYdJ7oyuDYdY32o/zuuWnEpH1n/3Cqg0QaXI3YArpOkCDO8ZDbuyT1iQ2+soMYucEVTgrfZeZ/+YC+nFTjZz2IPMUbtc65wszU0JaF22UU4Bp0ElkeuPV1tKl6qxm8dDYhuCXzsvbGraI8/K5NezXcN8lOZBcxw65+Hv0OyIxQtMRH7F6s7D5oFUH7dRyFemXLcyzw3CZiheIzp3PNl2eiCZn2BEGIdZgxUK/PzABmp2c/M4ktd07aB4RoMdPV+GiCwK1f4zDva/aeG7O5Bn2Zqjn2yBq0DCy384Y4kPQVMg3nmU06patD8r1/7pGb+Ohb4ie4uziJB/XeYYUTgQkaRj2s/IarfSK/jhzu96dMhV1839qe53MsC+wnsBizoO9QqEhqyTew47aDKLUwDFqZc9y3tm69WFzCuhqTbXK2bawTy/RR9Y5cnRavU51SZEjjGRGJ1P+YgsfuaB303wMDZfWoJWnIWBoedRL4/j59We9vuI6ZwP6AWkbVGn8I03UCzIOQYIHrBa9SQfvhpkJwlUJcd/3Qv+YMNdgz7vFAXxs/BmIi9APAeEzuSvYGzypTlR9MyMLf7B2eHeCH9Wq6+5olXMTyK0V2fxSRMQLrSkTqzz2xjEQkCI0qqUBw0ikAsbNyfe67nkDV5WU1w/WMHHmWGw69szrZJzJSNdZncAmP9LHIHgTDhaKw9PBxm8+BZgvuAUz6ccT59VFU+o7Yg4CCGWc2d83Dni/DDLclnYh2urrwNG2wcFYOWsHMw9Sq53m/b+lePWw9GHl06+SSFaeKSBkY2MoV2+f9jOqhyRs74RJoe5BH284it1zGwZF/DgAM6xkJzijxbSplqJR/m5CvTMIn0XFVOvHoLHfc/fccQjoPt3bwz+bA1X4BPVhjHhOUh++yB5vpgWXskePTvRSDGgvoMqtjvXuDfz4fge+Luj6pmTTm23aA72AFwFSPs2kSuc58M19fOcboqVh3Mo5zLS2gAxDLEp4i3+o0A0366/MmFPb05yhooMBnCN9OxDBrPS4zwBKdawN5YH7jFkRqB9UXA+uWBnlYkdj+QoRncPv1pDPOrKQeIUDDmkpV2C3UGdKzIgplT9wKb8nH+xFFxN6xllW7EHdw0u8BzpMYqRAC28xHoWPEdz3G3xgNFCP3N2VefsKYvBZ+t5jI9FSw08k+X0mwH1RcGBXzJ3zbLpzNLBJopStdzla2PTr0WEV9wKs01wDY0niK9TgeoxDpbi5qUrgxirm+kipCfHHsJYWFCCeDmvmHp3mFd7/0rVpJOGEU7opXRslZmYCb9ZcZnb2u46RNRgm3ylt5A5Qw/H5QKam0ROCCkWAFpl2nxtiTqKYMmE0oUN4rwfwXg/PWWkw+5be4MKNBN+GS8AoDliwHLKKemPlbwk8Xrwfha+4PNKFJfTunAvhVPxsJY3HEvHTJghCeUkouFuhS35zcHTEdQb/itk0DUT6LnWIDR6qsKycKlGkwn+eT7cB0tMr5RMl1/RGUXILdCo0u6MEtd7s7tR5LhW1iCAUMOFUeCLS371wfuGGPSd7VEFPEUhjnDTQ88aFEPe2J54NGzvF64sQUmPUmD0iWEjfkDzWpd9XfpwMSOR8/5iDfmYXXoL8gxzhtZhvgexd/mu66LGmbX+kuMSRI1uz4DPfC1isAUHOfOWkEhY+sZ9MSAyTOvIB/tfX9hs4kvFQydydc2f1BEWeNmxbWaI/ts37rb1cLzkVBZAffgvCnVUvC9lFBrP2VE0tjHDhCdFbuYQs1wIDBlkVfI+tnKLgBl3bD38HjoQ0Y/T+ozCDL729jmEetmsFv1PAcyKdcVr5OtLjbSIkrGbw/D42pjNrgZgwIpmcJOC5uDqTkd5il/ze/vvbmxyxifyaPvTBu0haaQo7cL51svxbjSfC9ZhG5n9Tkz/O2W6t/hgH5yq+k4xhw+Yhf7yPpuCVFWnMBxchTvowbwn6lzv40MRcFaCikKVucBqEnS8ILu9HZrFPDJ/S+A/iNr59iiOGBFXB/FX941pDW3C5OjeYeCnH+2gLSzLN5bIFMf6EqCk3fSUxSjNMRDyxJbujdA39zt67g23Bb0bLSR/8sCxr6OWmcKUTg2QhbFU/GeIKEKu8B7xXH7h/ojSvwQ2KyDIdQqrfJ8ld8RDhrvEDFsNYLjmFUKovUZTK1hM1i3CdWyA0Y7rfyoCDaqFyaxiMCxVtFuX1M8YXL9kMyd8Z39aFR0LgrafWLivFg02bvFHAPl7d6eXxhYrT5HxN+qQQwHSQOGVUqmiFi7QixK3xzqRw9ZjDIHrSoPFyrFkz1QBdq/PR+jerWm6Do0xDhs2J+JgABCkuE0mAsWzsJwbZA0nF9vDwU9N4n9TnIhITHTtDHv3IGXhVLqQ6pnk21ARwUznUq5D65PYqrpR6hLHOIinFRCuC3vZZjz2aAP4Fd9p2ngPS40Qf8r3jdXOUrY+gISLmU5aLz4GZZhakAEnWjcL1dC0oqavsQVSOndZXAZc4xJ0f4rSdMjxWRIEEF3PgJgrNN1M0CJy6IbDnRrZe7nbHHQ5p5Jh+F7TrUSiyvKs+ciRHNug1Gnu7ln3IaoDHnI0OUGJj7LMa0Z8a4AvjZLU2dBPGHlMmALcFV8bCwkBg2aCesVsurm/uxRWZ2FA+HivLim9HHxigWGeL2oC7JixytyzFJAIFJ6Mods7AP/Doq4sw8Yv3zfleiHiMWBw5cq9rhK53T/CSCsbUXZF0/tLu57OXE4jOD09pFSqRAMYYDhQcS8W+mkzeh+jFZmo3ibIgEcnueLfZszjpBiTta+SGIgZZfGYSgwtU2iWT/z6lRE3VSiQKyUMS6xhJs0dZRUftvhxoS1RmoKdRPz5iAJJ0y4Mz/LVrD9wgGpp+xFXNhgbrcIFzaCtXopRXy9i7hqonsHR+QrRb8UNOGd3NsCeeaKVLbi6A8HFiSyDqDLJzOGaZ+y9fs60klaF71ahXPg5Q4sw0lJlKKGSd4vlzEismZcDT6dZBxGAL8YFo7+jwkMUcK3dBUzuyMBbxgqe7kiHYNAqdtdHu4ddSlyPUgBbKCmbtQOu3Ii3LyT3LUTVuLPGsk4EUMnaNt3u7vRQ3EX4R3CR+rPILtVrvys8fv2vPaZcHllGkuXrldN+ISHoQAHC7qsmcoh3coUFrTZAatyaaug2iF/iEijsKt6fQyaU7OEG/lmtgPbAa5snzxipmsbUPpABRZrRd5tQYXX5TQ4tusoac9/zvOBQGps/YYlISeWLPe1MABl3aRlHpDY33JEVC2x9rmW79QzjMLeRPUDO157d5yQJVBInhh4Mvg0H+9Nmno6P19Tg07idSjWZJoF1aELE/Yqvh0bVnmuJdifnRp7jN/qiD+ir902iOdqlUvqr12uEENel0o92zfraet6VGHEllT+rJmLnzYcUpQ8X6pMMJmZxPdcsqAQeuLQuOo4VlABfmoWPGC598Chi0OaKBHOvILjqZBp5Ugveuly/VCEVG5zUvr5Mt7r79Py6yR9fYY0l/1iO70mIxXXw9PhDIMndCQNnD+BlQ6quh21Q04qsnEsp4HuevrJoe23yupvwTeplZYTXTLACMSlG9i4N2VUi/VY8mpctAYYzbV56OrYZWpPG7TwyZ1AUyCamk5GQFDl7QhHqtFdNMxERcYJfkKf6855h9dF5nCGlCzF17d6Nj3ZDarfuFFjPM7NMIR+zpDgs/0SgCxcFga8u4KaB6qsssmBC/BvxdJM+1QQSfRFBUuIxogpvwg4Hozv8q2zqEZw7L1PsLE69Jqmvls9Lo4nyOgJiwbewySC1ip7QF6YCmjtpK62YR15G6MBX0en4qf9MUQ22GjaE2yq0qXfhOYMGnrg6WwtqNaJhjEFDt2bPswUSISL+8/dE7OuNrcQtbkkxQwCwl9eCHv+JNnS0O5LzqY2jwKix5c9C1skYgpv2jmOGRa2dvb+4LCk6G6VapRpwmuh1/dbWOnnAOgoFzM8scGNeq3M5NHXGUY3z1WwsbJ/fPvx2lHsOi5Sl+vDaG2Prg+LWj+ygSuYFN+R3OMH4TGAJYwxScg+Eof/4bv331uiBujoaHzWRIB+m8s3T6rD5Mfqxdb4AhBV43AxgrXauTaIO3XwBjiwycuxjag7YvC+ox7xVVmZfwkOXwG03xEhtDvRQ9+vDWh1xRnXyTlV6zmZWmtM46/BpbsaIxGcKYZmnuhFtRFNABKl2G+1qRoKDIn1Zjtoi6HtR1TzocG/6pFKh5p8zj4PpE8mwRvDiQQTP8osRogk66M8dVQ91VjS1CTbbwVV9HeBuNKvGWgnsIS/Ky20mVutyBcMzqHDTgxWAWHjfBf4lzev9/ASB52glfrIE3PFoI2Ca4Yt1W6st/hfHZf7N54xtLrKGS2FLiVgBvJVBzU9YHMj+mkVzgkLzaEueVnQo0Cbl/5fvKGJJ6jZHC9TMvBEHJx8EQzuvv4P+9ahn2PsT0o9t1USfEvSuWcVW08WdWJJVKQJSyQRfDQaPO8/RRDXM8P9+0iuAA91NHT7R8lS7E34atQ4RbYA/LTw4XO4s3BOPR1ss3goY57cjDKEMMdzz6ULEbKXqa6KegXF3RWNM1bQdMzPDHGnBnNfUG7SPHqlPPqmoho9lm0kK6XtnOLZe9mhWzDYqgHYZYC+8x6GicylgjRiHkQokZF/NbbDUPIZYkqL8kPG5DJc4CzrZx5mmOkNKVJe6W8V/wmAQN7YJVb8PuwDn7/Xc49Uf/9HcZTGqDsIB2cHVpqGqgP+JO02uLeffBZU+1Qbqx2GABdzLXZ9ZQaxbknjrkQzKvUfYdnHhfjCFTORhl2N+ygds8mYEgYYV65ix1zjTV94ptUDW84Hi5g+Mwbi9zxCg5W7zIwdY0Fv5YOJBiuZL8dTvdgZTu2lWxdxbw3ReJtvqZCVPhxgKnuZOhEfgUx+puXD2xDvcLoAVrlM6XOFg0orvYLR93kzG05QcSFDjAojo6zD+Po9qzzpqlnyhbtjYtswNXMv++llZqTBSWDPe6pLYm3pgSR9y8DfMNJIpvoGfQCAqUgVgWxoq9XSiSN/1P36s1AdFv6De16gzoEih6hXCOomdmZ1cgBPU5a5Gh2MyXydba1rCvuXpYY7m0ozsnNu6XnC7kGHUFFBZMrK1w+uRTrPZ+5UJ3DLRFy0s493YnoRzdjv5HwTFVSicEN2lyigdYpXMNVm/0UYcS3YKIEd2e37OQl/yBzJlzyJ9Cv6U/E0lJlivzn6cT89rIMl928MqDmKENtPkX4L0ZuFrzZraunHZJia7oRuGvIuGpnwJsVXn+MkFOs6A2UOvIpfktY35ZH2FDMfb5D8fYkEuunnXGMeLLCgNIwzA9wECUj34tCfGOXOwY/ySRztBITliuCdh3YDpnFdhQP+bzYquFlZ1zqjhWyZ3BR42ul+hTRQNlbbbKUeZouxRrz3x5C/gnorlip5fYsevoV54puzSuFLF68nO85dSrg+QuaWwpNwuBtegSg54VL/ug8XwfUOpbwAZS0kqe4XNeIDoxtJDmvIty6C9N/Rs/jMYSctMUqmIWGS5sWvnGQm/pbI01UpTIE4pKr0SubqDm68hQYpXVyXNfcReJBN2g0kdvtSNXQka3wqG5EmEjbdB1weyFdWrbRMaa4orDYoFxXru5V3DtGArP2KBTJJWWir1TIc8lgBM1GcnxCeLOkbE2fbFw4H37GoMnMjJvIFFUhY13sR6VPJgSWd//aQSSGlKxQQb3349Ao6lvZPcwMHIz35qgDtCOY2F4z4p0wc9xZ43Ad6Ue+JFvpBSbngJ/bdN5q/pBUuqeuGe5dIWQ1tACmLDCATHPc7Py/30cQFxsP6KQzZaC/FvOe2mf7n+F7C+0AKKWj1H5bucrECAKcX/fnMJPFGsFG/Z+ey/MdCn1CgFSpolVpllwk5hMyr2jUBHd+4YXew+GvMouhbFYsKixfg74vCqP6Z7XgSocxBlci1Yu07w1z0VutfK+0xSzR/9MN4ea9qs0CiiVn9lgPm/8OMst4HmwOrGO3txfI8keDbNKGNtp9smCsJId3ewq5DxMQg4bhlIyOwEQ7l4pCU1q4+E0IwUfhU00XZNQXIf756y7VFKnhfvH3Z0TlgaCX1DsHGHe4nV4Bo34YOK8lJ8FyOQ5RuEEOs0dsblBrhoYpDFynqY7uUX7HvDhZE7DfHfQ5kI8rrrK4n3KySuI6XzCYvDxUYKjw1Ul5oju7TKXy9vAsC/RzL48iMof6zW/7b+FiMwLSNQqL456o02Qq+R1XEsLheZwkDUQyeIuuBpkhdjp/kriQXTkw9x2f+MutouuMclSD88A+pRyVTxEE4j6hGxJFn/cVcZepck80/KsWZesfnir0HbpoEOc/Mctv6D2fLeOIqYj2W6sNJbxPLN3+Cf6QVh2ZWGUcVDinyTXAwA4z1MY01XZ3PtMRZsfA7VU1xiBkFWecroMTwoFsQcuKhfDTXzpvFMui2hnvDQs07YLTvJmt46ibHe+tOC38k0l7P2gzIDoP0tzLfLtddTpTsCYXHzdWeMrY3WHyPS0PXxrmaIrccfxjyCV9AkzJuSkBTzwpusE9vTsFsIRdEB2i1q5MZCbF+Had2fwFTC9IvSpgoTSxHQjNYAz+ixDSCHFPk4aUdAxqydswqmX04Bh6g3DOyG1mDdC7t+Hjx0rhOl79u+Vt0d7rroZzwr4cnvAyh3knl1YRaCgAyY8gKfX+d977NoLiSKcXd8Bywfe63/ShJuMjfzPRj267ESj4tlHxMfT0Dwtsx54zM4Bp9ulw4i6ODtSUJTHuJyXig7sBkRLQz9BHGITLPrXfOEv6uny9hqoh2a8UdT3sE3gzwRsyxw82Df3d/gXOCJji6PvPiT7I4ixVk55Mg3oXsLcvQNZr5dhpA8pyu/Ab5xyHDKSJOnbf0XRx3b2h9Brj+hHW5ItZllAONdhxxNIJk908efNC5nzLU+J9nv8BJGZDNx1lpPJ/gpzUVavrYo7F7DxqkGKi0qT5dD22JRNPvFtVkRu7gC2Tq1LWG2mw9vXnTPfLPA/ruDWuczc+RRfIY/oNhT8w04BJn3QYS88Ho9tIDXUyh2jrMowGnpX/Xo+tgRxxeLWPGmkgbw6cICje6EUJV581Cf4pfen+iKioarehnHgCL1m9LprNzLXrRaC6fmTQsdCF4E7Fo1+JuCpZp0R/4cKkqOQsuhq2EPEH4ilXnakGWbuF+3F64ZIda092UWh9SbXSVJ5ghnmR65FJbXlIfD30GJSnL+o8HL8fCuJlX73ORAkRNdvU0J2dGZBNEcQSfLIRc7GZfZsMYBRf6dC28JYoY17h7Jx2dVbs/v3VnJgx6ao9E1B7hzJsZzpgHbV1ft9F/ZhU1t0dEqNk1f7wgNaHx542IuFRMZ6cGZuO2Uh2Ubfj3toLRENhxzWjm5FI3ppt8JoR1ogXhwvO8xlIjssy35j71h6/3HG7resgWAnAtkorDDrAnrnoFJj5S2Rr9qP/mNKXE/TtqYdmZHAFsdChF2jd95dfhMgXYczCT5NPtmmvku7CCRgTdoP8k+t7kTwVoAwLEoRzLSDs7am5Xj8tLXZbXLAQWR+3helbgKO+Fk9D6o5DjprRRtEtpS6Ko5dQ05tVrjDfmXx/h3h7a6tUvAjhr877s2auDWs2+IRyDuaDm5KwFdCQh15I7Zl6AOjydaLWztldxMrrkR+oM5C3iua6lPutq6mHsV0sBuSQ4w1GQMhHNlH0/ce3k88wmLewxy5HAdoAQPFbylTZWNyuJrzNxjsZZoLcXHSmpixUn8+Gjkp9g8SBAP/jWpY4x2mAbIbXbqHUtN42GCQ/IhWHt37eZr3e+ctWtza0kK9YOGZa1Baa1uaCLYMzrXc85pb9/mfxGbq3EgKH/VcKqKo7wTrfb545zmamcMDNaPsXHLbdPcyqkWZ2VvwKa9tqklDa5ve82MCuA7jyPtAkDEmIwxtfBr0m6IWB0/VHuPFFjE+zZGR/Fhv9afp9GHmgLkhGxiC2ylS3bof1QPfLmr/Jud6yMDg+/F0PLl+cwsOBZth00Jj7bCg86Y93Oj+QmxiJTSeRfxJV4ZvlXwEbXWLefg2xhWOXFIRHhI0IjsoUo8sAJr6uCntf8E1sT+uurcT1CghH6f0sXtKafPUur5rX1aQZxHJ9tGPjCBtXbcH5WLjr8j5U/VTO1/gYNMq/dC25qKH2KS8/4Dt7EmkntFRP+cLx6ASy/A9vA0EgPgGsDgmeDyLtGBQX06Fa7whTPxgXiaD6JPJdO3CXmQd721Th/wkkiTlybWEW7CQczj/tB7nF1YCIYD6C4T7ZTTvJ2f7WKu7F1qHvmyZVoJsxfMK9pvS5XLMFG1Trs4rM3HeUamMXfTnM9A4A7xv3RZSiJ4lto2/PZLQn1/AD7X4JvhIenucGMFnqUBtXCk/whkIMibvVmgRZyFRdUqwaehkVa29LIct0HaeUMRWGwbXcv7/PtmYpPocXAvmTZZwG/YXa/w9dlsnRn58RZyBZZD/GGZj3ltP1lrSQ+eTubWnQ/9kALkaU+Ro1WZB51j16eVoBPV9TYqVC103q7IAOuLMD5Yfvf9G/fM4slwxGPSvYYpSeqeJhKgn6rqyLVR3g+ayCgygj//CiisfBhcHO6dzmpmZ2YhPcLAnXTrrDhf12ovOEJnJAWQ4E+sPAid6EvnDC7m1bFMfqfgsdMgb4kFp48dK++2Lnl2iikuLe/F5tGBVb24MCgb00412kZGvrCM9KtXMvE7Gp3yY33LWMZX5X/mMyPjUTTXnKMg3Y5jV9n5Pns4PxUBMULVPdmZ5gJnMkOewAvoCYzNoS88dADgssHkO8rKOJtMMX1FrT07eztzLyiU5Nwz9mx6ujiu56nGh+PKDU5qHtPM8XlYskd9HKXUthu2wdNx/TEFEyjk2vNX5/TiWVSlXMAzceZstupOIg3OLVzwdlw7wl4LU2O5zeoUsTh+5w5uHHTiOYF5UTiWRj4xumRQq+UVyL5N5XaJ1T+VNVINyUHW8ZpC4Bq7FyYCpCkfEcD6OsnqzUK040jHPAJEs1twaxb+A7uO2hu/s/DsEZvYgmVVZuVM1l5K6SCuXRr84mseGDeW2cch0//aLtECQOlJWgs5oJKlO8tgaWEOiBNsR63wVFIssvhebWaNc6wwwMLvW5lthvtwm/7jd0I6GLrORIZx7ZZEv7tyh0mOKtrh7au/7/3xO6et/n/YZhHUP1vptKiFDdI/Gu0pdoKTFPGHIQjxEfZtZEafa0gj5bgqEFUiPietjlXgbQCcW8CTfkUcR3Nc9mjnWLX2DrR8A3bqZoitiS/991/tNtSkqPkr+KLwFL0Sd05uwdT1h1AsOiaUKndYQXT0aZYMnrtl7U8x+RT1ouHCJ1b+nzvNKO3SHqm0ycRQOwrimbivkM3T1p3v/r7TZo8lxmX474nutpvYucjQRcGaQ/CfcBhXAw7p1iYzWig3OVY8EvGXRdB5RLm+pdB9eVNsLRprbBns4vD/U2wBgGL+LzG1gqERuZ5LJac2Kcp3qUltxtWhNAqUvsBwqyB9F8WIhODBhTL8T8l0ATvYFwkt+cMxPHhDontoz7fuIp23M3bZyZv/xSFJLX9vKvLSrgGEvaqbAD6Jw1nGLG5QU9KmGVCcsEDZ9xpLwOPQ/m8S3+zM3WSmWdQZR/viyUd3NZlJWyzRcrCCvvP1t9u4EVwU4gVyAF7h0GBZIveymydcLzthkWT37feMM3hsAmfjlAFK329kZQ9FXSXPELHSPsxuHrj8rhYMxxWG87xlb5mHWWWWG/HSt2kxuoyuTuNdUR1d3bWA2DnHBHeF/meeqJM9hxz1WlAlUM0Jvgqpy06LH5OTHAo4fVhpmIIoSWt/MH8aEjHrlc7rJ+XgoK9tLnRsuUqNgZ5L3CeBv2xgHY7xKEPzAyjOWxOG08wxusH6EAmPlvuTODWqmz6Ptrt/hy80tsfrLyR4n8izNHEPoCwnIkcKblY8L3zazWnvPdrJEgj0T86Y2+IWDKfCiKiI5sv2l205mDjute6kW9ZXiqpi96pSDdn8u2L9cuZcI34T7PhktS0S2Mc0lYlOIpBn3CXCq6deOJflqJnJdKpODhWzWnEXqHBsTz6DpIa2lalUBuXjo6qTjQIzthZPKDtxmxornblbVmE873ssq+oV+h41j1lA61z6cSTn04+9AhnnvYIdIAgn9U80nzH/+4BwRAyEdHPr5iaQJbMtadzINNMAwA7aNWaDe2BdPVhAkLsfUXOIoHm2SIXWdnNnwqZkJxwd/zKJE7FV6kmj2SXB/TMiBOhjvEAwyn6Sz4RWDxqw1ML9W5wnQDdimKdddD8QDe2daYcEQIpr+eH7dXVYVzAWd7UbGQzU5EE9MuCZATUzoIS+6c4hiy0AmzUSf5Np5/4Dke8sXJ2dmXfznvWHP6yoaI95v99lRmzT9iholcOzupEYFGjjCnH7e2VbhGYTGMh0t+YENdP6QK2OdEM4R2HJiKp2ylg3RdbXfrqQTLkI80Gv8vBIfA17+eaOq/jJTWZ12yZiBpDEkyLuURZt6WdJFxXBri7Me6XO5L3HocwMOude9eflQAqu5n7Iz98ZlRAOhdOQZCZkcyBY4PfHXiC7ovj2W0eVD8Rkmv8zg/xDpl9E86B/EAccLyfRz+t94ADCBSqYaVBKk7oyjJ2leTO6BDTc7Ek0oSesNpZ7xRhCC6tcCPHQqxhf2Yws0aglPf6S5OelCN6DSB2M5tNqYOF+DQTpnK5uFkpD8csESqYWt3Pgr1EotbJNtto+bNgln86SueVdgPckn7vtRKqSn4pkhsJF9i58tyXtBN3Cewm3pmErY0aux09KdzBUiVVVm0vPaO4V6AzQeEK1rC9tVg0eB8cK8x6brNTAF+QHcV8iPbkLoG310Qs3wQHN7ruOhJJcjVEEnwqGoj2Kq/cmJ3v7/pkiKBbN9yf9JrSTVj3hKGVKk4clNSngGA7zkiUJLwURiNpO6/RHxMrs1Sos7Ki8EiWmkV2OKG3gx/TbRkxyrNg20kaYlpMtq4teirbl8DgoCxmwmNIGDldXcNzbwRiJGATcvajsx4f4eTIAfXHggy1+EWNekj9SsYUVrlfFMPJSU8iw6+EKfi02NGFTcyApmPNs3+RHPZzXl8Vt6lONdaDkHK/eTPzTE4B94aqGl5XSNibPEVkbtXHNrwmXCwCKGgS8PiOm2h2xvonSuGj1uMz+jS96ICndQzvRmOz2jrhaX7q4jAYQ4xKwS+HDqmV60QI0Jzx2Fk8EML71AsIXinUoSrFqdZWHKeykqzZQa6zuWIHeK0iDUuEepAwuFiaRUjJ6iOCJcHJPYP3/KfCIRWG6x/qkBbh/qfid2zkvuJX9lXurUW1HUCe7c3X8ZOp+5BusISt4U4SotcU6Nrl+1firxwOaRFyXyEVJAbK57Ji/9BSxYZ1PX+tM/4DKKF5dbu/kmGfHeV8t4QfZyparZWv02yeUQnm7roXz7Rpdx9ZAC5Yj3Am5RTD73qsmt9h2izX4rLQ6d0jQOEw64BQfkJEo5Q6wfoY3xfrKEu19TZ9bZ2pNzEttCp5UmXuNH3rgCMdY6lrQM9k+Qzrvmbpz66tvkdsDtd0MhODNVeCAluNMKAvb7DMWgLW/EPXPl/6mPmU7KNZVYNjeEQdechqXbuUN0hy/H8AV3ctNYExNe2P8Wtsc2giLqj18YjVEciUnCUxPIU0Aamw49R3N4V2T18nlgqVDRhy2NBATFL7/8gMOQRN1BJCFzYeOhLzuNdCfL3IbiiImbzqytNOSHuXhpWsyCjVcq2UQNaCiJzaZyOxXlF3H3Jln/46YRdClOawdam0rS77HI5q9F/z/CgHWaQXxq5oKtKv55LMLHMw6OoXgb2PW7RhjcLKHr+wxwO8Al4vcvm/R/rhRxNB9eW0l0aZwXniSpJl+rKizwsRt92mwSySIqEJxhuaDtc5wobsOdPPzCxNgOjANZ+9jWteyZtIuxqxsxJkRN6UKv29Jk+0TpiktaZT87B8b2mI7RnP2j2posB8XPt9eZgey9SBmiBhhyYvGAyXRnEeK1Hn+Q1fpfQgS4yp8poOoqJQYh3dma0cRiRzUYN8MKBKea7JsVGpN5Qk9HpFcEeGXAAXVZBy30i+e72FfHoLAZJGN4PoeYmo1kgjO9ilOi2kEEFTum5lKQFDXthkBu+ugPl/cFvHcjxprD7XCITzngauowFKHA6/NUpob31WzQW2dzQnaonHELE3fxOUzE2Wtds6VJHLeL7LTGQ3BLBpd3Z1ePXWzdDfbS9przAf34bPJ0MsISTP3L2/UkasAmmTnS3dr8Xymca4ET4CGLt3Z541LTf/6OTz0BMMrxEkZrUAPGV+pHTIQQKAzgTi7ahaYl6OO9EW59zn7f5E9shc4lBjQ60ZPsNsFhmnYSeAyukt/FwK2wYi0VBAGNRFXUnUqO9mmkmMW1iwMMYuAXaSY4ExmTAAj288c5TrUKU/fTgbo+nLLyMqZryX34dnHq1P6DJjbogo3wlSp9v2qIIv41zR6o4SQubFBfw2RDVRZx0y3Ur0DfiYNo5Dm+Ng8YKp/UwNldZI7xFdbZVK4lXtiLvlssLz1GEhevsXb53X1HRn+6RpHwJSLXlnu1yzuo7vV3yBVYCuo/8pfswA3r5AILRiVkJRurss+cydHmRqDU+9wo4343IL96BP5dxPdeEStu4fOO/FTf4CO7Fm/o8cN8bGq+7T2f4P1r17zQVhV+N6hC0u2ltVPPIWvcUA1Vnz95dBuhJIQl/JZ3sNrNMuV6zdqqLwawVBWbJoc3B5kBXtIbKCnamgZh6wIn05LQVagmbfjp0Bdqht2SqRqARbtNzKD+AUKPf+KTpRkddeJGMGH3bVP6ncMoKRMAUS8YO9Hnflt1jL2qNARI0+ZX/DP8g+HGoErcZo40vsQydggHuHFbXgvCFPipsDTt+ij+fxHWRSzlEYn1uKdpeffeQyXJHJkRdd+CaA8hA6VrLO6RbJg1SXVZfhilzdsCFev2Rhgp8bRkpno6L7wb0TRUSrz6uAL6RKM87vJcD4sehOc4L0U5Sm6ogI42tvRiJY4YVHmMhiChEslRmNgSQ+OX9bPjoMaPD8ZwEgRFrraWDqykIzTBBXEDW5CdULkSQVCSoqP1zBV5of9RvUEyCBaSbhFDPaLmKi4WTk9Q8T7ZVC+Haxw3/Kxk76BG4QHtHWf/KBu3o3nFDOMN4lETj+YF9Rpgib4kskOysQ8JPbOCv+bIhEC0VCkeYyHiM0RGFIcKJW+TlHDBYjuexAG8UL2Fm8dFr0Zno+OXCwGlEwC+kqpKDnzVUlqGdLK1cHSjatWwbu07Bk6wWhcI5peC6FdJc23lMWiMIKaSiPUmekI9al6MDpJ2vAktHBtqwHb8V5Dy5y81wlqQEhha0axhWlRbFun+vcsKJCC9qB2G8JVKUfHeGIItXr1x5v5TjyeZ1TIJdgHsg4kvtHUx5nk522PjOLeBXlQDNxqwYUn1iRQa0yMoG13XIylC0Ar38CuP/o6an2seyugswEL4tW7aS+JGZgYj66ctLJNwUJFcNePq08draTh1jl3og+/UFN4W1SBoGFvxNCI2HP20eBCV0lBWYVrFbG0e755gLltS0RktrKwA91cc+MW47A/SD6zr4E6Z3ToK0V0cPMScVtkJWTMJOhjIcIKjRTzAW2LlBapgtmaHSko9bdVcDJHxoVToVTiytuXKwVS9PhzYiktChzzwluAxoyYL66PRONYN+yIvTfhcbppq6XclReYP7OwEF5NEdJeX90Yeh9iX6j4QTpITwHYQUqKhU/5MCCALNnbNK41L8p74YxKf1nJ0+y4DjXiXMR1nd2VlFQ03JMk1FWIs3TglFtYSGZR35edLv2DrTTaABd76vRwIHjV6UaWCUuFNyfmt6L/fC5EjJVwmlrTXmMF1OkWo5LMf6iUsTsXzAW/EdxYtY2EDmBrOF/DPYVsMMnyAjB/ShjjgaYcafjxlhpPAdwji/91liNO+GZBrtV9x+i8Jpg8JIabHDiFxeJgWrPiH4IUs29dotm+aOJ3vbCeT7FHwr+bFkRgWy5TyLg3Gi51xKjAhKwk+8+V9r1V0yN8ebeZNsusHKrT31D61j8Q5ikvnnOjJDMJfsvebQIEDjW6swTD1ndS1M0BHr6J502NE0qEcSdb3oK6K1Lcu7HiFonObRfkkc+gmgljA95wNRBCFkRe3Hlmi23PzOtcqFjU+S2wBHObL41GkKmHBCkHSBnpysYM0wnV4Y03keWmQ8HKAnwnRyQqgQweA2+iH5R/bXIVX1XOBqgj3Zf8ttcNy0QssChkXOgoKrtEsj0iUccbzkmN40WayzXXwGIWenykwoz2azbYbnWxupcrB8CrOEZG6gcdK1KCsZFVVgl6Ly0gkD+EPI5jDWOLt14EwohCih2GD3NrhPNCNK+roKi5CXtizVKW0yhINFprgnAh+Gq0CnIJ2+3JHKrxa5sP0+VMkOyPbeVPonfsHLbSFQHTmMJAxeUB9eiDlMGByU65iFXDntIs4Klox51bC0gYy2TSmaNVtQuS6MXu/NX8/sNDH99xAeV/iaeEMN1fgofbjNYYTp7HL78wtuH7FqudB2Que4AoGucJsFaQxtAMlGPoiTER9ex36wGMOdCLensObq63cZvGFz0pXk9I0vT1y6unCJeSEv+kMJKRtZPxc1a5S6D9ZvH/1LjKZT3KIcHfECRMjs32a7sqqvvql2ZMPFYSJKnTqE6Hj2CiF1OD0xrukSC+Megmm9AJif2v4/LQMB2NmnVT4Z1x2r2IvanZamPJYLAjOulH8xQ/vQxy72Mi0bIjCOE1ji5pz7w44JddcOQhMSniqchK+OQRiZab+QeoxgYCQGahcU//FSZujMCxXvd/D7oVwn4qaP86qtvWypbm5FJ8lqfvYso3lxdoNcYQ9IkiYiZ5hkmngdrFdAKPGIHzS43j3U1elDyvgtpepeewhPmdluJID80NShaK5AndAwYCiYXRwFTfqJvce+dn1ei3Ka6WDqouke8RbP4bxfUgLWWRSLVDSbDOWbb7lKDX1nOZC0mbY44VGhcStVuuCgQy2r7nAS8JYq6nwxu/GonK9Wb2VoH2k8tZv37IbZBpEFcPnpuFVGmyPiEUWdebIYIaMV/m3+mGbu5MHVGTdMg4OXFpj65m3CS09HYzAaLBfWRd1NM0h/V6mcOBlISM14lttURFnsEFYzh/4zLFryuZ1WxCT1mxjDHfP3ra7j5vcHI7zgKEM9V2Q9cdtga/yvE4DemTDCsqmG5Ha192nxe0IRnxveT7+slsw/Qik1FVNeIVHDLsHIwiC56eOlRXkmACjTJloIC4EZTk35mqW8mgGnjm4WiQSQlJOvumzbJDX8QA4zgAW8wT3p7bS6IUXHY9vmvLCoJVYJiIs7lSvOIe14cJiMbp8qxqMsQiFaTMxSxG7NxGnvtLKL5ZpZRv6E5StvqirXyJevDZ0bvwTKvXPXdFI1/ubuCPHM4JvgzkH+jlQ/hDBoHLdtgHoXSivRbeROLezQUF/gGz5iKJwFseL9l7RKB5CX5xGrAyxtEx3V16bgsVrM+vl/6oK7Gbr7vmd835D0rfHEFkRBN52UFcPduMGEjt21bHhMrOBFXHfzKvPLKqkRuDpuOHUY6ZoYQtN/qDegMEnqHrJ3t8LOR6w8faCa6XVe35YyJ00NWRFQuUuPUFW9280jlZAauoMWVOfV6XIhtZS6tM+KhCEnbuJPyHFX7NwVVzj5QWofDWM2SyyeAuikEyRMKzTYy7981eMRjMysUhlnBQOdMJTvlS9PMWh1G1p9jKsvl8JCgXM7N+MVlaatdU2katyvNYhty3PENo2QAUdi1Sane7l6Wa3t3E/xIWquzWXMvebJS2sAU/UoAkLtCz+atRbdXHkPzSZ9ieXWuaguaWTwe/f/mPPExYUArHSYLikz5RPuk8u/Kc7VKr+imdnKE/SeDtPnyjUEGvov0/3U8xJlovh2MQ0kA4TGQKNy6uJmoQTtHxHmFEE/t6CR/Nv6+4jKnJIqzyjHzUQzcqdHXoo+SKsW++VY+eU1nO3iafytayfEQlf8KuWY10d75IIpAzEnjBhBSGwr6OgjbSfTuhdVyUqfK2Y5Nr70v0aJv76eYu3FuhWZJTEbJyRMcjYbTIwRQaT6ZYPihRPjwl6j51YGTkKS7+3vL9TbNOfpv7Xl+ga1JmDkLA4TcBIElF5nzCXteD7DPRiux4zM/YVgdH+OQLHxADQj89vnykqNgIpEHI9PM8nEneaelp1lLFieguzhswuEJwNynVp6jGzEluhfaDfHJNI8MxvXccfhavnVaZV5zNmaAHr9yGTmokNNgK2d84ASRNTdqAU6uJ7gySY6YvGuDZmQHaTh8NrKlDu2j7QC2eGynhA88/DcftZDVfOqtVnb4wonh1CHUgAB9653pNFUwcm3NOAiI15ulrNcwXS3v647urat4sL8UQK/c3VRNRMrQowNH3CE71V9nvjTyqoSKFFQWzR2SbG0+DcpaWraay2MvkQS6ih78QeoUJG43IrtnvRjpS3gTA9r2Tq7mpeeMwgMW0xmRUq1Y3yUczntBWVf1EL2SEqGTAg05rKnY8dU/06Jq0R1+ZyQP2j9Gm4Y2aKjClDEVMUpppL6LjkWDkeHiXJwNc/iFP23FKyc5i3jirNDGjWdjqA1Eehd78gE8+i91YM7Us/A4FTV3/xNouh96NFMW160rJWWPxsFThH8rXGZExA5668H7mSjFUr9/PBsVVfbuz5zHNmUaIEk08Ky8feKpsNbclJdtTl+mILxRuRxgVj00ebB6encAQYI+VTdzG7w1HteJf1QXiMGfGPpzVVmR3AI5/4g8jos1guWzpEYuMNQ+k/ge7XsPQ0BpyPWhWVEVvVIJNRcSn+p4Y4rT0lJFqxN66qYMigRmdNs2uALifSX8q6lGjZxGJRzfWU4NnqNkX4BXF2Iby+PVWY26bWRXA3dS4SnnmB7CbeBp7xotenAQo7Z/9ESTLkct6piyAxxFCUGryd5cw0eQGV6DyCaFleOXOvjwMDybHlNnrdLEUEi8P9SYsLOB646DnKwMaxS1otuJhRYH/r6WL9ryC3qW9DWa0F+F64f5xGbXXD+PJ5hu/MreMNQcozzWbQvQw+hXci75L6TEMNgzMjVJKVIys0cfK9ieJsWax55/zYXxsp8aReCAgT8/fcl7JE6cSnXPG4EoN/X5yooGu7WMRRWaGbcCwqSZWMc7CTfPSpx+pBw+xG6HFz0oUQXdfjV98FBygg+ZHdoyFnSQF1qJWkuYzpfRJ7sAjtFribsAJLogKdGdc+npbqgmT20rk1vbvst0EeM5BASSKogHWjaBpzuuwDLV5aSe0L5G9kvQMRofpFUukbn25obBIJIWPQqg1+MfYfosYSgLNv4REycWmKLH4N0kCbXdvvNTi2MX4ktLt5YweVwKwBmGzCKEoUjbYE/OesE6FRLPTBoqXg7YGL4axsUd1fZY8dd73FYV0QTOa4qhTRrAi/ehRPJagLnKiHxh150jiFBLhSp40c9ZuG2meOsgkUE3oszKJ39ge8+nVKXy9isv28DHmUS4abN2c+ecEVFlY8ziod+DNTZTqJi6fyiUcPEGr6Z5Otvahx9KM5QlYwc9a0BFe/FfQyLY2aXbKtJk0DoKi/msgtHO6DeJOOwOy+GFiB8cAz0nAbclbXrdLr5eX0Fsg4ZDdvmJPpMC/o6wLDHtwYaFFrGm5aViijw0qDqYWf5rZsUfJHj+OTuDR6ovvMfNQiO/W0hZC80Y47zAdMq+Z8c7YcDmC8gW/c82vuYq50ht+rP00859S0icunys5qK6fxhzGimk35vos8M0nH5+ISpryJkkPxJF3wCBdI4xtnfVOUuSE6kidLA+wkohw7b4QuSf9aXuzJpEY/R6vxpi6Ih7k3WGVehXinZiH/Y0KGSMhKF229xLNVY8bd/HtfVWbSrBt/WaVPcCSfS0pXJ9XbxPWNavmbdqGVM1iOy7THwwv2vxirXvs5HQUTjkCceLZLeSkTQc7P3WdfpIzTgPTCIYrOsvVV+opVoDQ2mRnv8d6N5F6s/4pP3CW1PT0ZeJn+eDpoddDlNmbRsr9wm478AHN6OtTVuMU0IydY42j07rbJiMo2gpSkWDR67zru76sdUXWh2z0FixTOv67Lo867Ae2bjSqXAQzAHvCSHvkMiw84UtGfioyCb6aEfBQI8S5ahURUjbKgIk6832MAOEiIi/Sf+YClKtgr/jIFo4hWEjdjQqYJOhG00mk13/dYJhXCJ66TsIB7+vnaAZ/Izh7sQ9gzfLpqmOgefk9ig7HGBjJeGBMWWIdNh0NIGl4x5hNp/2ML/ZKS+LtnXAf045H5AG9Krcx0j3Gdf6935Kn4S6sVXFb5300DryUt+vFPR1jX8XakyreDUTCdGQJrq/v6Y61POxn4N9MKWTxgekJeGyQT9WR0OlTB4yGiE/YQtzIL1HegWAGuwien40J4NnI/mZKSVXRPa+JscGhNm6znDfwnd07SDZDeHo51P7IaX8PNAMNHKmpjIlYmoGojtUTPnCHsf8HXsk5sQyswUdgJHWyRm/UuNZMSLvYDH7wAtu+U+9KD3xSH3v9lxU7HWDsVUAgZj2GxOARhpiMqbHpP6PERMDg8Qoa8X/mUSRoqDYnFVZFQvh0Qf3CqMj+Wq7NhdKQ4moUlqoAQw/7HhLfl0sUQJ2TkaeVbTdmx9h+H1nmz+CJBnBjqI9M3zltdqbliDHWYaM9Wp+1KmaWHy9ZyM2glLexkQO8tXwdy8xYr+kMXr5TjyWNeiN07GgLQBFWOv7UpK+ipTQAy1CBOrJgeGEOWNUTjHqNwqqD5Dyg3Xf2vAqQ9i5F9CfK7BG66UiibbmsiY3XovpPhWwXgW61b2fDtzcNrRt/4buCWOgC0xhaPkz+nSnIFLLPJRJp8jb/lBwXkvP+XUUbMfqRZLZK/cHfYZaWuLgY+1UcI/mnW9JnC3svioGlHR+ZZ6F81Dbb2bU1rttd16xph8dCoRTUtA0o2ShWVnqXgbN6/zXYTHo9beYGG0dKETddad36qn8QtvrYqvu8tQKzWJkL/ERxb1mahIBJ2fOKyLuO0PnaJcEhIIhtemYcVzzKJj6eedGz4DywYhXaBOpdVkp2GZG1U0abwGG6jB7wLTgY4iOLO/EyabdP7BgsJI0yoZf0RJQOscISzl3q7AKum/7mgzEheOeK+otu+bSApShrragLo4AeIf+EraRKzZlcxhMZ5cPSBmTr+2+tths9sHgnN3kPpMNfLVFuHiIK4X3x03IdrqiRfNV2xwKN04uinTmg5K5vYkOMgz70WiLukXnsHi/LdVYFRRXB8LSIjACx8ry2ZsWKDjNji4wTQdtnYIO0VvqBDtlLCl42kty3yJAl3AUAP6qR3vmf2WgDNdxTOd+RksEzLKfPWCBtEOtWOQAXSPrtJ6DxHU1+3cb15e4tbrihr3uPZZNJwwQO4tZzF/zDodWGotr5WCW6xJcGd6tzc0VLkyf7vCyCxibZBnkFxuEqnnf1uy5cbaN0jrWRGm0+wt54/TvGQA22pUDEPxV+mOcaLWCQ7dPOxnPS1LP+J2tz6UrXYULgBdmJqqTNasPjhm/quQQamySDVutrJEeCrfde6oJWUZ9fg0SXeH2EJp6TqLay7rvyzB3T+eRdD8wkpcTW6lxy6dHk6HfTXPxxoyfBymuOglPJrQeLIO/PDVt+rGARksXaTMF0LhTlcYVj3P6JZzimpvc6qPJNZQA7KfLiH+ik9CwUX6942dMiNY5ayAsSddMCf8dh0JjI6DuPgGq+6fPpFyhgMUgOktpS/ScLav+i2zx3zzUxL58zNdXCWAzi+kDjNfalSvcvtX/8+Au+i/SLmms7uxoQqBM1iKz00FPoCfn41sLI+08Ll6mn8nxc7O68szpeFeV7vpyc2mg0rK+pm61Des+8RgJQNf+emOPJCORo4Irks6glLNnNI2YLbWaB5UEN+/GRTvgp/qIcJv8tRKev02v5SWt9R56tu5iQy71AT2x4CQNPnshdqcqd/yXiBpkmZKPa8o3iRA0I31i8t1/VhB7S9qFAAKmB/r7w3syOviapHHLTjvqikYfZvFLq/+/z0dKTcsbW5Qh4mzosFqEmhclWnpWarDJ+7zdH+xoD6TlmAyKUp9jLnQTcMZ72R01hmncPrWWuN/plqr0b4M3UepbeUtc1whGUVx1+MRImWOI0EF0gLWCVfGCzfwO1j0DUigiNxRzM5ku9iozyT1cAyLia//roUhw+LEpJo5IjfEf1MqmAp4fskH7g21Txuu5eM7Mlrv5rqlyzBdz58GMWbjFVo9eAaWxnjSqpiYsSDypyyNrqZPBYBH+vd2dYj7hH1opzdDGzDWfBKm7ZXCMXjHbLe+wMlf5yqY6DL+2olxhdgaEraIAGPNrPJT7Dt15KkApX1D7yZ5EtNpvYtPKr7JSCAWF7mKveZpVajD9kxmiV9NNZ3DQ2oWc2BEivHdF+bO+PUEh2RozZA8xGgwug+16ot6SZHy5XYPcPXXNiPodld8GUVWj6Qx7eJJ6WXcqAYLSdwY7kErUMVnA5qdLLtNd5cBXOA5fVzZhoeJkXsHckki8iCNekLzPvpFDcgI2BU1QFzZTnkzaVQCx5O6ZP9Q4L8Ba49W623RoNnOyClIdq2kw8S9VsbgCe9b2KDN3i03W5RRSZO63Tl8/4aXRtjoR3PxpIcV31egOaKrgeuITcfQefhnjDG68Ec0A5znR19bZBikEYAuiu7ozw7FkkhVYo4guUPwBRkgqGgM56OG8KrJ3jzCr8okYLFzM0wP2MbdqtT3ZLjPY2iBFRtrWfFosibxT82DAJvey8nqh7ajH5BfWKA+QtoRr+SXYIzDwtXlbSEDANyj+Qe2/myh28aDGVGw8vBssUaxnLSlomZ7OnSAQcpGP4fW5tOEeXsz9z4qrhi8/t6TNxfHL0CjnHdUj1mZafD+05dzav4lZYhzBsW8zDAKRxJ1oOedehZNXmHkTaWlfHo84Twoofc1CIHkKBBRnC0CnDNDpRsym+pl/calEp5twgLcjK5dkCnS7mlIWQc5LNlqFP5YaZjueN+lJ/6sMNvU8T4GdLttohTw83vJr2uoMZrLPhLGiu8P0yr2FHmQdqVyAmkNAVeonyCmxN5E3tmrlbkGXAWsg7GjDP9MDVIOaoQ4vN8j9ltaftzEdlfZ/lIG+1CKhElZjpP+qIETYcULLHQCKxaqq1lW2PxqSnr6IC1wLe7qAU9mGW6GYVQ3SPnYWEWsBKz/tsj2afR+s9mMx1E6OHnkoVGeVj2EPk/9sGNrOeQFJ/wVXejU1sFGwUlnN/mbMaTcBXTig4GB6wScHjrD2dKWubI6QEFOvthBnAUG8kGPWSh8KdBW7fkYJhgqKMKdbRYYkVNUBP8JUNFj1EmTEYLLASq01lx3iyOPOfGUlnWWFYxA1Lu9W8GJ0JRtviXegW1dtPZWQrJpV1e6VFaYYjV4B913AHbIcZQYh6hi66qe+5ePd00ZGLY7H2uIUJSNyebGwINN+RurWTR5lPd4dmwdnqk/VxuVO+2JHrobfDdeBSlLIAXr9mMf97gpRYHUzsLPkjhtEhRHFXPL2TNW8g1iqjUN07lDygQdIBDKPEQ0T7ZEU8drV6akiuLUOtXX3GxHPXyVhS11DmMkbiN+p2NQq6uCk4qPCk4CIKB/CI8GovsaeOHvaO3XdYJjK60IUfA6dfJx1ClwyI7K3PuLqoeg4H9pwmPD22c3KrwUOziZYMHr/vol2Jh3BFHgV1O7O+ho2WUH40hTGlWHrQCsPKqQP7PTnpaAUee+4hgPpF1ARuW+w/YoV7Zf4t/HWQBcO/jbrbLomGNnrMwIP9ytoG9rrtEJqPvPdVW2bAY7Po5z3MSCseyKWBbFC6skTdsMYgAbBjFALy6ZSYrW7ZwlCougY0E2KgAXlUehRnD0XgjSHKzj0kuRhRqEfXm/V5wC81r3zV2GG4zNh7Idjeu/w7UICQVXzNlHWxK0IlEXsNrVTK4QQfVMLJyJmP79TIFdTSGkMvAASwCViZ3FRR8/EMkqzi3lh9BIWtTXRAAF2IOqU/OIUYJgQC60iJHK/DmcvVMlQM2Apeb75V1aVXfD/reKiWNojEegPJR9EaeSsomlv75Fqb6Uo6A9c4myeExBQl+TWhoZ19aSpHEwHy3bsd8m99zp1Dsgshwd6lKLWI4gsXm+tyOpiGUVSfOJloT9SJ6Q79BCBOeH4fXoJxgPrrUFIEA65skZvDdzMXWu6aontEu+zKiEAPL/sKImXYQB4CAHQgJ8VG8nDbmTZz/cuUA7fY85l0pV6Iudi+94EJGIVALhDjzhQXmdLMQCN0+03j4ta94oBvV7/0vd0LYhFzSHye+xRMxXUEwN1sSspK7kFFwEqY9dWgbeLdqdThKxm0AeyeiBS7XXy1E/MOXS9Cj6yOEqHMNmxysYiYyQVo00RBKhOBGTeivr7msRrfD8WbEAQhUQ3Jz+ajB6i9d6309KxgLljQ2k9V2DTfMFBZClkaydrmaqlKDXHi5SprvZVRK6il1jJ4/JV9Uu92txzb9Qa7U625rTtdYSvsicVQoLL0pKlH4xMn3s8hPnnS+IXrcLAwCeWVfbGmftGekoyML/FR6YE1P5FyF/W45K6n6QanmGLGST6ex+TGHsZo0sqMgWIORQ2lOEfAePbIZihE+FYCKbvGT56Sgwp6pwQDxXou9kfoKe3ojs30ZFePUdWRUZhruThkew+4NrDSbCm3ph4ClmF/3gbM6XXPsPlV1dI8EN/WzhRAYgb1KSUNuZvwwHNSaABfSJnLOhENnWYmMF5jJarUsizGHOduUB0HDF891Hym0X3c2WGGg+ulTa2L4ao6ToeoAESwSTg3ziyIlsY9FGLhd3uJzD7Nl5Z88bE3Pxr7kvcWuEdnU8AZrHpwg/1SVoos+73Yd6b6v0jHG7aZGOn1Qty29G8x5VKOTlcsmMdDlpCFNIGroALeazCQBXIGLdXgQTA6+1qjpAQcvSwFZakf7nlGMR71UKiiaw59ABSBfdfmjZqTZ7zM3CY0805lV4tOzYQwHkfm4Yw2+zjyoOT3n4TDtht+1U7ZQhhp33JJRzFu2IihFI3oQ8924TTPhU9+JVvf4eVm2YrMykYRCtYCbuOUxplOMX0Q1+cGpdsg/WSz9g08ct/YMvBUMSLLQkZSHy4eeKiLpddUgr5lLF+lHdG+RGwM6Xo2HnyLwGIH2CM5xB9LaskMz3zBQUBecHemrvRS0VRkhOGw2RQ6JS7FKGB2CW18DCRHV68/eaEsVvorJPp7n8SpMMisrNXN1hZhjz8F0UYJeP1/skEwxafKTIzfUILTNyNZnZiG6ckh9yrUDiNMmV6YL4Zg2j1dO3NUwm6Z7vzmV46ekF4kwWOsqzc76A7f3vnkJGGGcmlA7/PqdgwhL0+RCR6uMn+AQpC++5H+FkzwNWaz1nWBTqNhly/u8W/M4yHhoqwOkGcKNf4l8lY7to0AX37ACp7diktVmcfP8YDnqjqplt+tHlnmbq/kievjd7o2OhqN2wKahCzrrAItbMQoJfuX8NVPhlrw2plRlTbhMqQho3ooGn1qI2T666+Za12L2vHRLk6GpRlifH1vjYwt8XIz1lRMD4pVM7kGtuakf+RKB59y+uy5rGh/mOpIhNpOCBpkq9n1wD5wK/+8xzvYpaXcbxdaRWdvPptOTN0fR+AVhFrFxlTYhOha5WxhyeS9qmccCg7jBAQ8p6132PzzlZp+MEDQYZQnyK/Vz5tozm2sRCduYGcVcZ8ktzlBf3nAjUV3/tNzGDsM56c0jJrfHTEgzVW+XMVd9b1f5HRgW85mNU3oHY/fIFb5t6ckHtBgWgsGXqiz9tU+n3qlEXrfSLpTdv+45U8agRu4Xc1M/ZKP5uZRxtPKih+o7VwixsAIRICUE4uSkUlSymzZCQ3b64mhaK/kFGIXMAxLSkTHd5tDP3EOwQo3kOPCqaRKp2NM/SOJqjX2OQZKrnilYKCifRJf/l+ZAAFJ2QiEaMv0qqyZo4VfTRis9aMBhYShVe1JOQF71emFtI3mzTe5QLHNTOhtH+PWZNJIEn5mn7RQFva21MWWtov1g5MA7HaJuOqN4W79ZCoRJAa4yhOaFhHeU+v/R4f0NI+/e2xyAr2rUuKylF03TLP4Ow9yiUquqdCzmQDVCV/OAMi8HF6xNLnUBm0inlpD6zVAev3I4hGkcZrOl03VZt2+8lzLj/TlFZMBuWZgcKMrhPKtB0wPQIRdBMyjEzTFR7GMqTD/ffHWLBrFHy6gHc3zNj8Fn9OThzOJEvxs7EYFpC7qBjSVqlm5T1dB7hRDbcNmALqGfuwWdU7bgtpaysWLMGj6x7J8UE6vqtXsHKJ0Yexiedspw2RJg7klj2BXC1gulMJv5tldikNh+aEbeh4RIs1tOIjgvlf2qRhn6JECT/e0BeK7DULif0l2IvuPKb7+Nk+Nlldd6UHjuk9sjrDk98rPbCE61imQDvRHMSMkjD/dvk+p0E0Av9Nv2d+X1NQG5eH89tGyL4Z/cZ/no8vC8FL+mrwOGUuoVSkpIO53H3HuTOrF5U0k61pianVANcKJhUNNv8ppiC9f/eoV0EHuR2UlpnUWrg+PEuJtPDPUzZIplVQgikz3lutrY4EPf1YreSw/VkC57lT++jIoruPTd6Iv7JdaGOufEw7cQd1V2RVsRuF8gttvPV6sUUFHv2WMjHK3sS/KhuC4P4LGZWopTsz75OgLclfP6q8o8WjO/6QLD/mMVyBC+Q7BTcOrddO1ChldFEZSqmkOfykcbMPTAG117WzMq20Zw5Gbwc4smddsxt6qCogzMOwKPZyAXFTKHilOcOsCUw2bcIOyOaNnf/DH2sfPMuohUnhI91rJTzyjZXMdIr3TJy3UQzrHUsAdDTpPGWvaGsHOlP0Tmr16YYEnQZ1ZF5ISX0Kq9UUOzP3kwpmwW8R/pAz/tG0YFYeqsuuBSv1vfq7aMz/3TpIaAQAfXyaZ9XvKCiN/kh3ZT6ptYzbl5YMpifvRdLjpnaT3nnalAelDRCmu8pWY3iM+di8GEbr94jXVCvQCd7mcv04bDu9VT3R2D5yJZ27QUVwheqlMzVMXqt3sBEOz0IBL0sz2Sj5gm9/F32Cl+8AyMScow73l6n8cGvtrAfJC9GGyj8fL1fbdts15MrqpYb8CHCbUTLVYfazPyzQah2H2Jq0Wt3mUj6UlPHmJsUuFNcTpIdN411akvNST4W6DIlfOXth1hzuShAFUMBIWVB1r2JNWwygruTFdpLHPeIsfn++l840TlYXH5XUW6aeMNdn6r6x2nv90670DYfGYK9DtuzwTA+0XJP9GS9IFo4JTmRkiFtIWEyITjWyY9qwRyrBQ8bvaSRFpv9pELrqNqkBlCFyxYUYkHABGUApnazrDWSaC6kUIDvGp/pmxUMXxFOGYaZGlvr+QWbMK067Jh6i8PdeauQzt0PraNnsMf25R3ETBGOEPsPAP4wqechUf5oPktDN8zEZJKB+Du2x9riN1lEW9lkskS7BfkQ8e0RzzOJjAfcxZwCO9lEzDKTEkH8dFCCo0SmVEdQdpBHsrzp75Lsw+5rkjhFG/ELAcsc2D1FVM63FwuAtbU7ZoKIFc/GbD6rXHVLPrcLGM9X4em5qGXOJ9QFCjwDJo5QPMbuaTgjQD0viHfNCGSFFCbz2K7juw3liFaTike4u3C1huMlQh/hnMN97QWIhtn9+IZx4NnCTNP/FmoAqJAp6NwAz9DozvIWYTxIAVUygKyxioSeDo4PwDWykSEfr+zEW9tqwiU70n17GX8DhcQ5oY/U0DzTatuUkwDt7a2kcchTIZZLOAMPuitpGjMFAoB0ZjXnmL8OEq2dO297aFYu3ZrJCd1R/aCWY3+VUiU3NGUUrB9J9FSXqe2VLzavhydIjcXrrVs39Ij4xqjMS6CBBxOcEZ9v4/JAOcub07KQ+79f15EMStaL2tonQP7Qfus7xXGKJdjpnNP83A1Qr8iWr5nASUGwgU8F0RwOsSKIv/is3c/XrEyjisVJ2/M0sduBImFt3FPgI/9KvCNa7STSgPiglg2eKQIvImH+aBcs+csIaHrqIRzDSnNoNnl/QRDaqFF93mAP94IN/fvRsrOtzXJkowWR1h4jCnkF8DXirsohiQHsPMlXjiEz5clLerLaN9lRThqOpPCCxuYhxe6yTDhf7JDieya+STCstxsrzHbhfvDzzapSwk8A4WQvlg47ANsi3FqXa3H4HvlEU09bfQXQVtFHhgeG+EOmgIij0BjVKQ4LfpEeFMkSNXGKNxDavfriutkqc2ZBPJj4GfwEtIP2DlDHDKhRmt3G8TcMob5JxuOp7zmpT5SN24ZeHCGCAobsduj7qgBSbAUMtFH6tt+Pq2LxSrYXtwv4/zhx+nndXFRnv5ljZFHotWfEOpizTBVBs+W4AR1fylnxSLDjlbq6XN8unwD1Qk/TazQ5r5/ekXsdfAu4pJEGwpQ6LhpeuiIgHqo4Xd3PZsHHLA6+WvulD08xvDUOPZAnKVMUtfWfgoXLLvGH/fXx1aQKeaHh+aAYknQbnCEAcRwlMTnDu6vAPbzv/r11cNZWw83KFPeqSWS9zvWWKQNAm9DvA8DHZxrb7S0RBwQPWhROhEKAhtADHt3wbThIf+PVfVN5JRfCXh65JZHYXRwWuvNdF7s51BP8z9yq1MKTPYWykyXhH+8bNonQzZhRwt1IR9wD1SYKCWV+DNBYGWHas6wqUewkDlAzY8TcDJnXxp8QQpcZJTSWcmrTDFL5iOyV6xForHRxGeFAkONJ+sKZBaGLykoaaV/2yS92+M8EzxOkjwcSjbIQIPcO7ZpkhwJ1qJxTzvkAT8K7J/C7Cah2rZpZjqfeJi3uR48cMAkVfH3o1A8bdHkl7xZ2mL7E3h3Kve7gYYGwpkeMvmpOKALfrrZITCrdsoBuyjSpuaq0yro+1w9figP/jBJAa1Gxc322h9WF4Rsblzs+r3o8ItsJBrtjf/4qKbS5Yl2mAmzVTm0KkNSFyaf8zDojX9Zt/7gxQPdRwSdDbhib5VFMKgk/sUqOQF42Ymacflq22xk+Qvd102ce/JEBhUIJvlV9gESiOousADKDKjf79E/BXDIxK+1NR0oG8oTj6JHtUlmKMULoINNdvxl9rej1l0PmJD/58FvYXQG2thgEdJUPceX2y0IPM/BUujRL70KTj8Cf+o/q/JeIDL8uCnbZKCiehmaUdM89SuGIw42p8R7eO2ddoUxfb5oR+WLOOw6bme3Ao0oumhOLvl1/1qhZ4JCPLreYDwNpByrX2s4g2YZWb+2fdPWc2t3n81DUdY28RJvkIRLIuVu3yyOgQGb6cxywzrw+fO/sGArjtma54SyFWiGYIRbQeGuyVUmXG1YHOZaA9Cbugv6BmHHx2YuUuB/pcYr3TaUFOrqO2Pw49eQq4ajcIQ3CHtFFN1g9dB3QS7Z9QNarWojLgr8cddAu9zyRgIblV99w9tWOGEdzhVQhB2TpAPtGioK9s3/pyDLl0J14AG65fk1ztlumYSz2WZ857s9vQsIfveDZi665+/eRDOrzJkrzoqiL8EIN95/SwTAnUolfvtT29WoLbiQ88+EClZzsyiCDkkfAHBgdhTnS2BAei5odAVBu/qdiA3hjpwLWyy6oJxeqSKZU6dE/Yl4ATc6DU0VU9ZKOV7yv9D0B5N1y2nbTrnRwSSHlj3U82A4nH4XlCooLNOm0VhgPwJvTwNZ5ALWCenk1W7JtZlhxJBd6co+4PnknHhjmTl5UL1wHu2UcBWFqUZy2x/w0WTISEV35MSkJSbMyWk5dUZEql6cqFbEJSjo4ybJrwb6Qjy77Cl0wWVowQKg0OR5zZYyidz6Adh0VG2NaxJSquwBfbwBma2a6bPNumFH1JDyJu13UfzW+v4stNJV2sUGYk1hr4mt9dQkrVsks/rzgCpFu8xvouw9Sj9ULJJCCFb6TMvitkYl4VsvNHZeMnHWcxl5prfCNRtn2I3qIdLUAnvW2ztVTw9txXnDxJZZqS+7qcYePOzd0xns8zDucP7INa7L6wGyNbcoeFjdLUT14zsozPGx1Ap+EXhtvmPSDdrDEyuxNQMciSGneyBsVn5dlD1x4mBcC9W/orQW5/9xMfw+6B83+juTU5L1UXCIxMwbvhog3Cw+kiLYAf8Xb3UCdbfP5950kMBN9h/xbdikQmMeK+YPG44pXd+i0xXgUIgGSqQd0GkqkcymrwT6TitCrWK2IAtNM771jFwZBVNE6F7W/GzRYOvw4REPIHhkffuau0bPwk1v47/V+zXXMyyjh9ZlcwP+sos40GYY9FIEH39KMP3wCdxz9kOXjZ/4dtAOO+QnVxSL7bFjDCiN+KQzkcAVurYr/DA3Rjxs17C7iKNOT2cpGUp0bsEGW0TnTlMDM5mSuW3pHX80oiuvTdQkxDm4anmH6M2scuiaC20ct49N6nr6daBN3OK8+Ln/UePk1h2TYdub5HUs9BinktBxEoYrd7UONC5nFEJgLYKEyUgK4WJKr5MPtXYeT6HhvnpNqilBS95NCYxzfX9enjJx7v2qiHYEDGC109/C7EV22Dnbj5pRra/Q0qFVFPqg7cxYeZjQgxQcsRb3LtBWyp+w3iyBPoaqJlm9MZwRrhrRIYNAdLoEpgpVKY7QRFiC2hnZJuxZe7eMG7xD4cQok117wFUlL/zTzIrtPFJmrd5dNxiZmzzjEKPIKkRPEitnS67DtNoOcdNYYLdj8zC739HfMrK/jtxcYVxCBGIKOSaigpP+wKDySJXvPZCoq40UThXPn6ew/eiQ54Q0lSn7xPw59L4ufUMOCmK8NEDNTCDzv8VYjZj3licoO1URMqKl5aulvO8mYTAKmNuvqpXZ+je5VsBU4W6eoo9h7t4h8axMjdfWOdKuQ7+jZ7Gs20rqRBjnw8Nd1EmJ8F61oGPai6o4kgsFNKMXFyYxvhCAebqjzepTIjdB9R+xZqA11TfgmriMJgnICr9kqOHvOaWazOz1rNEEB84ZTmSVvnBZcZBx4r0lTU/9V70L9fpqUjw2c8SHS33Wq9t9DXQtxFpXn0t2tmIVz/Pocv2crf2o/s+08A1+7mS94xt1iVw33QxF2PvtgZ77ftTkGICONfHf29TnydI+x2yYbTKDGkoZWMkkeBOPn2ZKlPFBlLXu9CFxrPhWOh6vMo/uVWiUiPCW6r1Tq/YNfJC13z1h41yL0EJxFnN+jfngr9CZTN7Vb0XDgGeHrgNnnCBN5tHvZ6CAyifpqDd2gLYK9YDn48OS5aC3QQKmywo5GWr+aK/jUIfrZO7yGFd+hMc1aBeA6OfdirU8eBNZT+oRczezQZDuoFNTgml+6/mqI5Jn84Bw6sVQW7p36Y6S6+nt8CEEg9rrQEQ/ZEhTmewRpBqELU3ZkU2nJItkJRSDUxnl8gmk/7s9tHV8a+ol+BqwyEJvUjtEJJjdK2TKYi6Ya3PYzzjzznQQ94XBxgJq+s76SSESDRumeB7aTK509L9NMVPpWhFwv4CEF+f5WvJiE+MxqoS4mKUM7brP9AD4VCGqaoLkZhcrjOImoaSswUGQbpFihgi0vVip2+/Fsbd72StDhkaUd+3Nroby+J/FLcnLgtKUd/bQpUczSaVFXyoBGjcvBZtyfOMbpSEJRa41KeU2no3inspvgADKFYpkhExUs6HgSLSHTfx4kMIaIXtKeAqJR0UGK3qkt5CO71kfsAtXarfAAjH9kDDqJLfqM65Ih/CEzEs5tzUoq1abv/++n5ypekGNb9zDfn3g8nRJ7Hbi5iGfajQQqvxOhPcwK1caikmITZXPEhcDNjhRW9Qn0xwSy+tjKPa6uxbM5Gsex/DmfkHUEc5VqJ/wQsbSzzfHG1zltzq1+IKvvvW5Qj/yQjuDlxnzHjhs36F28dJwFb+YKRjOX2o7x2hX9ThDjFhE/rZS6ngdEAod0giELeqgU5Y1PodanRk4qTgzbAFJzgsYDAOgInknLw9BzRliFx4iLEGZVB+ssTF7qKlYS9q7jnOwgN939Jm+dzVLlW2Pzp3hElf1xOBRsKB5zgcGyjVWb6dobIpSgZsbDxWBjO2G9RANytEUZHKhTqelLnJ/bWwYYlnt4V3+IgG19czVtWgHMNBZJC9b/aVRKMHeS9v91fn9OtrYBCEdQn3RW+v7GH9sdvcQuPMxRc+u3t0XBWsQ2j2vk76HagveFJPzCpWppn1QNLZtZV805CcILKwZlnZhjesVqeSD1j5xE9sAMsRllqT3TnSa9uTjliKcMeMhTAd4IuDX4cx2CEyM2ffxlK4Acr3Tnb+SEWjkdaeivnKF6c56Ehd6IAsODy73aCf/+1ONxqQJaOGCk49LfC9nCC1b3ZR0zQJBLzyVu2c8s4YtmE1Ol1GZzigmslfwq4iPOca+Uc8y9k4TOxqskxdIZZwDICHXyptdLS2oL+7h32KpMJXspM0Anf1y9JPCd8QuC3GKs55z4eBXosG0nIDRjkZV0aA7usqBhuQ9HFTvIfYvuwnk9wjuq168I4CZeXXnrSFhwzhMusA9LX6K4xHC4D1/f/c4FTvtk7RRGypJ0vl27a5D8T8ZACuL+8nRqFjYelIAWI4VkuxPluJbGnrNM8o6/Ln80VP4vb0DQHkIvYCsDlKyybfchj/T1ToOF2HafiyEUmqDTZ16ZRDurkIrvEdjPM9+e7ydfI7Dasy9phxJ5hNW+GoPx/3kLwQUGiT0OjERM+5irSCAUSr4GYzdjEspLcqcnMyJfbloJ5lUvqCaK0nZIs69Tt8ANLfXvwSlbS+cztUyLFjp+7R4crZJoeyvzZeTbHEwH9tZBQpTuDcz9qUqiVynMFpBybLz8nMYyzHn27CCOnSgMv0Ht0ZLzvhC1Lc+7YiFusZQ50BNXWaIhVpQ0IcemeHcj78SZbGviyJiaqN0KAMF57stm43R8sWTlBQ53cGQwEoqS4bziUYXLi4uKyf2KC1STAYlBSEt2WgrbBIdeEjGjqy1xY4mzI5X7xZ8GS4GXY2IVrJbRjAlwbzm3WyFzumtcU+gEfKGt1aZutzDA3+rfWIqzpXy1t3V3LeCl+tG6yFBnwKRhHmQ1+/afksVooOrvP4o3HEVqc6OGk3CV8HzBH5NiPJ/U7sD2QVQ2fzEHo/H1uZBJNGBCY/sIG/9zhXHz2S1DFseiAStJehSZC5kzDH9cgZvyNaUPVZoQD6JQj80bjURWkIDBjBiOetR5xC9Z/xQWLSG/cXbCD1hMBtn1yC0p4J3WcFgYTd4cuopuZnQ/17A1lf/TrzryP0vuunPJ8pRdgCf8gest2Dqj/BZZFamEkb6bnkRPzBiUKAoYLkL8z9eT0ugVS8V8RGEVayyb/2hmGRaen3zImn4eJMVlh7QWG1HdJbHEys4MZad13EIdxVnmwHGMNuRGMX81Jz/eqH0OP7eNNNe5nuh6Fq8wMO82nJ/uQ97mto7WHvlNWS4YAJE+SdVrZYqdJ5RqrvMW5KezZv/CSp36dnSoPwIUdJzrBBSTLfgFv5jaN/jdke+93HNCSjdFY1IfrKiz7EoEQvOm1REHtZS+Q+ufFFqeWn0Nzu7Xz9hLWVa4pnfmPCiw0tPSylT7+2mn204oC1ssLgYc8qMX4xW0vXPuBJIhovMWcoC6F42KIKH01cr8tVBY97rnE4iYAtc7xde12sEMkaguNHEI73f3xLcRj73+iuBnFwdwC2DcFnetBVN0Mu/7UzvhfjtFvHBY8gIl9U3i28bX41jTjueBuX05juz5/bOoyY/Py31j/zYP9/JIKHEEENHIVw21jJyXaw7wAD2pWrDbfpBGwcQoBaLAwgrlstZ7+dVhhMeJjhJ51C8Onx5uAuw3I44qEy8UCsSeJYdQ0IfG/bpYFJxFbYv+LCaz054hnNLiLIdCKdln8CtAKoGxGoYPRXDyDpsyjj/KJfis5r/H5t7tXTRvhEyw8Y9p5nA9rih/+RfDx6QIM3p6Vw3rhOPb9OID2Jq1OxbVQMqHxnRsoIP/nRMaIKcS18pQGH8n56c+YF5xf51DdzJCdqaqtPKZjdjJqDO7G2X9/Mv5fldKHHF2OPR7+ePR3OgUGUzqzD7w3bbYA3hR2u/EOuRiiwXnuJlSfhQAGsdPzyF0/NW6nDrcPThloEYkiZTfAgnCDCd7dCZnW59UJB7FSgcIIFNtIIM2HsNf0Htht12dowiRzyBz4s+Mt3lWKg+yiHoltWAAVD1GgfU3u5bZ8ueZUNrTKcmn6lqOyDW1zXwFWbgCP3MA7z9AOA7DNSPIMakAWbpr8MXtrzbwW8GJ5ZLzXSs/y7OPdBwQpxbpVmfZT9nbSACLz8rKjz6SprWnF/UaweesNaGFqQBZux0oj/67OwJFBynaYXY0ODqPzAoC5r8gndIF4mqovf7DRl52U6SjC3gclV0jVpufb5D6sHJepRKujyej81+SWMeT0T8kq2sXke50wzdjyJ1YgoaBlhmvDdIj0OIMgeXCGNRy5ZJQttxvt0wa4Xk8zf0WoeVqooenQRpGLloHd8Nf3Ml+g1bqU4erfSVZhGypJhuRK7ase4n+S4h0NTqpYos9R55eMaPiDTczQSApJ0BDpbZEXsKDR1rVrTORGK1ywT7UifTVyMSL4VgdF29OGxTu35h9oQsaCaqh+vUCwIfeUTLks2Nx1N51O9IB63LM+NQsa4aYQ4JFbhDzrqPUrHxDabyvnsxK9bKBMTZu8ALvzMwCaO0nzbuAxAbwew0z5NBc+mcC1DVeWzEdzPARsO66i5V0L/g8pyrAvTH1eJdXefgJ+YuI96LrL5bLRV19lw+3xj9AKAThWESolgBTfqg4rQED5lWsmm7nEMXxJOEzmdp3Te1dqrNzZSEWRonchfsi45BtaxLx4+E/nn1XdxfIT8GbvHEs5EuhK/tAd/VMdc3OYK8Pzifeo+aYNbgnX2yPsTpUmQgliy3FWHNe/jRLeFowLqW+esMLek3K75HsUQ5mOQhOMJ/A+yVST91US7ojNXlhzPEpopTrQzzRwg1IpDQWMXwIXOHko9NApYXBD5ewtk8mbe8zlY71VB74nXhyp/U0nt0tqVvEye33bDqXupEcrzPrDtxP7rSJOCnYK032IdZ0AZIRqRX1DChTb8TCfDRo1aNidTv+90vUr2OA9Ip73f0ZCGhKJeCQAtU7Gb4ny5NeKbA3Fn5MhfA7jO7Y7ycFYYV3tIBHDHYcjO+nynfPT+XbCwpwjtFSDy4kTeGIXKVdiUY4B8kRB4wgRyoHTGmmKxJXXL1ijQPElOqudxOi/s80PCxIYXfqJUE2+1s8u+xm0mUeG+Km2hI7RESIoLwNYsJjpQFQZKgq5H1r9fOa1g4pKMjUuJCDS0eEgHipq89UNPUzjI4w8T59JhHAUqDmqmR6LtBxyTiqvTewo1jCCJ0oMpMlTAxevQ3svPqlWsen2nIF7KQJF/3K3trDvBqhEyJEu5heZkRcvp9WxdlIAeYoivThSTVEU2EFfnuGv3kwibkeJsK/+ulgsE+UjYSfIxtEC0nv4FQwIXqBj3MrG22x11nUUf6KZEmlXvPd8yNR5fLs4bWPhunVF86SNBJePW4S6si+XCMVTmVRLqwxt6QBAQKn2AGIFURt9w6Jd5bwKnEFAQVVzADA7rgZGjXb80wry84yVyYnTB9PMqc5KOLfs52vZxA4tNYNxE2qIiMZHQ4yD9i2+2b1Jz/NrUhfB7HLcH/2bIHtNkrN3PTikB83usHMtDp8rETALigJ/jzbkgfvCfx4VrMt5IRinKUjX1jKzuQRgJljbNAT2QnhZnM2SCB70SF9Oc04A2BJYyVSOSYHSeVXH/lmEY/S3N3U+B1tVhrieTO9LsNzU9zAR9T4oosnAvqqn4Xv/44vYYjulyyl3suma2CbRge1+oKXWQLbC1dv9HO3DKXUDx3L9avKS6p0UZQt/ufowuADtZxDJgz/FBkP+29Ilo1SgG68PKkHtDLWE3lDDNBLt2asCngU8VdKmfz/1RwvujfEZTt7+tAWxVHk5XWNBhZfue7o3cVHL71t6EIQqbJBEcSlAOfj4dI2cND2mXMZcANsqfThYglYy7SjO/5lvTssoqoUlVPndd4jfFBoyk/3NHt22s1Szx3lWsDGz3JjT7PZLXHxCYFxtbBsAZqpkV8rSpUo8aknX7uH6SJWULLsntsHQQn2SMgj90Gicy/4cj88f36H+nJWpWiXKNmwzzSc4p+d3fEMGk7izsQ8sjtwjUnaUJKP7qIAomPWUuMrBY3fxAXWJh1V5SOssQIvidvtJMTST2LEVkDQuUp1p/ujHn4NwSL+p3a+N1d9I5clbcj49GZfW4DrpsUHBkGIoaWip1QaoYFkLyVTuBLB+lWnCLr+Z+LppvUz9ykADeBRCcKHs4yYNHpwTaBQHyOS4r2yz6mJhAK6fLxqCpLHH/8R6hJCoIUxlqhvDkXpjZVq+vaSip/r0Hc2ubNN5Pdnj1RZuemEYqdzcdkPQQWGEHFDF3NzaSwVTqXL1W87Kyaf2nAVgtqzD9dHLHIWwMOU2O5zNywO0Ii1n4kf8G9Y8QQZgPEIiv3hqAmc3EqxsdkvyzwB+fflJTUDjeDpCDJO9GY1YAByo/pM97A9Q3EAcE3o47kNTaasAehpQmvP8AqktBLaKQDiTy0uypz04AipMqbaR6pclDdifGuh8Ez23GbGCUdxkhGv6/DY1ZLZNpncRckEWbRUmNWr3hG+M0MZJDPfx8fZqBxrwqsWPkLreS9PrFWIG6DIb76vDdCY8ViN8J+pMwzUIsbqAhFFwHwhGmHcDBrxAB1xCbIGZMTnxJBuzxxQ5WBraijyPuZpwUq+SKp6rVzhzkl+e7rAq/lsz5MZfXNV1LswstOOYygU3IQIsJKfl10dcnqmAIBqrpjC2dOi6PenapFuY5H+DwFwHNC7Rx1Zc46Q8lNqsYbLoh+UPI6okBzvPJqr4RB6LgIZRtx5+0nJyZbRLkmIQA+LBhIYEt0EbEbVPEk74nhlE1MwE2A4BPLEoiHc03rOFdT005aNogI6BJFxUyq/p3O0SSZNZWB5mdG8YUpIu08cn4tr2BaOLUC3Wjlac3kMd2gG/YUkcmqIJCBOOwQvdfSGihKTjZQYiBZ5H4R6y8hYPUChHiSUy/NlYkxzVUPvZDQz5KBSBNCLpKNKBiDeSGgGprA8kqEWiDka3KGq4qFUUmfCBkdlIuHLrzOAVGpCQRtfMMbc3wLhK6G2HtvP5yfJf2vsLhIiDboJTE3LsKWoK1II3a1xT6F+xGrQX7QbfTvBniO6UWyoOwQrsxEMC4tDgmN2dJoIQ+C3gPcIHCoAFkObff7sjgWkICDT5+niA5VYJl6i25RLwwqv1+B0FmUlzCWoThCLoxAQnQx3XPF+GtYRPVNTZ80x4eLYsRAljDjRpYKGnHfHhRcTYYxsI5zyudn3PfkCs7xNOBdN31A3iNVPybAbFRPDDpp9w/YM6MT9iZuOeh1URrbQ6ogabO2oXSwhr7IRzgzQgibvCKFiFgWws/1OLnJMfU2k8uPTmGcmqZThx3vo2f49SjMb6JQGHdRqOltWhmf8YLkmBZzs8nnP71aVeh/Td7CItfhAo21EtbA1K5ILSNKM88z72coAmafZp6tPLZ1heP+OAuCjZTwJTrgqobF5SRVCyx6FtXzZ/weHHD2mUrVCP7P6wIwCHNEJNzMPCxqEoL72/ntLfghsjp5a4NWDi71iV8WN/x1wExnVx3fkFGzn2Xt5RfTM+2W17d5t6JqGwQ5lXNqQD9PIIZcpQNYZgP6vCECqDI2jURKfE5Nz6kWFYSYYv8dn1nh75jt6+UAgQGqNKeJtL+c8/dwztyu2XIWjwJIVEvq75ZQynQXbR8QsA4JHWCDzvQ9CCmq2cjRktbNsKJL//X+1xDLr6xjSPqVO9LDodvw1oAx7PFr1hQPH7f4YW2RFblhcSyusQrRF85jnFIyy32a03iXecEDI7rRaupUyspVhEDvgx7gk5jj//oXNerBf6dbqFZOcGg/rpOroRxzNmFaEPSaIiS5462D8hmTJzzRkBkGBknjWqOPUvoiNNxu41hDAObrvFySrk3TizTPbWoB0eu4FAfZE1v2nNKWSOLUI+drDUsnRcnZRPWBQLPFtNX03Bwc5FBFGoknI/ZEXjIz89CPcfZg1/EfMG8qY/d7BmDuBO/QIAaib6wuhLYSIBHwggLFjnXkkbssUwhMGDsBAwBeXVmAOHzM7WgsgsFEtDl/Hhx3ExlGkd+XFIQaNStn4b5c/7M0oPUz+f+Jutaxj1+iZCRV+9kpnCn5OiRtwUvk2RzpvFc4zrQCaZet8/i1LRIpVhZ/PzFPVCF4/h2k7wmfq+qTwJP3fKE9KTfwq1di1IIkZQg2Qv6tRcOW98H1wzvJzADKraVSO1JKMnq/KzGfgvCRnly1yQNmGfpV7Nxrg+l7XiSaA6aMfsyqgLVi40XXib4WVttJz57AhXuPkPUX60Jp5+pVtJ7jPtTNhfaHCo7L+5FVjVfDXvk3wTdkDOD8pLbjSLY8lgfNGD/i/bNeaRJpqFDRmkmJlAyVLF1jcGkXiP+BYsnow0rKn9oLNfKgS8SyH/z91qY9SW8KlMvzyrqrNzQJtw9HrsxZ21pRskHkxLYHjdIrrC322eZdO6UNf6vgr22Il0/oO0dho+jpW9lQ2RfXPor6R4XvmzCQDREQuZm5qPGQyD9Rsu4AvB79psZHgozQsSaznSyMbskro3Byfo48j3ZpG59yVc22MktMcQ38mFZ3OBQ130/zPxiuCQk6MT6+nKfGuRvsz59mwr/1fui4s2BMiC85M4pojVRpTEnj270CHvLUhufC7TjVw3FkpP11CQav+QzRjas7/fTq5G/FG7QkoLCmJFi9KREGouY0cjUcjGFdT30WG8eIbKrfbHXVd/y+U3QuwTZPgCg1PdGMNesU6HfqQW0jTIFRVaNRyRM3AIoSvGdqZvsGRJuQRErAU26PJNmgnXhwhYI1/BQrArw11gY0kzReHaxDCxear4JGNC8t6U1EYv0Fejas8ylQh6ee6zmjdU8Gz3Ik+zeWS0hyb4fntYNjQEDZeFXDFgTur/TmeGfsbmhOY92zupRgagncvbVW794PTj+aixN/OsE8yhUea3BH0bLV48jiLezIg9pHsTJPEOTKd1v2CN96S4CaIjesAosVruOiO7miPDL4TTtemHP7xYWL6zsUBCABM3azam6RoFzAMvDfwq2Fth/LAuQuK6AQZqpmnjEV+op25Q9s+1/yjlMdZV/Ny0Ol/X8KWFPhGPfmY1xkTN3kKWxwUfXjD+1hJmeqaZOpAL1LpSiADjHEukHlsfue9pS6gXj6rpQCpM3TJ0AhkOHRVup1C3k6vY1smmNrBuoj3WowjNFCBQJwOgZbOBMWHLhnptvczTaNxjLLv4o44re2vA36Z2UjBMIrB9INkETMM4QaBRnFySmw62XwmcirRIYIjjYPP5psBZeifjjP/GBIQQDeWalgOMxNhiJXeIlBV2k6ljyLqqgzX2rRJLpI791e0XnoEXmrNAKXJLlF05G6TSyqd0ZSpay//US7Au3EX1FNSJk3KTTTubnzwGRo+x6vY9izNKAHv5WKUzEQnw78IGPJ6/gjy5xtBW90x0cQslxUGJqqLoRSbg9xniXt7Q7en/2VI1liFM5ff+uRFujx3OWCUbvIa+1zeHHzqLGHotjvnda12jj0tkXlcN1O/URqY7espYB1TMvnZg26LdMuzZhyrozwWpV1lP2XjGayNfCldilWDr8iPFfn9XzbizarIxxR1LOFLQSkT6STR/piY0Br1TNmB+IhszIoPwQ4ft8p3oo5o1a9JO87OTY2q/uNALEF9mLfbNgO1oruOIFTeZ5m2HxFPki+fOQ26ezYlI3JSVZ8t9/GVc+WNeEH8VtUPjywZXgTCXgyTosOhjCDZyhAHkOgapnnF8vU2vLLFdQqz8/oOwGIBElStHG9H9F+xxLYGsCQKcmIvwsgwLS3mWe4a2BPqQsJryNqJ88nuFM9YvJHRBSRXXTY3NNqZj/h9mfFCpsJWapWYbcWwr5iVC5206CWa7uw9eP22l/NS1ZBq2+5H0EIGeU8QMAZbgmQGrnpAd9ihQWGpou12Y0la4/02kyKt/rpzU1pi0rnxZXWOqBHu/uehNiPiBv2/RJUOVFX0StOBHCxxhLafdTEgK/aQnxCM7+ZLNpEDw/dIL7JNIofHtqTDMMgjly2YvXiJPbLKePnxCpUmlOsLTEXjigrjmuUTfMV9WFZDhgU26WTsYucVkh9NeIvZs4sCLVW9zYfpD7Fh2zn8x/GyZvTbb+xxNCGkJD8cQrjIk2J4jwz6VDp94vVwUZhAFAhJ7wDHc/kkDaQOR8i8u3VaKIPymh9m9VYVFVEoQhOARFAdhWU5MWCK0qOsCA9a4XyVDn+bg/CIb7heK7Fh0P4wmIKYWuJ23Y5mOy0NQyhBBBypohwORwUW86+CkUbSxgraVEoBmUpgVgMRT5LXdzFqIkPyQyL7j+adxMEOH9xa4dRlRQz2tuj5as38uwr9kjK1UwiZ53O7BXXvIdT8aW1C7ceVZDon7YdYQWeUCs8lpscQx5u9PfVBVBLyWeVCtmh5h5gb/5wdMs44urPqc+F3dg38HrVNN9WRMMz7uE3os7Oi7DMLs3bhfv2hoHdkIeJEFLlt54ppBfhuOD/SjnjbEEU4tSMlNpLjmjAZEvUdjlkr7LsQWwtkIBiW3VMbVS0dV5rfDXaNR7Qn5sM+C5jq8mFczq5l3aG41kDAw0c+vIAAWBkWsbMhFUxc1nZtVcRhgfkpAGyueTrB/LQIm6bcpy+TycGC6fCzpyHLykrBTxpIEAlj9HFa8JQ0sv5og3ooSe4uGHD+t/WofNdUR+MKmwYyriV+doUWHhzdP3xP6+PyHRqzAUorg+l3DZP06Gwxay1uuKtlPhuz5VJt5nnWCeBB6Sv5YbUSg+SwA/MlvUixeH5zjTGTUi4lXPraMnitGK1JkrlOXIx5AnCCEe31BDNKFfn8Oa8jKV/4WIPYOknnaqkvz/fBZWfnaHEvovy3Ao2gTW1JO8NPj6bMvwd9yZfnG7QUNpHzhVbbloIYBUFHtQ4yx+XsAzEHg/eJRWrzalmvGXVDGeVKXtbcsISI0pSyWmDmeaQ0L+ftf+2B3LzhebtCstRMwKYVuDMWbbFhdwtcyjTKcrXOooieyKFaioSPa0wGCgMvPJkR77vb3H9GGj5eBJesXmN13axJa5m+dG5g7ziBn0oOWLMub8zc4imX8ijQNGJXnmMjnaOyzs3U1lfXbQDwi6XMFZnCZbAqgprMbUT8fnyhyVHT1ULTimCtFIWQmdo54LbmbkeowRKiiJVBX7qdtfgno5qrouQjfxqo2u3oOqzkUzuHWOeXXqsW06jGjxUfDz/MqDSPyr3u6b+11xw/QdizoT3Go0SxJT3g6B3h2lfNKBzfxX5HjOgfUpI+8DhSzEGbqBKBgno+ohyFkjEVlE80UOHPG/l7km+E73RjpZcvgKs1TnAqIpiFXiJShUql/lNgCVoBQ95LNMx5U5+l3m5CxIbI1WteniZ5Q6PK34OTAfJtOkBw/RzSWsNMub4+igIj7Hi/VKT0zvpqLV/EUW6XGsz//HWhIJRK/DgSQECyN2MzwQniGSSytEM34JLNYJs9lDrW82JOMgk46oNy5sWQN+UJxcjaU2qL5vDFbMw7edrS41n9AS1Mxu0f97KAJ0lOUmH9vjciXdvzGhEwQDeQDahAbQwzVw28IHFh2j6yeJZMNw1Wi5hH63n51ACMRJVHk+V9Xps3MgKl9goO56HR153+jiWxd4k0c1rvgHxntwAKHaNTgDmgpKPrelKsoVkcKpBbEyFjAVsZTZgzkp41bVRu2fxGO4h1WbSEBRs68fiV18NIhKKfBVsAS3b93jADN9FfEacF7wEQV4dBlxOZ6s1IuaSweUG0sbLYoOXU6J6Oud/BcZCPhoSHCFNl02ZZYnnz2Q7mLaRWtWhyWUoK6GoA6pejHqBzMk5NBgPYSMW+8tZ54QGLlMqnyJ6h7m/JK092i9TSuMxHvo4mrV+RNunC2JnNr3ncDrzh+Qrt12aYTdSKOSoZwj/8R0NxGjqvfYGCGqtuuo8awmfbo9M5VJjnDDtz2okDpdBh7OilWVTaz4i88T2jkoE/uatOSTub0b0IwwO7CywK0PPCmNdWoMLSieKL4XWDKymdtOsks5OPBK5+k99rR+HSh3WK5K5B2AU6vUMubg0W9rdXwVjHkmrtNYS2mAyfE2RHZBzVvpgtVeDbxfwTtC7GHFy9dQHlIY38Rfl460I9w0vcIlqFU2PIRDp/AJoe7xKvhwuc8Q+bYdbhZxzPQESYxrBEQSCWaTgXi3KKN1SCcFH4Jw6w64Gn9zLzIZuCQqldMC7h24wxypiA8h3GnvXKXnAB9RTm3R8uv1G9q9/ufDG/bTDtYjK8qCGxLxHZwUlNK9HtFjLS1z4lv+Hx+yrLw0tS98Szfvta1z65RbtTMh5PacvX7MeckS4XETgEmYjD8NbHZ+maxyEL2FmoTqsp0aRAjMdGiYQrnnuJ83UF/cJZsXAT1PVJ67SHgIq5QQuKcFodxevoqE4p2IiBwa/PcFBJaNgsQX0vX6Ns+dPCKjMpXX0/O3Tau2poN9NN83sroTs5eYlj3QN/HGfG30ol6PbwJu5gbq3BgFx3rTeChOIlsvwNmfQpDqh7wqxSUNlAPkkaFGNxUINLwMrbzKmLJjQfGj50ZUG0GvaHjm6RDFQ3Ebjxb9PRsXrl/OIKCWqvsG2lb7JlwjGkP7QH+rv3Y4knrpL2r+DNcWh43r8ZyFBxgjzNZIP2TTbuzQ0Rm2Z2on0ZURs49Vv14NaSjxpvDz4wgwQqNpgLAszGv8lSa+wVcKgvqasrSKnWjjjvdPEPFIzwzNuEnZWR49uIqniIlV7Wg95TDVbm8WERX9b7frmwaI9QCybG2yO+G5XEmEhCMX7UhVjQsOkrmmCdrqFblbMHNT5ta25bvphSSH+fd76M/0i4UhekonxWbiHgXKCPKPkUOGlOUiMFE/i/CosfX630wCizbFVWT1kjopTMnlpAiYIj5gg5RMvTQWki9gjxqU9Ma4IAOs5E6TFNfF/mdiWoXy+2NDKiK5Lc3laYdV47LZnSZkF7ofByARQx+9gWli05HLLuG/l/a5g/4VEf5vIMFw191EoXiECxg9u45DlvZArCNCPf9c5XIGdgL6LBusuMdNVnUenXqqyFio82IaQ6ZeGWXQYYDbkIYrAWZbWdfnhc6UrFxgs1cUEtucpslv7QlO9lVqjtccqynvreTxTig0ZbTXhkIKo/OSAHf6zgSNt3utroVNJ31fb6isMQXel0GK7qmq2V/cqG14tgDB8/BAl0Rj5cDNhtGdnz4KLACJLVHQC4+V5ZoHU8iSGO8cRmheO5pJyrXInrS+R3GMIxxSxVRH0OtDd8f9FbD654luD5TRERW369ESrqr8OgzvhlJo1yyCJBC8TMzqVXmNe3zSFOCeB1s0JuZyQtYAI25aZ9byyURcpWcIqUudOTaAcZBMfNtqN4az/5uuOtTxAL6NoW4Rsedv/39b7nPix6Nt6ZKTvBmyqIRLf/pjPeOVaavFCuf0bsvdf1ECCVj+hjOuHPEErHtm+LXXEZ5QZViupzlA0DUDlY06SDXifZuyxOAAIdBt2OQCqGjmad21ujeY5RmoqdXOmG9lb4Q/3EpPJS/HWYA2hihrgmWsYkV6jq+sLHrnDXPUWuA0M83WHhF5s2ZdTXNqDduGTQgqSliTd3iBMtD/YhRkdksplZ4sl9U/1Qzjwj0wBckYo6Uk/hTQYw+WNjUXlQ7bWxv0ZlVeRUYnslV/gC6kFeAG+6AXMrgy7F86zYFH7b8KKyFi6ZZndhHtUkziBDQ/R/VpExeuWBrR6vlxBfhTmIRmx53RV2w3/Kp/6KjrMhm1OEUmbDNpq5OR6eVRdkwtxqN0VAd8k+T2OBb/N2o2EX2BlNv7bS23rfiVG0OFxPzBvT/N5S+AkZj33dX9lD7j/TCBOf8ury/ToY+jff5o/393vDCXG1tcWceQt9DrB7dEm3Chgvh0mpdv9VPdvzw6NuwH15MNGUAVHuWBju6LCe0Me7bP0nqR0SFcHf+jSFeeNyu3zVNkpnepDOiya5e6QLk+KWz0eK2TkZM4E1V/pMivgB9zpYQvbwd03Gx4mghhV1ak+g0RYlQ5URULeYhEvVpA6y0SrdTxWqwAUyWGomP9PNrQBc7cnQ/4Burw/2nRQbEBp9H0248RrqAkVGiBiHeXjDqmPYPYgm0YVjEXKydjspXDwmD9Mh0x2BbdxP8HrO9F2uw65dps1ZdUFu8FpmnGnBrv1/7MtfJwrSRhbdWsbDppKJeizdAVGKO/Fogam+mC5IpyQh0wdZeWlRipMMzqLC1Y3o/dX4EdYZhnuMjrIQx+uZlO0vyYD6zB1mvRsjPNz3UmorAq1fDOBp8SNg2hqd8kOMJP7tU5Z8WY6W1iW5QPSwSfTn9Pdwl9CslTTyUI+wgZJ1A6tKi/hbVX2MRyIbHSgt5ZOQlEYKgl5YKWqxEqOc7xbFr4/sUeYQIz/9Lov+I30JGJomHB0lKOPb8ttIywh6lsfDjtLI8gMaFKBRhpHmWuh4/uvGCh9+aYx0f3IuZiYv8xJpiBAj1OL+19n0VcoEPD7UUDQfoto/r4NS76rf/FpsvyZO9j/N4TiJATPBLS9lITUAmPhV76sAFYaUJlnjxGgK8zzVwgP7vOseASjfnwvUyNqQwSrdTcnvi2dtvbgvuSG37TLKmaGxmHHpt8kphlm/nWI605kNEODFkW3OcRKPFozF6Esc0iwvvqadI+TQlLwqZi0Gk6mBO/Y9X3NrfjFgjxr7eip20JFsY05QIFyiiiBk9N98tkcbhIMyTQsMDKbZF6eML2Z6ZvNBqRihBjdWJ5EiWnKO3X+doCarSyuhBdJUk3gX2O8DcDtVJv4KLbdMx7T/SZDemr8gStfucGlRF6jHjqflhc7ikhB31iRZwkD+d+POdI9XK4/ywhRTb7lzt/Ch6qceGuXKVQ5Nk1OnJHvWthF0zeb0qHKvIib84fN50LehnJ8/4V1CAmIE2J/FcxsolnpVE9Og20iXdG3m+qxbtPyQjXtwxu9hdB7rvlHsXhNGDFp3gEQHKM1R4rjyKn0un83WZz4g5UsmeNd0Hi0PGWvdvglHKzA+VpwIhk3jCe6NrBBTdtX6ybehJTWMkhnosoagOW8GiK8JU4wpZBo6Y9bTX78AF9HvSyANclzBZvAo5+BMA0B+1IOfRh5BwMveOljvW1BlC1If5vfiocdFnuS8KCwThV+NLVfrKrTb0dNiV0RLp1xatMM2erUB6i/iCClzw9wXRYzjZ1dZg0V+N0+Vh2JDTsWr6GpDeWt0FtnwW+RSrGBXGFBhIfQMyLurxLUHxhug8+m5i8DkAGkdvUUv6eMH1xsW6QoYYe3gqAA+5/LhI/Ft6IGyoVzPN7Ux171ldJSwtC5Lu7MdYyhsuDZwnQhZ8UNUvZdJWCJxJBNOmmS2CG4gWNUL/cijnb/bCB/hukRXF3c/lj9V4XH7+7nA6k+tMxCo+mpeb7wm332GDKW+AX7uTjPWQZMReOO197AQLOV7U3lp+TxRMILCWXV4/HMGaq/tF6v1/nG1lALqbfrlPPgDETWsgqhV3NHB/F9Y0Y0yTun5Y1+1tivzQIXib1sWu+ki63y42kpVkvLeuydXJMMy/poHXWlWl3GcrDLyoZmD7mrWsaXiFOmEPytu96B4DyUGMF/v/JM6n0gA8NJNh4Gn65QrQedobgKnvxnXpm7kAwDtvitUf7hsHbHLgwLc7yXALX9gpai1jQv4GFhxgVaGWwRMh2FEj+TlvWPCQDzUCbF1boyyvdZlLGmvmUjUalFT8+KEtSBtOFLUFeaus8P4og3gtlU6AmYXM3FrfNAAOQkpMyS7QY5dSdKRghM7/EBHTZe5aK18nFAQEH2vU2U13jCnCPPaZ6R8tAmRKEoOPwecFxdTTjfPYifYoCPcd09bNr10g4RnYYJ5lz0dCPOGY1j9tRCVBmMBDa5LqMOjCdYTOSp8W+Ss5fWOMJsfIqN1t1VUX+0lxTPYq3bMhrdWqgyOopVmi58I+Sbe7NXRAKj9tZuzvKzWoYUweFFzGjoNCJYeoiCcMqZikT/hjLSAv1R8fewofHyh+QmYhbiRham5FQoTyDTqhx9wBDhM2tnEt8mqeWiaGIOI1Zv5oJB8Qkx7alHZuN30FvoRMcRu0pKJEeTyJ9pZNLDUVOjFbDP3shwyDX9+y/Psvbx+ImpzNIJRIhQ8KB5EU44+qcb1fi4bhWwN74j7fZ1+n/k+4veJzon3K9h1otbSpyUe8hZEC6aA1rZAmCMSLIpWBbZjLpXH+QwS7GdaGbamywAG4dcffWb5sMWMIUyWx2q70a2NXYZ1nRUXd6XzLSVcyr/91d62GQS9c0agN5WmgJfHdQ6Zqkitukck/pMmwriMhCZfwF/VkA9opDD9NxtmcC5d/wDVX0jhhSaGtKLAGIdY1nFwyznUo4VZe/6UldW0FN3P0dXPDmKXaCT9rtukCjWxbgLkaEszSwsnVGTB6nMDvWknKgP47wiKvseBXOcMXDIy4V3zFfuUsBF6PfkKzwq/ZY6qw32NfezYvQicN/n385Rd37MNhraOiENtICffjy5Ev9zwpwvMZBPWISnxWwMy/1eXUN/JXkOOb+Kt0OsvuqoyYRHavcwCS3oavvbFjrlmtWSRP6Ivc1RIAozxGCaj8HpPPTy5/TVpXZOHyUSd61M5BiMETrcKhd0Ma9xZ/fXjLWN80cQur5EQFdW0NIRQDZqjwxCUHlFeeVx9L57Bdeg1PVLxhdJP6LWlbLkZu9NAfearTTZTrCKk0L1MmZS01pnqpRye2NF4YYFFEWe4lMaEfsFr51NGgb3J54gyODLxKqslTun5M/DYGPXZ+nzeg0Y18z2bc+4WUwxAVfKzrI99RfQTneNsUvCeXfr2co5uIR/8c92WwxmFqqjFVwjwDba0tSnS6zIe2pqtptWNySaebiWwwQjotm2DFoKNrJaiPZU7YBjb8JMTKTYXwOiZN4cFd9lUckDmM4IO2q8lgO2mXFNV1qIeEPQdS8cF19u87Smiirt7yWpTYCAL+ZwUiL21v4sLbkl7p9GKoHtTgE75hi7MI2wFUoFrSbh8glD7hGO4uX2IDNUT40ywud8OgGfVlU0xboi34qUb1NQNl4sED7+FHs8oLzs9dq3YKAPIVQKPw/qmxyGnUeFjkcZ06DCgBPKUyEPKOxlBNprOsavBzZshd+PU6uWgluEaZWO2PRhgewxUu0iWGuN4f4aeb7pCk1KbgIau9jVxr3VExKSDGna5kvYs+FtCJcJEG3zVjZaueHyC40strefpauCCbjPPYD91kMWteiXeraBAQP6NcLpZDfaWETpHVt6y4y43Qp7Zo788aTxg0FKQMZ8XbBJWe7exz7xjZC8l1C+91+oyqqONKasMIPu4nPqouJVZfpgjZJLq/WGHxnf+rPMbw4LHOLPHdGqXGoYpRALO3MjYkXW3yq3IjtVFWoMDoIhXEUURGtYqGUFABYsWeNvWHnjGz7I50Sav86VEasmK9mGi4MoP4da98y/AfrswJGCxI6UI2SdBEDRxri4ObuN1ujSojiFBNi2K66D/r4sftDwTeZpptnm9g7yMhDU63iAldm0skuXjBzONDm1ACRaD6+049v2yGWOncJsRZGA+fgtoz8qpHOKBgmKzvYJMj7+xVx5VQNr6zbT3l7F9nPH5VnMS5vYBYBsgMzg7RyJtEjnV3DIKrrgzqgPP/4WxGWVJ6ZYCbEZJO/9EPTBGyAGz7jkgWI5wv240z+aWl7PgzYdXkdAYWFT9ruCi1yaDczT4wnu6xNIP1P48wkZsb2IWpguA71fQmbzLZ2xszElO1dVxeu+n46sc4oGn/WnLdaM0ShLGjQ34hp+v4cIBaSPaZYS5UZQTtsMrVgAnXl1sJlAn7Pj9/lbt6q5pePjcWKphLOcIpx5B5oSfTEz9yaz3Jr12kQBHpTIyDhmVilUUjVGW7lQIk/AE3eiEcMQAFD6tpmCuHdLXfb/hGNhVm76AwdS48Jc8tWZ04L1ggfz/+l3ulLP8+NaEoYg+BO8Ffg4ueTdWJOnlK8d9nacgHL7b+nuY/srQaqsE8/3W4hSHTn9d6mj13gmOf6zz5izEjtFF53SRLctacFBKUyOOtfU21+NHqYhq3YjQJ0PqDc3RYgLPOHCTbYtdrMS4E2A6fNxbRHC5+Eq/X5eyT6tJsd7btZqk/gEofze2fOnROa1wfbKVJW5H+dYw1NzQ8H4wB3uA2N1tkoHeRMs2z87l2sdXpDFc74Vm3oRf8SkXyRL7q0UfbY8mU2wr8jIWWP9pgYMCM11INoU9HrQ96Hi4MVI6cQLuXtAPVt7z1tUnUYQpZwcyB7xL9XOSXIATtPuQLVWAvgAg4vlo4nyP85bvJFydKQoxQVEl2j1eOBpsJmuNya7ZE08e0HuqotUAgX/3cceDhaMM4Ne/bFDr3qn6Asb4SRZwEUxuxGBqJuxw5Na3629mpQFXrrT2EhxdRMqvSGIYRZ7S9DPUJbcxWR3QVu1L8EdkucA/oBbpce0o59xNcripE7j/Hq8EW3/Q9ZBQJ/QSFsDyrNmtoeDV7t8Y4g7CPN6EEbSogGo6KP07pP9AJZIcIpvRllLELx+tWtnQqrCvBFDJtZNbdTW56w2zCzj+AD3ANbE0OGr9p4adjaQmyZg6O12ys+4wcYWPut5zEF9gPF7apWTGGWtO4XnQS4I/WVCSZBGMf5PQ0Fti6z6clkgeL8+qrffh+VUzp1s7NmDUzmGEqt4/JqCPQKvWj5SIYxj8dMt8Qqx0yoMxCcMub4rrPv/lx8qzT9cM6ZDCcjs81pvZ19aA+ITdYZ9U7AnD4wTCYj2CF+7eSYAsMwo89l2eSyqd9P61ZkElQt/kE214ePGFmo2FqGJAwwaFuolZrqyAtjnC549wJYM/6YnexS4UV1iyTqPjnpgNx4eCtU9aZZZg6TICSbeqo5zDqlnEz8c7FnyVPJCC1bJe18EphqV92UJ/nonZWWh/Ja33LfDS7tCY41fLoDcJvo1HZA97epHDi9Qqk8NpixBvHriXOIPJ8ES7okfsfklRTHxB4yQMx9BZnAq+1TT71FQNe+i2ISFmbgK9q5fu0UclhEdWDgUwsMrbgx18KT4zYyjirQ9MdHClJ7mFfVmINPD2d1glHIH8XrPwY3MbAQL9jnOypdjS791bpV4g315O77p2Pw3QUB5+0GgYIgZmZ+sxkblXGDitt4s254zJfsrMmvAUCdxmFETb0+DkYeZ9asnYwi1GClc6YC3OiFhvhdkuv0U9Ma0USGCjAKKcwLpc6mZ8cb+NC/Ai1c6XYoPi/AzQUP4Y9R0SbMmuKXNq9APn0AbLbmaL61OtQ6goM5Z39YwX8UuL9KOmk19uDFMGdFaVxF9zFnx5QEF7leNI1dzjdpDppDHQNGKqBRjW1Z4iCqoiBkImi7rW2l8AwtZgSO1Jzpjk7bYml+ET0C7mePoVnAJGer8M+3LiW8IOAaQpTEk5JHX8SIrTMx2i3224X9MNiopGXYJ5T1HOo5cEelRofJoSV1Eb+uGdZSx929Kzzdcaj4+xKwPnuSJ8ao/qxShX6gRPQCEblJLBMuwVP4/vbm0ncl8/wg4SvuzxfGceXnhE9p0nwIodjSbc1z8nuwb8AwvXDxAn0rUsyinDuQGeQC1fmVDwrlZtK7Rr+pRfbAeeYLFXl+zxZhkrUKnz6Iegq4hmj6+1+DX5ZrAR65SNcUCz452Yi+e5bUayRpey6yHw8yu+M4Bmc4Gx2l26XSBaBrURz5lAx9Bej28kVCtE2wz6cX9X8fKFYibOA7ZO6iO3BWqhGbItl1fjof9lUOPimLziuccNonPrcE+T9R71dcBAGCnQ6FEE7T0ISc0Hvs779Orq3Ua3NTBoHMJDZG771zp2Ei+gCGqVdODpEZYTMKyUJUBXIr/wMZzI3HKFx1aK7tRMdVb6RMnkWKfkg2kJa3kRHKL+El5N/evbNkkPlGynNMAOlJ7A5PHqGa+cwoziyyO3Nv2+dZ2ysWLgfNjGqqZe3yGaajP679C8Z+uTnJaGdp294zASi4f5eLtEZMthT/3cBXwtwcHwNiGVnDdwLSL4YK5uDxgsWX17v/SYpsRaDFN6gl2ubbz2Ddh6goA36nx7RbxCGJGGWKLAbC9NgAn6To46UHunWw06takjxHzAA+HRTITv20LUi9NJ66szZD8ZiekQy/dEY8QOBm453Y/2pGlaqZI3oK0kHg3rPxsqRLErVHZNU+B17FxyOGqoMbkz6S96DFmM36lJbRjhn9a+zLAAIqYmGy8mDaEFuKXLgTgXe2puQPVyqZuV1niPirL85uF+M7cvY7BD2SwOH3QXAddSX+Bpqm95dFQKAHg7QOFIwoesRqLnFCg/jdjjtCErsJKpjgtO+B2uLpn6Jz6aWRbg/dtRsdU7Zmeb0Ct6HRAh8PTFwdvn5xbuyQv3FdRkdm0+WuOwtyzPPahKQYbmZskvtSGjZRKSAA8uAnToXLzCzokztox64w7K2WegskI3U3cxEWxifYw1Djtnf4tgwjexgT40MSzysY0hnasiUldAlgE5G6yVVtnGKceFW6X+s/dspCswsoEADgivS+BngBoIfnuy02K2+5Wy4/Wav9Ym3oiw0IutiyK3snI0wxovqk481w2h6x+kxWzoH9MTD3GwStz28ZIGxyX9gsY9GSpNJFB+bQC78i2Un3Ivj7tFDF2Yz5V+2X1XBnX0LbZimFZARCQXRFYs6LVFlTVCJkz0a6VmzC5RV0OIGFMa+edo60xPxCYKmpDTClXQ8e2lo9bB/0Em1+MIF3KBJ5ShoxLUa1xOKwEH7J6P77AVlnvWQ59VhurR/qsU3/EWV4BNbe9B6r3o1lvQhzVJf+qJk9ruqgETwFwwc06vzvDOvVhsiIr5zFRJP+6Gtzb82Vk3Yocv9yrl/Opv1W6ejQeg+1qCQjLLPRykjCeN7sfmbSo1JJ2gXLcBszgDlsFOxzVB0dhEwC/iCknu0u1I3e8NPRrvctyEbaw0dbV0wZoy2UQ8hEZxyy58MGu0yY9WU6Z1LOoHFEpu1dA3z+FZQww/yG0+gqMLoNNHY66iyFDCl+8padoipf3dlTmwF7epQCvMbcWx1FYMfmFto7L6wtpE+jYYV6zc3L03k9fbXt5SEWiqAlXVxddH9SEA9VXltLs0LZN4BNdRbdBH95DGR4lBELkLYU4AqZLXOVRilv8aMQc2ik20lAEU6uIpePohySsMYeACZnUUKjzvRgyj2bvmPOOuaGAf1pUFEYpfwSQd4XhNav2xYqooyJoRxG2Dr8ljmtF2Gu6i1lDpi23K+18qqu9ml+Tkir0s49eKbRTEVfoL46vcBe6VMEYXHh4bRrskmsf6zp8K1LmWyuxXUIA/lEYdHGcwKyF4QnaQGqEwPBbiu58dr2NcWXE3tk7jatYxoabE6oiNh16xbcWg0l9XCJ8oDu8Pwdb1/AbPs+iNbCum4osGZ5af+xRyo2uhJFQl8KElR+50U38BE1aIoklVdlyY5UBQdgC/YENw0Ip6/Ssknj1Sf0ZYjcPH2rxN+0zPXWdbDbXMgbXktzmSBeZUuM+76OJa8TBEoyyrN5SPUdwGkVFis5I1bIeaxckpg5oj5qRJ3/gDV+PDvKiYbPFjp1wO+osgA4Pr4LuGHl+RjPo78ZS8TBVHC2rwQr6ikoTezmcOdAOZ1zho7u/XQ8O9CQsxXhDYs/BXDjvDQw4eLSjKdFNNkbQq4yONgtIlPulgN93H1tqt8+wZpK+veJkFvh7/fURws1Pzy5VBga2HzTXpGK221tGugmqX5m5knDukFSSUnzsTlLSE8BVB2IqU5wEeKmH6fb+zYmcSKWiN87bV1w1MYNDtmXODGTKHhJi7FUCnBQNyQd2dEGF+et2D5XeWRFNg9YSS+zdY7KcNM5698NrDZN0DBXadAuyn8Db6QpcCUfLK6wz4EqeKDn440JDcOaKF0wGPr9trG4pHvGdF19R0rB4EdNDEyPihgzzLeANd/rRd93m54QHYltdZfagP+Rgc7wK+O5+byEQW+xOgSt5/Fg/WQE0xdXj4FfjxCQlB78eY37h7j5xg5u+Srn4Jahw6QgVWdS/oKL6u8kJY6kiL0IT7yXw2mGKdfzk3jGG1mCPOOHNEFYoHJ6O90PGNZEutIgIXV2JMnCpdiPtRT0Z1BciyTGeLibTtSES+09F6CTbY2+QuM+RhZxWa+ZAN5Mlkez7ZouxhEHwYqUUSjiR6ZhYQubqeSEr9v0UQYllXs49W7i5aYZ7/dcSAj7ORDY1h5Nutt7RmUFXkL6A4PZvD4/yyY0P0WAvqYULMJy4GbIaqlQGnobvaiFDSFaP8rrBiEcMtgn2HULMV8oq0zA2Hb+auGqkyiS4kU2AzFeC1+8zueUWOs+2MxBXQD/tPtn5UrX00MQqlexYMTAM94DE7BvZzsHmZj9tXBUECH8hJiWTr2/HCSpJ5sj65TyPAh49u0wUoSM86P9p61QDfDwpSRdwv0IX68Xz1f9lxADomi4MQ1eqJc2eHTMQcwwQqFERVOE/HGoBqAng0W9CnX3WZNmDDnn6DJ7+Tv1o8F1oewnaeJBEY3W1MqLdsIkz6Xu+BLxT8z24v7GC/1rq7eumUhjZnmOpMk8A/5zv0g8I8aV5toJh6gjNYh3taS6o/XbJmq1ONuAynZZV4kDvuIH7qnSpptKhkgQ5SmRcIu3lJti1+MhFmhQNbFVO9LsGc7S49yz9HlXytGDKBhUOrg/O0SW6v+SQjmKDQNrQ+OcnBw8iW5315W9lUFTLS49U1yoAwkf7riKNgM/Al8KqUCcGf7uAk0PqBzs4Ql9ALBHQFZxcUkYuMJITsmpmT/3Jm3jwbRm+f/B071+vA+x6cd1Ym/Q+DCZ/srPvrpTIGGS0uz3L4SyhJPN23J9toR7QccceV6h1S0h1vius2qyVZEfm2tQm3FU3gk4hVhHV5pPheUjlCo2t+pnUzaKNLQ6hGYgHqopwh9A4J3YoiWKik860Aby1yNcihKKr4V1UfeyxIbftpEB+EzFtmCw13jBASQKer5HENAZa0d+KzZPC291GPF8h6VzTOoLQRtPjEmcGhXc2hPw4sK3PdK/mLqU87WdkJvzKQebQkYXSzQG6QTcnB1Lo4tCagRXhq9Kz3mGNtm6LEdJgR5IP89YI4+L4SWHKyxce24220X6U1SviLx6QntijhLEe+xUDb5INKnb7+dUlOBwKsFu3rKjy74RprswiA7mAPgt0wWwwYPjRZUfq77kxlxzU9J9VFZsFX/Qj8K24qwbTsTGebuK74GwIhe15jKe7UlcRlrp5ZxasqnRXq4KmlnGFLvpWfLhwq9GTZ6P5OvZucbncRKhNDs82gU0z6gvmiyf9SwyRMuGo7rWL+u4JlID4gNnSVGW56MbToSgxphK5iDykjQ8DfjQ0mtOnv+HPF5LF0bzwobOA1gGQg8ILWKlgcdThMYLqAeoyxRLxUGeI+Gj//LmqBwHmnDMkzdMYlgZa5C5V0prnSGk0hCwYVxCEK55nK1quZEDYV7k4xoWDCrOJwYUR29Q/Vkik+mt/5fZFDd6xnG191uBBirwI6EmZ62v5DROqeIl7nCY0McWeHe66Rnn1AclU3AjjxMoPudc5hSzPEJQW55pn2OmleEsYSeY6ae8HwYhhxJJ4Pzy49utS0pd3lGU96xoWf866Y578FIfwIGMrCSXeAWnh310Fsr1vBmWRWOHxhw8BEIg0oph0G910PPTgHLTP8Zda6Z/jcJiwfnSZmFjWRl59ihbvg1qNoSZyKK64937kZldlOlYTzBQSJW29LfK+IGcdRPFGzygtfJ9JIM0gFovOclndkDTbg+ykdj8b/eZkoHaIkC6v0tkatnc1Jf7zICEL+qoodWnc0bAZUXPYS8E8AHiwwDfyWiqN2SM884dtMdLKvueZs0T5Soq3WisXp0en/TbQfgopNGFqq/tFSn/yHI0bgHrmNKHyCnK6366ILR4AWh+BcQ2d2NPSbcpvgslF6u8uQwHLAzzpNP6sgv1xi1qtZrLjTJMt6puLlfy5sYwmCoa/Ni5T908VkI88I5vB8eI2GfjTpddJzMNAe+atbp766Z+0MSa9zoZfYpIoDITw0qb0WBzS6Enk6rKaXsz5mU1uWb6GH2n/OQtBDdRU5Xej1q2zdxiJYy+YSmO08Zz18o5cH/dHONH2fr9v7nbsqXCn5VsgICsMUtX614tphkuMMiKJJiFJ4X+6JxEYcz1bp1u9g78WZqgh4lMOBbvEl+4KkzuXANVoVkZ7031hPOzzF+Pa3STj93tRXebcvIvFPX7NTZfmuht45cTQWiVwQBJ6TxN7DYYsfKKYDGDAHdj1cdprWeZHTiuSsNvptLJ1dckj/dA5cx3QSJltQfG2S3W61qWYJ9zisHo+A4i0IykA03AaURcVrGIG0yINghFENU4q61hRhoA0tCHCC7U5GdK9AIyQ4ceWElnCDLyXEKPW546IdYN7tcLBN3mQyIjKs/LGf3kBl70wTT3dIt+U8eDrjn4/YhmLPJCtiEF+942CoCyy4ZclW85CoJuuBbdMSTscMKXI5GmcD5rGH7+V6CEP8BDhYNn5eG98SPlRbIV/j9w/hnCkqf6Rqsg9jlmJ17kdb7iLarquETOMqcsSt+cJQKyEojKW54CPskpfSpiOSh16lTKElLQ9EUN3gIvFY1lSyAqJsGLcZL+GvTIPYhbU3rtppFpLqesuoFU5f+lpKmwvx/SUNukZmr/PnkLPK1LOrCO9yIilOkAc61TQDkDCtaD3LxQzJ9NtZIe3Mcj2AqDawOIsFYVH43mjBi5vnAagjagY6YyeWYdaytfU/lSvq7QvLkJVR50/dwMVfk+kaVugx0L7P7rYDW3N3TqhcETkiUBKpteU5d2AOH1R2BuTWMHh8oEFLXyWzI4Q0cnoUTc26V3hUpC45TPaftirUxyN5AZJEJN9nIunaviLhJvuqb9r4L86igqa8zLTOO0hCcZtuNejHIdhWXKaJOwyiuLqcwEYH7RrZorUi3RD4/+NBn0lqIAuBZ7y88hKxtt2qNzQEPzwSlNYKjNY27/Y2cclt2QA1e39fhY3U1TBbjJVTes3Zb1vi90bIRY2lTBucvIRH6H0QdtnoVXZtC/TIfTrwhdkNh/3pD55xbZVQ5GayRB0c6BJKz0XNNxkX9923BSUkw6gc934KYnnsAfF3Qpdgk/YjbMnS/y7CF+R0Rl+H7iL/pw5G0jXyLgXDMKX31oxMXw9G/jyeXZ1oBbFX6e2XPGOUytKrKgMfLD1yK3EVA3ABJhU4i+xl2qyfoAYz9kHZGg3uMLl3EeX+ZsAaUUDRLBegOeMs3sDULwEZtr6rZE7qDj1mVQ3OIJS1lqAW7TMlbqi6Z1aX9Zsyn/ULJ7QMgMsSL4RervIdlrnKnVM4nz2xR59nWA7nlA1IM0x9RrUzWhBxf+CeiYJHbuD9MU+krAMgNopaGVlTxFhL1D1xWobp7hDzUIR/hV2MpdIhH2VZD3TJQj64o0n6NACjYsrLCS0Vsi49C5XGem7Bp+xBNtlu6LE4OemzzKWakEGzJCMw/PBoAdDMVhNZhDZIEb7/ExAHrYN6rmBICxjiFfRw61PTdwB4ntztQsJ1IhicygO5N+2+EyKDraiZL6Zj7eodvcHVg6I17gc1aqmAtzCsxp9IG7koV+J6ERcuG3JSnMCus9RIjDFqB8SrlNwGD+lynBrY5nzc/aXeh+Tc5HBsXW5bGDTp0YnWevr1LEhsfxRmLdHHUTZbY4UfMSCvOkcgmeQp20Y/CVcAJPDNXk+HX8WQrB0FZ9g5bZBXhZtjxSYmGObGruEi8UGef21UbT2vXS/Iy26FiYEGHnng1bstXGjSZvpb4dpcEDXZbihAaQsXkQXCInPGdIwHY8rHEkjZYjjt1iixZSjGUXPu6oaEODChPKa81vr6Qo97ZGh5lpTcnSVVVdDHhP7fvWOhIifRpceydKQit4gW2rlUiOTaNEbM+HE6at9M9zYoew7piJI5QVxjovIiFMcGvEZWmNnuOiB6cj7HwNY7CWOvAskdxLPVjxSKbZTsrAHggYwWIpj8Dcw+fkApumft0ToajSQ8voigVrbboxmOYsDcd8RDbQK+hlwK8xWuAmP0F/k0AEH1XuxHFbFIfW1mL2wZzcV1gPGEovQGX0LyCYSYgZkV1iJGO94ojE6qN18gZd/M2tHLj/sb/h0YD8tnsq1Oi7MM63rOxRt6foxMm/6nt+4RPh+nOkL5sHIPcVtJP11Jc3Gr9ypF9i/xM0egkoj4l22wSExPqhklENg1grXEyZaZhudhbnbatD2qzUiWdTDvSFtawqTLkBi5aksDUlAbem8mN0Rgi2MYuCD8fA8rIq+nRUxvRamIMvVgyBgVH7q4PXbP1aTqj6yLrOml4nIQ5lc3aJbCsLez4ajQuNU/9Cjn4mSTP/bvQFTM/e51dQ1DV+CnHf8AV6q7BfqZBKss+ibIkiQpvQjH4KwoqwonYx5Rg0JZM7yJlJFjUUPgnEaOLuwhcy5YPMXEseZ7XQBjpWphoBRAGZyuouhxUBEAj4A4chYBS8tJQS2sLm8O4GNYFvXYpwZMLjhF4jxKR4sRGHzYbMwwFl/ptG3/vGA6GCihDArtBHNcBT9JMJhujjTDRUGVy73YASGUtwfKBJrm+/FS5X8dhz00HE1Ljct136HzbqYhWtrLewXDHlUp+GuyVl5+yKQfXS/4CYJgNwm36F+KVghS/LsGZVF6hNrsP3lV+ifmjDwhV905WAfpbYQeam3koGrAlyGsxD1iqLrSm81Y/a7vAZpIRefeykqRL3kKAFeYflC7jgVCyWZaV9XlqLzcYIBWe74pbIIGYZmjOH0cQRJdPtagUtGLUkm248FwqwXTJSOyeGZLIVLPNXTpMSDOd9WApXGlBFGPSpmjYTY9Fb1N/KSQM6tlc/9dNCZZuZWeAGagCwaV6kNlcSKBMvExDFMbtYhTG4lOuXiLeLFDW77DD1JPcR47BxrhQ2pUK1xXqMpqSshEGrzemewWa7F5BKkncg0J3MyjR/tyHhMwG0FRrgWwW+GvoZrMpKLNE/v+vRJ2T7/wMI/KI9wMUXX3zSN1lmFwoU5ksWW9AnxihpCQFYHnMtffW658bptTu2QlhO8nrEb3NweL2QN0aCoax9y7Y7JtVgh9UNpGN1hpua86h7JU6HYrqMtGsH8e9ydwxta0mNDkU8ajrRNeDZsUvlGxPCkGNbi0MS3TIVrd/Zzv4IL8Cxz7hlSf4oxU5ulLUSvF8bCfDqvYOsEuLI2SW3xhYkboRiJgiPNRKHYeHIwgiUOBmYRblDB8dYXPxWEU1N69Y3YrgLyMgTk12G+dOn+KHgj87K2CIQFdbLZwc5YxdAk0yMcbZOJ3XdqtTvVnvnaIIvPeAdJ4tzBL9j2fQIwX/K7Av3X9GmWdFmRzeTD+suc3tJtJI0NXlZ/blPEQ/IgdZs5gNVEHZG1cp0C1kzgGLzWLpJglCmArHe6JaP2dqDfPBX5fv9Pex8rxxXLEyuedgGGhahMVBdMgUOOy1hm2iHvMFR61Jhe6VXq8EjgpKo8XihmHwHV7NbbS0D1DwAEkxpFM42sblJ0Za2ilpTD8h95NQ3tvk7Mcb9GSJkGOASAvpEhJ20cMGISg3thcZ3HThhXZ1Yd3vUACLCudr34VlhqXZGJlEob/kKcK5paCXCqVrUlP6eosmth+zeQVKWT4tseg8mhF5gfjeJF5LZ3EQY2LQ1cAxZ6v9Lj1pctvXOmh6cVYVJK/xLXtEe7EZizxOaCJKH1XIOCAVrAY5foGzwxOYgwtuxQSCItg+RGsTOJsV8NtjY5kGzKpAMVR67n02gBJPtwQXS4IS0l6VhMclowFoe9/5GP2sWvFMu14hRLDce7BWHMzSJHwMiP7GH7t3sp3jPbYYgi04+oyTF5IPFKliU17nOjPG4vz1ji6tsfNRfpDTiwbs1e9p7w6cWRLIJSryYgNgOsl33evjBmiWiZgto3+VE4QtlvakOgRDavlGJgEaXgORR/5AHFvdfTuxeEE/kmGnzZY4FCTxEwr6pxRUUWnkQxQ6Dil64/mCOn0s58j3XYkAjnCPh61/YnhTXHSpLRBQuI+afvgHFnmpP33hbjqaeVDd/wZOua11zTDK87SCC2czwb5mE1WvXBrjIsqA1YEWxN2iizXDFJ1Roa4Ld+iqQiYsNCKWRwprAGGhpW98ITebpEizZJze4Iw5bu4QeMvWVoOMmLwzimfk4Kjj7048SzVV0qhN4Y72DwVdjdZHAvflgnj0O5DRMKEWD523NOgoU/n/291z+AAiBfjyACK+QMhl3GFEp2jWv+7TCltv1lF45xX8shC9fcjwbVCjVna438D+5hFhhe262j+ndcLsnwr86kX6imshS1dfaLxkKxqcsX/TxiojYy58UQj60Pk6kIbJ2KY/84UHlsuHsgTOQvSOAfjDZNsOiTHSefjAc3T23vgtfMGMD3y1eSCRTyDJ0Og3YKuM5CpQXTDA8p4Z8BNm0bDhKHYDsarC9JO22GufhtPHi2bCqwwuHIvUl/zrN04z9tImXhfGUjwNXhaNCWWRr8XZqb/w2awcY0LDoDONHnZBSGqTwQDlAuwVD7DlIpduBU0JDoJRvKUX7VpTD/vD3sd0V0mYPe9bFosTLE4SpWYnAyyJKvuwMdIYyJWka2VaFvZv9PNrG5Kj/fmfqC7OdT2Y9zCoqk+WeFZ5JACyOMWCJgFOBcI2G9DAfSD0xydhINNQY46ukasrv3vjMyzBWw/zcSNu8a2gU4vajRowy8ebQEoq/Zj9D0qPbTd67JjIuyEJDiBC46wMX4K1PISl+Z6gikhEduF7LJyhSuTj1LVrL9OMI2yObIu++P6Uz5PQLXbQ7F1wJS2C42gAAOm5XQH67vMXFSm8k4PrvpznUameF+S3P/RaaXsFHVLqseeRX0U05AZFOrves6cNX7fGFpwu1V1Y5NzoPpNvt7+cZOL3t5kEG5A8JVN7LNdKYq8ZADz8474IQyWRxBVsqKFGFC5+230D1kashxqZQpo/a43ZiAMLyWJmDPSxrQV+AKIV+ofQETMwjEz08FPH4z81jVSTdwVPFTely/XQWdTLuZAkEmUi6FUG1OXX+HbwTN+VDGKoOg0dQ0gZc4VkgG/5ihi0rvB2boZquXND9TxHl1kPTlPkUN23wIyqMtQ8mnzO+y26CYpRoA1sZnvsjU7sczcXHm4+TLXpLcc49L8oE7PS1DZoNMk3zGWjjD2pT3Yur66PLr6lW5UJDMnQFrAdVPF1LpjmsDvan/VkUUja3Wfz7GHQER9JMnTacQ7tVpWdLg/xdkRvg3pGU7eeVt5WJqQbsRxNTY3cKeSICVc3MNVgzAu1zPq2idAbE2v/aNs2ZcLoRqr9ywmb6HnuntwGpGkgEoqf363KG2ZA2gnzKcuw8XZxeFVo4y83R8he/DYlbM8nc8yc66CUoqQN3x2rQ8mzvyWFcsvd1ym2Jwy0UfYBbWN5PdASgvRh/vTEQPSL8sbmlgQOvTrrXkb0vnDy/LGLbKlovS/QenYlLzpyQyqFQP+IlWvc22OfALNndQPKtoGn879saUyVgzzYc2ufT0AiWZf2DsVzjUKfc0mU/Ca04YLuEm2okwbmTKpftqxD+BQFmeG/fstzrwTWxzyQZTzwwKIIct61/1VJY8uaNQ7LUQu8OT6/nLPgaSX4u1wGu4Ap363KNWS5nwmHLbx30IXkzt6iCv38+FgVrKo4bwmI1ayrGtFhzdUpNZ6qGu2bgi7MQoXhujoIlg4qmSfXDbHLl6J2uzCgTnRXIIc/DKLZTJdpttsq+2eU9YnGY7tMLve4anXvCWmlqp26XU6WhOYHfJiGi57J0b4ugjtDeFR4H9528Pu0gjVM63OCNvoAF9+lyoIVV+jKGw9cZ/6SVlx1myyfMlQbZRFbQ79PbDti3HOtuYQ40uOG9G0brUDZxx8Tq7hF9c+OejDUp7jLqb7yjARh40g5Ykpds4haSILrQCr3IT2jYzeW7eejBK+vCKnb2Qr2ScO2b+0qqI1ZjfIREI9BqWGdcDurum9w7dC1P7zBl8pr9Q9dGZFQqfodVdV+95c2oyWeoqpqngHEJJr7bkWkJRTv8UHPH6Nwz321epY0iiXFbKKsBrYu/nu7mC7jVDKvldMyTWYLQfTzADST7qsOSNK9tHoa6a6TG58eMWdwhaf+Sc+1l02FxmZXwyHOlOA+jSgE9BK7X+2cMClu3Zh56lyIMChlBe4L/fMfW54CZ+kICKiVLVqLyVr2mbto5I0Yv71SQwFJ8bC0j3smMCmCHO5vpxCn9aqTicv+gNIUWlYvkPtv+B3ipZJKyftZrY+NZTlLBA+vwqMnjBFSLjM1jfrNQ38jAggUmfwGToYwMzgcIBaFmRio45+SWfpz4NJ1CI0CwfsKy2bk0UqUO93uaxeJGt07UnQ0oohPuG1LfegYFw7p2fM4ZI4jpAMsGfRx1mJTgpQVpo3ZIn8mTeAY1dj6XJTArURjaE2D8AKnG8ergXw6RvQTYpQt2khank7SSZ/Em4xdZSjSDFsJwQUj/Y4Zyp2V0UrVQK6qVGomKd7odZN8ZFiNPj3xW9iAArNY6fvV0qDldxu+UKkngCe3tu+k6q89sm2dKRAR4z6ljURDjyQUuadMrXr7PnhdnXzFABbolX+ul+c0TngfmnGfu822DGcWe6RlVJOp+uEgGgRwNUDvtKTkbGiC5U+XEEyB5Pqws6gDP/qPqcHYDuodOVPkIfVRCFzDngySj8g/3ZsTLXien0AKftd5L6zcNaTufzdUjqWtTfGqRDbgGDiUBwhr26TNqb2g2tOClzXoM0XKj0T6CVH58C5N2qLPkL1mFAa9BRj2KQT6wT2AKa302ibC44oq+VQeB2jgzEvLPFJSNFE4VtXSEPLPrFR49KEjBIRZskU7dK7OxZWprjIlN0R7YU2XFfHwL3qgzhMqKi64oQUEWW+tUPF+FogQ/6uwolpN8r5N24eGrkZgiFp2UOJnzBnU/Fif/Gt9Ek6TXgR6cCqzUtA4ia/8H3YvUUFyHyThIgNmBbtRdS8YO6Zl46e+cSZaMxpbQdVGdYpuvz3GIlOgRyYe/621BTIe3h80uTcx7Tl7OEb/yJJsWEJfovaleE99tZ/ROUuH9S65aJwbcv/jXY992L07vNqZJDh5mtFkHzEWMGJx23/tsDVu2Pcr/s7soUAESdKC217wTCrsfIkBgs6WAAOb33r5YaitdXn23prgDbJ3StXSTEUhYjB06G/MypdtKZJBwEQXe5et4ChVBmerahOf2M1Y2iDsc9HH0mroGKH+tV9fLHz9GhHzD6hDaSpO5ixyHgSj9CZZoU2HrCtfJIjysaDLBRIJFHTib+kTzCd7aVrwUY1bEK0gEh+oI2gOYw8vbl1gQlIG+kMlsVARCHwyle8Ikabjwd+AJR5AT9/hJS877h75Xh6ZvdJRFZVOHOq8DwPosff3mRxW5BQRKChzD7a2FYTyuvnPmfPAj8WEzhS71YR2/z9UiKtTx0gdsxbx2YeNIbECOpH6IQWOf4CBwdoMmHVuQeRqtruo+iB2RbCK50hb7uEojmgyBZunmnEgD52f48Omkt/ttBpY2NtIRUaIIphZ4s6yeO/Vpks4ZShVQ29p87dJz77sb1dZO0m71bp0fvcFG8nJEuDduEI6O6L1Pp9gkq7Aki48iydN+Re8Ar8lcoZqVWN9yU6sPeRj1jDaaEhnoho9w7VF5oymKZZLyDzO1MMgm57e10rtMaTV9qVArFQP54s4EnFYlE0wLu0RGSHKnLf967NBJJI2L0jo64eJIbxgv/dIp9e3/8GAevKab9DHnXPjl0tEjzHHDTCdRGva3IutdYXmPp9oL1ajJODo8ei8MEIo9FTxCTHBi2+uLmTEmT74v6yi1rhlE7uzO3IRbSdhp1r0RKKI3jo0WvoNQ2eqNFaHyMXYM8OHGHc+U3eCvmvAGzDwMK+p3MzKuOrq4ZjKNyI8CBy1FVzobTAcG+OVeNSGaENZzLuUDPF26fY99AQmFYR35J4kiA4YH8TovmOJSLmCk+pxVxT2D6BoJzKzLM+EaexWRx4SSbVU8vbVyDPG1dkgSKaeaZayXZqinkMd03ePNe4KIo4SOaCPPTqdCYY+ENzh4235B5xBv9kvAsJ8iPTuaCspBXl2T5DmmhMWWR5rwRyv7MFeGhhSaIj9x4jCyWgiLYcPSKj/2RTJhG1757aVXcIL2oRd4970rQts4OwrSnHpgoxbY2LsBpMJv6R8suurXsI3LQ+RoOun3L7bYG4KCeSXUzoDX5+heRcPD4FS6lh8Zu6DQkEk4mE8OIxKtrlSU0KUJLXhyVtRaw+g7MOLALGEPZV3QNQfsD7ZCDQ26sVAHSESNTXLEpnPEvuZ/wZB0lu+cnNpFoBCdMu3spGK0cPsGChS5aV0fojteIK3nTPrxYIcImZaJnyxUoAmc7HXSBRn1Y6BT6nMm3fqgGK4sMgvr8RFBT74CG/t6V+szRipZGdyVrtWuJk4A5UMSchewH3GCf9otJoUIexctKJvBrS4eIHuyXXL9KahrI2/D3ny/g447IjB9bk8WR6valcMkMIYBnr/SuiSWdYMwjr87Ery/DJVbqpOdhQ3270un9u5sXeXbodno0mOLs1mMpsb+20EcqTDLX9eXhHuD6+Jaxe1aNeAcrqMRn5FwXwcPiBmGSXPunkRzIBidAHztG6of7Dn91BM7t5CUmh45CFLJYuZzBV4O1TeKRK5Kl8AjORXb6PC/kuUysmxjjmRpbOGp4U0IXAA30rEaUKyYWH6Mi9/AAfEqloXJp25CBs4Rg1LbrUsEhlJpEIwPdJBzrpCqY8wxWQaism3lj1q51p/ncLSx/OGJTV66YHXDj4khyiMmUCM21Vay4ZhIbpdFJ9sEZU6iBXQiFWsPZKklcIITI8bZFGHP6cdu5PKxFcQJr8gqdnQZGAmIfeuWN2jp9WPjgeCIW1FRjfriQy/I7IpHowAr0UB63p7ol47UQMAFPtk/qS+V38Qym22gSxJo80ziIvIPJiHMp2eCR+NB5GRmZyxwV4odDgdVY1/IhyacWtt9LwAtNFCJazA0CyDOxIppdDqvYvAPTiYaQ8Mm+VrT3YW/6kTgmDti9YwLmRD9t8x4j/Wp4LasibCHnw9zSglyMt/llv86cy9f6YOTJ1N3QrqVizib/4EZjEUJPwqjAWaVoWCMBpRh2jptGSRcRn0E25Krv9o+sMcJnaFzNjKcy9iXGiLxM0jySSM81tF8MwGvQ+dt4GqgeVJSCK6dY5WKlBeGbwueUmmp6SLiLicJtPHEfYeXZJ6zVyryKlKpVyPsAX+9tE+m0DvTPbRbtPDl2vZpEbtXsrhykLFID8CZ5Do+x93KjvwZmevBHCFd0ynKPk7eFlwfKgIrC7ZM4TYVNTmDP/yNk8VnXIB4SjBSbBr8I47gEaXbw0X1vvv4xXHf5vyPth+htblSGBn+nAFVSzDrGlpDlwjoqO+SHpLn/UHxBl04E9KjAiG0OI5GSISJN/2bqnBueXg8T1FsVqNbvaCVAsq61RfR00tuyHRMGGNucgA219ikdllZ+OdmiaRhLQQGZ6zonYD8G/Js+Pwxmh9EDNRK98iEJu/rD/2Ip+FyCekAYGwAgv58IcsGfBXv8Tt8Uy1/lb9YzXaShiBC9XTrAWf7Rr4GOY9zPnShIKeUFNeShs6hk/b2KGzVngVxoc+99IUUqkqrwY6zwFEEfbpofrpBJr35Jx5ZgM1HQaNW+xGmmna4YaG/YvYOvfMqbrgFuMaLe3lOEIuZricfP4HWmsVbcX7CV6d7GB3fbiAH6fMP0rqH8FN26IOHxpq8EYvYNO/MXt6ZgJk6Z+vrxUraZDtUytPfDVOwtAgTnlz0eIQFWkfvuW0rMGtU6xLVpIDy4Vv3thRz2WilljlTDfeYjE8tPfrT2FG7SWcqE4vZdybJEaAViJRxpmTfuvg6Np0NBRZ1CUxkUiuk4Vf/h090KS9i1CzGdqrt7gyLxC8GdL06Jqd0tKrUlapsnjheCy4IkR9Y1sZgpkHhQQ/1i7n9VDQeR3FSVsDhaCrHNjCi0R9rHAi8F1SdLPnhZgkmBPxo8M64XQ4GVEn1/5LqcMQwXGRkUb1VyNVD1EoQ82J3gQ6VneUjybXCwwNRGsBtKEMOIEIdKuxy7y8rFa7BxY96YpGDQIH7m3qYCZSDxKSroR2n8J7GOC2RRywqGqpm0UBHei23kGTY8FksFflK6Cctx/sCAFFjJY7cfSYHaShJvu5+lhmWKPq5BOFxYbBNbmQ45ZzJ+upYXsvzvRt8meByYqN5SYGsEy2lIRfUbCtqyrouz1LDPacWEBvsYXG28v4EDFg7WEsQ36REiMe7Gw/nYIVRi1UUiXLnuk44yw9gG7dMu8T5vkGN/u0wlizwbaOw6MtJ5GcDohwCQHLohh2gF9Wi6SRrcji5TtynyfUWwuagqj8UEfNsFR4uqO+1VEi8IpvSnPHmOKqLGgr4bxzSWLJ+kZaBwHQ2i7nugeO/WI0o7sYZMhki0od1Rk8qQL/uxpHkAqbSoDeVxENh1T4EEeWrNW3cmZEex7rHhgtJeIbohOfhOalZVLoq0dWgbaxoXKe6WqR8g9ciUZO5O4qb38pstQlXaLt+Meaep3QuMEbPBPbvKHtVj4IOMIAMtqazBKn9GM7hCyspJp0pRaveRsYv42urS/EB66YCKa5uN0HSCmlsggrvlrwk+AM1YcFqKK8gR06ZgjUbCmkR8cUwaeQaErVUtqPFVOWhlMHJs58biK4i45lp7PkspHPpjeqQWrA5FdplNjk7wxDQ8Nyq2lFSE67Q/5hp9qIKFbv7nBOdsGulQye4ZccDxLgso9cb0Pa6UWxWU4IAOOub/OMFrjM3xvroGC9CSRtqgWjm27lG3s5NIiw7m5nJrkuA80yhsWZUlg2s03W+qbZSMSxE2XL8EJ3sRoxO9Ue+3NCkJuq7prRhbSf8/DXeBPySS3ZDwZ0YcNBDHhLFywMNxwa0+XO8kbSIXKvnNiGDWRdhCWSKog46XBZsOiMPcf5lzD3RXuEManElD5QKMcVQ7HDO5UMjvVBYBnEy+z5YXXj9qvqAZ8a5nOX/R85Y6hPGK3xiKn7tqoweP0cp5z2ejacfm4oKr0ZRfNASXCv1iTKszFTfKiZk6cVscfEKRFa2UTCINX7x6/GUsRR8hSLp4WEWFCQDT4rP9KD0dHdJ/DlVQM05MPzsBqspeEC6vhYW/Gfx+r3PaS582MyUoBLWcK/0e3LxfKi36AztUJ6YhaqIfWI/OjYTiFHq/5XQBNJyYTer+VyWQkmAmZ8b+9vvM5mvdNZrZ2bZMSWb/hnIQfySz41UnCAIjwMSlkVmDzCHWcAEFi18Y1fBnKQY2xQJi1yo9ukXfuMJvagJQYAiwQoPDyFtcHvMhIXPQSjUhdmHmqwbzleqm6z4a/aHDp02glVm3UvN9K6YFY7VuF5GWcwTh3RxhUmKdC8Nc1PW2wBlJdHXFc9T8uIGCcvSkhPHJgZFhKm9ZnJc930XhljSVb9AAnxqxAjszqxRQ1xPvk4PkLCxw+Kz4xDB5DJsVkgeFGjsv6fdQj+2dXe8Y7rN/D5rnm1FxGAx/cyeSHr68eOBj7Q5Z6U/7wxUcBv8TC5CNMZee0h5kI/tc8yemvYaRHpS9erR/jHFWOfQeoWDOTkz1Rm2YzCR/5zxjkiYBAtixo9VeuH4DWwioKGu8u8fSDZiQ9JDv/+Ar+N16TQ8tUFppPXoMzCMTXJ7NivMxkxa97yFbDcmIRWvFlLOm+nrIm0iZnmHLyTu5riy5CD3N8J9LikL3NxqeSCd7SCrHCbVFv35640s4qNKqA7UPUJySqZHfyd4kkjylTWOAVtYHd/vkPBr4t8i9JAIOEQLSP6jwRWMkGKtWWXmhyqLl5puip/W8yhPOctL7Two3fNh+zfOaDzCo7QpM7ZN9O9Bl62qqG5LQWR/Dqua7tLQ48a0jA/iIM4siT/G9N5HXnvM2rCIXKdHEjOlFgjxFLqsX7jRC4LjNvTVO+ERp2oCvegYiU4rRD92T3J6fDT60bWqGXA8+pif5JEgSNiqO7kRURox7nkE8YHLVC2JaRFxOGf3i/qw35ycO3TC3RPev4BIEdSN94gBts8V9UnuYzykbfUmmvBmTprTNYgT5XS94z5fzZUKMdYrj7f4V23BLl+iykxDZKAzGyX5FVTTj+7CzRq/Q0EGzKshPhKjP6NoCtfEFq3db1WIdKercEjO7TDyn0+VZ6h6mw8EVt0ImD9NTM9iX5g5jcl+Tz9ThM3IeyBXOXJTv3DEFeWdwKW2ObSFurtecH2ftiZdGNXj37m67Kwr39b0WFzr1O8h4Rxq8AVhsM3o8D+3WXxtMdejx4L1Nl8mmYF3nL4xgPBhKTEYr6uDR2GZX+yP0fY/jocrn3O90gzWXrmzMFLvcHJMhHT0fK1tzuCAbQeLEB/dm3xXZCv0QOjD8Ruu+7SViF9eSQlByRjQOpvhaZmSKPHFBGI7GgDWc79DM9Yowz9msMJMUaFIFLs8DOX6s7TWazx4jbLghvUDUP6pHIi7zhmY3NcdxYVOfTCZSPSwMFV0wiwP+ZyiEQ0n3LTIUJK05CAHnsTsylvLOUbT8DBOPvel2vGFmfzD4sRFbc1L9bPMMYaI6M9huAREtPzdYJ8Utt3f/4vDkPapxZbG9cXA5/JHVSByp/G3zHzNDbBlUiUGbBh5zm3trKmNOO7oZU4Fd4YF324e91oRCycWpUlai/XOBF+P8dQaf4m7RCNnnt0hlIi74vt4V7uXtj86xBpVjqUfV78r2XRR27w7702UrBpzqhw22m36cqw/C2hGx8k2N2dDBqEVdPEbJXPpU1UFrCvkrsxsZ4NwMTeFJUeCPAyhZnRli4BJYtHJ5B9RZJ4jyyKWoXOEJL9Q5bs9iamqa4EnwwZus4A+kP+xsASzTH+J5GJIWdqlHR4t02c8bii5M649z2BJVdNhHCAoyHvGFGPOUzya8Y4bXxOVowHcm4/IoJ44WTdm4cs4OohdeeRu3pWmH7TxVOQwKq9TsM3yoYQaLgH5q14XNDC52oKmyqMjfx7JLLF8rt/56JajFyQe1aIvvALD2ceG5YOE9SUxyGVaG/f2OlIuwszjJW4ovwzt2V+R7f0qOFz0B39jSn/9vdFci2IosKWgNKtTpwSlJ8UNa9gHN+8pOCE3OJw48jzTh7CKOqmijyZWbFsERDv9mHXYKfXg1QrkgpIEJC04UUwdI5K1YQ8p5xBM/7PVS+6VcnjpMR/R+f9dKwXwu5sNYOSp5p0ewWlY0LDdxeIjU2YLOfTZUFujbVuqgI0HcI3xv5bbcr24SGfNXNWf1nkjyuDeh15apn+7Xjc5qE8gJzaLIEqFOTKjDKSlGahZkbTYklCbjsYSa++XW85o05wOjcWzqZyKRyXsdoGi1qsyVhzn8SfWwkomtqdF8Pm3+e/8nlV/fzT8v/Qxxaa+DOWl5JhS5/Ez5XQS/HFDS+tZYc/ZgWdfwSj4Q1zcpUilFXq9SrRYVkTE21p0H6rR7S4iP5l1zgSzYNADEGcApLn0eWFlAUS97FPrdBdU5MyaCax6FC560BmIHU23T1OZUPX3HuDl38fR7m/zY5/BPzxHshJT1Xod1pIEx2FbOJxnak7azGYMletfo788VLMwdZwaly6Fzeev5O6rB36W5dj3E//7MOkwWU4PzUZXstHJtCKBCbzqyMFhfGL/2v2GBKfe1TbiUJO1jv4qlYMgBmeK188b1P1UdtN14iAU7kuASspepKcuS4WPkUoU3kHckMaZQ54ldWGQelRUBXB2DMrolC42MTxcfozJcaDCz7z7i+5imYesachClg0kqk0xneEFqG3uwVCYI1s5YzgiPWXvxC5OIx5Oc15MDpUUCeH/VR0yc7OwCSA2HHDmoOS9aEBx/94WL8bL88CJV+7DPN0AhQWUjnkbuqE2EPAo/sVaf6mE6qwf6zhsscXyf565aw08i7KEqAgfi21sBNDuXNA8/5qUSrhDGJGiGseF+ayb0mlvd6iwGCZZkA7WvHW1VqplowtemNDeh8P0ioLYkrgtM3OpOhL1fbzKgWIfFkhPzDik9V0nGLW7IKxueL1wWO9/4GbXmL+B2LqxlGxWVzv4RnQ/1TCvvpOyw+cEfGiY3n5r5AFTQUJM9fkPXYXeU4If+D6Z3/wmBZspK71t0H1RE0ZI2VnJyTlIJXRUMLKhJY5Lz2yXPAKijALD3Yufz2w+e88paKZu9opmVCHSwpfp8xY+hnps1ChriUCywjVcnEE8oeRCSZjI9+d+7b3PKLaTaEcvTV0faAEzz7StBTJhbldmGuPI4ovbPDx8Nv3EBq9kZcGTokeDwevkxWY1e5kJ4m03798T/Dvxja60QNPPPDtL6vaLgLko2dvh8sKUjd/nTYKhFnuBh8MIqFPA364mtcyT+ZTNmiQ2MruqQijupjJNhBIpR2L1z1AzRX0K7g35AsYY74JXJ5QtN/2KLw/On/nqUZAbuqPV832Bld5E/y8vjDJ9ilVym4g0P1WEQx+cyu9qtoKgVpkhB2u5pVzZlPbDgfR7d5jrgHBa/lnzFHSL4awAXrxqj7JO78HJsgEU2zQ66IPNMoDWBl5ofoX8js8GRk6hlJWW8w9bnzxKYW1vYZS7/lB67KBLcbG0IV8Et1e1NcBY+Z9zwKNw6cfMHfFcSH9WU28PdI8apZUJvjR0n232+NcTWkI3KW7yCdZkD/LG2euW1f8aJD/x9XpgOjj35PHAK0wUXwpJqwO3sAw6E394FFhGmT/czD0vNuD5lFE17Ca1lLzrlkyFAyXJju8RzsJMjKhzWmCg7AJ0BCsNPUBtXIf6+byCYbLzzjQQc2410+p+yprGXKhzuNo1WeCK4WZvTzpIph+HBpiMkQl94zSjnPOVFMOxkJMHWRIXjVe1lfWloRwC/dirc20yRmeWg5VxSXrOlbpg6FFWDH9RBKf0Oph4Or9cYdv3WaJ/naI39O4YgBFT3tl+WvwOPyCBExVqpEpv+O9mtHQleKbuctBPVPxJdgrx9cOfN3QTo6clQ0zSYuzzqTnAzM3mil1M9omWtXDCFbsFDyISs6H7rPPH7zHg23ChVRaCEtQSjjN1+pxD/TwqcTmJW5Bdk98BQGQW+5SFrGO2KIY4QG2innTjf5kYyFo4pLrWKRhdQeqepTfJ0yeKm71BNPHGzcgOR2Ut6gSzFXRvnW9XlN+jarOW0UA7Vm0a1aft1OG88n1LrXYGLK00tI1ZZMHMQPzzC6ujRTeDN0lybCgttYkVbCmsxI5zawRq5hxOB66zily1cd1mc+5Bup1nmFwaRpcVfW18vvbrZWERPMhCkYTVTb1R5RIEYWfiUg5D6QJCcZ1FFt7FXcttVXmJscVE03q+jq60E0bx49Ib5s8asl5kSJn4okzJgPHfohS3VHPC0GWY9Y7wBN0Zt2uLPYdGEYFE51qG2zjGgfrZQ+5TYNNfexjVaeP6xyt5/Fmh1AbPjeweg8rM59mQ928rPHDQb9hjgZ3taU9Y/RI+dARa4x6sFD3g5XZ5AipnZQd6aFEzwyrFwSLqfXxrROL7scDGhcjt90zcaiD4ACgO6j93TcZsSj4zt1mxYpC+2IKftBayVo1tcNSwolABHkV3bRbMWuhIwYksAUaRALq7LIk4iYWR7xflOJCqi7hxPUBJRt5ku86GMVtAxB1r8bSXIKa1isLcMJNwDhm89ROMAFE5DwDdj5WZQQ5DAYfyWfRUn01ivvvbEvuBnhS9ahTrfKQC+qu7bVFGk2PWYP2uFeLgNemKakZ+GfEXbbCKULh64XIL6acLELBv+7rGvTFObJF0bn4kb6j5+2R8/j3MfKgkGqp589YhUV5YH4xHolyxvczskSWsBr7RMsWQBsggOWpD06eVZQbdpLqMWlgL8zwvIutV0YcWGRbnhOSXxPjbJV4TELxawnUuoEAisZhaoWy5DEjdSd2/VXjs3KdulGCpKHtl/lzs1jAN1enoyOfMVf0id01+um9Xpzfm5AvLqtT9yP/WmHEmOgDPvJHXrCzaXB20IYWCZaETzsSBa7sAktt6TBbP9AzOHaJCOf0NOH2XmU5I9Pich+cw5WBfBm/sqEJaHMp8T9US3p4ilvBV+R2OIVes5omBW7Iypu6D/0Jfsl9HrYtmVIsCe7pG6095KKxQR3SWdvQn0B9MjHjeSESQlKU9O9NeAlMdKy0V0hr3HZ9qQ3bw1hsZB0Q5KtUf2SlW8iLEpUqTe1vJlfxOyh4ndsVf8SY94ebx7ZXuLI4OExO7vlt9N2om+lZNYGN51byRfVkrYKjcJBTa+ZmP3y32wr4LLFhYoZvc4JwUX3Koyunur7TKSJciaChmIFQ0BRcFbRoB/ehZ1wZgHQLZdVGdzVlL6OwZk4X7Ah+8/62qWp3EjEIC51TPixbk2kNb8flOFYwRdiOL4Mc+Ozxo//YRUqo/IPFtR4ToaSbVruagFoxvPgGIZSg4U/084HmIOWBD1DipBATwm0T3keGhUi6C8M3I4TXEKfMP+L1JXXMPKfBXem8rPufda19cprNUl/P7Bu99WUFVW5HKY9jo79fZWMwQ1l4sWKPg8oTLm62ySnf8Vz5VLxRU6ZA3ke+aWepwzjyvP0iiI5sdi75ljjN9aGXGGM+p29cmXnVg5si/1/YrQTinGAQI0xRn24t7y8fvfcDbmwDDTga2ChiWJIypgtAuN4oGfoqqtMsXEFU8juqWHuuw+tBSzS7h8++ywOUEdR2liTjLnmeGKjnsCNIvsFMHD1fqqDJBAtUyrSrFipkTINVleM2xogY3cdjJTQI+96j8FD753ERr/MOBjAjh+y5cJ+6KsSFHB5yJBn1zeaXT0kNKQhCBP77F7NPKthScUBfKlJbifwRs3WiUkcfaGiSw30oeGiKnh5CCY5Y0LdyTDQ5S4nwNnY098DppIO0GjZiRGgZjAecoJD5E8liJ4NLT7Fsu3oNfC75pMobhViBuSC5bdZ8AnnzAIzxa1VcmU4XWY8XfaU0yTBY8Q6/hujk9VKxBUhCk4lUeh6pEPIOi39E8W/7HxBSE44ig6kb/X7NkKSz2ofcnepHBTmBcadO6uOw8RFh9Z9jBvJ+woIE+eD5fB0ayIEanIEGmct8ZW0AU2gB4gAK4kxb8ekA6ap+ro0/0PzzhT94JuTB6EUG/WOnHbSRD9f5xTkoab+8GObTHivY4kNVKOKz57t038yE+aopQKY9vSWl09hSjUv2SrmpDwedAtBOkHubp4NnYXOHlMdfGF3np9lEcp/OESU9STTvAYfPMoAmT5eypBd3awIltdxAmfRYDaYd3HUoO8CulHquJImhwdDaZ/Wm5N2WQ6jK7+TKVDjbY3nvbYGNT+xTVJc1V14sOYkRZLHGkhQPr+zTLukdJv3LnCmIvWOAyriw77fTEt8fDJWi9RohfA2Em0MVVgrLCUKsPE3MsIJcEshKnHVJjgEvGTTCvprS48qQXUdsVX4WYIq/N/Ykbf1I59++4LZ9lt6YAgxGUjKr9c2hp7vZs/qGop99um5UqSRUJ9iiFYrsj/hfXGz10R6Bu7uw4uzhiHM5jJkxLK5FSzKVtpruoSGvH/KksPYe7zeTGyrR5DH7df62WI9zHuF1avlhb8Fl/k9cWLRyqzCpgKu40pr0PkXvBsif5jkhBY2XOaZOB37imuU4jPd/QSWzHKvGfX49+3mth7rD9PiEeC2ikz/OiZPpGOtLviV1cS3VKVdvm4UJ3b4TBLSsshIKOGwpkgr9ULuy9vHihYlxsgloC670I1iWdgHSNvUmCeF4OnbKHftU8lQvGA6qcD/Ar0+X/MEgOfDDJxH6/WWxsUDfiktG/dieTFOR0ip61IrcXHxwb6LVZt+vSKs84lvr8pq1ju3f3+T4yh1yN68nY+vK6hZ2wnyiwsCSvOVMpE0ilreLsz5x6lzdRaxY067MgTytFpiRbz2vokBNnJlR3csHC1EXIzTdiPP5ylGrWtL8VMGpfKNYs9RGyGOb4r5D+vjZ4vLg2rBWLMkgjrK7pWH0eCZq9Jx5pY68GF93kCNFhpcVQaidDyPGiGOZP0qHNrGgXL4pGd6MeXd5uaI8DHJpgHlL7TpXCbbyYAu6T6LdeUzjtzdkqJM2tHums2tvM25fT0Bxicr2w6emB00fcEy38XGsa2T135usVfN51mKgXFnBorL2A4QXG4Dl0K+4jYVJiiux8h/WV7Dv0aYMMy01Gp25wEFnwxFEY6D1KJ8Ti8QvVMU60pSnHB1g9Gw34+NJKm3HX+hVgQu7IqfiKJ35gx8sS9/VfHktiVnkbr4vilBt1dhoaLwKcNZsZskc9a3o4ROIlxYS1mr6A6DKTD1+e9WQaPvEjANOGims6nQHv3phdq9yOoAdwMNztfrVSQoS+/NSB2elx+l78sMEXfcrLV2HMdhqHLG7raDfI63jNYhDDLVKZYgDAZzZujhXyPO/2iFslpL0FmQVz7AZMQbRG5bCWwwWi/t/poaZrHUbOq8L3mmYAWeKHOUWRQSc9ie+Mow/j8Ka8uMNvVBdttwVifIYh2vOYv1jpJ3fF28CCPMYobXITx+f+zaX0SNuiKqrg9AI4SAxrhUuJhqRCEI2dbVp6nuwQdk1Fj2BuSUnCwVtBdc/92CVuvFQB6jXkwEHMv+GMNbVQEmNRaLF7Oo6A3/of8cCsn9Z3JSQNBOQG3jwYX+xvSB65mgb0ZSozjV/3j7PzrKAUc7xToPXYlbzakhySAuLivOv8TC6sBxBAC0jIlCzLt0FMxRPZzbODdKcT2BEWqZYeJlWcMG6B0IASPQCzTsvONudiJcRJBQeBaedzgJ60Aaby6UtCeoG6oQnsvr9le2kr+x0B1nk9BEKVUzVa9gSC0OMRlyu7JBCxHKVMZxMvs2bH353XAAHsKtEK2UG48kE/IGi19keTYzXc/npLmN0K2g+TvHXhONJxKT7FdSxBhGY1RMtgI3vmG5eGgyYf4ioD+hwm1ftcvY8Bb7GsiisG0W3k5x2fwpfb3ugzZG5trWUP4/7Hpxdh0UC1HEu+0Pysr28sEp5vNpUTvy2XpG+98wCUWUi5DM4odbTMLuo7qprhebyp4QF/hgYGQV/OBuEWdc8h2OSaO0qsnEytJIMW/CldnCDufj0anGMaRildE0XoNN/Govdxe8VLDtnKv4v0FJa8jOuZqIwzTq1i0K9bV1YXxukYwufKHhRXHJbNHhahKuK593jhTkbY8r4Dby37d6ym410XetKU7+4PQacrGef6Pi8Z5IQRBEMku53rM0PaLdPv0iR4Dz930USOJ04vIVVvtK09kVPlBLGkIZvnw3DlgSDbUwhy0Gvf1CGcrg7p292u94PA4S20YZ8A4OacX7px6GzH9uYLL76OoQEGx8XiV+T/socyl/dAQB2+0UVv0T/cmcyondADT4kdMoMhQ+dimRY1mQoyP769U+Cl088GD6G/l8fZ6rkw8LE6wr5bNNdbqYMNxsQjToYkBzBTfmA1081/q8yaF3ZtKAWezaLW1gret0iRDkVKi/k6+YnoZWft+2mk4G3+YciazMYScp1m1dQk7aNbuQuAmchcAVwwWRfBbxClJZCYTcAhvOg/ZfwrsvEAK/G6fuw1BRyWJQ6G+JWYDasfu8kLfC9ZGxo+OKV01NpHOUh7kjfukqqxgY+tToD7ZVL0RKpcpfIMvIjl4RH3s/U51pWuAxh+ne6KgJ6814ftkCbO6UisGozBOB4Qg1QbWDdNXM9XvtPPlc8NbsKJCP3TwXbg09Rj/Q1AtUx5RqEwhh0tpvylMDQUkOhgpAt5VQzc+f6AsbkLhXQOBGERtouOlSZYjvtwGUK6QgxiGIQw/Set2mYIGL41721HFFIjHxq3FQum8LwMqzGE03QneubEV99E3ivqHLIHlArpQW/xTiFSs0MVfUG7JyqY40gWgJKjQjAc+TanULmeU+VRgJfz7Ll1dwZhumwd+v10dBBfUZ3zyWjA4ArM/yGs5V0vcifTD4gG7y6Q070k8LmDNFFLnz/Lj37Lqhp8zEfgjN+qG6zLFKnEEqhmxXfA2VoOTg45Ic2/eJCCcphhTAcEdjEfjuKD2h15Cu3ebBDzhdwVNsye/h80Gd9nK4b9Wtzth7kEW3qr7OsuuGLQ9J+rJ4NxZ13HZt4bkNRJyvPEPIc+cNy8jD8gnByBEGGygPCNQiEBs4XDdkqd4oGdeMpfEURlLnXmHuQz+hiRnRn0McVGnXN84/jsPgcCsIKQzWVlKH8oOnMSbGVuQ9Qfv/6BfycfRmYQ+18V5ocyXvA1f35giwpAMcCXyeLrM36Y9F+4QMyEqeZzlasq+1He3Qp239uGaZjetvlEMRL1kTB5QSjdZXY7Vj/ujet+PDYTtGPGUfNBeFPKr0eq5qpkk34sEakd2CaD0rPacUkvEAlpp+juJ6QIxSlNg57OvVpf//8EmOjR5fzOYb+IXpSVLeAX/YdkhYprTz/Txew0Ve5N4v+PehcI8RMoTIApb3nhHd1H5Y2Dbo1p/fzCkBBSO9NGKavxMYflvJJPIt9BUv2mJ/AotIFexu8wLqOOzdXaFJJHv7ozahM02nQ13PDXh4YImDvsPzooFeCjDypRkfjWyYm+hV/AJiO2qmoXXCGmyh6MWGUoIL1bHaQSILRsIrS+Bxw/2b0+w1EgqFvim4ZUKhVF+tCLxjcVx2qS2YPPdDgHWsXG/4j1VZLIplfXfmgamWTFOWxxv8CEBAqLPZXzReGViyH/wiwH4sQVHxcybkneYMnOOnlQFUALqZWtEjRtZHynFrHKBdJeeBGRVMyMGPVffeNgBNRK742TfQw1aDQmoqLJNOT9gKfTJY4MvdTUCTXESXhvuoB6XeCst0uPBwboPZb9MeuhEcami5mk0PDwQWyi/Z/CesXXvvMNtTzwhinZlNfZQq7pWdX1V53s33ttACdhOB8hDJ8saaRXsocROnU4QvFLHjS/RhW+ShpkAkVSNX+hjDjIDGISfgEhVki+O0+tBUOgrrs2ras2HNY7DjqetGQyOOwRolkJMkXIF8rg7XIULUJk3UkLr3sYsr+IJBodkZWVQAr2muDxft4cO6iG/T23ZJIVB/ysl2SiIY5eN8n6kMQhgivP4/2RYxJRkShEsVOQfeyo/PS4JgQBG41NTxeuyS0JKOWpIApCLzTnfHTiWl4qaI0a/lEWKDhHZE45WN/fc4UWTet5y1JDXT4/BC4e+JvACbG8fbJc9dbgKqslrWdi/NfBu7s/SJSffsn5vnV7vfmPWiZO4E5YTc/bGN0LHFAwH/tvYSwwJw1wE/eWQ4IVey6JJk6+/Xmh3aKPqgydRfHOwDr5Ddt/K9hxeIyfmcf1zjCcW7aKrHCh2gr0LqkOEEN9818ZnDQrl0P6nlSA/SrfnGhLsHkM7jWHvEc8S5CFM+00ywToldn9PyK0eKDIxWF7tF0FRUdhlylgzryqMWtv1D9FYH3mW+gn45Xi5xHjJacSM2xYS9gBEjFsEXv01xzXRTh8G4SmszR8QFO98qXDLS1sVnFO0IREPhyyK8lCD+xrnF3dPIYCrVbj+GxNamSmiU1R/KQR1yhcEIQzV1lF9JPl/vuYfUVa92eJ5pl9O2UX/NZRttg7soHJWvADH1e5nvnxRqRsUV5mQqZw4HFjS74QHBiik3yt+NwbZCKGJ/NNVSkHD5VWAssb7Ybm8F5Wm8fYdY5WxuZuTTn8FkaeLEoQ39cydcKYso9UkN970aBnoPTKVOg0NAod41F93dMWtglw/vrphNvyUJE8xYuh3+IZt+UA5y8/9yC/CshauKRetwcdPEfREqQ0n9bJh4fN4pzI3bc/j58cmXiE2/WyDwHtHtvsFdKJs3nfTj9/fpR4mU8FZTepf5MLKLoXO58KHr41L6AQhH7jZ+v1vME3CL5o6vlgEtmUwLBvaOPLWwJfs75awCtY96EPgPF0o+sBiM53x0d40Q7ZFJ4SzXRrk5/fl2kPRgPHPT3PLd664X0Ip7IfihsSdFdy0+PN1K3mZNa+TqUyacXetcL0xxBhpqobju9nuOHauBXdE3MIUoASlKMNTEYtRMlVviy1cs5xc9rDsHHER/3AOrnePU3r2mvyXtB91KjLDa9HAiub5ykb9m+v6ZXcWG/uU69H8Xq0mZRuSF6ElH+oZOAWLJRasfKabDFH0bARxD8vpGteccdwM0qNRm5zq01lkoWhRxe+E90SHkPxVGn2I5d51Erhme9QMxoNvNuRR7avHrHpgBtC6cMxsG8EHVTC1a2iNO1E99uqb04U83B28XzYQO5UO6ERQgSrJzqd4yskY2Gjg3PpIc8eag+FJPrr0PyTRLHUqUZRs1eUmN0Mro8FbmNh/QLkWFc/14KztZ5PPIanBLmXNnkmF3Nc9ZBxS3ppHCEcoTZLUCiqNxnGHwICt9Zo9nA7hAwXh8zQVdIosgsnxBaT854DZCSQm5axrbAc7H2fZES2bEQvG4MtwXW4CGM3EmsLy/dt5askktJFn2zIYglxU7z64XrbCZA3V0iK8nfOifGnXK4ooefhhWOo6hO22zrDVOAskL0pGoGa1CviN777P6wetmk/B45Xb8BoVUmtUXxq2ZpK0QhnJ84+KlOBKQd1hclwoMqB1J1cxO5txWPqjN8z/lCH3+8hrVZbgZWp4t97ofQGBCz6wRj6NVMwRYA3F51qHdjhjQdpTzTi1CDCEn6x3zKUvKea5NzHeOvH7065F0LAABWy/fRsUHfgrSRf66C9mhcffSZFZQSV6/me9/TmNrbmnFv9Aou1jgv8J5qOhUDyGEmCsi+TDtVZyNY51c522mZIgYLg6TaQW3aUFfkXonWwzfbO5feyGgDKAtB106NLNXT87uTRSwu7saIJpffgHtI7VmQcgGAO4tEtrUpsl0seh7yIksklROPGtooS/PKZEhwMERKOueOvSLj7FOfJOOdrs7qE+uWbKpyQxm+KWJniWb7Y/BJ9qznrzPHsmpPwfWi4+hBQ1Hh3Vf2NfwHJO81dVa6IUQ/ttDzxL4qZi4ZSDswWTpAeEEbNjONDuB1ezr36URB4e/GAvNMzNadPTtw31C1gm8RepPbq+4a09vUiCoIeJyw8FJKXFSQpghQrnQKATHbsUDbWiJIrzERllbS+NXgkmgAOnsHccWrPwCvjON8V2iR0WRI9WpmRLYbLJCexoXzdiDomh9Fb0VRHsBq1V+v4SJFkQ1I23apd2b8wbNxpAipT+s5epgsFQFjrluTEy+nXkvdmSSQcY2uxQbuWJYUpgWRIiljlnfmiiMskl2L+nG94eNsQB+vbxZ2j1kAneb5Sv+TvlxezfaQ3rTPBTB90gvEi14nhmUArH2NoHfXPO7ZpRjJRLL2JrQeET/rUU/Jo0kdP9O0ynMeLOpf+rD/IfRWvzpfTR081lP4abg14zOBdr/ymG0WQxCl/TwkltSc99Ay+pKnbXleUnX5VWH+Ck9ZAGply53Z+oIYu4Rp86JjOt7CNYc5xSRFyfO6ynVtIJ8pRu4XK8+sJPBpgr4cB44HZd8oVD6ho+apTdiAoKfj89YLnaLfVdk5OJt8JY1Ncar2O1vttXbNlAlDKsBlSAysOUB2BScBdtoYkujbkxo2ypf2eNuLLGxj6xRrKdgKHDP1sCE04Mv9/wcW3GmhlpL8t7Kz3ukLSaToBWjIhMW46CFdz9uTqqLkXTAC+AIjeHjYJJqkUZZNqrifRk2fqg7zPAFZ8xXi9gF3QYuFCXQpUwxqlH1GGGDJxQ9Md9brFoC2Ao1QVDS3S3MS70dR39q48iTj6t8XHjliczVC7F5HFqU9Qz3bgc1R+GYyNgeyUvOizeRBwWd/4gzIZ/18XGS2IdgehaLK1YDQxn8odHNO05d3NYpsNfVjkz5JZaiDWrAqi5G1VE2nco0SjzC7gDCq3m83at6faIPOT1pbuQUa04L2wuVkx4O7X80rEMSoTFunH4rOY18hxQrYbprnEbs02+L9zua97mfVNRDGEzW/H32OlYC1VVEs60VTVxEnwEpPZY8mqZTTgNF3d3G2d9B9QrkwYAfwAXvtxsacLX1Oavr/7WkVroZMK/Shy8OeCQ3QtgZb9UeVq2cGZKiL3KjdYt9IctAKzgjxMTtj1DsLj/1hZZdtxf61nGCh54puRQNvGeoeavV5mm1YKgfuJVAO1aLMdqrLyx6rrAHBxWLoDyr7RrZFvLVTKUUJ52JXYZV4CScmllSMcHCBVvarAjO2jmV/7FA9RBelGVqO/nzcvYCdtENmWnXU/ogWSuVHECeUsmyu13TNKp5/9uvSx5x6Jco2iKqun0QyX5rD7uuK/F7EDFB8FH1s7a3GRp0bzV7DdrWqbORYI6+t6EKWU/UNibTBJRwpfQqE9kdJme1k2bH7epn5DGmv1Q3ho5RmVAPuybLUhcg2AIBTOxEhYLoOds5MzjZDoIctJUAMaEsgPB0NKKK2jlMhWKS93W9vFv2x08WNkom4YcdnuBe0ac3KhagvthcvEo7/cSAlgIJ7KSyXimwVffXJaw5Rvw815yBnaGB8wABtlapFfU3PAldKC9i20C89JoQEBoQDzxhz717dh0SLGipNxbx2SUWb3lUDlGhX0CToFxWH6oKoq2tqRu1q0mj4UD+jGivUTlzbKj7/mQiVQ2dSr8D+Whm2dHCCCSswePc+zylIgtELtbBTpzLvzTIOMzrWD8WxLKjiURGo2xGgKgipxWAfwuX7L8EQ2Pn9tTN37bJiPFi9tKQLgvEv2UWr45KhYz9ObwoY99zUtr4bSMyS/IZsyvd82yabhXE48161Z3eQRBfbJ3Fnafyfuh15rhb0HWWLNnkym67nID0R8WHvsXJeMJxMeupwclCbZrz4GSAJMX+gFLL55oCsBlF0ZsEtHU+HK6PibyzFT+ye6auOV3GMtM0cCkjtnKxxnZ/4MYMkxG8Ho2reN9VnTyc/6LAuPNXwRGEEO5QIAlwRFTJ0z0iLW7wT9tsYWlDo7i46fvn3JstJ9geQGRQX7bmlSabe1DB2kuvFQiX0cV8C/123YDXYNVy05yuRiTDkagrvoBsyhlxpmqnd3y/kjUKYg9jEpa89UgMKMCiCT6AweKAtF3uU27rYAiwt2kI5gk6E0AE2sQ58JCygEyAAq2UwzTrDAw3hFTWNqdI4CKtSBJJpQX/kPhg7XlX8jrc/QIppcpBXGx7P3NV8lukn6cWWNjPnB1r6Fnqxvi/5vmAdY9OA+herc3+g9qJ6quOp/FATWFgwI1UlJTM0H9q0skEJ3ArETvKsbly40MWA0T5e+79r/OC8gsXXxVs3pgimsvOKp2aY8Xv9s1aRJrPpimy39zRbIxuzuFynELvV3rUUaIjAaGAwkj3+L4/3acp9tf8SefyTHQO2VGhrVCfvTQTAQUuJ0Xzmoei2MTY2qrpcv02SKQDGsqGVCbfg0jooUtrAM3P5Vh2vb2CFTfp+OcGUoN90gwqzI1bwh6+XAQr+VZK4QMHvapT1TS/fDrVsFpwhJnfC38VcEgJHwxn3jaDBs4itYjhUI3oSk1vJCW4TZk9UboXYa/vuWtARBM3b1hyOvIFVzIKtDjAfNbWnLuiQammVBUZuKX8u7sZEoLlkKe2xjZAANGQihuF380d1Oz4JLCqoq7aQIImA3DtcajmSZrIMbwA/TBnuWr9w5+jZLdJtdmGWsnQlRHXeiadLXjrZUaRiGHnznKmi/h9AIwS0HgKFeqOQGesoIJbVKkTDEdBTfGLC9UQclkTzBehsQIuu14MxQho0+wY7Ezid8x7qgD6EXz9ZXlsTw0/ba8xXxyMTrrlKZpH5SBSaOH/az+Fn32E3IfYfZBCV2tHYu1MvGmyljd3VKirF7CqQE2j2ASabpjU5OBC05xTT1oJhJnjSV+KR2NzMgU0Zf2ZpDOgZhtWrVkPuLcsh2KQPc2XQ2dyU4pOdkM5oRxF4p4S4dHZ8iVf9AxBF5NXDBsSOLh+Mr9c5bDozr0YcYalaj3Q0SifmQtxmty73Rj+iO+pQmCP716UMd0r4vtZgXyCVWR399p0/7EABl9Blz3CiZaPJttnAVRNYiTWfsbguI/t9ghpPciJgx/l8t0Nn23bYRjQ05YVf6+UAM+WSy2g+nWBaxdeKj51zqNtDY4oJsCczoPcz+VmxWZzMk4yasY14eafYZFUlY6wNIvEJNsPlUuke6M3y/MTagmEKmK0eSlSHIwMV0XsY+FdnCgchg1nWeEj9GzMwhDC9j2+hXn+XYxSxVWOr8mYCiDOgUIpLXN2h44epAMeMdt2pYVSFtOepHyX4+CG55Ke/cFXMP5KosLRe5Z/GM6p5ui1uTbfcNcl6yJ/5dsqgtM9sTAMdhMhfReJVKNAMf8jNotUKojdpwi9HBJ8skUofa/4osh1tmJ4nc113AkcFl/+NzkmmsipzhdsNE/KZxEfiZuvdmjL/as4SSUDnJMsA95bpRo3CgB8BYZHhMhrhChYsG/Zh4EUnWlajqZy7e7rktS9vFI0dB7hioMVqmumV3Z06HXiUBAT9adktg8RNVQNgGjbAezbF87Jhl/GLWwrc6lqYWfeOxPdUEyvMvW0O626fKO4SrMqJy6/AFGn70mMVmfiFHvr+Yk/gdlutspdfzD7WPov+2IEOqwPmazV6KNChwwKaruYHXwEV8n1/siSsnOrSp6ytmZJ/p+ofpicKaN65anms3mxH+tXYul4yGBvaEmGW2XYrrCgIp5hPZPT1wKoHIAgasi5rNjlaXYMva07U/+xaIb0Bf3Vw8F5leKbktSREYmmsC4Pk4p3rXggFHB7sVITYpirmdrmLhy3XKl3AFXxEpio+25ZE7HTJDvCux7Xt0I2nRsg7QP7FQm5EfAVWP7JJ55jcrz150B0oZyPc35UrByXKTXbzZwU+dnaqLFf2MkRkhfAafnLwbiQxuyLlezxb/e0vIO+1aMUfBzSS1nERZ2zy6SwyhaK9/t0pExi6UO/bT+e1i+KEFPwO1G2Xa7doMosNmBHj2qX2LijHD002qkWKT3ctkUbvXZ88wubhsFURgxULiI1vaxJEiIK9sgsInicIUS9Wc4zssM9OUR1tZNiZFQ9PoXI5/fkK0WvKbUG97nzWsRdGJjpPSBqG7dCrCxw0Yl+LuVyadXT2t/seyJ/KNhEyvYpnDHTFSY5ZslULvAFm/JzJwB+aC24CsVkCbOkVB1lSpjgyvBt9HDIxe/DvlzmzfD52joeaLlbF6jqSWx/7is55wYDDjCjwqXxWlcsou4PfAFvlaJNFMD5v4v4J6l7PhUx1kljfyM0B7mnn31fT0m88wBtt0/iEtf6WRXZAQ3rj4IbmIcHCGUp1XrUvED+U1/i9qp+xUu1oPfzrVD8kdlk0RRR8jAkh1SbGLrQMew7jl4pr+I0ymoOT5eE8n4ZC7yDOxouSQpjp7WgtrZNr9kFbmH+KWxeQCFhguYET2jB5O6ialBGte/b9SZZlBZqf6AwFADwrM9ZHoOznyLJdq/pzNz+K/yeObjevTg+R2vi8b5CqHmupY9qkBomyxJEwvmL5zWJLBb9qK0EHzBpOcyhVRjw5mp5LxWVaK5WsqZu89dMVRrSVg6AXPpOAf+VXxkOc/WvF5OLJHcPL45o7CHRyTYzWozfcoDWIadzpR2eLh5ZLAzCFEXjxrXADKHTTgK9dWDCYAazNlmGZLoXni1kfg3X5y0uJ8/BUHflV/nMf3/bfqbq0ViTLdjkypiCnltmuQXMNMDHxDlotlJUgBEhIrpSZUDobtpB/OoZadCPDSas7rsgv5znryqCXgvGJPqvNqofQSTP1aPegnONZoyWx3ocbIC7OeHCjJv7QO7WUXTBnlN5Cv2oaxHFHxA1DgO3qtHZOQPOXzeGiIudw7eU5NF+MOHMKbYrByzgmX/r6Pa7QvIXpZlwjDLSVThRvMoPBRmR6ZmuJkxcNXKABOW2U7EA66fl1nOco7gPrg8mkXTbrTE95jojSVZrXI8zHK6NreHXCHGot9lJ+BhbNzq00+NqFWfMum4COs0/xQGm9VeLzk7oYeyzdGD1nyY/zdyYI5KjDzun/mMQNs73s4OgwY3AGv3w2d5rujfhQRKDhjdqnEwBwd/oMgx09hVp4umTVmV7FkRrKq+f5HSdBVEXmq4fB8kBhDdx0/i+Uc1L3d9rQINOpx0CKdSfEa7D0jFf+ziRgOAs37e5302ASXyTdxdUkVySF/Y/xdzYVhqc06hlwcvznOPOQfR9Nx9pSag+iUfOAcmXoAbKsTIgr9poDs1x2Sh3VSGvvRx8eXgJqXQXr4Fl0bDKkZ0IjWrTNjtM4CQEAYD08Ek8EpPGHBr8m5uAOxfy+ye2SbUpa6Kf++/aUZ54FgKk/Io9QgJKYbnpVUsMSRBTvmhleEzKyg9ZqmftpsuU4kFAOm18j95rsJE6yGmmda+1i80W2oGSVDdszQdA9WqJhTUObCYabh1C+ZVlKDO1ZAKj3W/p4vBcrBMCk44zwxmninh01zI+33xsyMm1ZA6h2QTfvFbdBV3wBinh5+1gDG+M7VjCf7pkt8z0km+MltfuLXSFSceiTScltmNp0hlzyeO8M/NuiVeftTUS+41KKvGZSeAYwgoCq74wF4Be/QsTBSEhst69YWRelhB0Lu/IOM2RmBEyvtYnoncLiY2ecJ53e35Pki5CQsCCAG6DlXI7zayfAar23pi6hfklyjLVwabOzBvvj7xvavZn4uM0SA/+RBj3n4wSRn8sm1LplAVlF5czZ1pfAqVjMZKwOy+GyIYnlas358L+zOltP0qD5NCcThe/IVG5oY/HZSdyhO0O4L3efnEPkCfZYjlf7GZCRXyryBgU3jrDIxpHrmD1aQ75Kb0G/ZGaXUJTIALCNu4IS80zSeqJ/DlfVetcb5LJs1wcG5I+KAcyY23Au0glk0E0U+gmOkbFg2vxHb/mdvC3yzu+tDR29Lae5FdZuduVKm+mDEmo8gbwHRiFadCFmjuyCBSSU1foVGFPedS+DOcFh05Lr8eV50+BVMZrEz40RCo5KxxVxzStEwfRnaXJigGUQ4puGgjNqF996kr6sVs/SO/eWSDOPCTm7+6IRrl50KGPesq+Hb1onJdj37ro6n1EsiioQS2qKsNccdERkwVZ+W8zmtok2YXOgb3uAAI/pM9UG0WOU+gLo50qxWY89XTWMR8cATNtENIsmWhLZV42TyJyeN8JXT1/1jbVilQKfEcY5jZ8SQtBNt19MhlAgCinS54uCRrwBtmtsz6rqOzXgKYurj2JE/+J7clZvlvBovCbc799bsSZ6knkDR7B+6KC70SMX20ZFZj3dzf5nk+trkIgE1hB38WSCtI5QXXBP0pXb79U24zN+MZ9iophVIQ0LVtxhA5VVH0ea+UDOIgFHQ8UMsLycHj/RxWyI5EuP5fGjNBoPbjfU4yl7PGPTZHzP1eNf1eIW2ziTlNw9zuv6+fMC1iySKjem7nfh31nXJSPG35fswtL+Q6yohbLvHL08sEjFAgcEvcGAZG0VAMf6YQSn/FM7mJPK51JKmclwokmzWeZURyi8pQxn7fMGQt3kf5qOwcY0Cd2Ci+eBNgFw2DSTxj7fD8G/rZXvYb/FemEgxpcPYzHmOHh2bHuEmPRa0HwAQDtd7MOAsn5nprLNJb+sP9fAP1jROpu6ZQI+ZquLCutLoJC0Dbnernf6uusDMYEmX60aGTI2I8rkU0cuHzeidM409gffjcYp9UvtxIYTMSG7CD46n2v4cd6BfCXQGDvuBz5Ne36pQyPpJyP60y2axy33T3HYJQzVy4TMG94SZqG9FVD3ZQSSaO/RiGUoynVNA50lEKknlyoK079icsur2+XRJPR6IJnHQpt1aIHg99fUWN1UlmXKZqggjHYzgDnvf359v5oTEHLz+55S6sBFXpA7t/p3v/f3NmqyDDyJntGz8PpvgJmB1R6Xl3+/wN8cydv6kid/6tXm6IIBLi4Zhqz0mUvdn7vD0h2zqDZhhgkd3DDmb5SE1p0atV8MFXFoNKG34GNq3fITycNeyZ5umU2Sp2yh2UA9t8qd2oGCQrYXYFZBujn09UJ8Esfe8gzew6SNfX0/nbqxRB2wwCbllupERftjNN+OUbxyWo+Rsv4/V/4g6XrmWVCqlomvdd97adWVtY26crfWwDHK/LM/Jhg9BqWfMTWQZSyPuTy3RKP68RTUXdKIM2gk7BCT4VPsttpfIgEEiDKwWYfWLdXcggpa5oJUWz9MZPtUqDU2Bhzu5UKq2HoD3e+btwWfBJJbY4B35aN0c7Ik8F6gUzPVpOq77Bij0ZQPTPhk2sOClR9bvstSt7lJlQnjN0pwnqmU8O79Jb8TnXlDG9YItpeQXfU2vpNjagoaThFIrehjCrrRHJHx+tHkMPZexVItpKd9zWFFYeRXVp60xtzmEuEwtKxOtz1VftDRB2b10gOBv1YkR/TWasdlZPIOnaqxxjBRvSBtyCiAQ9XCfOlkddvavKT6vcKFT+HoQqSof4HJ7E7aZFedv+RovItzbgrJ4GuAmT/HxwK3CoNLkTDJGxVekLbaIQDjC4JJhgxJhxqj/EJmagmmhVz9pBimVJYBOirjhZuRgLJK2w7rZyR1ehcNYCd04wPyGrRfjpscp/qrj3YJFDmAIDOCpDMKTXwR3CAuCqPXUDxaREvMaR/ZLS+sylKmaEPi0Jmq9pWAz4s10lw2E53TmyROWQnE4JWM7N82ipEu8p47d1A1orddh70IZT0funSbFgTpa4vEnCxRJpFByyaBdnsSzO9PwanRwoAeGoOve9PhHtgSN1/fleZ2qCz1+DntNT8Syb47J2nFqdGjMTCQxwVUsQcQoSsSOAMjp/xnN4iDoAJ9HXI8k9LeTaDBQPh/vztiK+YIwdp1f4WyXHg89wMK0OwAhBTSv9C/7LORNuZOFtfiHUALae607CehSmo3gccEItmprJZ9Mz4zCK25ozTuT+22pQVRlwijpz599JoM5YPFNLSdx4wzFqVsibeQQMJRsOxPFqyo0DPVCmOVqgFtUQAkFVzHscXS24Z18oJCJ2rVDaD8rjCnt0fEyBeg9Kv8293mWKQTHHrzEwJVHCwzxUPhwrprvy0aVMub3DO5q3l9RjZgrCYGBZwU2GtY5hdxLrJsyfIDmhta8tCUpu+nF4+M3aopcPonlEBGpc2dSksjjKbrJulreGPgdkdo5KyQBtgMH7QxzrecuE11Hhkp0EueRdGZtqirb9ZrJAE/dFGUjSm9vmrQBa4Id8GACj+w3cqxz4BzKiWG3jNKJ+Z53FPgzO3WBI5G8y7GmnYShSO01Z7c0LnNMcipYFn6Epqapdez1E0cQvroPCVltAVILsWaQe2XDZf6os3MCRewbRikE5KNPEkkbmIld5CidAvbQYLJhC8UhAROjprBeUtOBZk6UhAbKaHZmEo5H0sAe0HMviVuXMIZO0WflF1981E9PtCjSq5+4TZMlacgn5ab8ZYpgkdUvbjsq954HLoOfYDq01CZC0E0vMlbQDCl2oNbzXS5QDrKWCIxU+Nz5NRdyVceKyEi1tyHz2yuvo1VDwzG/KkHv5BEDKiSSyXQ2/d+GmChS7yWPxb6beJY5AVglNpErORW3PWtSjCPhHHYEQGAApaYXgOhwX5BIB+GWzzXPQbFUEGOflJX3odkrTCLUlbdbM1KmTvGMNy6AaRymY7BkdkWcGWsMidvJpnszjbo9CqjmaFlBseaaFf3y5Y2lEbsqmlr3FNf7EcfEugySjwK6iRQMjc5bo9MIjhioGj9v4+4aaBX2rCjoGk1X58MTVopIFfQOwogLbXQ0StxqNwPS4MOy0jQMQYw7Q7LqEQkEnvd0pefFFnhg+M7vH73UM+2w2bokX8KfMVe9ZLWnq96gNZ8gHqIe8MACYEezhmpupo/02c8ID/BoVuzqLDO/jOqQIgWuaV1HB6lCQBYTOY2MOzXXTloHvMBiMBBFLPNx8hmU/79OwvNIDc8hflCmUv1wy+MdyuU9PrC1OI3n/kjIfKFzHtahoXvag7Ch1zqaj6EQCNA9yFMpzX90mGV3jf3CXGNzlinxBOiNKcHdnTgblnkdLO75QuStTEYpQcQXnbYJmnCivDYgvdmbsameKmg5rtwMc4NL82+uoM0ga8lhnsN5PkoGTOYyr4sfdE9jXGso9S2iPAygNzta8SXd0qryVcxNvUszVySatqdOD22KS+7XqSclBAVhE8Pi+u+7RXZEEzY5RXsepvc7crh+66NVnqBjVKmAYng1OiI+IQiSijGDADjVQoOM5zXaJhMcPt7IiDLMElI8v7jT8FGzQJ3GK98j/cFYFNLGe8vh1mh6Y93JZc8qAn/nUMOFstoIh+V3+4gnF4y9KpNjz3h7pU6YYwTyTnWbL8FKW+hTlkYj9Mx/D3iQdMiTnBiPw2f8G7nHQVSerDrj8Fl/fi23wkgEtkyQf5wc8JkWrfbZ9ijJK0wqW8Y6I7sYKt1ro842HwVYV2+q0vzUSMdi9ThQSeSzz5FLM8PdBgQrq2sm2KWYVhU2Y4b6qPWwWAhIeZ4iJuq1u7m4fat8yISNpUzAf2EheuBik5pfmoSJJVv/MwZbVSuUAH0/4hlHQ9gXPz7lyuTN4lsTiBP9PjpE1jasCBHEnBPmexUzs6+GcNhLHtcNELlN7IeDu4ZLWt2yF9KP36O8hAWGQNcsL6XNXZ2Cscko/lEN76fItSqOb/zl7dryUMnyXTwRAqn5YAUnFIHQgr04nc8VtTkwY0/aDRD+1n4DbBOV/OiwSz/gZ5WMqM+yK5O9Z6RMY2oG2dS2rFWYbBMm6apyG86WVqw1c98Zr7gdjHpJKarsjpXdUkF1w0hp9YkMubc4jZunZYqdQm7gJn6iwg6mPjPE8e2ynBB+6a9XP7Y6/lJKarusPN7+3bhXLg/KPD/To38TBBFDQgK82oolZAdR1gT+9icKbIcn11Lph3VegD4iat4DEP0p7nWlnqlQMCvF29Q6x9Wtsh8tRti5OxHNXsE7c29g3oijqVZkJGlQtf252njf8JbrFek/ea59Lf/WUS98kUeYgSL6ro5S4dnC2ZnHlYSutL7Vr3GhM9+IlzYKZB9Lsk3egF5RDGdLKZrqMkCXxraNrcMQrS6fHeOu8HQ2XoBs37JMKTJOOcJTjdqyRDGW2zdIii9L6rOetJ1ufpXQhLHwNDj7n5bUv+yLjBak6Fl4ya0JwJeM8r7rNisZXVtluKdyv0x72Ye2TLjLOwQjTRB+94cPTQBqJe8H2vrNxZ0r5baLoq7AFuqk0x7UpSUHY5fKRsVf8DGciJ/8LzmixuyUKaEwEdcHj3NGZnFR2qe71XapCPYIjdMvjA6PLp6s0duhkGGwJtTcE1oORDGtH+waRUCogb4L/b3mPmJb0dufTweMNXCTbgGQw8bQ1u26EuN+npkQLJSnuWe0PTu+XVgaQ3g41csBYM/eD1BtVwoZ5R56zV7tjnh1UeGreaeMC3efnUt0Q16TuwNbzA9afFppC/bCV0A3pruLms09BV+eSYuG2GX920Fz/jPfLkbW7Tj8NPf1GLF3cLOe4moPUCUbrUjqwuS1r33cVAbC/XaRRpKY5EkmwFVoAQ7XlADLP+Pp8BpAwgzY0S/iwPyT7n+ruqVDBGFfkAEV5xnhBiT3ioB4WYxyF6xxkJtBYlCzzpfu/Wwlw4WLYZB8tpT8rG+QLGToKSouGkZV31qK6y9IKXXKnRrC/k016OZKmfOvtrp7pNyrh5qv03DJDWRRAx8S1Ystt4CoZ8RyGHUJm+9gQS2y1xkPkxcQNBrzxFsmxTZFcR9z7DJKD/zNezVjN97UhH4CUMb6abTzfOrfbzx5v4iQJoS5+1uyZYJ8LMx1A819xdjQqixKu/W1AQ4M2rgnaKtovP0tKwu15P/ef/7JaSxfb0x0F48U0kh4pZVVai8z7TP/2HnZ+K8t05l6KIT8w8HEPwY2MqOkO/CPue5+CKQsX6dE1un6+JOhOSvkwA6Ej6ChpZyNljk8prp+n0G8X5liBv52EuAkAf5OCkENQRUQKTHDsn0OiMIxw0AwEXUo4PqKep3E7mMfsVuNyOQ6KS5BhxCME3DDDOzA3nudBnzIforFrHbmjFZnJNRIOgZVSnza5YIzy1gEMQtaPWS3IYnennDnfitdfhC6lslZV+vF0B/cy9TFCDCXBEswb/PeR2oFfsJDQujdtEmne/5lAM1UMOYUqgOO6JUwyvTzjHTIBmyvjeXg9VOeNnHzLUmdSg1MmeEB0UmGUtX88nkR736VIP7FpLY0VObhB71UziXrNU93OCcUqPsPFAwWreTNazrr7pkQ5s54Agmn53WYhXWj8J/QZCS43n3C2JdM2hJS3U0rV7WCzq1ZGm0aRycN/QzhDKo7IwBsG8+I7UyrijLfpgzaFtNAX751GkSeKP0aRLoXVIGTvWYKxA3GMwIM9IRHhA201AZTf9JpZGQ2sUR7rg6c5Ifj+hL9N7C5HIKbxyaiOGP29kXsZHWsB9eig26xM7rVCV9BKlW+W75T2p5Hn97gx0Vtqy+BN+rM+dNM0PXeGaSQ4P7hj4FohLxJKsaYqldcDtII1AoF0gtLqZ8A8xyRBsTxhKPH4ZJXQ252cwqbLsxuYc/pNCfcvLPtPNKy55EahhxijmaQJruUnMl8196JXWJrPz0X/Hu1PyFtUdGu5huSnsZzJghzHBTmycB7Pb9lYMTnzFM6cRscSI9wXeUhPnwyMUz1owtyidTP+kWjlWcJrxJtg4Zd2LxQ/cavLH/lX/N12Kh+PyjJPaolgSCs3O/c/frC4+M9osTlSRzRB5fhIS6f5/8rX9/jiXPJUPFzLwzbIr4t5/wpbMDA/E9I3QXQsjjYyDlkrJLOeWqMOh0/pqieujFMZzIgJ0ZToksfY2zkhIayANLZXY2WGgp1uJMso25dTCRA4W/Zb2rIedDz2/CIXU7xrVLW7JoIYT+SG6OdxOsM/d1hwiEzgbakYY9K8j9+mXDeqQcKtXg6HT3BKZm6hTCY/7N2oTMmMjeDHCyZWKNpe0DxoHuzdykM4NcrpEx+urMnGNjXPaIyzRq3f2HNB0VODhko2D0aksZCZ784Bcc5a74nUVV1pgpIP3Iy4GzCjl/YjuDMrQGPR0yzRr7O9ACJTWymBeaZ63fVac/Koknov7UzdlmXOa5KzB4fcCc4e8gKdBpOexzuJnAjBfkWtydo+5PGJbQ28UkSRz6pBn/7ueoGWzkHuKt4GA66Pd+VR3HwkNLdpHs0kCdII8kDZcVutfyfnP/rBqVWSyoC4wJ5jxBesXapjOFKyPMrRb1eCGWwlgRK1vD+Ck7HUxSFhGgq+kZd8ZyEaW/cmo6pCVdXPZSt4Wfe7T2gFSbv/2/t/1tG3S7pta43Y3mwG+d/7rgtKhk1gmgtSe3rHEMlwdA5kHnID6CUYUKJjWEblX9ne73qGbL78MKKQ1bN1gmvUd9iFsDIc2LbyrpSZSNT0FCTiU+DMms5vXaQO0JOn3dNvgi05fkXk19FejjtNRclJ62JDwMBbXeIkQuPKszm4JsE17FS4h5C3ETKAMJATgr+eE1QjobuhV4u9s8dQnUDRVi8ejbxoLktSfiQS5+XCYBD5uql3J2SBrhlqG0+HZ550WuddK7XMTImXA/SabN96z4/Ggfemvv7K5YR6u3axgZtt6UgKQnLZ4gmG2/4jZ61JbLll5Ithq62dwVw14I44+cI5O2wAn69kshmyCJVXLen8Tvu4kNOIMBCHpJvSL89C+iRDfL8WdakdzJYAoSCpnihmbt2w2krQvQbIRGBHeal09udHcvFMSp6CkYZObUlh4t5/1aJTDj/jpuQd2VXHw4LUUTkTflE6RgiT08BtW9fzp9Ebk3kLBT8qhUZXx0IKMUvfixn0jnfiQ8TgbIfJJc+v+vLS74Vcgma4GZ3MjT9taXc5vyOvlpJTYHuQm3Ys2eMYL3d5z6qG/2B9PBizQWag5FXePwEo2U1STiEgO5wWqqvjoaF5JUkceDjm1d2+Pwl7AunGWcWLXDdMeV/7KDl/wwIjQr3TEJzWVz4wiKowT/ZTAEMdte74WDYwa1M3Is07alRjjfVCJQC68Pze3W7vjmNJpa46EXTuIHrsILvUu/wX3ySD8J/F4dKKYEH3z5lNqUUjCW+UtoEr5InRWLYgjWC5x7woxfpkVbkbIFquxWJxA1ZBBhHIk6ryJmG4H0fJsI7vS0cH0fecJTOXQR4k04vFcPAJNZ/abVlXQ7RWuNlhGWuYgS+p23JoQSAdDc+GiUG1ai1TN48pgYSxeI94V6KqcWJJIWLIFVXbna86OlVBGxHMGNpxCZ99vEkUM1nAXFuSzc1raVetwH09PZc3+qwZzohNlUQ2fUZ4Fv9LoEHbE3E9VV7FJK/ewFYxvk1/4a8iOUSNC3S7EVSIP7f1pgIeaZ+Owpcxv/xdjXhN0EEMx/Tx/+gMZ73WcTDQ6UE9R5jUL+laVY6K1aGedbID8wnxl2xoMNUnxgK+Jh8jvzjIbq3vlHKcDKFE2n/Yki+ZJxDQZ3VZ5RVia9JMs0DSOsdYHpVxWi1zzQzV4OmzNnl/l8iFwgzqRrargHHnD1yBCSvG2UvSN8BbfeLz4g+o4f089+0pwmd4FosLlZGvQfndMAItDtLzaGVy5TB+ynNp9+y5xtaW+2oFBbnBmGogeZ1ShaMRbLx39AXRtVliBN4rBV1ADhUs5PQ5TI70ND3X/QLImMG3oosTU+cDrytajO1KJVxmbGqXs2qabuvvWRt8DDk9LUSzWADuNSKkeOfMU7o7XxCVE5zCW3nDqHZWT4veUMTKJmqhQEYDGYHQv0UNalvh3a4mUcr6aJigtqfBstVD2ItCB3zioHIMFF8xqJjX1pVIjmOIroATFTUYmdJkZKn0OqzINNiPmvUsdCfCUlotO3iOScQOaSbj/c1j+fKuZ4G7puE3UTjualeYV6lBiXxJ02YelrvYYiT3nq2Q5fLGSaUbK6IIp5kilt3CgOZTCFKr6C+LBdWHsjvouw8RzcnKOCzRZ9GDT9lt294TmBplrB9IHNUswcqZhUSAdGBEA/GsQo4hysgpgwmFxSBAJ8VqfIhllE8C0CLlSjTHZ0X4CAoDwwrQNTk3lti355Vmcbn8h6EBzacVZdUal1lQ25PU9ZrxbCp3AjOh7ndxCDATZfBp7xddZ0+M/mKFuCx/UtSnknHNKjQfgmwsDKSVKnnyUwSrIGB0Rnp82qlt39l3RMiwysT5QCXPDEW1WEQ3mlG0teYTByMEh00Crl4qfyXkp1LO7Eh3potljtqHJi8qVir4NTK9MRs4XtJvH9hn+vvA/5Gi5BhoHPeFAKcPM1Z0PhuIoqWVhZOA+OFL605CD5DN1Xp40XFozfj+MyY8uakHbLAnHzpbUtrjZLOzlf+wdMvyfCNMoHCVsKmFEnq1uz8vfqrbtNAVmOVrboPCbG9PusGF5sMc9au8Gidq332Dygn3TSt3IaI2scuXTWpAkeqInou2fj+ZW9wJfdv4jcUtH0oh1yONsh0HWxBxQj6CzxPH2BxK17I1rwxq+xc+WJxGJIRFXqqDY4ROi6aQPC0/UX6zuhPrryujsbDsQK7xWKMwh9wkypmh9wtc6KwB9Ny+ThYqct8lbojScSnO+G31RF5usPo3mscpUcWu+Mz+MNZhSKvL2rrv3Enp1ZxM16JHWEYnzdWzgY18IA313P63Upph4tLkMKQlKUpIRmd2n78Td+Bluq+I/ILnfr7x/gGgchWZ384Ucz9rePR24o09hRXKhZpbVwN/VMHOrV4vi8po3PA/dzgTUqghZgIl92pWSmiK7HW7apu6Z2v+Kl0yGM0I8E+w8rbnSbuXLxG2TQN6AsxCdg//hpm/ZvNAz+FYW72r0GCm2bH7D2w4AFLWJYbEfnEkp+tMRGKYBLFJM3FVM9bZZdJAoX9rMt/BQmCmhD+70e8IlNFbc3RBGBEsZnhRmplG3OrOFyTKxra3ME3eN1btiNQyr+fOR2M1sBN7Li8iv1hY/QcDMyXlKxSp+zHfK42axxbdqxGCJhtMfWmxBMOvl7ERaDpJvn8l37hEPcg45L7vLReFJJvKd2/iX1YRZk6NFnKy3MjOT49UFJiK9IazvshZQYwcYtev3POKZeKrNKlokZLcBBSYz+aOkNzRwh7OkRczqcS11RIvrliI+TG3LWBz9SComb18n/RU4oUGhCHbP0MU3FvEOktjrSBZ67iBrYLjUcsDxD8endbPJl+MLvqFBeRuKyJvnPLaNs7iiKccKR5i1sSSTlN5RxxN/cVN5gI5Z0VubLjsob9Rsd+HWsnfQTjOIaAaW9h5r8eMwaIrPDTvmGjp6XCpqg506x8qIaeaMzEHxI8mSWycTVDXVqTmemKIOcQXyr8yI1nH+dKP0O9a0CK2SaSPxahAa5XlO4vXaaEHo1crF9rRY/VZusyRCjIX3uROjClVFIU/EDwDPCXxrcpTDoToVYWeWLk3imcx5bBXWyvLHO8HwRCo7DI8jTpA8incvDqTAT5ZaVRdsHTBdX6bPBwP43seWmImtQ7SBkg2kdx3cK4+XZvCwcVy1zbV+lwMJuUjpsQoIqKp3p/JSMganKAyvB5uPXxKbZmxUHFCJ5EFn7YOQwvDXE77q66D4Ts586OwPqVVN4D0I7SfRF4p/Qw8ivzZM9AGDVhXsK4DV8SWOfly6OXcKHdsHW22ZGTvPk/C3FceToAsSrDXhjMBgNO2Aq1P4p/EzzzuBVCAAwMs0v3Gi9fdtiqElXZNKAzlwZaN90IAH3LZ9X6hmPwhDTgyFhcB7CGBxaqUF4rCDMIQRWY3LieqdoeUskDZGBT8lzvMsag25eIl1B6nW6aNQdk5IWIMdd9y8VOuBF46hMmYOA+MNbxTmjkPqaF8l72eyXwh3X1X0s/TIQhPCTF8Zgaid0RIpnlH2k2WU5qsKSRwmAYX2euQUMq0GKG8ppz8xDE+Caosi5tC6EHLK6X1dIFe9c6jknCEJdraOzzmKu11sKn8qFy2SKtKjyFdbloO0PXVabSy3xGAMyf+2Dxwr75y+lVPj5SF2bqYuuAzMYTm2zsHPnUxQAXfL9zII+9MDYXRcjSWlfJ/CBHHt3dB1q2BsW6uZs45ccpGHnCC1iR49Ebvps8wXG2c9cEQ/KJ1B4u6e2mDjzXlHqYK3N3OBvGX/p4XQIpxXPKYzeii84bjbPODbfXo7UMVsBnxgcjyW3AhQynkA65locyM1uUzRsl6Du1hvCjFxFboKr5fkRiBJFUCKT4a8tff1rukjXx8QesHfatSE9P9PyicrDCcIS/z8cLtxkuD121ouzw3DQ3cd2nOFYBEM1aBvdwhkyVLoA4OgYUgRiK5IBsC4j2y3osYoac3Exw0l29I/SHFBvqr2zJ4fOEqZpvGzlugfDB1JcnPkdxkTGmRS9WmZg3zS6b44PhFOtUBni0dXt/Oxo4MI7fDzkDy/bUdgfif5jT8sFcfaDltk2N5nUSC7c/eAiBrCxSPDI5GgyaSFoQ0szy9CNFYrR1Wl11Ro/X2uKPp478t5Le/V671aU2JrDmaqPXRisVliYUgcyPnHULUTmqdzvsbWb465qwMnV74xE/keDUGH+YBgDby4HiymzJOnXwp2qoNDN61SxbqE4EvTl/Qj2wm5K9gTOn0UQbM7xzkQ517a1uJ/v5voStf2HgztJ4xlJ5MYXx2n/k8GVDfkx9g2ALuejosolk9Mjr5CufeXTXaneQAX5v5duDnEsZV4GEOtbkezNfpWf7N3CAn5VEDFaOkQB0UpMhIjtWBFfGI81uTV5/5LDo2NnSclTPyQsTTPMAYE/T6FwHbWiDjk7sZSPJmcvLD12FwzUghd7SEgZG8beufKV5lc8g+ROoEYvhrARDv3DF9CRtBsJMKmIowSWhlptNgzQTFjDyF893x95A29/oL1/8uX6yeZtMOSdcENRmqwYTVQ+dNdCqEpbY/xcTyf4iOEp0go3b0ZCCvjvv7WHSWYTDNhDLZMidPHlR/Fj9Omm8Z1m4C9D66V21rix3JkqgKTo0QlZjuTdCdHKBwt7a+ta+lq7aY+oRK9RkmUfZzIIWkcpJXz967UPK4B+KAafaKea+krvTITycD2TO7jrEtj9Xf2mFC13MawCmEs+1ITM/flo3jyxeJf3N/mIqAAEBJMyjIoH+yue3ngUUPal51ljinHkIw5RJVRW9LeLdq+0GfSM0yqTKxcwXsZ15FS1g24eNMKxtXeppoAWeGJ8cubePhD6PD7mGX+wB6P9CpmpZ/+qXTvbpZYDQAgvN7A9iXxHz9AzRa2Mebwpal3Go4+Pw+Vrx5iA/i9KsHD+bqzmM5zoGUjcion5qYRwutAbNWSBc/0v01n71U614y6nABZim4RrQLt6KgBZPrqTHbyoblJNmF/fTPfKUPnOdoP/Yt/zHzlN5kWQwjwgJ/5LQdk87FAo6IDG/9fvuXI38d9iKnmHSFg6MIdQP5mwCFEUHjCN++3yuN+X7pQfF4IFeN687IBAGpY3V85NhaNJJJBkQGLBBAdn3x8UAJc9QO9UrBQnOIuQGMTyxUffEb0RwL/OWuFGecvQEGR8hM5/kcrfM3OmL+B6401jOVnPxUOHZzAPTongdqtAEVyS8DpE5kg6vaCPpTNHpJyVpGh0U3BEETU3eWXyd6431urzvDCntzgp+pUzBcjA7y5qoJACMsa5b5754EmuWM/yCT2Pqi42JO5cxpJsqOHRsGH5tzExoOZrilM7yObOHbURxY9xoBMUHWVCoFUV2wQohNkdy3Czajrqw4Vl4zlRj6eRp2Z7sLOgfz0pxu6QD9cLF78nCXq/3UbSpd/onIUtnizGQUYwpdgi7WZ/Hx5FTDlwAOsyqBgaahVpa1WUUceLQIXbWc00rIb0kT1uvAXG7BP9YquXxcDD2QO2V0O+bFHMm5yCZ3NG3V8bwyz61bHBtL+9e7WnPvDQzdPmaXSHwykxawfFUU/FJnujrHsuTUDTugn1Rvfe6gBLkQ3O0fhY6BSTP/NevFff9xfDMz3eJCZWlTcs6ehbwX0bi1vD9Ba9zJssFkFuyoXaVj76/A/yqcksAARtoVeAxlRYL9xwZqTQwB4Hq3ufK4TIa/WxEAdJEs5KHbFnED4A89TAM7AVaeGEYIqArLTqAWl5kRYVkTyFn/Gk0AbZsxFoHoj2yZu/pbaI11xN+0pFxKrRC21vPTZlxrXAfKAZmQ+bawnDwsnjU2VBx+PmJMzuWmqPJSfc/xEWA902TjhNG8Z6R+/Mz87EEu9D+3UQ9OrwEVNOHOy4XpjNNGdAVG0tg4KqD0wa5jjr0aUWqWUsKDM0Zy2HnNNHXwpmZW6We+IprIJDoZzCRw5swrSw/NXvTYIBxZuCWOOoY9uLLiLFgY0H8R+yYgRcAI1+DJQWT7qVfbdSdcc3N3q4wIFT4JWK/NOcP3BOY4XAskNM+SAXOttgD7XgQAQqGKn7VedIKoiz+zCBRP0x7b5Izs3j+KRA7knnV23+bteOT81xz/E7xJOZq5ylkf6BWse+E4dCWJ/ikWZkyAltWhU0hOSGcwHPZVDVK24+4ulv++9wzvP65WtELXOzZD0Q6F4ShcfOzRd97xSwhCD2ODea/6sbcCdeWQLXoRN9gV3hKYKoDIe/cwnn+ix1HcGrFVyeX9wv7fbgV8WGr5rxNMZuPOJXSwchait9ettdrb0elKEEG+OB07SqtcecWUoF4FrnMUR6XoCEYbM9LzeJ5IQd6ZxIsZ3oHkilN4wNhTb/vFrbz8Q+niZNsmVX1Q/tIoZGUBCZUGt8bGC8iKd01ijZoFFcgANxd2v6rK/8CbSLnlsOldgleRg/8janGipITwskPe8m+LnXqbHW/67clHO9lzYybyM1ZHStH7q9pbPDEbOWYJlihsU1//l5XKsjYUSV8AZ7JTR4idwuCkda68JATHpNAblYBjy2B16+l8GS7pfHqnkY3aBG8EOEzTf1es6vQLMQAdiwAqY6QEmrTK+4WLzDfV2zbubcc4RUWPBo4Ar/o6bUnLnlZ1CH+TIFOJWqi5/qXcmKX9API0JItURLPlTa/215kmiHOCJPQl5T0jTxDZEb6hWnYkmKaQQnRmKY4q8o+cef0ll+hxR1NLJhopjKzRcd1Ha8upfa8wyDZ9wmDTlmqG3Dfxqc54OLLoJQbo3AcaPg5hoqy1MzNFd6DvD28PE0vNVfngGrxN2yItAW1lkj/UvSlL0BZHKZJpLyQtUMonbToYOLvDZQv1yRjqiO4IVaD29QuIvNm846IqzeWUDmwYuWpVZmhwhqqiX6XRbCLPMmr1t2P12ExtCZA01VP3KOt/gFVPnUhdcKY2x+krrzVvomwbSUO0dxv/035IuL6DyEH1/PDQvL7yGgpCQDOxggNMlKxpxh1Awi9FhBqFFW7FM23UVqJuEfuvGWH1ZDK4OVtOxVI2NMp+BqQA06VLBWHSnNQHYnYLRQjkbRfv53mYRwBTINqftRgzs8RlGfWquJOR9Da6Z58GrArsF6KSFkGMUUQ76c5CNv5/WhCD/TkGvek0oBxT7Q9ZLNBhO2jp2vlYwYjdLhY2LzYC2qVie6B1kLOG7elPZ9BHUmJz4auNNpyp0gzVaF1Inagejjj18l5wtp0dYrH+1UWgvA42MeD4G9UWxv7917xl1wptf5DdwQ7qTqT3RpWHh2jkwqURczQZSKFjut7WmKoqLjiMKtIJkda63TW+P32jWvUEcvaRTQhMgroMwvUt/mpv4z7OYtoq0ejm0OdoF4K9vg9F1lI1WF9JtVhRDbJSgSrfywvbsequfRhugjwNMB10Ze25RZe1VR4E2WhFFAW6VifE7t9pg+ClXlS9ks9rbZoMuNzw3CNfSN5OyCZjZUzLD69wZVfgSOvVxMcTMIZufTz5cfEYsNjtuJ0/5vk2AHX7ndXeYl6P5GRgDCss9H1KwcX9yu31BayV3gM/Gl5zWJNss/NI/F6ldLh0WnSuf4HCMk4AE0b7kpU1nAzn1Q7qCK4kVL531CpMRaMVHvF1xNAffeA+e+scFFp3cd8YpShYpJB7jrEughelE70bu8gSOpRHsUyptZudmrp9jGHIA+TCRjJ6REVSINP/8NNAreU2zQGAnUve43cMxW3pkZqRDG95Y6D92XaW+YkPt6QP1+EouniRC2qejzTuMMw0M+YX3qbZeD5Kom2ayAAlxbFMiLIhlEchI9vvD+pqemK/8o8JraQ3DFyp1NvJIjeqHTf0m9yOmaE8yuTzGfIjTMnZTLj7JnICFiiAyIFnDO+RtOnQFebOzp8H/oM0j27zCXgzgeDxQenmhckX8M+OVjBdClmgKfKFSojtbcVlVhJz/5dKsY2a8UEwoyEJC+G8y8PGkjj0R4aKyLwmHI66PuBi/GtgrqE5iSTFdSMFnDHIs5DmEtAKPFPfJc6xEGep/QWyt75TrnczylUkZOhwlkTd6Hthp4b2DCWdhWM0fsKQjCzY+o07pFYZdUWOOC5N9Xu1Q8BwT+jfYbEMz0UZBr/XZnE/WNvJ559yGBPZgpeJeR8ASKcMwrwNqbB20cts90Kip/Tp2LgK6rE+cxJpp3QormgojerGDFl/bV9lvkTjBpZ0Qe9VjKs2R7bzEFCj7EyTc7poEanvkuv75KvD4kvQARFjOr12us36z2KmRS46Gj05IvvTJfUbvChrXLdbapKBhoqJ22zs0D0buA9bUxtOkXBBZDh0jBMP6PBEGap/86UrcrFUlq/irfaL0Su5eK4RKLBR+PU+f6TK+yJ+Zo6rMNkEy4zMQOWJv2pMW5SXm70TGB44rQfXS2xSqLxTAWscChwmaYfiWi9i1RYElY1vf+kzMHYjmAvaR7Gok82Pc5K4z5OJOYk++8KTdPhJl9+7zTv4CFHxY2ZEdnbXYtYFTsUzhFmfINP1zwmXixj3W0Fj/66DKPkf4vE+rEKhTN2+dvDEQg4e3hepuiG0D4cOYX0VNV1LULV/70yT2yt2tFVvdTig1hLpjncnGn+ApMHQaa7mVk1jL5uYCip2HSrDLK6k0b0bF/HXPAcTTsufFyCfQG/4EzOmBaQ/jSaUS08NF2jchxGi97+dYBUHGllzHOWdy2yrXlFqQWdJmAPYUD9COt3OxTsPqcqrS906mm7aU0MlLDxvmB9zWxBYCdtphICwtRxYCKKSwYG16ONCweRO7HV8yW8TynQkacBQdL4Auot4VlHexpcnkviIBDHH97zZz3i+tz5wgUJykz0wRP8cguvuJIA8INqUfD706b7Qt8inkkThTI03f0ggFu5PDYiyRqkCL5mENhAds9D/QuOdNBW4YE4XdjbLqDtWOjU6tLztbluQMXcMsQY0meIuaGwaG6e3xDuv/ybxFdZt7HIS+uAt3bGXTva2dyrXJAIND5g9I4wAOykr8uJ11XrRhsQ+STdHu0R1lyLTPptxIvf/GMlBNEbbH+x7oJ0j6gp9E5ibpkafn4WRTLQIUAkIKh1FYamd1hMoBw111frqOZzUwkIPrzR6XIo6LK4cu12I0ApilOYN6OKv0vXEGP3j7amkHQtuTj4AMnatCNuQCa3gRQ1U3h+HcG5p8TMsbStPu8OOzjdnYem2B5ctz15KMKwQcpZUzTFZbamKMK+xbXY/qKCbYpnPwchx5M/69wsInchRUG9QbbKpTGq/Li2V6n3Xc4hVe2ntqxEL4OQurZ2yjW0II497UnxOM0HknSp1pCDDnB7sxUnh/IeTJVM6oi/+GWMe0F1wbN078ei/VbHJEjzesGwptct1PKMquAkPfAI21HgAsYHp2szfPbtz4ssUMi8s9FMxNnk+0MwoFt28LHhQAzcV9oeM45bed9EQeXQDym0oQkZw7SDxlLK3+4uz5dTBrey9FYeKNQ2cwGE+8FoYyNUXQxDFJ3hqzbUv6uLALe7ASmiduZEfD5OZhCSRDW38qkkDMu57BvTUrud/25lPTZp79P2jd3KpcKSoIOP/85S+7TleGtzLgfI1MKdq+eMkYQHMtIpBjQ36l/TdfUt0y/gTCcKVYfz5B86puH5nFwIx5VTRM9VfKPLkEBzJXONMQOXpeiLlj+dEpy0wzRdc9jLipWrCcOZyg11kBxpQoMCOWJWlYHsZ04bVciWoIDoZ7nRZdXVgDHDUP3NvkeYJXLEiN5hoTrAtm87NdSB9SYD1Z1ukEUUa6V9y8jRb+i/P7xos8RkNl5pROQ4jPFc2+X1bknq7nwrW9S649tyQYB94h8i4M/vKEkdJM9Kky8txwtkp2JR4+2F5ebPQSCVCwcEXHZ1tZkBr8Qbxr4G1rGCWYOpFz8UW00LgVeAWXM8hMaE3JpwkuXyIXsXXOKq/viSHXJcpyWP+iXM2IXaWTSee3ItGY6ArfqkEWqH1O1mxmRX6LrfNO4/ghXG5eLkmtY3+sbIhmsmln/0OF0dbsIzgYzS1m7mrCUjCXYJlc6seUImys/dx2qP9zQBiqNW21PjdtKaGyd1S6fHFL4D0l/9nktE74v0lysgumqWQtxm5IulCjXp2DkX5ski9ugYhTptWPHjDBH1I/xgceCyk7K4lI/S3LMuuU7/cdiBagX1eMPtbjwsYPMIb7sr/bbju5emc4RFTDiaM3M/GxdG/EqC01K2obVbR+9Cbm7yA4NCMNPlp8xBLya1i6cOV3Aq1M+GQslZZ+WwAP/oX0/KClDmCZiilNMMPyi3JGgMWYidlnfQL7UTj0HT88oppdCiuOJn9OeiqX5ZJX730wcynF9ZwrXLbdWG19b2QSS4CEwpb7Ce6Lh19cqEBKvbkGBns8HCoyd1f8iQZwgQ67pQW/TkK2thiC12uxqkEAjwq1LtEFFW0hdtI7e1UcERs24wRj+zjF6UvT8Eh1gqqQI0p2uBbR3jnSJzJQAVFkFxslWejWq1aeRQVpxuEXfNkszl14Ffb5uncBX7tyrcqsm9FWNZY4i5ESsjmdfo3954aDrvzLskZClbM11ZrwhB7QnJluR/z8lExZacssHNSeZIDiAzwfckoxs7NcbE4wvEqpI9wYEpkiSeNIEdp2NYkxySCwNIcFKsR2b/LR+hhgPX9/FCZTFLOgJa1vS+RITGnCTUUaWKbS0KRNH+W2V23YWAbIb3wxJ1bFkHuLZySnUFau9ynNM+6QFzcS850v4acBAjQMEmbRaKKWR3Dqth5mk2EwqyqXK5ggOXG1mLdG3MCtyGv3mI6Mnjlvdu1UIHtfxaIKhQnpUQ45XgIZB1x/Xjl+G+rwP+lZQ4kopSdwq5DayyCXqCIkFBeL6HoG0C02IIhaO/s218+OE9XpB94KEBqqNDiYkjw6f+fjt+oUTZrMcpB+Qc3ccI/thn635G8MU9dhYIJ5M9NADRFTXcfGWRZIbPEF5tR3dRkUc43vh4RXOpQ9zhTkR7MmMP3QDPGxgUN6H70wBLOaUaO/9e1vMqPkmtAt8NqKA5hNHJdEQdsAbLdpdnIBksRLHgL3iHLPzfEwUvXnH43Al83rS0jao2oWCtJJTyyHCqKg8MM4HdgPqHjzMw5uOOBPDB+ZN7OSAG3Ap24zNiYHTXaNi9n0XkiD24jy+rpFA2/n/8xdyadkI3AX1Rb/dxNif1eUj+Hmo6BJG4m2BektbbcmU/SwiQrhZc7lFm3CA5bb6SZvIsc46zpuge/EbyIdtIUxqgNhIPvthlDRzQ8hMoaGK/QUCrgER8MmR8l8/aDJ0EocZkNAvZuM0pQyu0upkVaooGxtlONOalyotwXfPLRrsCk61lnXPNcRvigGh2Ts5oFxfedBcBhZO3LnAN+N6tKCY2zYnsPBVmoQuVuj+hLNVNxJEWGyehwi2JVquZDip/3TYXM4cGkxbgaycDBa2OdLQXIIfAS9wPXGySw5aGBxyY3HNgB2msTDjuiRSoA8Y0h3gfHaICx2g3QRihNWBt4XFkXa4z+nxRD2HK7U1vNrGeyuJMC8wmFVbtVE406eGx9Q77bhG0bIGbZhSICFg+Vvz1gCmpQLqMLboSnZllPXzihszT3c2777wMJ8yNOfCHVENEM/6c4Yg9o5lrGSCbUFJHSX2aGBhS77oXcv/qM0USENEAw77/mi4wKOeKNh/oI8rdCCWjDxdPMWqSgMRhUFZEj3BeW8QqkOAk4GALPSRa9ud37pjcA/JwUMRkOSF/pK6T66moo2Es0bownIeM7JmziiR1xaIwGoJMfOxgsvL6qgaINN8ooib9eRzmvdFcKs8gX4GkPhHozw+FlTeKeBRbbrvHhpDmYOo8g+IhkWhj1Y9CwTquvanSOhdBtwHqJ6ZmE17s8pZZba/Xkc+bML9Ql40KfwXQsxg0QuS9WUGzFKqDIweMxA6b4ni9go7+/tAj8WOWGA1GQ27PjmRn7+HH7J6uzAxVnkaRcwRtsBd6iOX+e63eeve59nWoH/XmntAuT3OcJdy4zydULq4ofWB6zFTt+Zvni9A8I9fRnCC8ulPkaa+oXTwYfN884JJtt5f6Uk/2vTTnk51oAlyaH2uW9xaFdI1fQhLnzZiNzhbs+zyMrXogFmyiwtmiWAimi2pqsQW7QgzZL3n4LAz1fwap7/kVwWuLP09YlYLotDNBlT5EyT9oCwdJzbUqxWxFpqfBGbuykm5Z+374sfO6wJnwhF6VWElXIRtJ4ts4lNW9DcOIInCFNMMsqysu6PXUA0GXJhF1tzeCBIinsjRh+edl/c2gAQvvuLezgysJrJpWvHFFK2qAzHO76dbjvx+c3OKnbckjTFA8/dPs0KIExDJ9OQ4Zwsj1sVS+kTcd3ye577+eBegd4/ZsMiwC/7DugOA0TEIgT2Ht56cq8f1EDLm6q6hGev/wrKQA0ZJYYB7M/vZe63vBSQGHCZWgOcAYH9QKF0HfOXy1aj/e86sHk3xS4k8NeFc5ZbH9fLUbQ9IrGhioxotrsuOuWa306vNLMoBMF2acejma0XkgVDVCjNJxhDvvrLlJVOWmLxhysBj075oaIbZXUODvAG5djTpjL8P+5hlCDCQMMQW7M2XJJaT2icWtlkTkDIdag67o97L0p3vFtUhPXNG+FK/FNkjWGuftD0oKSpEMwleLRBgPlxsC++zDES41bwq8RyERWmji9OBRzNvkVzrMr0QownAbWuletgRGx9QaAm3qJNWlsb4VhSCwFI2Pp6CK2skl1Opqg/Zyl6LkGCsIyaH/JacU0KBrH89j5QiMjYueBg6mHmS2piMgkb0o5yqyktf9lrBayTEQ3zZXzpdCNt4UtvkPZZxHoK2Lspm6flWJsZ4YIcZW92gJci6nUSvPq7hg42bqlTUZS97oEa13nFCdflF6huBSPgX6IVYSFGvNrRGC8y/cPcu//a5aLSrT14bQtUMVNHtl/oOcx4ug+antTulQl+CzThbBG0qKXjZP16Uij/46d7LClPxdMH7zSeALP3NoOVibe0L3l3/NBTdw/lppkyCuZK8TrfYNAqzU4NihegTP3ClQNjbZ4A1wBPb6Ay2jtfCcYE+BVaHY2T99a8FUJFhRp8SqQzZh6oOSfORIJKknY75dwk3WDOqknsX3n+TdIeFMK0A4xG5SiwdUw2FXxt46K/PVpxUNgQ5hdEPNPpvYDNuceKPXGBQULEAWmL10Rp+RngS5qeYfeYa1tcWUbBRDz0+wfusnu7TEtTD5Yy1MZSdAD22LqhwYfNfYlOQgWDG38umIuDWv7evU/3+fFHKd1RCdxuMR3NvDls6K+7g2cHm9YCxXZVp8tCECpBD5HCDpftLVKWV5UnHeGfJTa9zEPkGzzFbqk1/Y9BukdtogZ2CYfJ6nH3TLLR3HzvwpAZX6GzzDCN14CDmDydNVj0MEO+EyZaOe5vX+fDfCEB+oh6ZyF3ZQN3icqrEHYOJlEPDAMpDyxj+M2NY1FUPUVUrsypY7MjEpaBlG6HnxDYyM/CcS9EDuS0mj1kkHxjKjxETaW0EN9sImfmBJ2lv1dr9aWzbpYOIMTmunbRrpc8oYlf7LKaQPFIkrLy6V9Pct8+pu2w6EfNIfGkCkYg1GDV/z+3lpkZuPpsZYB7qCPhjj9tTLbbB43GG/mz8oEvxYhQPwCO+cXazxhmng9LBF0xQI2Qho0CGa66/2TLm6sL/KNdpK6FZvRrvueXW8JG2om2/te6hMQQj6P8vIioceaGctMkPSCLNZ0OBou8PJYxQTlEGI5K8ZHLY0P7uQI0v/gzV9pEMTaczoLIElHn/7Slhnxwt51SWMwhsoTUPIac4sjPW5d14rcirKcxERv/DTxqUs1wAeCOAe/berrJJ1WRCutsGo90Ah8fqnJKRaKKueHMgDpeQFrfMPd5C5EKCxSQ6+7z97gHAUpr+YBp+72KxqYQD+XEP3eSfffpQ/RQdwSFSGntMv50VHBBN0BCIAFekNsJ0lA2x8IrV6Lap0VGJ2j/GMB8/LbR+lNT01ZgSzzLSNz+uQGALWK3XhEfBBGtEUo6opTctiyJf5NrGEQV+Pyy2jXa9aKT/+CZlVDMWDVfWiGNo5PGHd5LTmNu1Kr3N17gHqPI2iG3u4VoZCrF9FbJfw/uS+Tx5ZtYdE//6kct2eKc6DMFXZEii+VG1HR0rbaL5QgklP9t/Y9BUFFyzwMjjgHTsaayn0qHSRH/YnYYIskFf0EI4ufCCpgCmGPU8IigV4H4gThazPZOLX+6Ai3EgIGcU3Ch1K8nE9S1kvypcVi9iFzfDmECOSsISDHgpHoQluaQkDyLOCIPstNGE4PmmtPK5uA26DVxkFJcABoXIAa1GT/kUm/8RTim9mhj3iAi3kNKdT27IVj6dfL3wBHWyVy4MxDanz5/yp3hMNyHcmTzPniR6VHjTu6LKwWQQSshJBUKJKN7WFPtRrAAYmEuNpV6x2zWolw46s1IfyA11BnAzogx5RW7EVTC/6tXV/yYvIUbZC87Nf9Yf0JDtCqnQFJl20lD1IMCjdskT9v21yhwNpUy8wi6Jz/20LKdchcwUHV4jeL7QlkTxqJ7s++Xa9VIPxf7++xVPpnjmKYv5en4t+fuqTvMsyHFvV6TYTkzFAucgeYUkPe5pUe7U/wAg+RkZmyVoV9s5tX8fS3BqeK4WOqmxhY9cNeB+2ji4TCaUG7eLD8IHIsirt/zjLr0rO+yFQ3gRx3xlO7nYORUOcP9+HtMTZE9oUlhNdPq0ziGmb2dLfNem7psTh9Dp63xlzW3ZcifKiKujemXAPuPeolc1Gsgqr335F/9T41YXuCBbdtBdc9YGtudCk+6JNzOO53zBkb9pam6lMyX/eK6j/OtE4IIxQKGTMS/fSrN9za5TrFbARnYv+LJohWTJlGHh6sp0zQ0fQNiz5aSqhlY+eZEInrDR6mHaYDAEydLcpPayHQFGx/HmsPVnd9bkOwDs55cqa+2AV3638cz0HUjdF12PKns6s+uS1wIVcsGU8GKoDyib/34mNAyGwB6l95iUk9tTubNZgzJFxwS3eCI6gxUykxjZnu95sbgAGMJ3sd7Z7gRDUQv6CDC31E38UTkegKU4ZL0rr+VvK+G7q9JKd6Tl22zw+v0PyvIYvTWB12E+E6AzGDfGAkl24jHzqDEHXMpnvO0ztBAr5udJinJphDRZh36dvHGxyM/j3skTXbQm8c5uO+VxcYZomAzcA2co8wuNOuccCBbLlHIGyHDMWs789twpfFSSKD2ayR1mjYvrokWd11SgcXE4U2uLq36A/cwfEDol0Tkx5tjJdccT1/4jxyrWkr97xJyz0cSs+IWerNco8bfVkw2RaWh9XbWWmc87KhQiZTx5RflerneV4sJgZVh3dGJccuVODJQ7OoKPQZu7Znb6QYv7aqEe+Yaqk8drZB2c/XS0LAfo1wvQdKORIrwVgy4CdQEwSmV1a2cPMPb9LhmsJ3/sCGZfrh9XIoYQkHMVaf40AWT7OYaoyiyB0aUL2qdMAySVBkN1fw9S6SeYt68r5b6qoTkfPdNi+abe6LorNKzIKzCeZxGqt4ayoJRPhXM03hgjXp8e0FGCKsWRYvVd6LPlOhd2JOduv4b+eF3/pPq++4RJ7Exc5ev39bTbqTHQDVSXRUlRDz6WAsLEVN4P+MhmPe5WwdA5dXksS9DIlXFm8ibPWT8i9oUMFaP76BT/l+D96qx6AV8cJFsLwboqwK9JJ4KkQ6Tz9IGMM9fF1LXntocW/GHT35MA3TAbGjEmitBmcLoiuPt+nUCrL5STEKIOKFPpHLjmg5z4mT9La1mTaZMzGzoU3i+1ffpHjPrBJlAj1EV4oEL4UPp21aIVocRQz1i8TNlX5UqwlYy0UOeibboLSgPTNXucnvuYcSUqDb824QwJtHLj8PoRJT4uNSHEOUAdWfLQ7s8X7QUoGTG0UNwHHAv9Zg6kIcUqyXejysenq2xqcMuhLqslhBb3aaCuOKTDmxdrZjQLR6glgVLfu+GUxaOEskSKFPAgThMxvoaLBW2LA9gWvzpxirVFx3YbylIEEbqEU2LDM73hjLaRZsVS5aobH56XdbnsQHt//HjHnJgFwTrz/5siKb7MNcH2G8C2I5rCSwXbtt4K5i2mqZJ49js9LrYVdLMNZGH/hTKZIYW3UpofaCMd7VKeyHImgJhzS6A/qXuSKy0fdpeSFjdJLyfAI4q2CkqJqlmw9hr0DLDkqeKCId7s9ydp8/DDhzRb/j0SlFPpqb6IYP0+squJw/U1OH6+sllNqZt9VN/1ZpNkNGrzxh6ymtiShiy72iMAhq5QDYfgwNgewGrKefl3myvFdM/xxmfQTvmDPO28vNu/Pt6vJ2uMAMTu1LPHd62jZJs/jrTK+S66Mw+vGDo5Me0AOeMu98Os7nA7LS/mc0xwmo6T+L5R7VIan/VSFaS9E2tGz8Z+gwE07rIxpfjqnaibltNF9YfHLGqKFq8+q2GRlMXlZaZF+QEibRVrH+oZfMX17+0DLc27uXDAHfQY9VlF8MZbjJvuYGnYs7EHtecFqx9Ooq0kvsYHZyo0Zq/v3p2n1n+aKGYMxj67hmdSuQQdJId/bkTWHQgq2h2Vq4qg6utBHsB+/8GGkBIMBy7qRJBUJ3U4Kj952e/YPKzA4L406M1rIBllqClbYwP6e/XjVrZE1QnsWXBU6coteCUly+3wXNFvKtFgx8eABl6kMsCEALHvGHNjS3nIeCPFn3+X+r1T3tixWYppEmlrDJ51qTJT3FO48KYRTwJ4/PyDM+rfyK8/rOjkIcv6vRXyLd2Hff7XzpsS2/U4XIe3M1B77+O5d6nwg2htnHVNC0Tu6EAe+Rpi1iK8UPLLpbbM2sEwj9QzQsAzFjZdGp5dmMydaiBBSbgwBaThf2hLDdz0Fj2eBJLHQE8nsy+N2vuR0HJFb+hUFU6qnHwuFiXJs08r+ITVq/ZoFlnBXtUbZ2BRhltjepUYUofOyDd+lIK2Gv48W8acH4XHCCCibMY64O5Qf5BrYR1u1r35WWIyxsm+L/ajKxZ/aFK/IiZkzkZF3e2sKi8LnFyS8/I3aAK+M+vuXDhD4b9JbJy+YOsXrHFYXxpWuveBPcbRqe6848XeKBoZSq3YUjOqqFs7J4o92KCdEaMKvOybPABmXzyCnnIhFzXm+AwAwibAHJdFjPNtwk63HuvEqqzBb6c4q1mX16o66xKipIhWV4yABhlbCKXxFerCY+zyrUn+P2P4n6FpsMAPxt/XkeQeZIjW4mvTnDJ6FEG0/a9zgeOkW5VbtkXKTr6SnSUT4JD9/LKm/96dOpSm9S6+e++wU+7kZOY+YHukClyBdtFeFGLYgEoKGDrirorJGJ2xGz6F5pIXdYg5tKfdViOcfAihr5gb3hQdngYAmQc1GAjceuMUiDSrSH456txSraoAmBboFnL9nfacmhSgWL65OqPl6zC9MM0ad1UIjLnjEEjA1BSKSyTS7cmH6L178nftLN0TZoE/YNAsMtb9hZTRSKn6Y7YXl5OMX0Qbp1eQqzL6hlW4TxZUjQ5yShrqeY8OfQsVZfUvhsanOI9u4TYyIT1zFpt/USVqYm87i0aKX9QvsonZD7HYM0z1cFVGSbGb5/yOTI+cFDSaSzr46g/yewdkH+FAoh4t/OnAXp1QWOHf9L4OufOBfpLuLwko7vErhsCAagloWP8cHthYT4JdM59+oSK7vgbG4faDnkCLIF/Ko+k3N08h6gP2NZXyxULTz2VLPn74jqAgu4/JD31vJgy/HeC3mAiM3SBmP3xRcqgplhA0c85Wh3Am1vbADwDbryd4gNjzv8dS3FTk1elgFPPIDJbesiIg8H8pzcCj7aLTIilgUYXhwz7DzrSACxnfGpYzox2v8oyqQw30FBObKyE8oZnxwYNDKOfdLxMYImFH8zGufxl3MjP7m6tZDDFu0F0m9bppbyVjMP8F6nKMaZW8y9aD2mgeXWawOXAwYVC2ZH7nD7wGuSEcl4Z1lN+oQgeXzEim3xPx4e1dQR9UpkvRxCpyJQEqYqTfHEQGo1LmXXTNgjyb7BZ6/dXx77bAhyBy/b7sTpx5QcC8fslylGsLvNIIDDyVTLvHgHQInFoB8mvlmFeWD2ctMqYqGzLANA2xvBq7F9HQ69eMFERa7sn0uWJvYQHAHBsgKBeGDOvFGQXIQrlLcVNSRN9wD/onCPsBsgNuhcelaxsicuVpaow/urCyg9MTj8oEIG1CfdY6nW8SHqvvqCMQ+eEeUHesb9sH3glSagvdDnAtY2jlQqiPVjt7qrCIlOGBR3OnvVTa9NOoTrt7OOUvC7WnNLVMcrk8Rg+tWUWX+dz3eZeaCbcxw7MxoNP2ghg8z+YYCQBkDtiSE4KTm3t8higGj2N42HqHmPHIMlI3NnB9UuS9llQC0V5IwvniNH9DEXo1WdN/SyvF93NMHzemiGCXmnBOXxnReG8LntIYQ/wlglOY5BI1Bm8nzLiBTCKzL3rhzkSInK+bipp1C7TQodpgFoDRY9mg0vmCQlhapwKEwGJyo41YUG3J4f7COiE21JMBho3PR0VJ0tWRJQd6rxC53bBsOEwhS4+ggwS4DSB9jGgNmdnyvCnURQwYP0d7+h+VoQ22ZgwTuw+6jB5t0nAwgR6+UgTGiEIam84ZFlPZ889sbO/yXUcaE31o9d+k4p7Bfp0yLj9G5dH6xqRubnkzN4zirXdLzghl+4KXB+Otj4sU6D9fDu1RQQiI0WdeAJAIa4vy7Nz1q8qil5Vage7ixDHFYAMgLK3d8tZ23xejw87cyXfckYnKyDyN/D/GUSyROmNFX4PdxiJ0v672ISaR/aGsx5E3SNPHY+dy7T7/Ei4qPI/PabKpXxnSbftD2ThMeJTarJwiihwVNVZJ8p7vk5uV81V4kvaw2qit5odBr0jvwx43/d9RNd9Z1IkHycc6e7vPfdKoXKQeWOFkPxj6HyC2RsvPJwktgzRvjMssyF4awl3TYQLlU5eyWL/94hZKl9X4qOLjHAmk5Go2WFcLE9os05ob8ynPHWGnJ82Em+3XKQaHyMQ1/2qKAES7keOg37GtbHoeTSfkKhlG+D6tjuVomVR3KNTG8X0BCNI+wo4+3UuNW0dZM4JOHBvUt8vRns2/OBrTqS1PDdJbi+HzB8z5GdsxuXcuc6RST7PUBlgPbl4DVIbiExUB9g87fykJ29qHlZVOuLgW2itS4RYuu1XldAhwy4CgXxrJvWV8BqHL+zrDicAgaYr5fJVFJRqhWZzEDqz2HcbNPH/UtQ7qQGlRay/F9ebs744gqk4BTAwWyPPVmj2C0PEI0cmdpKAyhqiHIAkuug6yyumB9Hds5tfnRcR059SxHEETDws2tgXJ22ZRIeerlS71ID6odpxlgW4qImpB5EEXFVnC5SEUmh/KEco8Rp3q+bzcsVq5/AZdZFEtR74gOclUMjTdBJh45MP3iuaJEPwwYzYYgCbmz5z3HnWSy6d8c98nn/fmqzhNzmnH9CxgnqPRMM0vqpJeKuOIhoudttq+SGNdOyr+/kU1R8CANpgaFj7vjjQlNjMuko0WwOI5qjvWWbiTcmxerqEkcinn/M7TNGmYELdu3DfqWdYbE1XSD/g57N8x9bSZx4ZinqQPh7fo9zDmQOnJ4rPlNjU9Z8OE0qB4bvBzfCQwuUx8J7sROPS/a3KdR/yZYZHXDqkXK6HL9RYfYWQJ7hT0WerBJ9NfLJfsKxq4S5EHbC98Uk15xyUutZ1g+lKitz0YTHW5uopooMHPlNMBVahiMtoh3BzQLq4D9dl1vPTp8s526Uwv3bkrMQJkc/0OIO+aLdxr4Dwxn8g+Ue9nOj2eyXr12xWmPFrQEhOy5uy3tZCFhTLVayU0EDCrKudJ3SJ4NdPWiIe9udboqF6f/COyuS8pYfQFfiwV7+IBvuNJ0asEOj6xYVJhhcdOFxAh2Hp1rCTyp5XlJyWY259gppW+Mnx4+udI9+b7hHk5I7qakEdKJCCMztYszs0EgSkXj6XYWnWqcpt1HkI37ShwS2Zn4y/59feMJtJ2HM0TG01pvrc90xa0ZSQrJrlhpfTG1M6wirRoAXJqEM7g0BH50oKaPvHTt3H94C5udctwhu7KTt1gMSTNjma3QLThZAVCgtvKH6Ic48IMefIF4izZV4pezgUtSeaHl1EwUwlttSZbfEYZY/K4tbtMioSI2ZYMdt7Wcgb+2szx5iKSALD2ZRnN5jhOEoCSBXXr2W9BvJALUziRc8ACOsbpTkACSYwL1+6fyjiWCKXZNNPmnYEwvWz6HMO/BMHqsMzvQ3/ApaY2hfA/aJTDWdssxVaVvn74G28VMqWc9ukvCLLavP02RR0ON2ooblE8U81JsAWCl/t3me4Mi2n8WLGof229onONBsAInYYzdx7pYNVP7uLhktt1b8QjRBqJqkxnndbwTeOizO0h1jyV2x5zKblQ1TBuN29e1c3o815gCi70AuAYJZ6iUjqHYPIuh9D5rjnNLPChi+sOrPBTZfhO3+ijEvhSXF7LECz+LUceYfC8lGl2UXXYq5cjylGpopeC9Vqhk0vRXZ+Q7YFiAVUoJstn2+m4aYGkvy3TpWXRIWkPn89vf8iQNHlZDko6jek+ZbDHAXHpkfNL82In1/NdRXWa2/n6CBGQkZnGXQKrG+9dus5IGJaJ6ywvnf+dod+SAilenxe3oYBQEhAQoHrJO593QPpCZnDuxqPqohsuDRUugipdazj1x3PoSOZAbK0QTwQnSJ8aiR4H7zdMJkM+X3t2vIZhV/zURAhPg/a8EYjFmaev3Q+OkExfRUSudiH7w4Djoal58jqhsUuMC88xZsmMCOMkll/tpnacH9ceM6JVtSyNosn2CjYqZ4ZNOUsdJW02CsHjgjKlKIr6M84nKSFsQ7IvzWMNek9XF522MX/dfyqeTFCaX+wbiVAhXkxPhx6FligUwo17zb9s/1wrr7ZUQXZmqoibeKo7ouKp2m2HsJoHrMyL7G8Iz0uMwxii0RsH4OmnNFce7XwN6iNVrF/54hPU3lVCPljFkfrXVahtTmpEN5KB9tiOK1AvdNhlcUKceU5PsoCZu6PcWeKYCTRR+jIuLklFeB3RZn2gbOu+6b3i4ZcF98d/NVmT8ZvABMin/hvy+1kgc7XBalyqGh7yW7oEmdNfBbRo8ac/OdlGjoFhQDekhF57laKZ7q1yxRnk0M+QwCX2Aml2iJfhzBOn/+WRq92GFmxscyG8LGGfRXwnS1hu18H+UsBS2AHrZeHNijtGfwJlJxlL3PvekWQMU05uqCYF+clkHzSYHAaYRM5Zgux213KDCv6heni+/julwAOM2ZWWRXadIQ0vUmHOcL7NcveJwHbsYINw44SRviRdQ/9vo2IoIlxNPTOUO0wHJcszew9f/MkSP4KUfDurIDMT0lC4YgBZ5lPFUC8zgTYAZOki7ZyWzlIIgKOH45fUtTAxBfNpZUXUnRNbfS1bE2T1GlA4KSS6HrIYWgC36x4WE2rH2x2lknSTXDSooHrG5LpV7ZNqVoH7umIlZF5eoo37kHRNuX7y7cyOWSfR4zW2Q0rC05mj4KG2UJq5CYJljGFAPigKW2PWJ5wYM66ZjDOwKhl5MIwKpvO4kiewkuRtih4X4yx7WTleTaYKPqaSOfEFvhdd1ydPHOOKqii96YNPlxb4YxiTrmZ6WcGpv9z2K5RErONIZ3gGl18E1wsFDnSRentDKFbaPaH3xh1wHPKQqwEpjcQZliYgwIZYM8f9ojgA5w+0YK1icpiLNKb8oQtXbYHV0rts+yXBUwRtBdmBv1DADEf2gL8jQ5fOLEPTBrtJJrKqYJRRoz2aXJwqpyMNjIpCQvT16mpbPhzliOEL/jUZ7lZWQci3ilnv432e2QLoZs1xHxLdo8Y0KvsncAsnSMqyZ+L1MGVskp8VtFKwGVJrirGFEe4F9wLu/pzlHichD84RAGBDgM7HnZsPo9yFhB4dFwRv1WwlXSqnRsEOCW+QSdQy4BsKIdMFgTBzNzAvGZOUCa+JCFMJcqhHqjm1CHx10DuWRlbkE76oAZVrTzjJN7+pAUJhK19qNgCK44v+UszEZIIlnbee21zhy05KvaU6OulVxDDSjMGkuXBH3GhKMv4+WKNv/yp1q5yz3unKukbbjUSWstmEzYWHOBXUa3FkLI59QPLZpIkW3g7zomDuA6+sZrRY/cCjzwlw4BdeZTuhcVDs8LAuLhSU6NaMhhoxiEzH08sAunhhIT6+lY2XGYfmI4zl2x1JUVeHXN0qlPiPxLzBMX9vcr/njOVq16E1or/rq8NRPyJkx0pGQPkk0MLyhtVZWzLdMSXOdChRtHXFp5yvyk02hKMZoYYUQJrv0k8VIl5YHTmL8r4Jeeo6vy4sORyALc2gnAisf3PZ50VoInYF2yziddxpp2JzcF1xghfceKPkS8NV1dUCg9QPkRxD5BgNC7K8doSlDrqeY51e/70eqWLWTKNef3gYhWFWNWeVYJPNHJ9XOuDqxX/XMCjMU7mtE82NfRTbL/6No4IBI302sK7G7rkFaXYi8d+BFGl1FEe6sxHZrkC2vpUSkvjZoVLnqeSQ+dr21R+wGZybxsbQ7JcATWsDAk4T4qLkiuj4wbP6JOqgkPyRNwgSyKZP2zsx/0J2MlTok2WJ4/lpBTrp9LoGHk2X9tQBBfNMVYVXRX3pH+EqKHAwWcFASQ4Tjrug424ifaPrBDfdsbiQIzzZS4MV9HoZ/H7LjRs6Lf6oe8WKBP9DRDLBePSfhny7tr+vPfFWvim65w8EE/fG/xUThI9cXS6IjqhzN0q31rD3dT99wyL8LPi1vr5Lsi/ECX3BxlnPPeiCw2Ea1oBOir+53Zwd4Kk3uawPy6xb9ySxTpLy8dpluNpbsFL+fCppDg7JG2dC/KS6MULxLNrl4+AdSav+OuRDvGnZhVMK5OvWI36nwP7icJjY0hBYj/D2cbVmj5pfgsiK3qRvZkDrkP+13QL4Ndh2fELQDzHIq/2JymSIq7cIcp0DDMchmdgj6/N2XVhTNgCMxaUL2ZoHstsr6q7yRIy1uShfHPazdnH2lyMYMQu7KluR0TYM3H1M3+Ap5lnyOgMVzBEZNL4HB7PjpN98vlVH+wMTSWt5At5hP7DXK3+aTNrEE1B3Bx+0OBkwsUtdxjoX3RFHCaaM6HygMClUS1bSowR3UZU1AmwtGevW6da0XGqJ0N1iYStABWJ+pF6+CZbOg3S6ZVt3Xq4fG5+HvXvFrLVemROGAP+/yZBVb1aAKxgyjlF4B8kKPoP38Z6IcHBUKWsZX38fjyvzzPa6vxh4z0wErnFYEiwyaqpj1NSfYv5MoLToJL3TFKAPgKe1IdxlANpSmZhsrdUnJ/xpaF8ShPcMBgxkN8rV3REpaQV0IaZp7xwH25/YTyj07tqm3N5LsrOXRS1FZOw6kyYDwUhfLbxfpUGfmGf31Ft0uRWS6GwuN/4MvD5OolOzgyA6t4EH99vPMSTBWNss9ILymNV+/MycVfx6o1w0ZeTvf/8mDi84L+4C0pedH/vcnutPqODG9r6FbH8cTD80W9o9vyoi+YiyaAfR7EDFM0sR/d45qUwvbKr4rJ56Y9BG18uWuLArAUhVqhCBufa0KrdE4Lra68YrqJzGqd6DUN52J6SazLWr6ToienkEzzbR18f8lWLVBkqo989FTQidghWNwleT5bGZXk3mEYoes4EWSc70YD/HVAxq3L2/wkBEYBFvFEID1A8UKgKLPGgfgPgtRIuXHg1KOYEtW4gGMe9AHqQylJQPkZG6iq53ZnF1QHmsnhWtyRIFYLLCCeTRnH24mK681GwulCNlUl1TACkZj6vzvF4VntDeXTpMZEnViVCGLVHCp5zU7B5HV/KRkVRn0LSh0ToR5Lcqh+/Lf5g0DPwocrgpfErUlPb9PppHSz3KqCo4RprwakLzgV+UxY9qz1UzuIPLL93NbEf0oFykO9toHFQ8HaN4YVhUVyVBiKMZO72j3yB5hrbXhGRgI+vP5yrizytQpki8vQ8/uFe3KQia5P8Bvr7/kKcnxE7Mixq1mKTVTPG//xWOfF9bmy5iG6+fi2mbdpd1/ceQ+9RKYLGzhHIivjhJROYPO95mwopv1p3cWIRG1bgFOhAGlRTPJW5qeAr1yNhQKm0R/CQ5G6ynGjc/xdi7JSAWW07qqOIn38KruMLPIPKeYNm9v5UmlmazKOeB7IlzVRXC1hBXau67kv2/em24h41eHmmlBdUhlUgN/y48zP6GpphmZiTKxb5sAROJn3vOflpCYV7uNyrEjZ4u/4Sj52tjRGcHe/DzhFdjD5hdmLKir5OkFzk7nwUe8XY2EzOeKb4B51dxMz0p9AqbfHf8ZTdebTwrFUVCfFW30CiK6VfTfCcxuI4hhRDeesRxbn9Yzxim7MoEoaOsfZuYUypu17HOkgPNJ2Yyuc+/5EXJVBId91gzV6R+IET0Euqf1kqzlR1jpUxVN1q2H2+YuyKyjd498Iz+Oblh3xIZmmjjRUR4ZpxgqpZuB7kT2qy1XeyO/LU0tnhcKNuTC+tEgWwR/sq19ebUjAs8xfvY6g1from9KHLCltFQ5L+a/Z2xFRSSR7hmT31Qaf37mWgd21jivVXVktnSlf5DCO7vPVMDOrQ5Yq+z+SlR0X2uUekDEQ6kjIAyT0nHs4zFKVHfPzmT5RnPiRv0LoyFQySr2dpWsJnrZ+5zdR6aczmVCCjwmXgCCjshjc3nzsNpyZWq0VQXb0U/weJ9QC1ivViY7fT9J7q4mAD/Qx4c/UHlFZTmi+xHcwK8eoERrl7uS41wb6NSXeZIgqHONfFHdUF3qPhTiu5RywqHqeornX7JEYTiPuc97ZPFnMF8o/Mz5TkFqUqf/wpV9qvJ5St+niHVDj0qYwfBFzuVrSmT4r8S5yR+ase41krcryAofVomhjBh2xiEeNvo0MCuHSd9SglodqSp/CS0qU5NQZtzh7SoUPdYRjWBkmS+h/c55Wax0UhcgfTwgNxC/hDYaMe4aVeqq1NQXvYjfs83VhyvBeXHsBnSWAEUGDvBoNv736RQ8fWS4v+l8VNLjboQA0LVImD6oaFB4aJZGVozINRU5bksGieQ+YAx+RzkS3lXBwggVxmCnimYoN6gKJAE2oH7k2QHHA/FMStyJlSQTsD5rDP0k/N0Wa4MLsSFMxvwuMSFgPHDdv5Qn4HvWyQ/B82xaB0+YbY+czlN3Mt5epoZv4CBPvp5P+pIEznwS41hVulcoaSuuvE184kaiDssYsGEuQfivYqWgqMngkyIe3b+DvUfTxrh7pnQRkBKU1famJaaNDgY0bxSsXqNy6dfyOIqel6FeGLFBfvUzo1Tx4nXRzHDh/G6Sfm5NpV9EUdRC/wJB+kutYXE46d0ELB68aIbQxnnlps8rUOzwoTeLBXhNxIdkbhmG1HYCzsnXaYgod7fXc2w6DpL84u0HuRCjBCrXV3gpaa5SnTd0MkyjYlemC/F+GOn70qMiq8ACVvjD1PDtxlH9XF63xOHktpX5OYu+1LCoFWbS4WuZ0FZp1wdj73+uOGD5UhtG/OWjK7iMuDKkbFDIZbQbg3P1ICCnisPyFSKizbmZaF71m9VamCqYMXlbKChdNeQWUcxNK85lLvpla29KglizofCXDJZlAYHN5cos938NEdcKBflSq+FrWVkDnzdqmHkcUM+JoTpIqYFEJBtwGCvUQ8GEaNhYC+j1I1xt99QrFAKC3zdivIPgco/ftKwguzvF8v+V6MxzFY9CwIFboRyZDB01UClFX+L8O/Yo5dObsDaTkvsNnyaXBfAdDA57w/1TieNdJI+3WvvSkIsiPUsz3W8B5qRGK5js5rT3ZJq8TAfVBtqeVuCqCbRnbIcMrTWsbCtGj2+/zc/BVJGELk9Ji5Mkarcq0lg5aHya08Sw+8Y95XmfmMnjhko4l6u7GvUSM8r/DzGqfvl2Pm1XSApKPBHfHO2VT2XNUoOhcpsSVDJXMyO4oOsxvVr6yGUiI0A3z3fuoC9UnzHRfm9XsFZwCys3iGnljMRaN76gA9ox4/kAXeUAwwp9qG07ipE5xiHk+LqO3bRiVdER9IgL52L01Y2lQ2jAzgXoOZ752G5lXOHe/A3CpY7C56IaxAC6zsC4xmNTYhYJXssV4aInpHooaFieLKgK0VT3x1Q7q9nmIY4F8vpoo8f3F3daQJ7tAA7qdpQN1Ww3os906OD4iRFRlIk4aVoKiz70zEF9Vv6wBsGmbs0yY4kdj0OooNUpOVXtxlo7R7M/h9Gezv4n/W2BN7St2NXyOwpb7E07C6smFhlCQ2Hcgn4Y1zUgLHWeBKXL6IwLjqFKfTYskAprMLvOBwP4D0jxmif7y9DLTz0C1IfQ6NYspp1VeHc/eFXhUO0QpfVE8GC8fTlUXF1rrJc/00+C3/OTO/CnMbv7/zhkP1tR/rWtnYIWS9Nbp9d8z3XUcf1PYQyOPvD4kbwDGPoCygmzzVN8UeH+5nYduPOaMAusB2y4n8c+yEBtxbOaOPZK3odwpf/rEk2EFrfLEuiW4pKq1cT5I4xo3NSGX9nte96Lzw/FBn/WpT4qOfNZAHvqNFtSSvap5SDatnkZpfumD5yMNfgeiqxfVBnuCbt5TveQBQ30z3/EyGUD3+ncwYC6O/D+iEeK2e/iRBpMNFyBJiRidzjt2gVx7m3O+Aar+tyGi0nQbELBIsecwOqNAeQEARB4u4EpNPlwh7XsrPvNWqGHOl7mYA2CGwNm4OsdOjvZLYkvFRSxKC2C4b9EC7DD/GBH/D4bW1K6LwlrOP3VGm37P9pPKOiBRH6S9rk60eE1m18FZaPq0Cg3JChsgkWedL1GFgVMO2vd50WjZmtyj0geBDmyr6mvqxcZSDUYZcnCmQM5D5qqXm9rSqFBsBVKmJ7xs1EDco5BcuItwreBVYNIxCKlfrJSgdnK09rhr54qGn6JheI+M9c1/2bGXpFIZNDaEAY33iCDKWxRydkwHET1us08xprNlPa1R3/7Y1otEjAtF7t373i7olsSgGcX82HbZtAAD7ny14uMrxAVpdlku/97OBzp35TCew4rntJPREk3CSlLCEe6ovZ2pCGmmIu/3tM6jS/kF3oLD9N7hoZynFobXdvPHoah69vZfq5BE/cdx41/0i91/ufcmtXfjgm/y3s5zbfS9PETwHnDBzxG1AF3QnohhViSvZ9JtOpsRwzWESlVi3PCoWeCBvCdwsNXjxi1gF+yxlyMs2bN7N5EVDZ8j0+d5SShYUXcQpj5yMM1+C7QcoOaOrzY/PyxyxEoJ72Yvd8ZFZMsVaS3tdT44uTWH8jjUYIypAFd3r1vGV8MCa4ZTfLss2kGTbJtsZbKymdW7Tl+8wGzoim0SLdD5vlRnA07HwZtyBNmirtdx0Gw7RDDYkLH0JjovBecrY5+oAfmUWAaeYbIEteThJxPznn0kamsmk4YMYrssxLuuHGvFLPyJbYuoDyH1jU4I6Rbsu+FE8JOZ9+pfl2/noxJ6cVHTr2MFffpoxqDdKfCF7ofJauwjne2dtP2DnXiAlkmX/OWFRNdzm/DMCyNAx0TtvmiHGWz1zumkT4xSqh0YwOt5iH/bB6j4gWFjj4BxU9caD+aLevVcnKO8miP5VNSR9mXcSbD85y2dMUbJktnaXq4n/9byhAxJlroDEnMd+tg17BHd2YyO7OSJxQFcfrAWegjc9YHJIXiXJlDoJHDL82jf/FPNTqImlDzUDsbZZ5ZHzR2rzN4AN/PY533nb3d9vg+OY3TImlkKm56dvfgtS2t1qME57hS6KEclzz46M7qXUxz37DZJfGYKv8MWiib3V5AKrQAMbCYt0xO9EbXTgFMeE2jkp3UECdZXA4N7/wgo7rVPW0JekfVwrY9Q9Il/lQdgy0SfR8RwNSnNkKbe2JFTCUCi2CBxJDciPOpy4yL6jNIrnbY+t2qUwawz3gAXrFX+27GEABBlO/c5rkUIDD8NZTFsxwpbYAALG/RaNB932sQPpXWzR5eHFjH2GGKrFkMBxPvcpyO3qLdOxt+k2m9htNOH0FvULXo2t8KvYeK5Y5nHxPAUulyQl1t/qHRdrnJM/JGeTshC7zzIJSQ3ehEZAQnlT2mkx9vUvJhZ7pktSZ7S9xkMLGH25krxuIpNG1e17dVN20uz6U0EwGHjQY8HkIzTicXw+r8L00DJTChgbtucNPIaW0YShXLQ3RHSf4rcm4lDtFMAxKkhXGWp/p82kG6Rx/RJMFBDzTCNu0ImIQx8wHdHfgrUY8azqJGdtK2a6tJZkg8q3m6Bt7CbjqaIoFzz1zmU+cN1txE9/bfwYdbAt6u9MXXvUE+U1ER94YQ3mJMgdoJ8ItgbIcnnpKTZQ4ppjOQCU8QkD2j3GULv/jkDpHxVeUy89sZ5zi1WESaU8ByWFpaj8ik6Sw8bF0kPjvfVLh0/zFaFaZKpzMa/7WIC8gRS9GCRtufT8jOxZOWn8vQf21eEN5qYJjgF/zgx+SAYnUQYKcnCONAbLcH4Z8RbYcIOD3rwTEP96oFxUJ9bCO07trshi8abUW1XYCV+7eNNyFg45oUUTOLjQvNhQMBiH4dAjkawSkk8u3HlEZTrvgS+jJRf8oFmBilaS72KkozKwrA3P8YfMiiC/PuW34Y6o1uZaBayKaUbYy4pAsrYp6THuorevV0RAmP5ZkqxHs+MMkB9uH0oOnUwnG2czxUmzzSssfANKSmL9OZVtuBOgWo3QWJ+Dfo5EkLzoIip7T9Qb2wAYs+MNaZ7DtPGgQcCwK5gF6qsi+ok8nnotX9CQloa96d2dLMYYeMEEVvbtnEkxN618YW/3KMdRoSUQFsCHOJYGXAN0dFKi3NOHjCbr6XtmHWXbh5QInt8ks5xRUx0J/86yx/d+cUe3XzwX3tMDGmg4uS08MemJzMgIoYWuaN+xTQx3wKA1UCl/dE+l7gE3PBTO81wnUc0Fq9UTKBo5qw8kJqCGQ+q+a7IMB3vrrUfgYj94owKOfcls8OxObxX1Tj9a6Z4wnHpkSpTELVssJPLbZxSZxKSt1qSVjAceFuPh1eYFKjKGmYeCVDOIk70rri0xaBgEpz+I+LSD8EmSYjKJX+B3R6dPUTym5j2pC2cTiFI8iyvDTmAIOuWlKKADLtwrUKDLwJ27oYYXp9o8Ntz713AFqn0h/FGWibsCAnxBDOqks4jwBY3jxt9tKXOrINpCOCcY5FLNLobThOUqpFK0UwfibcecS30XqevSbjwxkm32zshdor38+QdwDEvwtwzCJQdpkLRv3kIBRFKwFvaha88ipK9bH12q9R67V7x4I8LmgW+3OKYNHj1MWiNWqealyQPOKwOdYjQpa7X6goi8L7o2ISIJ0bPRUwEca0xxHMde8oQGvI/pUQuHfbe0B7a7/rx5ooPzb9sj6YJkpb5MNkj1aRH8yGSnDCZRohKLNtVQHp2BoIL/IzE2g5A6AHQNKn1o2mGjStzHOfYjd1yCh+h6wE1rH0iD7d+4DiGHHiNQhv9+2rCYl0Y2026qnpYjaGz3NHYYEZAgFD1bSN0pAPIkDhsFsATLHRvjkE/WfxMSBd2NdvXKQt0vAVwsNxzAyP3Q8360YD3BLGnZ5r2HW0ecDcWXLK6esBz1BUph0WrShvQFBKkfX8C5rLk1bfCndPSwYl1ng9uscQRZGk3agbmsxvXvWJQRR2TnLmnBDmX1GYm4iM72HrtAy0bd1T/FRDoiKRybOELSCy0jjWoPPyjadi7oyL1690SL7PqE3Mr8Z74/5p1vSQ5Rp5Q1N1FduBCLy4rIkAQQV5/4ThujNiHKNKSCeqSygb9kxTd1FPVKFOIQs55Sgpqv/mjzcvz49kx+xtIyOjIgd6PmksHE3RubkcONeXZQlXO8zW6MRShJDOUzBBZTSerZpYEc8ERSaKgEGDzqQKN2Zy+kDQZDxieGJI3lSrgY9z8KMOO37AU39JzcKJAbI3DJ1UECxby8urtNyDN/7kS6SUVRo5q+721c3v7CKO2crGSXljG9xyWme3FV2SuC0YjDiB+NCv8qFczW8A6ugVVQXqTVRhbbiBktZi0jXZebDPsLM/uHBiKp3T8CX/QH2DledgevlI1wTjfHOVlB0BgMl6b9MXqBW8UjeCQN1qaxr8m2oW4KT3+ZILiSwk1LM5CGzC2QsBWGLkcP2n0wGKi6ksS1724ZNTAhpltOGzBrXq+A0wTxQSuZaj6lITPln3znPLacg0hEtfu1Smqbt9xVDvLY4KTHng+lsSwv1EiS5WBcIE7WoIj3/fknwMDzGOi7r8IQpnkYsLA5DQyEhH3rCIJFKx0GY7jZw1c9wIpmAiy7tQoArj+aewYTku7tuSR92J4Ylyj+H89G2BrHKoESGlctmcGFDh9rzBA9jPOzrv8Nn9v7CchDF18kY90joeL04UR3Z3EdwPQ9nutY2imKMi42kH1XKqK/IiHIYRDjt5nqbU2itSNmStgo5J+stoeghPgYVuapkA4LJXS7LIQ6V8IwBgDJ1r+33IBdtEJBT/JMH093ZNCUrbC+cu5rphAOMQll/45vdA0onAAgQz4/w9hlON4+L0kCo7KeeOiBJqgtzvojOvfpFI4ECdIHbbFzdW02vZBGrpD14mPiyRa6EaBMB6IClIwT83/2aPXJ0RQl0vtttxB22MOUFUGN5/US2ZyRHLtQDogy3EqlTT1qqmZQXzzDGe/eFxY2ASb1T5iiE6fg8/bgyXm5QV7OnOl/DMaYZZia/VbKUxprXLowCG4wWpGj0YLb8uzfIHrJU94+hq+dutJ3jEeE7pghqZ8nuXCpPUSjH0uRNThyuvhnLXPwLFUGfzQeWM6oDfXDdXkWjXqX5wLPFyMs6ngvJvDG8RTa2lJLfkyHwZvIHmkUQE40wllSoVYt0AxcXk1sKHNpXRG8WwjpZ6eJlb8QXiE3LF+vGcK7Igh6qMJi1JX36Y4H59gtfLcVCNWY95YeH7impw2Av9PQhpZzG5w5p6VKzWg82ZMmfX3ARjLxuaxHbkmCOC9mRiEwvKDxI2x/MMR/DdeWbxx8HzZRSjh700015b+c89vO4fEsr/cZxhOhUhpGwFdngRae3TP+ikjdAYOUoAbiGqa6HKKIgfykO3RLSXhvc2f/GJINAu3LnSBpr9sJHX2mvtEFHaVjuQkH9p1MmKHK3cQhk/HPn65A/tItJce5LZCiM+zLUpZDd6oHrucpwWUtCLe/kZeKeDVin0a5jIzRXtv1eQwBbOa7FV7HctvidmHQpadXk+APkx+6/L2TPYGKJc8tKQb8oSgeYZe93NT3qnvp2DWHmW6VutrL766HE9XhtbxlEi1YAgmeWI6cJUSq8dLMJVgHoFlDkQ8DVUsN5UjuEx7v4a/Eed0evxoSY5asbN11HpMhQYX3s/haGhA9hDi7Nk6it/8oGMEAMDg097vj3DEmBUculCelSiK+NCiFxmol6yWtCqRu4luOUMLOdw3iZwfDQXZYKGPtQAp2sVYxFRXJsWcuwEyazqRrWBci4PGM716Ygn5jc5baVJoLlIEL+Dahe6jAPcl1vT5LqVUWQC4yELHJea8+70mOD6YldPVxrjqVmnyb/JLQ0Cv0bHWzy/+Wq3BtxZTCqflNlj9TSZ4T7Jf9l4N4q0HpSI07KfrXwdJFrZojJRPuenNB89zYGtlTNIPf0UTAODWYYOnbKbLSWLpqewJN7D+WYSBcNl6yFSzyFp5nqY2WT1I2UR2H1z5u4fSL5iBh7m8R6WBp3dOD8MOHMXdXWL1Q4AProeAKAMpRjz4CZmgWe7Aoqi1+6dNTliUwywl7vKgDPHQeH7h+yejAKwSihZ4cLUybzWHuGhQSQrBk+t78ei30rDJqBbBV7tVP/OFgDHz059A8CTGVD0RSKYbSFm12Wpz8APr3PkLlXaIl+hAmHTwxGrStG2tcikpbqWR2d8XBaaEJY/pZNxvTrr0TQO+3lWQlr1bXQ/Crkv0pVSnMa9RUWzUD9Eav0D27mIfn87dT+sdF+K3yMlLxeBhU8G5h4LeKwWajN0fJC/JZzdcfUJWIamwEFWnpyz0SEXMDPmZ/xTuLjC2FzNnYQHAgH8Oz/998Rz3BeKsZ7xHL0ysasnA525QVXgs3BKCLMRYNELywqG2jis0pOtHKJxthICfkB2nK8CDFYr6BFpk1fmBYNl3PyBI9zaIwhl9JBE03KHrHzYvDwFrqfCjCdgplMzgJD09t783PPrrXCXmKPEAqTuZKdvm3LPcFFp5NnWq3jQlf25i6tXmWrxQyyEQDauA3onrBlcr0j+ZdpSZW6tZAHoUKnxaZPRXGEGabHZlW3Mt6RyVGhtQY/mzsWwctbVEcytgYtTx4PVMEfoDtDN46JNbWxko9ZTPzLNEoN9fPof52bzJjNWU55tG087VKWzxh915YxFYKtAajsf7JTKZeckqu0epwkRRuF3ptRLLdffh0LMtSjiIhfI8csGI5iTOUa8r0mXF3b9Y1M5mtM3IMXrL5sn8JEl2JkJ9MqSKgOQ17yc+cHTjaLz7sYJECqiHqSShh0aWk0l6kkLm8IbdFYJsyEHXXWoTI5VDD9hIZN++hlTDGoSHrzENduP9p+n94x1SsbkPe0DptB/mJ1LPapBR7BMD2f1LMHz0Owuc9YIYWg/B8Mv6oCrt3Sze/odN2kK8huk7CEq93s4xTVdLTmaZJxD8tngEVtJvrHLscj7MxWlGRKiLh8lt+Kh4oML4vp91LYl+al3PxBvOU9eVb2vTptWehc5DcUvoYZi6BJhO/JSLFS2BPyAOzaasgSEpZZ2YDdWKUdU01Gq+7MVOhgp8xLPKmHwOAEqPlff8OIo6kmNTR4uM5XDro0fT0arQdbFEIU0z8CQyrtDBw+j8Bms7YZTQody7jiEmXG6UBysKnABKrXG/g+ajc2X23pyU5KZlOEyXApjGRtkNpSf1fWFyNZBIYW5VIvfwkfj0c4QhQ69s+YikBmtOP7nSFgPR/0zv8HuusZSGUCaHZfcGHbKSx1eAwdNP8EXHzvqdvLK/fdjbAQs+2KDq3Wou6fQNOaJHO9yEd42B6JYbRnypyEbaWhQh5j1PCWLMaFhpnBY0hPEmJvfesPc/UHj0IkHK9I1j3U11eXiZOdDkYHH9hZBPrXM2czYxwKubVPZwo30i4+uW7z2lCWddZLfmI9FO95dJOnHu5Ou1rXT53+rpEOOcKULMEhSkua98qVXUMWJWnMzzlzE25OJb5jiiVckCGXeKu+JjQvC0l907UqKhnQWYo/O2/vy192JvVndfnpwf4/l0O0s505Mkt1IyUPAmqcVPxSXvrcOWgB7U8C0jdhH9KrHkVE3znY6CW6uiV1Jv/kD25qVTTo6V3WzbGL/YxOJ0FjpgDP/FPGk0gZN6he7/QVTa1bKl9I57io1f7onlpaBYBLOncdnJB0hNWfuyxySZxivQPmkUBXi1VZiM/MbHKdfRHokP6YZsM9KaeuzDccuWvFanCU9aEa+Gh5kkn08SC3aLRxlThcGc9krusligH1PeWmZ87KC6Ucc3nfC//u8QQd9GjdYPhni7aAt1ed6Vsn7fjwidZ5F3lWUF2EiwbLIOpgafgRbITNsaUgzOtfsWiq7IHdEmTp/VpOE4RAKMZmYDk5mJiXdCP9df93ILxyO7Htnq8ETGkQdE4AhdApqYxM9Q6istZPwJ83Y/QWMtq+KCeAv4wo75LNUY17AA5OTAgiaZFevGC24n4+5x813ckhHToKeD45HBGm4vGimdR0VionixOSklbsGxz/9eWCUqr70Q8YKy7ooq4HVXfZm0tKOvKSdkMi2ZAxSH8lJ819+Iyw8rwqRReLDOvFXzFPVQS/+Z5QvPsZhDR53Q540aXU8ctRhD16quCUJATXvDDkG8bTnkqyEI154j6KdnOyJN+U5yn20e6QKwhxRner4lzUrs6mr+pPbvwIDYJ0ZmzBxcJfQ429b6QofsWtvDdP5RNSWN+CIBfbAUgAG8JnkMiOHX3nLnfu0DL5p6pMXNM9DMB6BMy5pgeIMK/X0x674ID5ncX/P6TERm/HHA77avdSS0z8kRRpbZVIMbUguuPSXe664tx8PIFx989oFSeaDtMafL1EDTBmdo0XKSOrVubRiPbYzZVB3Rxr8O2dS7RBo/5AAcMl/gG6fEXg6+sOUK77xXl9S8wvIqj97T8/v31EvlQ5iVnG/2M8QYzcJ9slRby2DePbUA5YIZQkSDpz8MKDnGeLkGNxhxQhteds++sdMc0On9mjX6IDHgEBcW5+mPZXGsOs/twHc3o9vLBIpiunwVcPME7TMnYrJd+7ITsB5tph825hBHujGHc/YmXWjxAzru7jAkUSbvmdrF16P9tgOBGGjMUiwBHuiPd3AwuvHByDktBji3l1kVegGPXINB5vtb/T3S7CYBD430ZESH+hE8wCi7naue0jplK24ZkN7UfC1Zz6JFla7rhcgX3WTAykNBg9xbsgUGBg9TqWxGVCWBgNs5k7MxfSGKo9vOVgXXnLlWCVtn1fYPmP6mEtnDATRQ5ZDW9qOlvL8OKh7XOoFNhMkh/UMS4uucaFdiw0Eb0mHroyfZN02AuMHuw2sD3cKcr9Ds+t901M+61nfnBYE1AO/KAnIUigEsswhuXJnMEvdyMMc8ymNZvlvtmTLL+Xz2Vrj5JiFcO8KR0A3xkbDIUPAbv7ydpJ0M0Bvn134QiheVyJXWpKcgUMHiN32HbgH6hnNUINprDIxxAIXFlNdmxpE1pXPRkqJ3CTxw3Mi5IWxyVC2KOcxRAlAkoNa+tW7PUvPf42iQZ3lV+zzXMtmHhCMuT+ktRSnsjDBQyGOfGkHxI7bDS+J5w5Cxfk9VRtVlE9JpIOl38mEZZRuGUaujT6h/Jq1tFvkgKYZkfQE1rG3kl7qlA1WydJ8A5SscwN+bnyh9iSm94xv8BQYmnWCL7uV3oH0h9RMXtJH6+Bhuko4ij7e7TBkH/rQGugFgcHFCRF0gwRhY1LOPYarP9xWtaS8ngfILS8MCijj936SBkUAILtp1zB1jDOro/Fzu0GV/AQ6miramlcdgeD9Ik07ZMtBQf8g25XU71ykkOUwbWrkH1iN6599xXwMhXtpb64nf8k32cySuYFlJyKX0gYbgmPwylxifq2aKTLhdEMxSR0SHWub/aCLSbLO3HGuG6d5gXUZwJlE+CFUa0lAJ9EjmDgzQRLnYMLlcBDN5rOm0yQb2VZt+Nqwh+g/hh/tZOQahnXO5MOK3k1uAUqIdaEMC9w1htfHTNIip+uCoz19H+VMOuBbbYLKgh+0d5oSkLWRMQfY8GVeMuh4c7/t54shZTbtHeljcMOC5f23kswn8UmZpagUfCuvtsuzhKLLAXnSEPPYtx9Zb4XWo0h3j61TkSaCZAmZFI1h2OwNFpCrdVL5ouss3jzoV7acNym3JOpw8zzJKkfNBDgsjLUh+CbVtdYMO0T13NxP4SfbTmbph5PbPDObFXASCpwPnNa4fCLfFzi/ZXXufbLiHAF/IpYa7QOUPzru8iRoSqS9vxbHOibP6435lx+sNOCkPbJaHKufdPGWdW+1Yq+vzIUXkR/JtJbNqvtfSRcZCQTQ/yCyNU6kWOa+SyMXmS1mZTMAP8KqBpvsp3RaQQL7icf9vP3mVvZ0Y4Shjaj+cImvPfW9fQsC6VwhS3iIM/sJDjxOQd9zseUe+rwvhNLPb6MRq1OXMLj/vgRgbWohb1SyRtkoJtysbQ4RPuxBB+6hIJjhYavos2YEuC5dVTLFfS5K97Ll8Qlh8VWXGWsV7rWaA+Yo880BsghqTHBRPkbNUmQu6EOzvDnq4T2CAmF2B9ywV77GvJQOVkGVbUhVqg5+WQJV7ZP5BLrxgrky4mMnLaBVZov+C06ivfAzhOt2eTFAjQycKGSekEUn44WUTip5GI+pXuCiQH2xFhdJ/2lInD4kSsHDnYxZ1VrbrzExfAr0iJ6VAy8txX9POXPNvq2WuMkPQvnB48N7VuzdiPp85QFEVHqrwvIiW8dRT4purcKim4bHw83Xalwrufz2oFpEaHxDB5SLiuXjh7E3t/qUTg6mzCQ2gat7k45ajrL54MwTMph2S1kBiMTYTAzCgEsOvXwaYRD3m+yKSxOYEI9VHVyR5JGKcGnXvD4M6TVGyM/OGSwKQU+MSIgMTdvTe8KcWofcVj8/o0FhUdiS9KOO3hGeVL+acv50HMeL7t/MwCvrZe8O//o+wvhZImYnyBwS72AHp+cpBUzZWt5T1GyDc65Gq75mmZacMMW3odcv/Bzc+bhfmu/vyxGLvvfYZl/jI0eydSLztUf97dvzrd2oq182BfBoDeBW0ADul32egRPQ9g0SidjVZicBGeAy3zZCk7btkGYFwx00I6nn0/mqjRmGckv+1r45celHdEPGgAU29EZQq9fwX0IGA3+nIItT7zfBYnxzpFrdwhh4E7ieX5BdTFZuxVhVvm7moJSeT/0n5ooub1d8T1lowX90jg+ffg8Oagd7ShmcnpBbmr06Kp2mlhWo+sZK+SEnte6EmOygSt0bmL0xA9c+ezPheiBbI3kFO/6CSucCTAW8B/vvP+ySmrWmsaEqyoKGdVX0BI4lpukKgQ2mGTiazNEOtJvGDDpRX2f8dZJt8vPERDxX/dEkwzGoYzDi5EM/jONU71rBnwlsePNsrEIZoT1u4Jn5VRqEhZRJoiM4XY9BONtAucTyNQwFnUcOBxUvku09HtTFaNlq5zBgOMpMaJS5gHZR0sf/pm5rBwr06r/5d85jxnWWPLeu42BmUdAUz1/iW2XeYtsFStMINm+8otjR7r1J6QjxhGGUKLhMOCdn7Qp4X0lvx8Nfat4UNHpMddAYJCeuCakgbitxZ7wQ16pBZwEXPPfu+macqCEpvBkUkaGPCpTILMcsOkOeoLE8PEXO3m0Zisn/15A2Gr31SnQZEx2aeCl8TaFGgtoOq1MQbKtNZBru+Yj+ymM6mF90cIS3cp7G0FRwI1jpuj+TwTjdaANa2K1yk9a5SNSdzAoj3ws70PwrGkDMybsuK7J1XXhuucI4EXxrNF1YPgvoQ19HDcemcmguPur35GpvkH/P6otypUIEhfNQrG3jlo87JjU5Y4D4er1q/PlxufyxLOazU8Y/cCwKMoqgFVJhoEtKeoZdnKE03jCj31Mk0Tm+9Ok6bDbCb4OSCsQ9snix/Xk5pGoO/dD2jprhT72FLoBDDyjywx9uGAMJd2xtTONzfM4NeXlbrBwYiZknZy7sTo2LO19eTqxCtSPqrMkg1MBLC8ngI7ubxBdqxOb1xNEvKVDyTEyUF0gD+4QNqyu1bRu9ZqQXguOkbhJhCCDxm3RUp2t4TRu1VAPiGZmYzyCof5yZl/ZTZABrHY96GKmypTQ+pAZVqZy0en+8kYg1hLVhEUcebxB6XsUZilnZ0CHpIKW5GziYwiTOHXlPD6h4hPCv/Osg5DZozjBEm4MqPsztf2GqabDv5ZI1liWQK/NEgnZHl+onpJyB5RhaioaVD+NM/S7c2+Md57VbB3CI8B/tyWgyOr6LUen62rjDjyrXXHzBQBLRNDjQn2XGWrzIogDPIr9OxAyJnQ1ZV0LnIOE7K2gxMTUIIQ5UEjahG5H0ADcp146ij7RbC0RroBsRWkKdfvGYFvso8J016U5oHxIpeX/ohKWhIQElZLkSmlbLi3BU497z3zaXL18d2X3M8TTOMRYraF8xGWR+xRw+fC1zTvLeoteDzcCw1zQVI6hBddPH+Wecrgg51UquKRf4wYalDQz5w4bjIoSP39MZSfoSAeqcXlDDPB5LBn1bzfhedUxSg3Nyzn9E7WkKoOTNfFT14YrTJ6lcEd0zdtKMTTOy02xzL3yjjShw8s3To1WEv1mm5sKDovz96SIu7HU26HEC4o+6tkGMv062S9lranuVxC/OVd/9oi5WPfpRzKwdk3dLdZcTnKtkL7KBFATH1vhFRnyAZjlXclsAIV7M/tHgr9/DhJZ5e5I4dDw2xKpn9TkltBonrbncbfsDg5wGHj4hsxlzFueZmiIAnzzIiL2WBYXSUTwwZgZqzrWErkxPmfdTV8hRtbR/DrealYxpUKKLY681TAY8xfPSFPf7e6Ceiiud/TuG4ao8giv8Cp4VxHKZ8hZOPNSwvw8zX1pbiBhIfQg14cEPj9nP1r31cGsjV2/Ae9mpm3UHgXDD2pvqGwVST/GdKMinQV44sPIkG6zjRX+M6utoJ/eo0iqBlZlpRC3hUQSpLDU301O1ziEaT0tB9bQQVbD9cJTCcF5vo/nt2L7tRh+I541CpilC2IfyPsofr5WMSbkHXcFR6TDrphWJ1GQADVWLiQJryzYIXpM6LXGkAnd2rtwazRkD7UurN2K04qMG7g7IZ2cBCV1jGftNhJO6B+9bsDsJQHUiBDflEvujbEA/Qw3/3SGAPK7KYoQv/ytJcOvNA1rjfxqfsTrkT5CcOTvL31v1NkkQ8XVJnGV5T2cXfmfbggVtTP8+wc8+J8aYVYs4oROaXr6eIHUxf5QNbTJ7OEoV1uOzbGtw1qO5ykvU7/CA9uoQl3lLpT+6tCtAQL859jKwQdIV0dpVmcalz9ezSS/xqey7ZIKFca4xhBOhwmt9tyj2w7WpiSTZ8BSBKKYCYpV5QEC6t07GZImrVk0tgq3R/YQCprsKAkw7LnwbN5Xud7B4OuvsKtrSjCGxbh7gMJemVdF0WUuVS/md0s/x4UdKKJKCRKqLp3m0sCvsGRRIZQM1BhMVCv46FZtu1fFKE3c0ovESIS589wfwOURNw9/xCMJ3R+v/DZ6U1nAD+M7bajXOkfvBZ6aIuSX5sZbFmWBZm08S/jLKxUJUUiXE7aOAJvW0ktzjD7XEpQfN78e23l+vS1FVTNyoB+Z4toGgv1PRlKHILkhOMEzEhJzG9vRTwsFSaVbg/qiXiCfe6uFqZpj+VPyjQESwG9zAXQdQXzowUBTdnT/S2CQDbqqrxVxtqHrB2GGz/Hp5pX0iGoeS/wBpmR2fBdxAK19CDlCOqm1LiQKjHrttEIQZsA+F6mCfABOy2+x+oF0v9IJ5vZENcLBbbQw/U/rGwaqqN+FdRiXjHKgB0oxghVuD0QishCmAN/TlEM9BtVPAcGw++GnldSU6bPDKot9/vuo7vtCf+zNj7IABF8MAVUDZl1CAnJq+XIbbCDFroMQLzJR8n+tlpyjpHq5F6MnK0yRX07Fh2mlGolN9WN5oKp+JJLVcV7FkfQ2EZr1VPyPkLmnbhRuFBhBT1NIbctMkffHao1K3MSD/Idt4itv81YCxJcflePvLbeQ9dxjv8t9NJ2/teIQa7HOmjQAhKJ3y4X9+Fg/TDxpNfS5waqfHuthrIbX3kDh4V1bft++t0ojUu8+2zsF10CN9LGbhD5kMXCBufJ4VgamqemIkTUI6KVCpS+pVI5e5Vwu7sv/eqAPxCAq27We+OdwdtJM3bg4IZT0TtihI5UMhre5fAhiQMpqQQYWNAgDLSTiLRHb2aJ09aRiT+L/AUYK6EhIb0nVESWAYizTje7zXrsuG0rOcyEKUv3jojWb8HboP8bnIm0gsDCnzPAyKc0RDW3nlYANfsfkXQj3yQ4fJoiNi52VmVsWQjWsdUC+H9zAf7YqA5RY1zbcE01dUULfwjapVJNiU2M5iaGBNzir8UvaG9CMtLyEiY4iAyYzvYsZXoYg1/CZEozDr2NwHI5jU48m5yAqmXLNFMHSMKKJ/XpDZIDyjE3FWhYAJI4zWdrEMh/d2kPYEar+YQh49DS8YQz9eSrpFdBHT3CM5VpvclmA70oaVC4tL8zB9L2ax4BPv7lKgq351L9L+mKyn/yrtZgpis2NeiFUZyCdDUryJ0Sou12hsfaeImas7tr0wuGZGyHsr8PDK76ClUf8Ej4YRt9mSyNBZRKU/tIh7+Rkf+aXlVEzE/v0FKO4EmAtSU1/7wcul9M2kwjjKNMvDY1bN58vpJYef2fvJ6EorXOOHqOT1mVYVJd7z7YWYk88V2p6ttE/Aydb//e87iMFk7GCwTpkT6AnOxezBvDSmifBOLXl7/u7MzAcZxx1q0HqhXXTaY2mBS5Px7P8Ogx24KasDfbUHD3c+b9DJ+dHy3+XdfvX238iQCoygwOSfbnjWP49heeTKNcHKlimQMOUkMhFYijRbtsv5uQe16STuEPZ8kLEDdCxzRNGs0ZTRDS7YOwvSTcBL5rUpL/nsuYkk7ir4ewRaEn+ieMCQhReLJmw/wT3BAt/ahVEYNvZmHGoEr+4sk8WbJuw3WumBB8GPxOlzVW3f4yN1moO97WuCIewbpv7NYI/0fJeMe51RXic5rKQKzgbWzSIleimx40u55t0qQgW1lkzh58Zer+92RxRyls9FaoIioJ6HKso0RNqs7V9VBVIf0+xZPqAIZmOtLYP0TJpnpsrGPSM1zV6ZGoVsYcqKecx5Ty/AyLlc5Tzi6HH3iq2HCYfX34uqeFzAE27DErkpjT9ak8bakXwC9+4b6W+1jLnxEVxEuBfCUdmTeEL+orpql4B+6nWxJZAakVOfAyf0ZdDUyXn6oQJK9bN0zigKB0FB+60frQvXWMY2jxX4ladz0K7MpL4de/KfJ7YblgWgBkurDTEoLyJPHGZL6qzRusZzZ6hfWJs3Bmri8343kgD2ZiotJhKjubn+M3SHRl93DFHLUT5QAMnyQhFdwZjO5Agojbep/5TRpjqn4d0rBERITIuURkaayc3cjwODTXT6ZM73HmAUqghPFnheWo9gF/DE/NilkhR+w2ZXBp7wQFoF5JXnQF/gBVBqFncIukGL7CeQXsrf5Q0NaWC1kJ12OgQMDcasmodvB+ATSL0RoXOwYa2gl/sWZH8xp2Qhb0rCyGDSyJ4H/D2CIkO3eyuhoyOSGp2yFpHNnQV1oJZyV6xOc2yT20a3QGT9FLBdzZPA1NW+2xSkG57O1SIFqrfEWfDp79uRjm1dRacxN41X+qPUL12GAEOiFgTDpx7o+C4JDGxRr9Badqqa7xWo7GEGMvU8+wttaznwUqEKvfYwT0wcoEZzclFeY+W306V7nyKQHE9fyZDUA5R7lfi1BqkLaVZJaqEDZvR425ZMqqvAWWjkHOD27eFZ+NP7cvj2rb/lXc6yzp9de7szPhC1IRQdq+1mqG8YasY0niKfsdQOjK3OrYeAG0BJX0w+ecxV4Ezdpus4THRSCiWa93BkVmXpM4bmO3t0lMv8Ka8MrXp5cWl4zvq1KSQ2xs6vlGxBPbY1xZbHCcWKFClYaB3EyqvyJrQOp6BwGdbf2jPijBT0nuQIhm9j+AKfgPEzAMIm6z+TZMrMSQELEmX5+6uaJHxKoY7N+VcyN7t7f7bjDI68dNK7rQ+jPUVRGeinijb2iob4hyg/r3nK6A4jRYZ7FiWJhClbQxjjpqAe2aOZfitpvRESjxR9Mc0KXIHXaaX+O75XMVI8rnkSBYbXORAsQuljVSv9pZoE2PCpD8cYS41YgdsfhQuHUKMWSPEPcaKeNsAl1HSKV6hVCRcV5znJqN8jPYN/X1Q4kVWc/P8eVLLRDkLlcXcHhO7VCx6QeTyYLQkre62Vo83GuS7at328l5uaI1CUa5vVjnytoEMYWGVdallRWBP52xBhWYD9wN2DfXV2KNVx3WB+Y6d4at9hXpTyQehctBDIrwDUxCTcUCU6uobyJy8tlxvpn0hHipWnMKP3H/8ZCQgIzIym2eU3c+GeYkb6f1BwUhla99BGAJqpODWObD5mT3YzByIxLwk4utgWSOGxfkYJ02Mv6HUXcAsXyX5xzZuGbhPQ3sN24Q/IzI/GYMt7mr2GYpZcg9wdEl4wcg9CZ9YnnL3xs4hKmQBCQQ/Q1zylGpMZ64lDgu6Pn8IwEOrdenfya6HSE4JTdOxQsIOZApKRxQ/wMnaJwe0pV4eBhpzlmCn3K9uDs2ej+ob0xZc98zPYQs8KgJNai4yf1MTvXPGIjvTbv9qQJvXUjdtY7gH77F1WAfQdDiYdVWFVtRRZMqJT/W2fJ5h+/wWyzbI/Zy8z0aSsVtep8GdXubF99btvxVmSh4B7LXQZSoogSjYZvI9smp04BGn3FeiDHkYshnC0gsiPZ5sm5+qfu2DGPCfoE7slmSiivYag/Vd6PyTbrsy+BxSQ2MG8v6r0Nni4/XxtspmLAUlO29TEeazAWodeGCx3bWsSjViOJoghuXX2fR/uM31gVZn5TVDAQOr4AFVTZ3evyBY4ZNc5Gjkd3QKu7HKg60RY2yddcaKhnK37FloZox9qqvcZA5vEkqyqE53SHHprQMwxba9UrC9x2v/FRv1TMY6XpTDH2euRHLcmHzrHLGzh3/5+e3r3A1y1vRhOo4Hjyd6b/drexZreRJADjrAx3gk5VjBohRzFSzKIVXPWGpHXI6yI0E05duvtzE+pY/0pqLvDBIdN+E0qrDvRukudd3xOjacYoIWAwvuP25DxMdhq9YLd9ErzSgAgeaSFFmvalIhMwKhv+5v+bc4kl98xQRcGAB8rszlEKq9AqB5a19/4ASD7Cc251q7KmYv7XGj4x1hdtBbvN2wJ0jIH0D202M0f2H7J5BX20NN5TFuT4oiiz4G8vRv8EJpea+SlqVrv9XfoiUe7VlIA2UlBWqWpYLDfBZoXJ4LJ2QvA4ru4pMOG9bUrjZA1S67Ck2G48YI8x8gsYa+9vzetvhCSmjL7VXP01XotRw3+sV5rhk7Qcx00dOwgVpyS57bsz641g2wXrom7KsTKT3QQLXDwT7IUs+lB8Thyi4R2Nu39TzqSHSmgA+lcoi+PG7YeG5uTFHsDGszHsn4mhYQBeb9bbNG8JG5gzb5GzhGJXFetZWXoxmdAaPpAd6aUxLQh6jOJNGqNdkeD3c11394VbZkyV4FRUkR64PlHCMmwrWDVbbvcRi+agubzQkkpp6pRT2ZsTqv/lWobQeHZjRsapJuuJl+wLNClHwlP8RUgMhoeyZsG1wLXZpBozwlMJWLWDcC7Ltk1ZyQmgIA9yl9HUJrjKpBHqRNj2McvLQ6cx07m1REGmT21Z+F86tqu+7I9sjyCKMIZmfFSKosMaU5VI9GcOwHeD9oXq4jbbXa5jcCXkKbPyvBrCya6x0CthfswVaSabDxANU8XQJw5rFb3ueHkA8ObNPeo/L9KBn97gLZvPRAdASINEubUdGZqL4rYJ/cy0ZDOF9wbObSFcfM1UfBTgQHin8bp0tnnlCs/HHokzrPEVSJBlprC3YYOlQoTJb4qRoc4euCO5e2SOYz8YRQS0GNeR1h+DJJFM3t9woRuvK/NerFqKuXjvuR1dOpTG+W75UgbbQ2cS3FUPDIpyebR92o1IZbLjJ0l/WsrdWZTqe34kg719ckJ7okDQ1nXmk7zP5vS3wiA+ZL5qlaIXX0x17+G15LBk3d2M93GHzayPh0i/ouqZ1VGp0OrnpdElM/tNSEExCRPdmQ/RQimF+DPOFbnY4wbZ8XjEvtzf8wPDsoiKguziiU82nZ3zXa1ucbO2PJRcYl8ml7SSHofrJs9JIqstQaEMQ9mO+7D0rsMkkhYZQoKPb2hVM6HFAtVTqkceLVSiz3keARKkTKToHbx6wtv8dnKJDOW1rh4peAhEEUOqOhbWlgaXSO72S1nZY94QcmW8C0U6Xxt6Z2oTUurzOq6a9+y37G4RBQV4TPKyUYg/yYDmhnqTRnytkRRibGIeVXL/8TTAVRuq8kUeJf60oT1BR3NfCmXjxzY3syQZZJQZfi3U4nzisRnHhmvfG7buCyj/huYDeNtN/HiejekWJ0zGCq7DumG/dRscICkTYU9R+xzE1pyx+QTuiaRoSBCSv+pEKdRI9eEeFoX8a1kYNoxNLDZnZ5uUL94rptbbMSxstutJ+NyWyVGFLZB71YsbE+XkqGor5g3HtqH/fDi6R5TKutIo1rYSzH3Xh2nAuynT9Jl3SqrmZZd1xo7ykBxvbKxaDVApjgvUOgR0TyGmipUlB3MSN0l7YVaRxw46nTnJo/nm7qkf1sR+UI7kl3DZFriQe3jRCfjiPkUQAtxwUtsJ8WOgf6XtoQzNPN5GVXSDqWOqQCZ1ezJe5JVXP6mwFzUt8bE+GDEfSA9fM0kQakaT7gTdgFEch8iNVmQkZsvKtJsOv6YUGBFXsq5PSi11VzPPDlotS17DvHffQRXjzTjEnFFtVjevX4pmIlXjlsoeyvsW7399Oo+rBsDVu81eEtTjwfy6D8doJH79qVLGUNM3IG45ejevgaX95IBFfRqwWiaPNpTE2+OHZu13XsGF+Pi56tEc/mmX9krXrhn6MqwZAENMgr96iERuds5ckZCU++liAR1q4eJxES5lSUdtP16MQBhpqrKwSowU2hBNid97yMUJdtyrlckcCq5jy5OKjv1BEkqDpFMyZsTkQOMmBwmtR5Ga4eQ/3G5cLykJU5OHdTe1iUAaJRu9HdT3EZ5Qz3UftIh9qTdR6F7F/hCqmn9LMHnIRGanvqfGdIJVkO6pRobx9nf2F48wH3IjVLWkJiMIutDsw9OZfjq5nfOKnrOaZ2pPhh0Pf9O8w7HqbEf+7JdBB0VNYyAQJFm3skPr9brxAxGWAqjndAmxzbxMTWNzfR5KXqzD3ZiCEoVM0RpuhtNC0c3AET5GtJ/+Ey99Qy8E6mqy/qtmiEq5jy3najdKorEzBeIbByxu+ZPu/n+FDC5IoqXCNOyrc0QKno+Vq/AcN2CUv+jvqOs3HZahRni54Bga77aYtKIboHzn1Y/mqsQfpNnnCEA3chfptyG4HTY044hL78/NJuck3z39pkGr0hyG2zJuxwwkVza2gQMKFAi1fmwIVgDFBCMFz1DYZVV0nWNV5hPiFe7W487pJ9YQkGWOlJ/0jgIMjduopxqXbrqwKKT9lBz3Cm2muT2lI32y4+gGyNv/BfykS7/6KHo2p/Hitj9aYWtopQKdpxkRVSu4bbxJdyBEGh/Q81asKuQzjky2jro77EwQOq1PV/A+CWJY6+43ur/HHoyC5Sg+2CNYgEaOCYw4UUUFyRiJKV//QY/GQHCceFXvnh4pGu7eqLSgPrhc+F6uTEQGHhFW7cAT+H9y3LfXNHCWDEy94Lxzo9DBiL7Iv8zvxBfw4balMAGC6E9CK0bbRZGRdVP874d7qbpX7233/KHAVZhZaVLtM08EFBWo7tlGr6Q0nZSCVO00ZsryUhDs9/y452TfwV4x34wU/WDRjzgqogZuM7ydc6+clFV+kXoDEJ/gANtOWLuX49V/E7C+/KW3BMlBRRs+3ppMmD+gxCONHWUuH12+GKbw/gS6hMTm7oCzNT9HCn9qm0X9jaO0nfe17KBlhLv2gb+8FPLYNH8feIB2ifgwoHDOu64n2NHuUJ13GZ6t0zq6vK0aRw3v90+vytdx40ZezXZMsBg7FrZJfAOW+VkLHmwl4xtn51zHy6tKj8v1eXguJyySq0mBMpcYI9yE8TAW7M5Q+LJucur/z+3BvUmJp+RSk7MtKRRwpxzSqPy34rtua7RCNAdUSf+eib5aoIxsXtd8fAR7MQvTcMVt2nvSH3gUpNTl63D4tsnh7KRV7QfvxoHoBGn+Yq1aeDmO2RZRdvzXVt0Bwkp9MNEc5Q4U56VdDdVPGx3DxG2/EzjmKfqdyLFxvnVyykOMOMB/YSyFJuwSySKeI1r6fs+k9zdta3OvsLBmgs7e2WxQUES0VkYf9lSb2Ur4jz0jIUcNgexHZaMjJE8Cg0aO1juRBQhmi5Ag+AR0ZBxg/vJc7p0k+IPwPmDRarYtN6AQTz2/7wQygG4nCVf+hcYsHU4zXcP3TKi9zxirzBTr0mH4dkSSPTbJfbrlBZBaIFfSWwcasCCJswuf4jbe87RUSB2veqL8RSh48bETd4evnI6haDouCdwlnLah19sAWOGX352mqtHIgzV31np9vYKaJywXzB1FNUQ9sqobtlK4fwvIEyTGd12dJJswytpyt3t5diz7hfAkn8SCbx4uRulRVEPeGz25L5YFmU2Ns8p/v5oR7hxfjr3qhvjapg50uMlILCefEmSFVew82T7rw5I5FqYUjIEOwgmkAtBKsFPBYHREN4oZOYs+PWwcnaFQMlxQZztku6rsiAz2TEPyUnc+7qSTBiKoGLR7LY/1Bu5Io4+W+ig8W3YsJUBnqJnKIy9E7sTJYMSg76wB4LDms5rE4MtlXcyDc6/aewRAnfkEelF1kteeDfpw3bxe8k1iKrCMzegGKi8zotSjKF6pqGCrrTzXtZUmu+XddYqdt1gHuo3xim+FF4x1ZmMnc+b/bkPT1f5ee6pEQ+q7stQMbw8UIChOqXpcSUFWT9i75shY4UWdfwO8ZvaOKPfOIqDuPw4hULXsGr5Z7rQtrD3123WcL8uEPYx+yx/9Bir2RyWDCxIW3ilhRK7eqz05iCrJHFxDFvW44CG0y+E8PAWtv3E14PaudqYn6Pmr6iOsSvafk+tvW0UBhAhQ9X2dIR7ZAwcLkRk4Bq8nN45uW7InXLSnU2K53VBWOrorCtPrYdsL+LJ+B1V3zjfqiQnxWmPH0/gKnQBu7mvFigtjcGjMK4s/P0J0V3oMChONgzZyTKBGE4EuWDykarboZB6nbc5u1hPkWQG8TEFhfPV/MPLXyQBotIuUI1Hndemd4qTtb+rur9gc80Dxf0jWpS0vS6RuXa+7/dO1xezx0N3mru7Fb5D4i5MliBEteIRj4MUW6FdxoySZoHj1P6OQLe2b/jxQWBVFNePi/iGpis8674+9QhrHpgFOHnnA7t6/CWB7oEYVaZpn7C6ErOYx1hJV+Uv6jwhTNsN/9jrIj3jG77HXraAOaxyg4lEfEbexNsLypdNtIZ5Vy+VuKEfxBEy9juFtCsFpqzhlaZ0/ogNVf4Z7C8N9smpLq9PPME7PlwBl9HBhMJZq/z7a+H9yvY0Ul77x57bWf4Q6nDJgZDOEcuLuYnvL+8MnV+SMgmCI4hrFmj9YAhn75HO7Qrt958AxJs0wWBsMk/lI7MfEyE7nGVapptnUhSvPpFZlC+dETAdrPMXAsvrqh7xmuP6fK6nRkGChEpO+1v2gfz6pL71SYdW1ogZL6q5PLSp5tF1IbO9NocaLtkRhjs8PByWlUZl4Y7OAio8f2oL6PpiDkoeXY3LL6h6CYkRasXF9IFkR11CTTC1cYHg2hZfv+WwG+vzGfULNh94BhezI1wugRp5PnH/PzUQLqtbehUjXyUWDvYR33p+nfTR9nEX1bqa2dOObUp1b0kLDHlTX8AsIyWkvq6GuS1WKaBlhBXkRtH7dmuYtRRxyjBGChIxAw6JRwMiBsfJPr3mF1OzlUYJ4xnSfaiACnWi7ph2n3M/9PFZ5DqlJ++zrYHKPSmlLLy/7o1MRPxz5F5Ferw94SK0BIsAuRKofGIf0/8QxWJnj/FMxYFPKcwXEsJHac53uO9D4VTRM8gjToSJSmy21FS+NiXm4O4aHOVlyhRZEAQ2PaSs/rIAUl0CLn/16vVKVVmCO+bDmU3bOU69ZDd+I13PaD+uG4ufnBysyliKsa1DtrpTmh9NTdeSDrNKDtqKsI6sdMqlX1Hv4vb9L9h83CGaNYCS303spTOFsCVuiQHPQv2/SuA+R0PA8E5/cZ5WNxFWUkH/jtru+ouWvsnLj6YihmDqOLRAwPt1iNX2p/hrxGKe379p3zzPDwry6+evJM5NU538W8q0efgybSB0wPBgVNtQ5PMZiRss78PkA4qx0jWg3jGmMXcDZ2CG7jWi5Gbrsyb+3x86NRs4H+iX4OnusC6tBLQ3EylkCyg22KhjyTRX0n7APS5kn2uJoqQbnkrT0NbANboTgEZPXI0Y3ueDPRkOwGNdIhicYCee/9JwRIoPbGxQTFDQD0CuTkfoul8fU4AutUbREJElmPfMFKEEtv1IVERDSUAALuFuIAUL73EBEj5r2AIvHFLrt+lG5mIci7/CMqZJxSb0nGsaDVEfMZ2Z6DLqkNti1lpul7nkjkBbBhIaC1Zbe68EajGA7mOB+PhJRnHHhsk/MH+bouyQKGCi5imSV2sv8+dmOpH1E0G79J3vJrZWEVmUQ6vbdmLmboR2UlCcfQzZ/Wkrsj+CxMykaexam1LotYN0G57cSeUoDKESV0sehbCLPbLar0TmFYsHhc/c9NbK5QsnUsl+Xvyb8dAh5Oh1sXwYcvNjjLp939+2ymcug6KAsTpp4Lu0Hy1tysTO32/Eq3/xVB39hmZFelHzZ0XnOx1b0zlM+dsQmKf8qN8l9KfTlNtu8n+13HH/fzWOxhpee3KkJcnzg19z4lk87fIcG/BLaW/g7x74+r5bWu69MJYaFSmj0UzBhV18G105pB5MlZYPDj9cfOVrA672FsG6cB9ZrCAYPfJMKWXZNTh+PYrXgxvy2n1UGx1bbQzXpd4Mi88QVVCVDL5vYuMSNWox3xmVIYcSLrVWcfahOFS5HWtLnArXBW4b9PWBSG0OdG1qHc6zC0reB4X9JnopDQozxC4Ekn8H5vw4G6w/To63rs9AAOnnR558Nz6l1nBUzk1N6T2R+9kSfFEYJno17idEUliGoMDNBSTYR68E+dP7Nzv/Uhn1S8vStGMeWUhuzrWXhqwX7xAoe3ZR3aJwaE5pTf6P5S3V2Uv1Bj6Vn/nImypxEawd6C2c50e/bra5rLACRoH31NUagIvgIsHHbSaKtvHHcuOsTvapbBQNT++rShzzvKvPbsehJ9yR8JmOUUT1G4slXyz1WhIq0WXKDaPhHB1rzx4/5q7o+YmbdcfuSt0YbV3upTzKr1VKHD0Amsj7KEv6UQY+i22hbW2gITIEVQCkcDNcTX2d0yLo4/Sb4SSUknES5ckexDey/BD+k5ENXfWNYz5l3uAi4gF7IQu+ocBGK2PST1eUXe+GxfIzKUOZKf0tXtgGT6xL7EXLxCOo2PrFKrix1HmnzcLcOYPQ88UxXpuORhV7BM9KxCee8kSHh4F7EYRfh2IvHUGeLAOavHJAusoKC6ysTdpOKbgq83EM/afCbxv1GKoiPonizdIQ+XZiiiiE3NX21f7hyV/V1/O0XYgxk6ww+uxPPp9cl87Ft21GK3eswW2pcg5e33eDBWFgEUL2d9GafoWFS2LvD3Y25WKefom4sdburW1sRrhwOcHtSd5I2VDtSktfdKgQEUX2V560KW7VYshEews493G5S6/+GRk6cAdNxwJa+HMdBurTXzyzJph/YDsW2MnwQXC6COyT1Dqp3paCxE6A6a7aSLgGvcTAYLq1whl4fmV4hKAXIolDK1QwiCWIPH/w+Qg47GGLHUmaYFwabayQSEPqNSRymBp5Xk4azZX+/t/ho5NPFnuW/sXLIqGP9zJby3HaarWPwPVmzOukCujfcqgbPw8pmJ8rc6OI0CbApNwlJ9966OITiIDoyG1Y1MjMFOOpfv1RdJayeQL1AI2l3nPEbpnKWttEhGwgaPIKl1X+ecdGInw7rZeTz7I+nl0t2cLPWfJYv2tY2YPMnhUbAIfjRmJi7on46z4jaHlVy7davX4ZDgQ1rhbL+PCTGSVXJZkdLI0sGZTn8lJDxk7inBrY8keIRcjQGyYXZr+qWshRfmUfE617tgQoFs/d4wEN5MV9SAEMuh/NVeRW7TpJwkFNmUGBUjWrDdp5m3CWhFguXVQeC+2NIvB7TBuALGra6Qnzxt3/eTYhuUBVjAhh1/JVJWxNtO25m9s5EbfiDKb++mrFJp6Qp95+3Eyg0qOUbEfF/tKYduF9AmeKkANoc1XCS38B6inp7UH+LY6D4n9U6NN+jg+K5Dk6L/bBI+l2PebM54/9HyDiuyPo2tWsiLdMAUC5hINRGwZ7YcxPiAx1eDI3XLS9aaEjYbe8i13ITKEXK3YXnOyBJYTbEEzzxTT/iGK0LaftGGYUfy2wLN8Qd4zbtpmq6QShz+WkWIs4yXDxNrdK4f6SPNIo75ff5rtQhyOqFfL7/SJXqQkW7JnrocR3m55OtSYa1eG4U0kGJON4DKyZBCEjwaQXg8vTBpW8VBjFoPX4XwwaUcKePlrZ3BAYZYndmYsdbPZ0/kNcYu/C0FCaOj7GMWIZkIvr8yM0Haz8RoZu8vliX9uQhhmu3pXlRyJHzLKMvUz1AqVg95O5+NyJAx/w2fFuYOZlWZ+0qu0EVWw0MCQ0crBsNkB+O5tty8WBLbcPwqVLAZ6bRuI1l3qnHNX4Oe3Wp5TByDLnStal6aA78LXd0rWUMENIULLeL2idpnAoseU5ImYtA1Og3rBBDxma9te8geO+lkbO2OHU6/VfTVgk+pTQXgVWK+ZReda8WFeuMuvnD3P0K3Rw1tkQ9uw/xD29r1AHxHMVKvZrhZocTasrzMOmFm9QDHDgiY3L2lWxdZDPHldv6DERCPkords3eKw8EyQCUYAfYTkfxyiC81b5yoIIuPyqe2LnCsNVMP9G/4H4kni7KyN+fNK3dSunCthDTrMQXsstg2s+SFT3dfrYviwnAFF1RMSuunoYafW9Zc2X8zSu3yeqrJWUy1fTRacKpomEfGmqn5nrxkEF1Q9/lsskZP6hVIqcHuJ1RgrrDIlEkERYAxJWIOv/8Se1/UzTBfQ9CrQwMY3GhP9EDhbURjoyqCAtpeak7tkyaVPXkrn/+htt8SLRxoTqO5/0Nzc/gFxwKXY/hRLXulBvPsgFMkK5UBC5NJlOMLalDuIcmOBSfD0fRrkjmg8id4M9WfLkCTRnKTSWxpvY88UnKbMc6KLfUi+I4XNzlher+8zI2V6IOYUoObvpst+k1KNt1zPbwqp3t2AwU9QAadJ2HAwfpOvZLeHeicQyP/rpBiDLk86LTqqJx2kXGdBwaGJlmvJDpqiqe6iZjDetszTEAiw/0wpgd/7noS2zrYbDyGWQq2xA3NrD25gRtt3zASPdhhsJUI/NZ1X8Q9exbC61nEJ4tPfJHWVuG1xqz7mkHA98Dyjm1PpkhTaIDY8sk250oDpWMDbu/ZKAXKTCQLtnx+i3NWFz0Tel8KAbJ06IPpWp4f1+nMeAiv1vjq9rYkP2KyUiBUJAYMd+o3mwZPIXIN/1cSpTHXEIzCitUQqRZUTrYe/pQdaRquEsuoSxuhGe4gIY8Pywqj/DKKHxeZuR4kiBVYrdbbcgOqJ+ND+7kDjF/qKuCRKp/gFClzZQuZZglVxjrj9OQwk0opgNz9TVV/PvMHq3GRNqK1hP3msf9DRtgv9NvBaY0sAU+4Ciw9pQoQoEfEMqXrBYwvNVhHHLPuBMbHUp2KKAsPHU91qnQdQnqZR98vA7iJRUWxnhtavyfAQHrJu6X6sEYYc1K9Dl3Br8z6AetECUSf7L/qlvfO446+idYSB7YwoFB/X8TTJwbFvbBC+Miakf6qQrt82tzvJHaqogtH/l7UyD/cYflDj9dROTl9uoUZgBR3HjEw0W/rMsjUqciTy/m5a+W9gQ1hKx3z3FxAcn6RdZJ9G8qQt6CSvlllPz1xtnxaTGVFM9p3cERZd4IG7o0FNAv80zZqOq7x0f+Ht96ml/IGgvOdcxzZD1zmcRu+KKmt99bzP7d6elWVgz/rFZ4Zc4pSZ0HHwEeaakapUuzA3HzvMGWLGFJ2vdovC/xKvdiGgEeCbCA5PwdG4O7asY6RYuV+zHcnncFuGzrDwChmauPeY8HCr2+l/y5kUU02qsaa9nv2AfDVM5ioy6JoPOEEART/mbTnQA29+Slu+bbXNPO7qHoYuff2g9NIISZoCRck/8EHkUZj7bvXOdLtqcRoIZDbs/BHchHH8ILutSO79iPSBMhlarABlIs7SgYEzqteFCx3RvT5yMjNJOrx1dYZ0F0rJQLwozNd0i4jNf4O/PPLoMgBht/g/apcHIwaqKb9gIb/gGnyP7BdANN2H1RB1Vx5Ny9kwfDyoAGogPMqCH3hrYQfF1S+mJ3Uf+rO2BdgGue3qKoFUARNiNSTBynM+oAn8XA7dHCi/mbfiXXMPWZElTIhtXe4cpccpiwUkG0JKR48fPYMCsWR7duEjCAW9ON7IlKmt/iMzSa5S1EXbzCgw5O4Avp0Vl9COQIlPlGO+olvOvBXv6EWVIh2nk2KOzas4FPpmDvKgDtq4q9a6hkWqExHHB76rdN38Bj+W3VaRtsNg6NnZwAi/jISIqGWuVcb92drwbxazdAGO/OMnkTF1DcoSImxaWQP8v8IoKQoBNkgIlm7ID3p6BhCpFt9jD2DYrd/+0TXtIOn634NDWl2OAI1v3eMeAttp10DF1lMitnEDqfEPNrKB5gjSLisPFDwtbPceDLRYxnYQ/GCVxgp2Rn1UZ+ChQe4UDDLYyy0FrvCbgCfdClvCDaknICOtELzZS+z97yfpsEoE5bdnsg/eJTX8zGYU9za92vDhk2tkOIwZITdol8Eck6DA8Rke5r1wN9f6cYWDLEVbgREbNLJ0AfseXz8FkGv+1oPrazMk1IbdCitv4mXRX1tStvot/8+NYmGqGLyN0niPcQPgIBei0AYH5M3MdBo5/BDcjDA7mnZw55tw+KSuWb/6lEgrwcn9dHKQRyqCMA2FiLfvisZgjiqDCyiSSTBW/hobDtSQe/Bj70yA7W+PV0NkPjUPE9C+DsVq0LT6khMbhlemoU8d94VdX0wHBLfmTMYqjwExGCsRq/6hWLerVRirNmAoTmNPOVh0Hj39htXAen8qbWacRPR3ZWNrXkqKom02ojUruFZDyZcPbSxsC2DFr0NQkxkE2/d2n3f/UN270j/aAFDFaa5aIa5svXxiHiVr6hycxSUuVYAwGNLXc/02Mx4OGctFWRxS1yNNZqFHgEt30BDrV/2nTECrHsYLYtxBqzRx6c79GicrY+ncxUetAdkuL69dWWykZ/Qb1+bXNykk62uVv3yPz5jdkt4QQ1/8epQ4mLfgbxNPD1jbFVkNkZvChdQlwlGjnlejqf4EFnHSvDVcl1FQy2c3lTvhPqy8oSFUlaZGCU5eL0rAeGf+tGMTj/YRd5Nozt/YJ22KK/A/LxafsncCBBHXRBzxIdxMkz4oSqBZT6hF9jOrGJvZjp24kVBUguD8998zTUfJVS5cZlczMGCILhxXCLlzqETEJL8nJfBLTmKKAHxlPzr1AOKQu8L2Yj5qMNdQm3+rLdoJ2dN+2fkSn3knTxvi4akELpRXbHIhN5Nxvve3VGjxI7/ODWgtWp8xmgrmLO0NRdyBhSa6LbhLWVMcDNZiJUxGe7UI04kcNPje4a7DrJ6M8Ew/87tk/BtdK5RIIDMcj4Row/4bLkGc/TPC3wKQgj5Kkgvnr3toIs+x6htFMwhEL2H6Exb4fbjpvgLhPg8Lum3S4Yt5nn79mmv45fTQWxl1qsMRxvWMqBtSF8GnOUrcU6uL4rwINH+HQ0MZsepq7JvcRUMduCTbT8HX7/RIfXWLt3l2CueuyG5HqMnFEqTh7swKCx18VWR5BYbC/y74OPLCwOwSTV/GphGEvxXne3xvkhXF7SHEkHs7Frbu3Qa6d0th0N3m3YWueMbTJQAGHosXpHRLR26gR/lMVUtw/ZBOwDXYk8JS/T7W5gFgDNLfuEWMSizdguEp17jMl6+CmHG4u7TlnSTveqx2jrwN0yY6NoL6z2GlDeDJtYvLjCLATcU5w3I+SYgZuhFDV5qapSEn9w2aSA+trGAycUzK59UTvJ0ZwVCdewpMSyJ/ByEqSUE+i+IZq4c3EGQSAtF1ucvuM5k01FjgT8n2P95bkTZQiOhXQ3enm52Emlj1seODur10QJnRiGTtKMgXbuQzpGmFud1IyNlYh0jKZpOgbocyZltxk4hKFbsipP2IvFWzZtypDGsaexZ+mouSqFpKPfqye28jhXV4b/0uwR93GdXtdvT31ySlu15ZQs5tuRWFiy4cjDvwt2626nuN60bGACpG+MgXhnSr/9agTDa9z1NYc0daUh1znAjDgnLXX7OwoW7WqcF0pGxH1Z6xXreoH+HL8p3IywqHavoJTpusidVvzgmy/yJJWDIoyG7bmRJ4QWZrwjXKlo5jm58Y5PsXenkgwLF01T4kM0J2tR4sho2h/dYDpRLnoF2W+0CWRTyC2NIAdZRQjCs4gtNC3/4uIb27jUoyBnVZZgwV4BjfO1HVV63wdasa33LcB/JhNMk4DArhK3GZaDofKou5ri1LDJbYWguIFa+24yDgmcX35HBabarFhlL2Jl8TY3M33FiQYO4y9bvHZewjO7uSo4pvcW7X6KWyeC5qGXCkD/Ark9PoLSWgkFhItwVXaB86kv1yVHtHbs81I64a+GgVJCUabg1fooY9WQx0s1knLGRSc4sHQiOOq3MLqIu7Qb29loplkU9NziIeVmMXzQFEikF7deYKI29RXzNZ8F4p8I2UGeOHpCFiRXau1+tl0Nx4TG5B1F1bmVGUrM1VPNx/iOuvDjqUSYeMl84EQvHUlVA6jrck50roxLFU4CpAGR7pj0g9VPg/olAmXm9A5dhIIUsPRBeR9aYPZAy8hTO6dhb6ga5djthCej9Wvc7XA+SfD3cwA4CAGly5103q+HIVYpvYnKrEzUJrruoWpsiUKY+d1BxDrDTK81qEqbJkPIywRYCaA4noVu590kS8L3Uq3tpeodx1txGKm3xvaVNsIwBvxqLEaT4t4D3eVgTH6l3zwN6Vk21ze/mt2Vfd3Q8hsChAqPmo8ihBG3u3JfiJobc3vkV68QqQULlHuTEqnLbO/82hriGsPHCPVT8wYaT6EuseZ2ybDUwDoWnpk9fvw3ljTbOif2WqRcOtMF0dUKlngK6NxSJedHaxQRTQ8D8hkclqFkOD//a9/pX47OpIT5ATPfr3CL52HwXaGl9+aYTJZY4I8BAihcw+EvUZxwFN1J4X4BIasfHoWNd07USX/1+3v5acCn18KErRm8nZ9BAnJJ4eJb5g1KKcNRy/LrRm3bAEEcO1ekV+tb3LUOjF5S8g9zeNFDUPvt8BKOqSvJ/3TPih2yjyfbWY8DqXnP2EVOECPunijtf+9B1NPIBPrgY6r6v6hPQ/gwAHYPh3DXQP1ciA4W2fpuan7EihD+o1l3Lh6L2TwRboOR6PMxFTsAUpGELXKj9Plg6jwNL3TfxHEUx5ptsACBMfY69I9NaU5GKvV8coSOLClSl2na/mim8I6os53LutqtTrS46S8MO+6aDrQ2es0YT2EQFuRbjHwr2JxtAIfSAz38buudFWpVG7zXD9wbVdjkvyopIJqdPmLH0im01DzZCQRMxutUJf90q5zmYhoV02UEsuos7RL2a094lnG4S93th51sPqnfGe11xdbFEVydIujdk7SGPNsGSf542XNu9OXVqpGKyd7uUA8oUbL8qFjbRYA1tlwRCq2BfZ+0//qmlKBfFFhy/IV0pB5UMWXqpyVsDqtJjJ8do+L4ESOKi1lT49DXV0edsFzVvuTN8zTYHl2l20WoSEWApGVljet0f3a7EVsBULZ1yvJ7c7EOt38lw0IGkSP/23Lcm6V2lHIpcYLGWZOx35KGV7NBQJng/vz5OwzYciy6gZyOco/9H7cR974vkMYgif01h6B2FTDrdevFttf7yEW28J3TwuPiQcp3Eyu9qMCu8hHb/kvQEhs19YKAu1+D+sz4EyvJmejGg+BChAjCLtCUR+Om9U8Z6RDF2kJgoeJ+ZWMLtGjUlGlWbMdJjXqOBLP6GFcltq/7CoZbBW3743n7zeDyrW7nq5GYOVAK0Jv5dKXG/2AljzQx6IhSHywQFXi2ULUXBM9Jj+X2QIaCrKy/1TcEI0e5+Lhl2so93BYJWkIddVj24i0MtwTFCf936kHLU32N/nL2VTrSqW0dwZscjHiICb4P8qex+XULXLa272rzzblQqGnEjldb+WRytVc8syZLbjzvCZMkArq2KFePSbdQqIoTEqNYwx5tpCwO0VMFD0Wl69QisXfjJZRWvlKUdlUNwbJ1OA5iydgMlEmT5x/zRvNpbwosdbDjMKQm/Tp7T4SVO1WYkd0GQTAoH/omJAo6oWETemPoKupJ9oLZflimukRR6ipJtTS+rTYlKnFiP8584Qt5eujAZZrb/e+E8dTkJpvNiqJPxFJtnLT5c3uH7NvRFf18/Zs1LAlKGP8c04PFy56ruWexxcu950v5XAmxiJ8D4keffz3PqGoSvi0RHF6GnilSpmGVdpprRz0WkpaeSxQDHbH11cY21a+zkbea2hETpcj44mcZaZ7bffCLqngP3T80qxU09b6LPu3onfqYsgC9RuBXQWPZhQOqmcabVQNKLwWuUqA0ZptucJqr9lPEAiIwKZQJGMB2/tjMaPzehAqKHcxpoYB8NJCzZg01IHoky3ay2RMhs0+P5O2hjgSxRNkEQFf0kBmtlE1BAdzDbyr7v3vy22C6//i2IGW6lkIL2hG/A7qDbMANAgEDkFSwX/OJ30cVqPRgovtm07IIWwfPlCcfBxbm6LMZ0NC6uuC98ghfj3KeH2NvSS/qHYdBCNWylqSBhWAA/sCdtvIfeVto3ej8FQQdZFO8fx6K+FilVrAHDg9Um5o1QEaV/dK9284R+B2hzdHNBZF+rElIN/7/k/Y93q2jDCQpaHv//3j3fTJA2H6ljjxqI7xhfYo8QCM8P+93SV12B87jr3IX1mA/ZaR1UUKlXVMGavuL8fHbc3GPrh2REReZTYi2B6Fj0zVYGkTlOs58Gyosgw+givmzgsDrrBZZOE8/IcqOqe/qgkh8CWh31+WRlnRAVJBkrLBqZKHXwH3bIbbbMbj/qQh15glNNxfeP6avgwTpkxu/8Hbu4b2rGFJPsb8oIZQgCmFIa1P8yC796L4/THU8hl+OCi1p3jF78jODoS0V7C/BQ2ozVFxI71JctrKxKFN05mEFcOS0DKciO3duY2EPzRqxbSR6KMPi22WkXhw/ztwzTqF9FLDvKGX0ga8bjEwzxGUL2xm1ag1mlfplqctRG/T/qGGP0KNLcjxAO4lZn3ZC0LyBFRL0dVCBMVrsctLVXQ+4oZaJmFGAVBKri34v2DKq1liVr6IAAJ0Xt2bsbA5YDwjqZNEi+FfGWSDLFznxYt4w7LDMvAxpyziJzQORzjnuJy5I53o6gJqQY4KzOtdB5t76mHx0EGOcWE3IufYglEmKxOXajrZjDTq/qGTi+mxPg+D7MDUfsolJAmbmY6ohj616o58j6qO1qR0kEpdwpppqW/Amq5F91XuWZTXhp1eZ1uQw3hMSALgAXq6MwNM2Qd142Pjb2aGe5464JAHp36vJtXeUdBS7wXpnp0Om9N67h70GNJJfJ9RYhdUPbG0M1d6LIB55ouHUy3jpBxvu5xutjoGe6dQMrDSjQSpKPheFsICLFsTbwUc1HPQ9Pqf0AkGTQ5waAAFdi6epjy+BhIUpX3KMazbbv0/NMi6x2FYffD/ssY/DQpcGtjY4WDT+UTdiO+rpSpv3S2tItL90eSWFIo9TCtUatgwJLcBL33u+oVms4nq+TOn6YBdth2rJa5PPGJgxPTsmx7wFLBnX9Enr1AkeHD6Xzigo3EZoq/PEcY6N1w+VNq0VP3jLwVMOSJXkGRmxxMuVXm6lv6MkcpnAeskNA7LPILlDTctieba1lp1kfP/3Y4oJmsMT9YTXsAp4pG1fGP4nQli3WP09ioP8pbEiC665+iHKy8vQQnYwMoW/qjdEX2NJqVvjYEFd2NzM7wqSLK1iJf4QTqzp5JxIPv9LnLo79PU24sbVjb+o1mfMOGxUS6kewVoEj72cCBwpoUty6mOcGJfPukF+WwRuT90ASf/xRKicG+iep1RiNOxmjmcnMxxQyupDBBl3sBmwteU13tMBlZdU6dEkvMb780i6UQ7xDPV6aqSanhAkX7bPwVqPR/o8nMS+EYOYPpst0EPevl0CbPWoZMxGHVdaD0UanElupO6TIgOkmLsQ7JJXXVpPPB/Ht0VrVsx0xFq6lPlplOxB0AFFvMwmQajR4cCAmfqQZuFk0J+KnrSEBSDjioC3YH3DURZl1p/iOw+ZFCyjsazJgI7/a9Mz4EgusG6STM1fxXjovzQGSv7F3qRTTD1zJwLMRkji+Wmtftik7EoR3ub91cXFle5d9N0T7it0HicIwzIvu8PN7DmoU+7349AzSxbRU7C1OpaYvsvOlj1V082LjvduDIivWZH5UmZYZnLwcsRYZn5JK+jeKCuq6gyxJi4mrzknmHxnygF1gqosbgkedWuWszc6Lz+QEQvM9Cf8xGo93H4mrM+hRPAcwoVsfuxes2423WGPt85zSOsR2yWSmgv4UHKVu6WNuPpg88RZZtzINgcKTi3w5U53DifBR0kVa2N+SAw9gXJIuIyBRKTaXnkJH2aDm61o/bdPVmG9ifun069j28qs94eE1+1ohaLWBzK2jjpXKaqvTntw4HCL0FxaQwj5rp2YdG03B/d747Zy1riGQJjWBxfR9vxr7o6U40uuvxqgJY6rbnYHRmKxydkrQ0WX/sXi7vtvDZVxmomaky4amJCIYz0eo00bO9+0pLLKhkxuJUA8xwpAPTYINs6unE3qgn30vblc/8/Ags9ds5IpiBu3tCxtNzKBhciervywfvK4eeTO6Vbv8TO8ksWjTND5i9CgjxjwMdVn3KRW0YSHy09F1ZGpLXHuZgK0a5BDtDKJo0AkcCkpLSxk8Lau4RRUkRPX7fZmrgE1utCPB+eoYt3p9wvkXm291RcM9jL3uAcHAk4UTHElkIr0SC6AQzSVkS49e0E9bio+zfJ4eKjtkeIKBLx4s72ZLOX9DlFzl+wjCDWrZwHP79tevLARiqTlecV5dupaH+Ki5b4mzVZj0987zQbijhflyFY53vvIfvJBrZdT7bO8lXR0AaTKIdXKhs0XhjtMv7JRsIysOSSTZZr0hTO775zlu0KwGtT+Tl2gXmLtc2ZirXoLA9Jq6Q/9XvG3EhIc7FunoadotLyvZJNv+wQyfqyzrYudlP+roUs4kYMeaqys2POdLVAkaOuI3jB7wUDMw6mOO6cZgf5ppGE/ZlaA86tY21Nm/3U0XzEYFGkX1VK3pbdTHZdX1dr3E57BhmAh7jUFDIa01i9CYN3AlNzfrEV46XGd4HwHC+Ud0WMMIr0TBFbx3oZLOYwM4e5rkhcN/ATZu5SOz56kg0xVLOxNZLw2k45UCFXM5WJ5GlIdejQAeK/JxxZ554+bzicXloo70ApiKmAhyil39PcMkH80Qt5tVaSPHw++xwlZBtEzH1uZrrPWAQPSryyi10l/oOLeBJfXHEuC3baWb3NT21X9w21weEF/frm+GnzHgOzUAuaqtVBBNqPD+L1UFXP01h+cmE1QH25PHX5XJwLDWadMcla/awPlqi0M6L7ujebR41IU4Bqxrvpm54jbz3XzjRSElnPtSEVEn2lCB3EcYomwBeSA5TGBu2cNeQl16PBLZw2JsooN4kg7KRf8ApZbGt/OPIsDRo2BTvo07seQ2UR2ynW0vx93nkbiAqilAUajZxWjwyesX7Lw4yQjhoM72cjFeP28AGQWhswz6IDBJ2G4A1nWth4VcJORXtqjoxiJ8ZHgfHgIRqyXzoJoCRFp7V/Axx069iQs7pC5pZ94vr979h+A5LmYRcKyaysH0Im9z8b5R+bOXwIXQ1zSUpRqul5/LhHydwfqOZ66cu/F0+ytG6i9nlVYES4f14WraPDk5qc3HbB2O5lLMYahFrdBvKaq2vvX0GvbhYwSy2QWcmozjpYrhiMqck5Gzv2qzpNhr+F3M1bSsj7scuNaDF4u0LBalY7u2Yr1P1oFFJucJXH/p6ILkad1tQH13AKlAScDEt+QtX4pntD6TLGxHE8N3q4S65LCHjRxLh4pr22iGqtMAfPY0cFuuxuOi3UFGFdG2dz5fTJewCfF83mnldfbghKaYSXbpg+Tvc0sKDv5MBCDRUb9oM5uOoIV34layy9V/qQvvE5n7SR0zbhSkL6jI3lPRwmf0CLcal9c06CiHubgPIsTSaD+8XF8kWUkYWuu5mpijKuMKqmAH+ROCKED24YZzy+KVTU6Q3LYF2N1qN8fgnVURd05MRq2e5dNtVjc0Jp+aaZayNpjTQYQMfvVewyiMufgjCFa+Q/pxDYa1Iv8v/HqxPX/losNUkzfVDljz9ODcKI2Bx8gt9EDBsivAj9YN2fap7MghPytKa3Ni8cMNDhIPxa7nfmAlttiUsCQ7Oq6JR0k53DyVpkCFbWsuiYmN0a/v71Y6KOCTn2tKIxkWqD7YsKen1qYYgmef0ZhG9+lYsexrKKpDqtzNujNnvVjB5Oqeej2yxHIdro/6ijYhFd0j1nHpEfBYjcIMQwiTRFUrRdFTEBdW88QjAuzLno2hCZVyI4CTukGOdRYhRZo9/nvj/yD2VFyRf5EzIzft3y18nmfX7oFbmioWU0X3jbBOsgR2F48Vn/zt+k9grrz8S6JPvWxx2uVNRJZDMcEAo11Ll+a3BHdtoM4v9JyrZmqEVHTWjQG2HbDAx8ax4T15cI/hHqWIx0kE2kbINWXVt5+9jS5SwBkYE/N4uiWY1YiSdqqXthN2oky+KTK/6UdXCmPa6th1KYJgmRfpZsjFdIGQS/pex1gIqZFmUS3SgLUTXFGMUDjwIWmL0TpOvVJuEUoOxua9P9Mh/wjUWH0K1YZmZpFPVLRXz+Ftcq2cgVu1PY52fwdhjeWDojUwtMEIlUVhfLJSbgzeW2iB8ro+9tRbQNYw0BjoXO7BcuWjbC8n6brbjosAY4pESh4fs8bZmCX2QX00KbMPEAeGNpJ6Bj9Eoe0h2MXGJWCjB1vGEwTUGlaJ+UL3mbeV7UWtB3FBvXiZnYZO4nBYX2iIzhd5ovCByOQTmHCmoqNuJU1ipna3z7mcYf8ySz/qXhOqtl1FIcCGzX9ekyG805zMZQSFzjBiZuAe7cpcKIrHCYjhSE8T2J2AqJQ+jRIJWoo+chWYCwV5/R9Le/aRX3dZl8AfKluI7+ZrVZ1Yg4SWTgQbDUSN6Ic3Hv/cXsk7FlYhStaWGgb4CdCf0Xb3cMMB8HyrigL+a+I0Mqkawc36heO59kM5gWuWxgJnkgyBJxeysWt9uMwKYhI1YVrvB2WVNLjfVxgmHj+6rV0YEFaqzESNgJjIcKMEUbchgOiaAQX9GZQzc55W+8ZmNayCZ9rh8/WK6M1H9J0mKLBI3h6rGpD84d2PzvyHmYpHzQgmwP+C0OwzdJ6rIJmWxSX+pwTQMfiaJVuxTPH69Mwnt0fD2izH8uJnnyz0ypSvKlc/KSCN9Z0IyUs1yjnK9q1w2ASGKBTv5P/7MxC+pOnUQoiIYjsPEHjydZNKkTYF51CW4F/L83s3NWGannp1psHIFuBYPWrYm+ddy4vkwsTyAyRQZuifrVKZy2krjs1Kc44qkJl5vhyMfZJdjkRpG89gjXgSeIFFgKSDp7YAJiZjpt0ehQkDPA4B9TShcUlzIi8kJynrYiLePqQzOaYSdPu7Q48wF97tjC06/6bPWJkwu9csNLhhPJaM6O8MCaiaBI2ES5IK9xWKERFdM95v2Xsf+j/6uM5NjxDNdiBfz6ePHY/xWD8tHTxESRxaU0lhdSKhi92iTv+B8mTBOZ+GKqI2EWlgiMGp+YhceSbw+PrMYsBENK6bA2ur5yDDa7LbQDxSssF3tyE83mO1HDd4m0ImDEkVnD/fv0hSwH78iLggzbcPpxcSNivFR6iddTveg+PaW3GwR2w0N6x5ccHI5ICFKYu0DeptVADh5iYIT8k/RHl8kKdgIty8FyU64v9s0VwCZJAL8B+sy1U24hETvcZ0Ra2W3TgzVJmXziOIrdjlv1tE2uUQ6l4eBIkc3CDWCff2gZtzcUqUP3Gj9/glW5jWLwRyi/tU6nWUQC/OoNyN+d2fznEsIoF5bi9ZCG62Bmptd5PWB3IsQEWS/sdkq2ITv88giE9FALTx4QqpVcXt7RubE+/yxcvMTpMWwXkamzrhhxGn16WH3O2JnqQT8q4Wp0qy7Bcg+SIRkvZXE9/6UK6KNaR41BbEsJDcHKu/OC1JPbKzaIU7elRI1HX69MLP6YlFOg8h4zAnFBHsacynsY42BYe8Va6cRIdeBK3KrfP/9uCRf0sgJWVle63TGFpmz8Fg7AE1PZev8JwVa2ZavAbrtJA8BlMJR934cTNvcS7k42LXl8OJr/pjiZlqFL6mVvsLtrpjln8dtsDMEAHjUyHLj5kP/ppZxr7+A2ZTDr2+QeNb1z7LlfUkyIwW1TMF8r6I38GIUx9ZG9U3uENzYIBxyPqu8a7daEtTKIezOj8Fxf5439l+2JV3rh4DVI85O/nyf++yX+8T8VdgQ/Pb4+q2sMzXEGdHQhABVtAgQRXJ9iMevQs/uKJoZ0rMaXjxstEXNQUNYLcO2rhYYy/c/bjwsbRrLiYTVE01jxUrcEbQZQzj4VjYxpIiRSIyUkX2/9alS6A3Ley1VYK/WVKe1kIKjqlxE7ltWJyjjcpfQ52Z1D2j/ylleQo34kapBhAxb22vrlPCloyA+Bwwi+c8LDqqoPgge1dTGe/UP7WxCWcEbMdcaPbBHNGXkyY8jqOLdGdpz9/DWh0JJWrATH3IUJr0bBAIqE08GCxO72NsZxJJovJ7UW42itGtGcg6Z5TwPNELJDyVgw8rD3coGRo9u1uutiHXgVzvMQwOunT5afOFqlw5rfKnrGdFmEggfwQx8o4hVg4oWLwpLs6jdgk0AclCUKuexQ1f7+xRhLxWGFsRcoq1bLwGCiq5wbmrTR45iAB03+sUrICZq67OTEsEOtEILKmrIVMlvQuL7IALmgrbfXcrk1q+UguZ6+bnRyz+I98npGlTjNYd90Qpg7soJrINlHdmj8nGhfy4MRFLvynFGgdmAcvq3dgYIH0iVk6AH84aDo8FH0YD7HYdFHIsi4D1OpdTpdNf4xC3KTuyYPCaA8o4BAIn92BEf/Nhr1rIYgPcpjOsxNb9INGEiTEejXfdSDc8T8GD03FYIaUxqe4FW9iWI3U97OsQi9O266R6J3AtPSH1dLBx8o5p4/QeUcc3Rhiw83lCM2oSCoScfrSzKnHvbAtB1E76ZaJ4h6gHl226eQ6IO15+KUURS8CoP8wmRrLbofYh6aiIZrr5hAhFXkPnve8aIZsYLnPncqUt5cdVwKz1+f92NzJseqvjakrviitgBXYjdGT3YF/woBQrYwBKjbtPgJwNehEAiVRxpFYw4wKMTgoWYYYVx/b0aV9MMJeYesutKoBIvpIeCuUwFSmT5Gwf+Zr4q3u5gADIreWlka1TtU+wQrckiJqTR9s317x1rP2gx4VGAUoNETTLaJLuC1vU4Bea43IuzoMngzWDR46SnvcqCsIEvzwssQf2MAx3y8okDueoaivrrZfMPRFP4c4n2SNlAp1fvjPEYKizqsKM3lzaSjFu6q60+gawQzZ5lHZUn2mrIwvYeqI9SycSJmlT7HUNwEZU0ST+QKrkAJjRfo5WCgw2r10roEgmvbZapHQeyCDHbsbit743usrSCtrOF1IYD97KdMESdJg7JR7oLRad6mmpIWgujGDhR6s8p3BZE6mkTbh35mhngXtuqn0jriY/0zwhh6XnkXnKhM5MIhNEljFRHjrDvt3C1f3uZGopXd7ls3PVdIU+OvZ5y0lhbwJmjgkrs9NKRpRJbsmWfQTDT8tUPF1vQkP9hd51JMk5mJtT08Dk3/aqQyOtowT9z/AtCPX6mdT8kpvJBFSb/3+6gy9BOIgjJRC7L36yttMrNxxdscSH9L9eGg71U4PVcV5WhLzeiOTULAMjt1Z+5anzOpMC8GlodwZ7uinnAGFnlcVP26Ws2K8uOraZ3x2nCG3cwDxyeiiPKHxCNriuUKP0F54dLUUipsT1yCPZTzui/wNWn6lm4j8+jSOjxujNLtTP/iXeu27HmD+D6DwrATTHRSXdvvgMELKWukivjBYIuQa0s7ezJzv0sMkyej0IsoIMvWiybxsoa4RyXwTcfZvG7FOCQORUOHQUp4F9spre08RTSI9oNJbwhtT6akUGb2qkoZ4lWcPPseqD9oKUboQkTN9Hm4LMFRJH9UpI7kZ8XZ5tNfbircYv7JM8zvOT4tmM9FLEI8bVl8hSrPdrzPvfOfYlCepI3J5ditweRE1KaQZDqS27zNaGyX43mf0hzdlT+hxzuj23+iap/YVlWgBx7ATP3DEVFs5yDfujBSNrKN+F+wahVKBYRYpG42ngWIczK8Kyf+77hPMRp694VG0C0EX0VYtt2fy80jxYJ6enJzatoyqCz6XgaK/NjvpLhWsUMI54LgW2OxoW5fm2A3YHIaujIyKMQhWWoXBineLunZkH5/nfW6yVP6EwGZqCIq4rV7SQGEHBBgybJ8DcZ6wBC5NkYiHIwTbVqpVBnP5gUTMTrLldNe5ybiUXJgjodfBoC+XS3zulW39Rc8k9n1syjNBs7Cs13EP7Fqcvjro8LEEf8YQKjmIK4/9bINpW9M9zfwKm+BVo3hBOkCzBXLwhPlAebcDQHKTzfc0FcOt4pBGdM51i+YIRvntNIt2vCOLCu+4liQyfBnkaeicWMI+S2b+xZ3eWZ34YwZF0n1df1KzRg92wBa/FOnQdz3a1wRZnnGdPffIKzZBtPw3Weshj9IwWhubmePoitgd1cT5Ra0yFrmGyKqfXhf/l4FoKfQvUoSWLbhF561QiRBJpGJI8uspBApL5B9vFr4yJFFUXYpoJkbI1CY418vlXN1Vb2cMOQKxuyORZKr46Txy0SjN4unPOTkBoSl1700+HleKFLbnx+fNxDUsh1kr9GhDYs17TA9bCRNoQybycUxeQnnh8Qpe4zgwcqyY2wTaxymp+GiY6Iv3AyTvyPW6pMp0jvQG08aJ1CfIMMe44PHA86wQR7Ep4y9I9uw2Cogx20QtG5d643EovQCFIQ5LaITxWA6INmEIopCvvbhrimVvEvGdKPzkYBKfWqkiJ86QtTcv/SYcJTILwIUsmcH3ROr1dji/Y2alH3uF8Tst0PgBEGkwpiJtN6iq5QXTa8b5Yvii8//w3tJBF9HZJN00W+iByfKo1bd7yKtVXWdREWizD7dA+ZaXAgA4adnoUKLmwbOs4egKYhKjp/lW7PZe5VZd38C17YE+sIVVw8VHQ50ZWeinfMGLsRW3HrPq871rTTKifZc5dedSRJZDeC3lkvbt8eAReZ4McGPAcoe29dgBNLtoymDYgkm70lhhBt6Ug79kwV74wnsgqP2ytm6T/pM6Kn35Zr5GSsVV1c7qnXy3v5sDUxL50hitf6ZyjSY3fCpP325FXL+ObKn0p/4dKzoZWbqw93px1qMeJNkFKmEY9Ft6mQOWDOLdQvSiGNW5nOHCrwmdqh60AqQlEqZUIPyyAhpcmtvj2DRAr+qzDOb2nqk9aqlZJzTXNsVSCGcru5j3uPjhZFWiP7HGW96f0YDmXaZmVITM7/+7Ib+RDrCSyZWRzdG/dKiiOLgAegCc3loYb+TT1+DBYYXmJZAITh4tPFA8lfYV4Y2QS/ecZWQgY0r2Xm6mUAWgHnRLDFzcukvIFb7WUl1oXrA6Wa2nWzGbpeyzjF9NVsAfrk3hXxPYQuK0KvDJnDr2YxyZeXgJ9ZISM5+B9/J/BiMm7IOvAeTHLvvFPaAK3ZiwtTwp2L6QBcwvij8uogLtixbBKoXyQACaP03lAkmSnBetr8Dp3ejsmyN9ne8XVKrdsGHjRbhhsCdUlsNEqn42GaxcK965vQtw40yDLaVJPDg9lEOegmeAk4IpTq7xLJn1yUIiCM8m4SR5GqBl6jq/RjWOlz34BcwRzj0Baj3Ny9FY9fWwMp0MdtBfjiqJos/sU4oxH593YM/RMXXMVwLb8tIRJKVLeeWKrLxO3AfMU6A1yh7nV5inkl2bgbndth/Wj8LbX4JQ+gLo9uIcoNhhYnIxxuC7Y9xazpSUSm6U3XvQi9Bvh+1BtUk3EiWr+KswfdcM1WwF43mXThOY7gpbgqkbTu22EnXh0xG1477vPXhM8bspnAXp+IGh+WYrxZY37sVCVUE3CwR0g56wpOnSoRd3Bo+RvxUxP6ZRpQxkrlUOh3ORakjMNRAhm6txLnMa7b41RyneCJ+67RF7r6yZThvQ4mX2P1gIpoveA1G5XETH1KEqSNUIJg9lpwvF0GbPYDq0Rn4XyYUVJHsRvwrxLB63VEHEevOeI0h8H0oNffa95yeegKqlgXXH5v2U+NNkVe+SaedfweCIpe9uhr5KCseRfouUxwKn+9nBtOcFM7IMFzgvO6YocL9q/Dsf0kwhgFu4icN8wTf0ZfJBI+402/EWtiUgqEla12TIHvE27aGcxVnHdCqamznWW1vMMiHc2xr8Tlzi/SE+4DkXimn8CgXzaho9sxuaeI4X+6yOYnUrtN1dc3m5d6dvNRIzYyqc+/+i6NcTnGJzL/XNtEiW0kkKHXlQz/CehzH6wW8eE0ignRFn6ub8RbJAOrfhsd7u316SCw06gAceJcK4V3TOpHTEB8SF3tCOT3I3B2YZdYgH+DByVfwPqw9THcRCOC5Jp0jbXoOwxHCIf7xEgchrSQ+Q00W0eRizTikxw7FUVZo+0coh8X/BcPVrDu2G7V3iHQ5XT42aqqXSn7Xu25m6qsgoFnr+1Jww3iqArlrMR6Xi2f3CJBzHhOkiB1Ob4FJCA7vPLJNtyILugg7ebxLbD7/cOgsBhlW9DJWymdA35TZuRywg2Nu+lmjFSMApoo2fgQjFjhURaoh2Gje+3wm/fRAk0diZ/ZZu7Bi2386mVsj93U8jVSB45s5FwEepCvLdsok/BoeTtJ/kR7QxyYNtS7hSJ7a4Swy9IomiKfpwJ2be2tfV5g1zjgCY9DrUx+xxlFsetzMuvgihEgrfx3AlNxrcAmiCB5I6EvVHcOfhIVoSxP/B0Pq2R1OvRHe6t1/4caTzda7RkbhAFQxAGwLweWr/bFJTvHnfy5azqbXitqhMkwHT3OuhifDveOYCf9czxAwppzQmnsICjtKC0wDAiRl9gaNDoLdtK7k9EwZAhIK+9ZtBt5i1AOEx9sYs0GBo9ty6NpLphHMe231VCVdpSCJssof0gackr9xHglO7yx2y4LMmsaeZqcRTLTx+fvYkF4RVjVT0zC0pRxEmzt6U3HLP6pSI7Hw3lzSK5AL18qEy2ht4DdUZ4k0mjh766JTPGwas1oesbW4BV9vR8l85ImmDZFHU6q5bQqrIb/SXUMJoM2uITwNVfzwgUzu0c8p/f1+AUaN1TMfeERvvUQMRXefL8cO8m9h1FGTuQ8M8OEpSsBRX84X1WdRIgvZD4yIRijNbqtppuBdDHgCmfyRcfXkm7zPoRrzaFfJYFEAAIGB+Qk359yp6eFbhalZn5wnsFja58o15F1wkvVotlo1VpNnbZK1omppLVxo5o458mFHWVVliiVCf7Tc4THlmjhbVyXCVdN3V+f/kV0ZSSQ6xAC1fh6s9SdWMoEI53sOFsv/mUU+u9yiFPMb3ZX+GsSaDlUVlRju7tISHPfCLmVldVZy/edih6BrPNCoS3IgVNVVRk7ALpoVNqdkBtqbzL7hn3o8yhCMc3C5JX2Bx8f8ka/iqeM8D/XaylfGsV+kUM2E7zlCleVPrZr9928nkSONrdI7g42wNhuu8tTFd1WnYYSIb5CANTJOBavsSSq81OjyJalQeLERMv1ZuboE2JOu4Jim0uds4fNDquugiWp44W3uFmyq/fvWVwiQBEgGQ+izC7YKzBmA4QmPz6f0c/FUDvJyyR0jQtRzNXgDb59SV+HFF7HEW15JrC51DswS42Mhv7570auZKEoG7VHgf78cm2uRsltzshpsRnDCHMy2913Hvf8HmE++OOthXpOGZc1OhrQxXjrD5BnYmVlbxpYvqwU0oOe9PvhpaLOGBk6xx1xk1vLU+gQqmb718wLXsFeSa++Wr0FGyxc8+yt+aJL3hkEoVH2X5NOmw/Ta6WSfEJgJ3w6b3a+DScttHgObe/6BgOcCsm2YmHZSFyGsGbAKHgpuujpUveZyKMduLO4jkChcrrdAWNu12QEr3DZDof5ixcVlRWrFjmU1zHL2MXbDWonfnxc1RjNu7ZS/XErpRhze4HpkFHipjlu05wNplK5RLS0SL9ECbWlMBSJkLbj1j97ovHO49PMKZZZGM/VlS3lkQHAYHBu0oLQ0L5c2E/GtpQIj7j2awcNlSXDs4y7/hkI2LUItkCKtEaa21v/BJRDH0PIREpXqxU/Kr96imN2SWG/QPqIuK1xoHuFAoGMgOp03JSp6vOtRHj7f96JbfWzSQG3tODfhsdDL14dZF2tv43Y4Mx15eUY5XXXnE2RGFDF3NjM1e1iUWaxNI+zOv5zMUe8DAWufTtNH1eGyjdLMLrVznoQXbihzJlFFHBvzE6+atQ4T6+U2tXcaddo7XeB/FBnzIHbAz45drsJFaR4dOoo7hPGqKfkVps8DTEFe+T1+wL1WzWx+oakqbcZ0N7sltHqkrVex8WXjhDpmzY01JnOkM7+i1FpuW9o/U72l5a23/fRIHR/VOM77ADZ2DcP95boHQYNcQKWBNQCGRyFVajosbO/G/neBpPYqlxDXf//s1Dt8Gej41h0pKaR19b+7eZQGFKwNanrsBvKBLP77Q/BDBIpNflJTgHRTX9qFCQDnS6qTyjd0CecSH6lBmv3eNifr252n6GsMzbbZrLIRel7uuomSxai5AqR1Yl2CFI49AZB+wRsM5zu2PSB7zzbNDo6L0HMZcmJ3By+w+1RAq9qmKRNcnBFghDMHdceYeNqd5B7UaUGeMK6R+Eo17+rREP15rKcuUZ2eVd/WqzUnNMoffHZMLM0Be/UGfmmlEkhQwdXCWb4nxpxnlKfB9MoQ5KKWp60GpeRQlCAx8bDBerLX8xxPG+unP35U/T3ayOJ4EhgAvKDcL2j9XYYcP5b8bLmPJbEgF1Gwy+9ZIuVvh/4D+LgVk7JEu9EH3f0wel0HMK/HdFOyn8wzOK/tmXC3K64yRA+GXnDz6RkWvQO2xSsy0EBXWsXwG/FBEzVOXrjWbkq6iaVWz4F6CTe12vCkVYfgr+sR3/glvG6/VcBTr2EFTOJdvu9sxa+zFeqVPhSaPofmqRG0hkCWGMdARjDdyZ9gmv6/2r7c2mqTIpPFofwiWH+9doPqxuT5sIqZCUAVUHTJYPgdpZ3rHjnWN7shtkbszeMtdtT65x6cWugQo4jTrAPb3+yv3DC5bZHA1HOw96aQbj49m/10psPjEI0qNh7SRmZm1phut7tSqkBx+E20lIKGnMFVHpEGLD3Dj9bp1vQLFkUjEfTRKt/gFfRfjqJhSA3IaC86RVnL5wWyI8OB4EmzZa8JaZD33th+jiubpKDz1V2DqjrUpCoJ3qAQ1LRn0YSjvFyCqOXm9EHGqY1XamauWaTA82MIe5TiP0fYBNSJPIQP6LbQQjj607QI+s6jfF2Updv2gQ+4cDcgJKWMPI/exScRLjtM8+UtHUAIqR2bygXowIjgQBcarKj/0WiTsiscsuL1YLoVQMXK95QqtfsZzPs3SUFEdf6/Y6X8t+C/HxB6Lw/io2DkTxuUjnhnr17IUkWm9ykG1BgLTH0kZ9UbsgbSnEqWwW23sI4cVbDsyipUxKvjJtLAOoY5n0Kpo4Fw2aK0dOr/AgnkPSqea1pF/qutXnlfeQ0/P4ZTuEfynMDUDPS6pqjQMQEF8ZX2fRU5HT/hnPkN3iP5s7CxkbCexsSx69oyHAL7p5CKqw6SmYlvObXHEfyWWqH2/JRduRzE7j8IrM5AnfhFbcdQbXX51bSGOMlyzfBosT6pISqiBQ8baOi4Huc/wYjiMElfM9T9Xm5gi0DRRQOE+joeOV/FSq6raJM5wDbw7BCy8qe2xCTij2wAc9LegLdApQhcS7php7/95ruP0whptR690K6S5l0gNL0PVBmUDzgb4C4VyKLg20pK4jV3LjbqUNI3Q2T5Df8m8dFjm9R1UGej7fxKr0SivU05Duzsqc6N0KmGhrUzxknFUQcxNDTjaxBkZnM0ZclghiDhPWXnmd24aO4cIWh1KHjtCgi8gde9Mf2w5z6HuW2GmhmFGTsDQgKP2KDql/lbNDjntF60514HyC6HXV0sKD0DiX0gMyZlVAyl/bBebEWIsyHh0J3T78IorOkBfXynuI/5sWpuGhm5Px0RqZP71sp/C9O+EBUCciJzCCQYzJImlyDdgChUUdtDNjSlYTHLYM9eIjxwDj+vllPxHITIyNWSHx86hXBNq1hbj4QAzpcii6RnqBfOE5vvM9cr7KRa6PXcAaVimPFyLKHXF7ElkFQMlMwptq0jRLJu1h2BJ7wovyuT0Ebjd9is64US+7GPZ3tFS85IpTMZqWRfkytz7yFGBnTo3+xOHb8xblR723ujvSzGnTo8sRx2aTJW7iAksH8qcI/cUJgoxvZ7T4udXxFuiX3xpPtWLKKLctCXKmriVheUYEWHDnhY3IBr5cRZgQuB8nAuWVP8J3zOyCbzaNxwWdJg9dhCM/VHCIq8MMCdJ4N9XYLA/QhidrZriue3lcnelxvR7n5sNVCMJENs8CyITCAC4LlpnzlJyTjLkBTOviYYEJk+0S3Lth3/duu6FYBaQ0+34ZLZvdjeqzYk0xJo6r7nPtjga0ZEdcyh776/xqwZgJ9Fb+hcHvGFSrvYCexbt+Oa1oWveLAixYLIWdRjiwrZkG2N02ZjBRoMEuz2lHe9GUTo58bEtfmsW+7NeeEfwIrWpOFs1aoHcKFWslsSKPiVAiLK+2NuHY5mnluNIcx0/coebPCbhlMbQEMPhbMeH4/FnOq38WSkd+seS2ZBU4RO5WDSPPs3JV3d62iU8GvzV7pphYmNzz+KD/F09oFs4RKdes3KRxRk3nI6ez608DmaFKEBd2v7Ua91CLs0wj3zcyalPOYDD9zRybB7YKX8QRvc4woUu/4+Xdv2pJDwY1iFVFux7zNuMhGyahBQzfeyQHsRSiBVBxe3juWUleKElvPcMykSWqKVbSeBzcVj0+/vN89SnlQ4AacrB4MlSg1RNY4SrjPRHPWBv7mLU+r2iVOcUDG6XXggxVeMsSqrUQ62WmmpkNr8y1ZBQkNyA0C+5La1ZsTIyajjZRzTCm8xpnE1RUHSH+mfI+3a5rN11q6somJ2PKCWaj1yrvQSYUK1puruzn9QW1+ZMIwwdt4o5Akg6aJBj6GkqNMzpg43IfCgM+kPPQTyRnty/mRyeyPfXQ8cV7HHuy38okRbuAlfXEcz6c9WjcluwHEjXeww4Rp1/fs73z+kLHSaMzMAfhxN1S0gPUQuLfa/A2ijbnMO+avucCwqVTvMR7ssdNLQ3c3uUE7fUO0NjBEGD/bIpPsyAwQJ9VI6VwY45isYwjRV1k5fl9dPv35QYBkYG80Kjf7P1XAnW6X9MzXN67bD9uVLoUN9adMLk7CI4FvI+k5n+WJb9kgxsvsGfuVvbnFASIgFhNQCvku099TEIsW1QxXnw6G1Qa3fJ91x/wMAOUdMqRDxNlf1czM8QbhgsqU8NoV7pvGdcx9yaJjjC2yY+dvTFvblu35EWBjlXJuwN7DvuOkZVIzFvzIQjPxwfwqlaMVdAMqMpnoa2r+LU8fo0ySOZyN/GR5mhX1Zk3vLBqAOHLDV7tPqhjhzV58rCECh7wkUlM0y2SFKb4zUjPsIAoHuoy3eyz2MPHAlEa/Bz1oPxSpG+AuX7ieGlf0qY0i66gZCOAhQ7kUEY+PgVRm+0Sr7yj0OXyYfKvhHB5Adb83l3youEUVLJtbe1CiSFWiZb5JyFaFcIqYWtbFPmDfKl5rjhjg8DbArrsF64T48zxzBOStNiN/3sPtQKIif2sW7wB3Ye0pm2QDGs8tWOjuKF8rown4esVGL4NzKjf9jJtXsXFLD/AH9ohklGqAcmX2QRrj2Yt731eMwy4wzGokfvNtYBbHPegLOQddWNMI3vIat7t/Z3OpJJVBn9Mw6yu/svRs/SHYUj9dUkC4XnLjgiwHvAoYgWHw8cnyxvLY8N1BgBZCJ9h79B51/MkymskP955R7HW4kr5cIWu7CGwgFFTGdg/dFYuV48y4aYx2VNvMQgf06FH6Hc+VvwC0Cilj6myyIhYn+cZeCgCLkq8CKL16JW7hlIx3JzgzCrQBvGujrT/ZdPm67drXPavWumuVXrw1SXzy/kygZz3fflYzVYPzbEJ+FlC60EFHLIWS8IFtSAoyjPQAFinmxZru6B5RqU0QDWM2dTzAFLxDepI562sZAK9OvhHZEEE6rP6x4wB18JsHjUBMoEjiJ+REJzlybI0xBEYaZORR9PK9x4NCXJniTGPrfDAC8NlBbiYfB9D0BKVX8JoXT4o4HtSSZ7Z+gTukTAf9ixNUIVVwD594gCqw79lvW+Ab/OwRaDjHdJzDAd/d6dAeG1zW28u0Rtcraja+HbXlD5xv6k2z+BtJtc1TfLVk03ih6gUdyYdknKqUATbxSngKsQH2ErrgGzC9fx7qcrAqDM8+QtooDX1BGuRu5gaab/+ZyVT5kUXkF68yOm88brO1iGHpK88b95d99SOUd5mA2ewizfzF+gtTuwpY95/aFpc0H1iuc0utxauMSafpH4bCtTX+JES5QfjVmMBWtMitqd0w+EVN44mxlc3oD/lcXw+br9FR0Njfuw8PQ4hYJyo5YIXHA8smUhKJgiZt7pFO70G4mwmBIZ0R2lLJL5maNEy3D9tLCPLFBHyXVE/5eKRNGzyLuYPgxKejf7j5uij//DxM3TshDRx3uvln2epFwjxsb2DeRvx1/u4GxjFB+P6qEeEA+HD4eVRnoe9Ce10Q+Uv3cQchfsz4g7OwQ7EQRM2J3oNt+uPSPV/vnXcDmd/VSv06zz3EaOpm9uqe2fRgmEADjgtwZ+ar5IEmXIR/AptZ8hQtODzuvCKL68dlZwnSgYGA7uMcY1vQL/d9CSgOPstIB7cfIfCoBLNnYuLnkbY4XU9OhzZjixhkSXH9tjybzG7iRME0UUFDHVO5MqNk3FI3N3zsTPvzCn3DgImTWS0gMS9wk8LHaChGsQH288SfVLtOHqCmf1xeiTJlWPQywyHT0W1AAmgVNDf96jcxcwnILlUVlop3Gqzo8rmaDS/ojO0ND43iTqpZDKsoGIMy4tY3R05lXuIopqnN1Mv9oToT7qlHEC5GrplcHB3GjUm03f1kR29uPCzX0aQYn8tnPrem/pJbTKiBbSHpQkRP1yKO2E9Pyz2xCBRR0QMMyrYY5dh9SEIaetBhaldIJVHY2ROAxuhqFsMWtMr2bNz/S8oAd72zQSj+2Dts9Dy5WCX/YAXZ1Bl0un7FjrUDDYZzKu71wGyLHdmajZG8R38SRoUBMFMq05muN6gJk1M9JaFEPuFLASbkXHe3kxgos+kwHcqGqCw79IfNOv9TNHQq/9NLnDni9igpxWNN9y5LXuQGdoWAGwKGIwLkCFiBy12XQQf6sHlZP7yPJnZxjitIJ8O2r4H4wj11/47uH7xkXBXgL0ttoQCn84U0znPJqQO7sv3SvAuA1+vaJce0wb1ucXo5fj1aJIG0s4ZS1Ffxonv3j8M7XYSY8JiO6HH72N3rhgj0mamfzK/f/5QvzLgZBGJVG6MNm3UnncZWTvtagMJ87tbi3VMsuVfqNdedSTy5XuzU+Bhek2IpfHU9talhvtWVQY1Lpl/TGJac7punhTQ6r8n8mtyjxSciEPuNeI33qqkqnKW9pMnzEbNqO3pbizUZsZHT2VjOs479K5jdLrI0frzws+ak5UHqAfDloQPLdopH5hk9ct45P9Tb9bCneAnjPiaRJVVHoZNKVCUVS2LrNqeeKch9JbZD25bUeZtS/3ZWH9wiFdVvmTER+Nxr4OfYvsivMku3hDO2fbURMjB2PVJtBUXk/Z8+fT7vyRVgDWDFgqYHtWw5MGnx27ytrsDEzTwedNQPecR1eaniP9TFzeA+pN1J7Efac/A7ZHVAC3sQR+M/c4/tQaY2O7oY86t0YhKM+DvVJ5cR7DByEHVa9ggcEuxitzZ/vWVfixUMhmYPhoLogeVnH2J2sQRBX6Lq+PdBUV+z42fIk+MpU1ndquOP2/n30ydDWhcQnjk5suHwj0p6jl4OHdTjUbwd4WLpLu+uN4cwlBQtS1qF6YvtQO67eptKON0ItW+sv2VMSow2O4x+NTTgu/caFpaPSgEeXmWeabXPo0imLkJ9Y4M1kyOXgdXgySpZ8y2tE0RckoXmAGQsEHkuLS+f7D7OShJS6zqXhoPQDZGrG1GMp/aAAt3LChAM+t318xbu00RhDLUN1T0ysX0xxTluIJVfcm+xQo4fKzbBXC77qXHQQgsJIvD+Xu3ppGCHzRVVAPPwoS6L4MYMzCE6+sJB6QuNASRzwLZ9iHg4eKIOjAB6h73ejKDO7EiGe66T5GBgUqfM3R5VlUqJlCFs1QLjJdUgJM2z268Uv6zlZeX/0j2MZkNk7IODjXu6DWfQoXUxCQxTxep8og7Hy4HumsybLdsockpYvM1TE346R3GNsy3BCBPNn3WRk2RyjaZoSpOXXWNfhHNqRIp2j/9N6CVKbSkrCvvEVDn20tlyw36OBIXeOD2pVqv5y1TKhZ2GyATchI9hvvVzkJXHslKvQ54NpU7o8YCy281NKFFAglG/bl5z9Urr7PXyG9BOTZCM54ILsZdMpQIOhksiJvkdh4Ho7Ek6HjSo+Rg9KsKETa0Mozl8kmYd5g7sQPrwMpSlFu6NPvLlW91sjxhQsKFym1cgQqkN1BO94r4gLxyyZy2q67O3/eNPdDi7y4AgaekHQ0UL678bU6Wc472tabn20nMB2rBNqyDT1V7CrzwoKmGDM74h7BSWMuOeWKFMMhrVbBqhvbvbTWjRcitht2OjUZVLW54djg10c8idys/y7wOji280qsqeQKPKIW1i04cq3R4ljkNiBdQQXIumqMQxWbthSi0W0xE0n7+t8mnhxBwc9qz8Y6xhCQir7QToMZHUqqihhHwEhTu8zqDH8cQXNSUgjxcqLcPAG49GYON89wbLfOpKkQsjvxaC10kJ+Z2kJvqF0d8JoXliWxYehL+Tt9cZ9ta80CcD5viQy7neDRjmOmcjncmmDMLYg6yqzZyKn7mRuzEREOzxMpYSAB3l3xU+spqgPybmuDNkum08XZMeaMoa3sTDIZMcuDT0zP2nWEz60KoAUyxHpw8urg1HMHF0ucE3fGbjzriaQ/CIPVvryLIGZYHlq8i8sZwdkQZMPJBILd03dn4H2xx1UrXiCdBHdk2abEtl9LfS/Vxlhm3YbyHvUv/ta5aa1gTprIaRYhfn8Vba/D/X/31lQ8HfRRt5+rEJKljopdEbCjCHOFZMcsddhnLtZXpF24ArwftnHgx9HVkQ+R0OdnHenzU6smYLTX/3QSAVBusKIui+XweTUfbA22W8n0Vv1ZmRthZKx44GoXf6zZNyjKyJOUQo1Z5e3lHp4wsf9ytsjRP1dU3QkYSl1eclp8MZ5pMmm4HeDuFT4ALwt9qf84ojmBbWDraaYlyh+vnGRoxTsD1jrPv4n3IEYEfwCkDgus1kT9dGsPDe9FujdA5FYVft34KSscqVu9zlkb6m9zhA2WcAi3RPiVfnfXrNyqc83w9dmBHgPsBGd6S+1oS17o5gfszEKQraH1p+00lzqw5vuAGppQ5rgAUw/XloFeEqd2vi2+/wceoEMTDoaep3O3fmQMfDOhU5yQkgGvHw3ealPAo/jYElwNY5yBgKldjt++eANErPOpPE0z/m1yMO6MqlnO+lxQ0l2lZUL41u2k0ZIKlvIHTIo/OUkFwSONqD7temWr4O0Yu0nJZLJbsu2aRaqbgNzA5V0gQSQsgVpkr94zsxMFsHAOYNjaaKsIpCacHsKxC/7ypZYN7rT1YScqCEFpXV4GvOP6R+h2BzMMlywHdx6ZLwTQ2GWlvYE77wJFdengq0tUOLDWLByLwnn4UpLmBqSmIMhnGpp+qm4Ek4XPOnM5TipKw+RZRdG8VAwBoOl3OETKL03uGAnHL5TD9OwW4QbyGmAFjZslpKoRr89vZg8aA6397IBpa7BiChQAO7XEjURGnRMoCl07eQLITc4LBLQ18e4ihsp6kbK73DjsH7Nj2uvND6NgEbchegKmqbt2FZYmNLpzJXdiMAaHa/zmFGmXVZ5cLRmfcZuCs+YbnWCZp+xIu/r8RIll4AOAB77AKZNsi1JUs4Vx/V5cw2RvEffSXnkA9g0ckiylvD2CEq0GYltwaeJJjv0L8CnD80fx4iyjm4xyRsWvJHUs0bttuivch7cZOUK8Z4NC+QrIz2JRjd/+Wo3NYMBjxJVIgi7GAmjq+95tSvxvv7sFjKu9BdIBsslckYhagC0WHubf9gTm2ipqM6Y8ipJhd4ZePf+YyRJOKUU2muWiK6m/CAtnYUOpUhxsETFlLfhY/okGL9DHamJe+bPgJlxjTH+jxuXFuceYAUbxuaiIFivlAaFBZLkmzA8dL5dJ0ZSpaeJOtSf51ZGZYXMtgy5QOpo7b9m/KCmC/ztDlT9/gwGJV7w7E+mW4+QrqdbQ+kipuww+D8x/9p0HTHQSqI1DyygSRYiLMzYaq8nbyqiacwxLemnltIYzpWRLkZUVllnhIvL1+3ZASusYYHtjGN9K2rJchGauAAapPTuzczEn0tLwAEFMJucCubkq8V27/9dlqC/u71J5ZAkLiv1SnhnEHVNAWo/4Xguu1DEEZpfvZ0Bs9PLxDdsTyBysxtrnI7jjBpG8gJaJDGGvMpypgK509inQFOP+m8IRtxhJNI3DzEmV2+BX5kYjnPqU6eP47Sxkfx/aZhVXa59Msj4sydc59zzN7OZcTgNzWQbxiDDXQ/Z7GTzw8o9D4AUQORBQo4SssGDxJvT9uh20KhwkV+PZHI9T7EFF4oFSOM5Fe7/6YFroXlwFZiE9wBm3M+1RH0uoXMySOuj8p2unAt/9S/wteouLWu91eKFujgyS+czVsJtjjMtJKcBZmej+0CUQ+Cc9CIoS5SZDXzm5xgdyx8FmVtJ9pR/1uPyQqPoBqYI4oj1Y8ilYaAGjUj1DojQmFzSwt2sP0ZFCKRKRQ3KpxgQ2886n9S6FGQeeJFr6X8cW5X2KFADZy/xijT3s8CFwuCrmgCS5o9BVcmjw14HmG+MGjPpc41CYCU5qleKc/GJq8wt6czrjRk0NXT0F+PFo4mIzPSa++a4TTbRSLOY5WE2gGoX8Ah6ZRbJbqNKCsBq6vlzVCrC2r853TDnYlyW2ytSqUjexgQsNUJapaJGcMmy/Cs2YJj+8G/r6168GyEDD2INsBTAe6TjLCyS8F6GGXX6E8+7sBUxbnzQHT7i5GsxY6tCAaOfusoJtBqIc3ByyjdYARhJ02V39h1qsRqG7j0CLN8H9XP472wU4pcuJxTqDthDjvX7+w5CbspAACl+dMKe9vUk1wGlF9NjH7W+0zvK3xpo91/fNtiQ5B9IYhldRD6qUaJ1oukNHMTdLxMdIsStrmAgkTlpepGW8uvkvuRrnO50h4DN3jZZ/ezPnHOZ3+GZZgKJIPTvDApzHZrxKEQXTn1ezc0I+0HrYfVpieYru69ECR9zBJq0+K+jiv3tXhMmBk+9T+0KWS00crXXqHLUA5OVmId0QTvzzIVy/sqaSmrGDJU5jP+06DOb240Vz45RtWPZ3qoQ0ZPFy0eVSr7GoiYYGoy1kAosqKmnj+04Li/KCO4psnQDLjen2/vAqPfQrUCv/XTVRl+AfwhfPRPo3LnlNygJVxBnoWCRunuDz+cR8Va3n7sWMRjoJ0L8g910DBypiWrHEpTjiOxU9YwjT8VUyEunSPvZI5SuPm9yybD3GQA57GxFCMDgA4rUX0rJIN2UQZU84Q3MlNnj9frEmbPE91AI8kDWgNloTnm8YFyXVM0O3lvn2p7pmK6ZC3wPPSkmu2bHWxeg/jqddluNRBhjmfcE/4NVFvLJ1if46bjqIT1C1TeSt9JbsDFOWclbtJx28lqO25vIs7z2sjyHiywSozl7oFACu4i/9OUGfxNb5Wvr2gHX0h5r36LlT6wBKHsztJPw6wwAk48kUmpJPb0zNQ0pnX6iKU/BFzGnvSnKKzK2IhU3sIYZWQKZZqWvDZV+X3+Z5KzBiDJKHIbZG+R1sshNdHvlEg/JYvn6DBn6R0ymtIM4RwXyoU/p+IPOVA6V7kpvTkxSvaAdF220NALIfibJC0q9QgyB2fYSYtmgOqc4/2cN/kiiZIUkkYWzPnGpFNhzcED1zj337up8q9rnXpi8XEpiGkXUvOyLDpRHMlB01a9YzaLT+k44SlEXJcL9JxTCxcs40wahJWuTagRs0B+8GSGv+8BWTC1oRW3DtXY/YbGGfJB5dClpvTmui0yCkVPfxJl4mYZd2HjJUSM5BzOd934zBk2L7y44vle6WUy6Z5yE/cfSMd42CShSBm28AS+prRx+hivkI0fcykT4K8PHr5WjJgKBlXbSDtXxsFDFNZkit1224riqEUfNQ5f6Lj2bOTkNYoLODTje1807x3Nj7lna6AAG7jpKVUroOcBzFfdONqV+axxaNUMrJso3sEaKoadkjqPIahA0ZuIuerUClGrxQRcWfsANI0EMflJKzc7k8vnnwF2uO+ihNcb+uzeWRzogvFjiA7+8f7OhkAFX0bKtLHEA1mOZOrlhcSAM7VaTV5BZ3xCtnEnHVGc27CjumXquJgGIRuAFPhIZu3zzWr1vFxzkF4PjBfztWcCaO6lPTXC/iSCMDCTwDL1xeOlZFtgmk4ZhnjFdbtFW+BGZq3xssdqnQQFmUrAXKLPf3Rbdgsb6zRfOUTdjRKX321Bn9SrULdmT+RFmKXRxtgaFUbEzcAM1ByncE+dUD/sfI9MuJnFN7UsvmUCmjVRtnNdpmQMgQ+qfVYfK/AhSV8CFFhJilFoyjneg12N+D0IzasY4wOeJ/HwZMcBK1YqtZYFMYquLUTOFsZmt8vJOAqIBMUZAOGt2Fabo9MMej/rA2zrJ5NGEd0QbVTlP3OH9B2iT9MyW4HTDlWrVRBPnEqIhukch6r4Vvjg/WUyBZyFqJXV7bDny6gcdr7KNsjE0I1VP1Ldr0PRyV6mTsc2cIsFEXVmg4pLLd1kXpOjHHp0zjDs+wwkY1Xq1ES0sgSKG8arLPbeQlHqhylT+cTOj+bn9Fq2SXrsfsrfoBpgtWG9m7UcfCPZ3Qnjo0dvv/I8lgyznMSNNvuTYALGNpGFcXV2eFdceHoNK2Np2uo9wPLXk0vDhw0xWp/BQJXymE7+NK195XwThs8z3mHPmwe1MQzVm2lV+lyQvjsygYBCmDoQSYjJO5Tr8P0DdARBr8sEnDsa7b/jIo1lqsNciJGoWy6KTDq31FHKlJOryFpyVn4Odngrf3UjvXsQ7sFGg9lu1NLj3mqebkQ0kxFQSvuHBq2DJ1VHIMZR0U3Ro8eZ+DRsqGlr1dyl+qUeGTQZ1iGFEWqCF68IyX4OoxEFthRfLrTOXxyeecpmJ8h3eV7j8z2Sf/hTXLy2T1SIPMaPBPAV/oDrsg36kj4D2WDkIUGKV8lGj5opBWY/s9mra0lD2jhT570Qj2/Dt0Y5MnjmIYQTfgkd5+mrsTUaDMzHH0+8Kt2Go32FKHUN0I3piyhS8sWtdgpcpDmzpQulsBlFrI8ij66AE334exPkbN1tmumJPRyKtzQ3t0xm7n37Q+O5ajsjAgBNThRVoUVqvJSZRLt0pqkqfI0GJ05WuDgXyKnCo0eao5QZaU40Zfvy+KfJRIt1jiPZ4j4F1wE+yTYMc+0GdV3OtcS1PqsOVAlWMqJ8eALNO+3m6NwaReJ6dkNvUmCVPIDu7xQb7EBXZGqBQRrF683jWs3w/2xGNL4Q4hUAAnTJxPl69CGyCKTW/ny4t5vFbwjrpJsJ4BF/xHY9zXhydkYQxIFbOnu/3WuqWACj2EmdhhhHbor0VyPHYPp8Jp+3mS9QmUG/r4D5t6suG2RZN/R4edVvw43L2xUtEUPvP2He4NwrD1ziSy/HlPHXru/s1fvjp3T6x8mooPUQlKm5DrItCyMuOl63ulpa4omHxygInC6syPcWLXAap5Kt6DWP6fivfr7EBC0yD6T9xnOKHVf5dAzObwXHtv1dQncznC+COiOsGJd+oZPVSQXVbn+oMF6y9inD7pwoEmDRxKoa7U1BwuNPusEECCTMWJ4SKDl7+rvHNEagLZuhnug/2GdvWOJ9zUOKiaGtb5YTzSBjWt9lG2MOX1I/z091fFMyeTFLrKsoYPcJ0vtHADqlvnOX6mmKHPv6HgXAt7IHJ9Cqo1rwWIgSX5x3/nFc64JyVEQOtrgcIXJU3fAPgo6uy2gTf6QrS4G5qctklt8SrL1z5bagi9pIJ0lz00+8gVeGUOAYlIAX5dCfVSB2REJhqnFmT85iNCsb4RFz8iS/kryafTwwkQ9mkxEVDUlmuunSuDTertPPEeE0PMoBwHreMl01YiRj61THTV15/hcgqyZuBiHxpwE+nXAcBwOeRI7ciFSCYdGAaU+z+2/OlzgmQfQkCNoSWenqAFDmIe68Ri5Sa5zNCHslX+Qap8RRicui8Vclo3J4bsvQCR9eN399Y+UFIuJHDbqgsHPN4Vgql+HWKS22WGdJQLnwA6lpukIxb8eQl2WPmHm2PZzHDJErYHRSIdwzWqD0j4C7VMjOtCbD6u2Xy/3Q/qB1Dubo2EKh07Hyn6mVtxQc2Xm4ax5gKr81cI3YU2Kub07c3oAPXQ8VuZlvC1CG1jUsUQPIgJGQBqh3aMnAQ0Xpj5LWS0c4RQ4Z/km1jDPeiT4SSkuSvG3qCIvCrYUw6pXjWNKrPHMXdsHYMNhvmSq4BA2xMOwFRVRvMPG0M00debJZ4Qw0TzmACgz+rwZCtT7vrVuGOkUCEZL7yLH4IV//cYr3/gR/YdjP8X76lFU1dF0L7+3+RiYgxgMpZt63gEepWWM8//QRzZvBi0SymSctWBgyFRpGmH8h0VYvT64Ca1X8LiqWgLguaS2osMRpgLD1s2o9OVAgibCOzypabZjTfX8i+DrLS4ZPcMYbDfiLSjnUme1ggOfeKLzDhhzBlqcczIapXu8mMqOWLwIgeh8o33cY/TN+NHKPcUiPF3vzRjHMB/xcEBgD1kWxKvsl0skqQMW77obv8k15L4SXYlaiOCyd8cHhL4daRwnMjtiK8Tn0HjB1EuuXxaXVFVtNOHpfzYcRcNPw/dK2CnCYcGBXlER4zlb9GpBxYU0JRcrueUmPkCMKIFpkCybySQFySxY7eYzYammNmx7Te0COzj0ZvzgbBljr/Y47rJbrNjTCT+VMnSGEIxmfW+PNuHO2n/mqhSzDHuK2OxTvM/4C19Lg6fOJ4Fhmvxh5KjduIFKyLubo8mq9JD3XlzRMMF7SBbTqSdWmi4IEyRHKYjJ7mNO1NIdEBUuQgtDtfILOvNH5CP53vMTbls7WFKAXpmdNykixKzDwjcd1YbRj8Pw7R4I9Nr4RnNdcXNAyG2xUOkpBmPQgUfD/fBgTxh/OhZ/z6kKEVW6of85Qt4fdmARZQe2uCu64vtysyCVguCKbQeyhjsjWZn62/7uPEJw3c4wJu9mWwcYrbXbtSTbixQEwX+vnyMCuE8s++yoZAMk92Q5oMGyAQ8yrQ7bOYLOFjlcpIl2g36GsX7Z/EckxOlXsDg+q+1Ep6VlHIqd6qO6zlDdH6ajXF4B1MHgf17IeAMzrz7g4N6UpqKgdHK/1OA4e8YzHtE2pu+mts0YqR93xFNDZnCoZOZgNAViI6S0n6nUnUX0pBtRIcoiphVBCo/Ae0ulA6euEGdGf2LVVAKqvgjNXHy3HGF0GYjL0kfDUOy3dS1oTlg6we3awraysQMXEhzxsrlZM0gm1BM7YrG0BUHeiJASmUnaerbMKNHUG/znKDX/YVI75y3ZhAmQu3l0GtkWRaw/m1KInUe/1PtZKmAxwLRI/DMo8/2T2ob0Kd0na62l+7qDctWIAHhoPb5G4p5OJcWZfzTYIUBLwo7Ln7jeu2vSvkCfxF6n1gOnXoW12R7d5f8WAzG1bOZGGwjE/Tlfhmy+scsaqBUS2dNFlbEAFD6SVBCyt+chjtUoRAX4LPid6c4CJ8jKmpJq+jEOnUrB886fdRlnVuPsvTuQkzuct1v+jXSs0avlRpPgJEdjezTgHXB0Tw1Rzk0aQqFzHvu0TfhYXk1Hhd9iupB7U2+9+dKJcUTmoFWT6nvTXxmN2kHreP2nbB4ABkR3OR6Z4NHoUxVto35AK0up9z3XXBqhOHzGI8RNEb8dJhqqbYiAOrpl5lPkBooFe0da8tO83OurQm7sGGqFppSo/PyA4vmGTAwqUAgIkBwGfE9D9jot5csR42ghP8nBSfdWyCxjUEIULZkoXgF0VdLvom4QBsnH9e7bUZIrDLtWg9twOS9LL+Sfj4zuwzjS/RUvz/dTIdICuXKMHJuQb3N0CujvENbeMRuqiPJQ12S709p/48ruEltoLmDkeI5r8moCfxMbfKh9gCPKhaVpYUuG0x6aa7IPLnTHCH04T9piB35f/mW5WDz/LQX57T9YnSbcVDdCw0gujISfBEb1eP4ZCTd+lsNXbPN5ISlPNr5pVwSNGeGfKMH5h7XEu6SxY/FdX8Xh73gyOSN91vVvLR0vXbj3TyluOS13JbCn4MRtBl9VAtuZaLmBaJ5tvQFyNuLmHPU+QeP6DRro/S5AB9iyFrebLqCBL2e+MzSIM5J0oYtQq6GuDTyWbKQx3Q+HIuDCgQ5Zj0K46iqHEPe1CrCoFa0Eh+wOgMd/BXGvbsiTyxaxoxOAeK9/eZyhqvgBA5tcSR2VNb/Uolu+ZTgysyRyAyPk2OH4ZK536YFSXubXveBmkYohrgLklcs4OirbpDn0VNbUQw5Lx76GKW4jL4ZW1eg7BNtvwHdL/e9CvGGq7ddFXeic9uXVlJtItgbeQ9RMhu8dKYFfRrCy6SGBJ0F0oiw5PdgnULmPepH9u3b4R5eJqv3KTDljGLL8QC+QAa7VJ18lWyLeG9DEIy3FKLbylVyXIkyNBD6MSb7UOB1D9xplNRosfAHEIWqGYd9c+Y3bNBh1qMNZfVSExo8LUxTaF+4j5vO4Us5JiNjlBTCoMVWGHvCkgXRI8Y9qUM44ZVtNtk0CR/nIMgIVpW3w16GMRfhE8Z3wqLUoPVTegeRiPU9mGimqVqkFyn45bq4aqaWpuV5aCHsMMG/BZTxd4juTBO2CgAitYjotEV22UA+2GHAQ466Fo6ZtTv0iq/Nq/s5MtmSMuYI/ilxI9ch6BimO0OPqlyE5ZzMvxlc2+Jui5lG35WZCpEru7v6HJzjZSXNPB/kgRw/MlraLBZaD1ukM7LWTrum1R2hfxS3AY8mME68I674O0sR4AohQYu7tOLnAEES+olMYiKeZl0rme5YDHZn6gN3y3OGDZKUOQBIudKL+blXUhSmkiJ1l6xX5Jbq8OXPaMcF+DySDRyv5SkiDrLYvszUolDan7PJeCKR5RrcQOwoYP8WJ54fFMjaH9yKjw7mk8qEaeW22JGEc14Ws3XlEF7S08KwoqHLk815S17UGorrmlHD1JyB9rDKx+XE63hjB/C3BamJjFixdH4wZrT5W183Kd1nVWtR+iVGZ07nYYkklqWpZYMRO9AjqlanSp1ZORmYiQZ5M+7x6P64mRdNjY6ynXmp1PNwynjH+dZZiPhjJSgAdxmAuV/JfGV9pjCEIDwYhySIn5EwPStwYFAQ1EHNyFKjGgkaBw30qwNj2XsiF8b12md6IzwycDTBljJy+2xYdyCewf8E6qWQuNTPxhFzYUKRCJFWqh/dFzShOd/jT+vaplQxaDmFpZmwdb4ZYabE5n1g0EXhpmghNKXjWolgbZrR/wqrUfeIBnLxyQnj0UzkPW1apsyPSSfoL2EdLacieoQDW1KsmIPN0C7z9+jt5VdKJti0TZ9Zeo+FiZrCkgQ6W4+hlCaTXpyi3DDaUNCBSs7HOLA9yWcP+RImssGZJz/ErXXu72FSK1j0uf0/PWI1z52i/DCsEJZ/GUeXPGYh7prSdAxgxdKYGgNbOtmdKiQgreFurz+wXTHAdmmw5WZFmLKB55v4Vb4IThthu0NoQaXKK6ONMUTVU/sCYMqATIKSiFqca2JkDrBDQmgB9nIfLgmoJsn0AoEoXm9TjecCKij9iEdeu2ty2phSCjef69KUXMlNXaz9IDSC+wsMBzJjblmLeKAsTYEGY6OZc2M4/RiUP5Z+bGqaAeGvsoDo5HCMIkb5S+p0vPB05b0eZoblKO/BTg5DFK4gJ3ldr4I6XxW23PErBWFXUbLQL2HrIM0Mc7/z7daVHdrSNOG6en3/GOnZB/bulLbl3PXu6NaO96DNYUOZww7Qe6uAAnWYdb31tHeZSaxFEeUk/M2A8NVQqcPZpb+97gNSRcd2Z8cqqJzUjpCtuYxzUXKEJu/Us+4bva5OLpmiylmXZdlEIXbMxuWq/HrCGn/DiXTFyzfWD20xyNoCvVHcRj6qrE7AuQYfliR7k/6FDP0TJdzCAhowP4pdnYmel3kp5k1c180SwyBDH4qGkWqr6QB4UE27gSF5V18ens9EKgV0Yx3wpMDxrP/hKOeukeWJY8pM3qEsL851q8VJofi/VNHl6zLa7ngl8yEVloJHDLrFYZdM5TNySHX8aOGr9oVY9auaW7dUAVlSBLQeEGzLJSv1Rpg+NkXfKEVaomdX7nCZLPd4Isdu/4NrLUGNPEBb7wK3eBDsnawWQSHLAdkFMaVH7MyaqHqm4ycImXhyJaYCUs5VhGvVUrkYOve/bkuaCkvA0nw7oC8OorvpaY1U+bQxO2YRWVsQjXyzk7M8QSeiP/j1ZO62SJOtBW3r9gRd6FodmJvVu5A5VCujxDd/v8alYJn55O7NO2pN2BfZS3LG9RReyO1uq9TADeMOmGKFh8XdWFwJlgeBHcmoLixO0mTwUl7wsMuErLFU8zl37aWTR2rHMJqncrUOreXPxd03ex6jhNbmZls+40MLAV/2+eqF9aDcfeOJr5oTYFMYRHytFeBzANja1pIj9X8Psv/TtBM3ncpPf+kEDg66m5213KI1JD+iSW08Wph+cnH7MxNUXBsjm2FTqJ35k9Yv3V8b2kVxv5I90LruzEt6gQBbJNxs6ZDlk5x9rn3KvSO48pn8X9VSBvDSIB0+Gq04A02yHQ+QHNffNWhs1Vt8EGih4V+kv5RAJcvZgwZF+3mp8nd+qAkVMgp8FbdCZA1Cw0YTnTft0oYU5LB0UKujISsYm4VtrbMkt+xoPh666ccMDlB9S8S7u4cYbU3ctLrFtksZ0/fQyuYuyMly9RzWkDBG0BzsgxvFN7RiaZJr+3jPKXg/gBFUcki/fu9ELNleWwXD7Sb9pjwqdceyUSaBrv0koa4hoXAm5ocDHushRNgTqgzFzMCm954stRNTP6P9JkSirxiV5JuCGPuy3lh1/vDCL9PCJnCaPnK6gySHBWmtFah+CZtsOL7+ltnzSNOv7je5PrBxjpjgbvp0J4Ndph01pRaJokXpGG9+fZPIcZ/ta6v5bBVapMxL+whShixdSiNs5gb6Vm/Ib/wO3Bp7SQgxfyUIAUPrGWyu+OW0bLbGRs1hQR9mZ3naSG+pR2en9apGmCJFh2aYK1VJzux4AtRaoJ4qkz+MzMJR89Gr3Kgh3iKMBc6LxluI2LXWOAKssx3fn2cn9S0HTSVgmbqyFlUVNwGH2Osk9Pa5GalAoNv/ciUNsABOZlWGUw/i/mWs0Yeu7TzMWFgypiaAHlAquWeTn53vdt+tKnWU5o+Xtr0CoL2DJn8ozcPFFgtzw2sDNhsp9JnkH5ORXzITEEpOw4CGlwE+6JJ4FadPBz38K0dmOa0ziX5pyiIWvGU3lypKMycbH6K6Oym1iYzVx30ODu6HoEVuXJFU0Yf5A6+EzQ+pUIAsqz6Xs+qp5/h/xmIxVbYUKcfKM4lyG5uECAP0yi9MVlAWEpB3JYabwyXhOJncl/5BRjz5OTRxijU/AG/cn/dcQqzEvYOtCrZfDhI6sHE3aCmW1JEFSkCW1wg0ZiO4ijEaVwlEnDisfDL6JxVom/ySp0ZXi3j7Wl9wW0bGzXO6S8Y7/gUBVhfdXF/ukEmPlFST18Govqoean/z9UrQlLQ1JzSmSVIDRAEqepnOVp2Cvv6gHbmvNo7rpNSsWZviLMqg1TlQEy+EFwN/n0/MTNJkAIVGF8CFq9JzQbEpjlI0xciGgIezmMaIuIGaH+JcpwquxbahrNdOVwi28qL2Ckj/dPOMmP+Xjz1a68ZOd2E45kiNDNXmvMTB/ouhUhdPz9bqR30Ghc76j79C/iduuRxljG+BgEUF58Um9sTyA7cH99mR77zOmwNJ0qYCEOeH72A7yQUXXkX4z9Ri4yZ2uyXp7ysvxRcZJdqZ4Jj/gRK9dr+b7niJBTuWX4S3jZ2+Om5bAdS8k89QKa8sKu5jd0xVoNqgPlZO3d+BZTHWx9o1uDzCmdzebaam0Rdrq8jVtFC1dzvzUBKECuhYfMlRirbBgX2ZIa486wcs+34uuKS+W3fbOE4+WPW4zjhxW9PryOndjDcWpkSWmc5Wztryxpx+u+s/twyQeBdgpoHDy/WZ1iUfhSMxQGz88NZfUgA45G3d22xz/xNeB9HCDvaj1cRNLXTnMhLXkTKfHjHfn/UQnrjvCjD4y7K5Sgfr8YtMh3VsPO2hb38GRrmO0rNQtAXMaxBcUJCtl7Gia9d4ZmL6mo2pdhpjzzuqj+xUG4ASCR63Ja2QF3u8GXczkRXhQCXISpQWkhotb6XhFERILqucpOfwpA7z80QiSfTvfeVqVhheQUXhRsL4LvaswjDvOUhtL5bfCwe6+kdzh8JeouPq8rqAunhigifGVX25GT2blQ8+YQXjjcZGo8hNevUyH5Kks0tpDNxezMMhsInb4rwnQNBXOLilrBLdJLTBso6keHtZfXszWbkG//sHCF7o0JbggEMhrHNoNTYHIrmhBebZgx5qu6Nxz7UOVSps8vSYlFHc+nfJYM2ZThxmky5vk5Abg5muDZdR1sSA0KR8E+CjftFT5nGN+8GC9y3AejwR14dqGKJCL66n+lDlIBMDcAehSPJO7wH+CAwmO23lBX1fzCOr4AmPMilTR0MHY43dMYLROfGhlV6d9Ovz5xqimcBBo3jwlczi425/erVgXFIKduvrR5s5bTenqoXSzmcaPmt3dPg18RWVCR1KwbTWARMpB1DQi4XXnHRnWPflulHjnb3G5xxUm68MQ484zyN6aVQV2Lfq98RIX5vOaHEHbAJybtMWcT4OncIHbSpGwyVYfnJZnbZlNRjdSps6pSpR3DMkzodeUftOyy75eG5OD7um+6gbIEASWaDLVais6fazfst/piASJKeS2gtN036aJR3CiOrfijbwDTISw1iJUX7H3iOaveXquHJ0rYz9cIDvUiTBGF08qe2N6PoUxkbx6ag71Oj9x5ZLfgLxHUrOQc3gVyMU46zZsxyKg3EfkdojDMzPHC4tEnsPuk8qpb1AMrIT1qlQ/Cp0XsdxQrUJgj2CJ1FTuK0qOyT9vPl3b0lFGCfi5QFrgzff7bSkoPE0vo6ViaNcoiv1r7aHPffXGb7wZJxKmTayYjgJdRvLbqpohfpRsBy+eH5YCpM8gmLa6et3sWYpqgDUEAtNJb1fhkZxgQsJ+Ezge/ZKHMmCHAkvLW9jBQiIh1wDh8FudXbn6C5sDsHjm/KIaF8z1Bo7bKHOo84o75QISvh5tnhYAzidEgovc2tYz3j7IpZO9nHgbA+zxfSXMUWM1n7XnKF/zZvWSVMn1tr0WnbrjzpLaCGDQBTOBjuAN3etEiQpx+eNzsaAnSwxww0YkOoXWIMHYt6tEQ17tafYzFwvgiprDUGqwtfgkm6LXh0ZsmxrEP6Iod7ZF4360fNpRXlKDHvxN/sN6o99N3y2+gXkZH070wTsJmmXYMIsfeaZdNZWXWrRYZwL07oBidt4mf9AW1TfadU4B4v922Wzr4pwbTrDFHaXoV6N4Y19R/YXzsaEKQSE1rynPIRmNq4buNBHEdaHEVTTAoX+3+lowcjJAcu3BMAQ7s1VJZR21NIoECasjtYLmoWc4csb8YHH1MOwDXemtOUGP3wZ3Izl28lUVW6SgB91Zfe5hZwumhc9U9UBBjUV+WSwbcnl4QPDU9fV6vkg88rCCoCKtySRuMlJFFUWM8KOlXCUn0lnJh7HEn/3CkDhRkUaQw4x2ysYhLE1wrsY94fI7h4oSMhjwfAdJDp6XYT7uestd96C+jY8irZ3/QXlqWloZuUBU1vfVSmo7xnAO6dxllSGyQcDlTb+BhU55fQL7jAt3j3vjTmfYounjW2povC0YS52qwGMTfwor2Afm7AvWME6snvhlkHPZ4g5svt0WjuGXkwgXgHW4hBASaBqxrSBiB9r63rMUWFJcSdMgAiKwHtzwT2/WGwzl+xneW3L3N69grjFKFVJtapYMb/+ciN336GEp7pRAQmmPmnf6xnrUkOr0FUQgvL6o2qWLPyfDzXziQ2zkYChGnRd7dA+VWrhp5j81PT9Q2s4gz5DrvZLv87M5O3Jzh+vE9YouYi5lcZ7vsSEJo+OiNf0ErFdS2+02/xUhVaDqpowzy7eYbF+WaX8gL4zx1Q8Y4Re9ZfTgrYF0cQiRNie3cZtooDAymUyzyhXvEk1bUkSiCHWT/WpfwilE3BWeNxnA2YruWm5Y18Qzzbc+/L0xP+sFG3B1Nv++h3tr9eeTtfxGNHe1AG4mhrzjvAaLG4eHYChqzoprLMLnsWg4mRTIFpNqjfYgdkUuKKgg3QoDdoUne9oY5loeAKdyBTgUCELyfonXYPHHvcUQg9WLyxY3Cbou7HJl37IuWwmMz2y43EsF7FlrYhZd50CFG+Zm5ojKvUEu0i0tM/iuBJiTSr/MWYZW2hy2LhyfkwmBpMZkzZbevuuOnKU586QVoRSV4jU6RhG38kgWrTl7NLH10eolYzZNsof6AO+hB3G+ZVDzMPBzzW7qgXRQPIklCZa6cvd4c5RB9OSebB3+pHFJCzSf4HzS4sQDV39cFksq/zNbNT+5a7XlhnAaliryQO8IrQ36+rgOb2g8qpcqyako63Nexjn4lJGj40Q3z72rJrwLjClyIWpFgFmaiXXbeeu/e1a6LPW/4JQDjIJo0EJ54vB8hvbFJ2ON44XPeLDfq004IV37j6Ag+YrVEuXyrhuhh37XhXTdLndZMbJTQtOa4/MUy/RVx3JadBGghzhzzbCtdqE7gWaL9SWdgMpxtFbNE7nvqxgICEYZ58R+LKTXaZQrmiKTd7gz7Qkat3FqsjWCPu04QEBduTXoKvZMW0o0DrReOppXExhoghQwtoIDeZ4vujjuv/oRmqUuA94gfeHihD6q4h0Vhq5CqZjQ82dN/oiQxHYSoaQhrb868YRGcXr7yu7jHWtW5wXCrzs0LidypI6qMU/cVLOmYBvOs8UGN1rFGZq67H48+KRr/KQGHq6p5C0+S8CFFdtSlfjXssko5E6xmjLt9iT2QqIIaHFOmgPgVmdwPww/3oQVK7QhI8c6WDOFWNfoVRM79RgTnCBW2XEYABcTwomxzq5o6JPx/QSH05nku87ZBNInHMZWFUcm1029zWfIyaxxgKg3IL8Fk1NZZhHfG8z7quVqgRcZozHuREoEbmjGLtdHsFC8gwWpHZqTZXhUiQqjoj+SA9/kcIETBFyI8U8Eb4UxFAAVWDXHsFkJgBUUberg6Gtf+HYZYXegr+XMt3vxbLV1Bg0U8jBlcPsaBOVCNEHdfThG/slGFRm8Hi31ebaFK/bSs5WJfU8jVDVEr7nmF2UmTMR8eF9M6YqrKRvw42PZJgmtEusbVhexFZlx5IjlAEZG49P9FcnNoP1ZyBSkujpgU3kZUoAi2INhgo589FCMuMKfOUs01bcPo4bVq/qrcrK/cmNloKoPzreCnRi5z5tPt3TXFNMEkp0iyQ6HEy8Cw0HZOOWmhVm87CsW/jg8LJaZ3VFenhpjdEroOMMiLSiRHeEHOEMbRfTq+RpXmugQIXrdUOn/WqAeImOLEeh+VevU+ZJ26aBR7jUs6Y3gQuDQqvKsjyXvKOvp+dDqH+WUmr/vWSO87VH2G+S8baLbkgNk9lvcnwW0t/KdOUnyoqH9Y64SGwPJgp3PVUd2DZaWGJBK6cUvAKrDMgkPX5SvSkfVjNkITJie7QHPs8xLJ47WJiqmvl3KJY0T2W/bdS81+scWkEQ84D7aODR2CriK0gvEErhNqhOgwTt11/arGL52pZz9HEDXieAS8iXkZwTSO6k2X8KrV5h0gOV4fc02IpaHiQonDy7B4Y+yb3l5pxbZF1mJ8xi/gTZzOKb3QKSPKw8OCRQBDZWtoK6IcgpiRWiSPcSN7QlSUdaa5qS59Kr1aV+P1zwUiK3f4AGj06rXyotUrCxR2GHAF8ZXRXpJpppca8n0S/Goj5XLZpDydTP90d3w2vfy0BEEjGfOsAlq6URVwCC6XnrZAuOAh36O2BXWpZ5p8RhL4tQT+rpJLvDAF/RRTCTbQ+60pyIwuTVQG372ik8CVA5KQxBJBNfVV7GkG1qRECA1CNdIQ/9higuOEQD/NQaC/ySHY9gst6YP2lM9HGAdETR7Lz8fWmaK0CKGydhcrzJH62afBTlQrrQrJEU93LafuT417/rY5TvX11GerfgBWxxYIklop8jVeR+C5tkZ7sOD+KDiR2/QypT/fogxX6tmfVzyR2cql3HI1rH2UlQUlDQR2HP0aSawlT1BrFg90Y4k26CVw2rt++lrqalt1ZFteBSrmfiSML4Xf+IwanvetVPIfwFUoKfy/Fp7q7sDbWaYTfAUSsL7tsb5Z+En5j6cmgg/Kw9uYKL/0OzvNAfZYSwnuPVHjuSA5MUXdONBZG0rc98eJaejbJQigdX69YwFXLBLCxHv0nNPDhR4rn9OpJTl/ET9/xZTSsrrcS2yqokB6gx4s5HdgE2OTV91e327OIiaZ75k1I2NPPNnpZ+VhI9trGZ6GMMk3uYoWhEp+bKEassYLcirQl8qnDjq7fBOlVH+5n4qActdO3LB50DJMmme4ovImP+Gmn63ENWnvgz9kghX3chM8K1d02oyf0Xdzs7l4tFal/TWenhh1nNGQP+yXVxRPKjRBEidqJPRHLDJAxPdHSNjvgseZhH5K30NjwHaZvge9KeH6SQZba/ErQcKHDBgmJPlytFTSg+H3MhNlMN6d3SrIqjELK1dGFcKvQUP1CFKM8IZAEAzN4ClzrlqPZfM9sD/5nnICqpz79Q5kxugQ2lZSl21bT9BTLltCCWSV5XY/ssuJoTjUUhp995vWVOUCWnFgoSV5H8PC0E1nFFHGzz9fZ8UCPAQFViHlCLIFiKu5A5RYpZRSxIkO2R5smqdAx6ezAR8GMw6iGmH7go0i/4hXLM7B21aHVteWGWDipdkyyjoj/d8xbJUHfUYX1OiJ5SBJ/cS7NSqpa643XUcNGI14DZ1K76Q02lYnzYhuIpJe4apz3swr4NVi+R2ntsnzKh8YZF3SldGilRfZmfzi+4PngHcAh7siMPSLCqlnH+gs/tjK53R4jzLhvYfMR95QWCHEDVSRoacbomSVxUX+FtcuAEGzgmxcvbWzi8xjNQcZWhjLNRsocxFPYNGFZYaUObVCD65F0WQypB3yhboYT3XBKRs1gUleFLbBf15RISNJog95V/EV10XG88cBIpuKqg9oxDDC+GxetD8htv1512uE+0PqhzqMzC1tAPYBWx90pbBwyks1rczkf0vbDtGGlNK0Ps4e6ZXEFBA/vgJ6HGgBvlMm7Ftgtfmzj3YN5nCZ4ScgPbsa5kpbGh+o19ZndEG250q3FvRnd+8pax0fN6o1e0qvk1MQ890jdinUvP4kAcEwMeP0sAmxVpj+CnBRhWQESG1TAp5BWQ4wP2F72x/Zjs/OFosAKJfJ1d5rzChQfprojbuxTSAJp5QGWekQceuFo3qZc7SDsJCIy4EJ4lknFsu1JOEYnU/BzogH/o0zbiaag5d/YcVTId8/q9U6FMnHirQd4GhfX1iM/BLPiRJAo9+vOQO90U9zISY0x7OmCTehmDAAnYdtqt8AkfExphHGH0qJiabwLwsRGro34pwtsjuZ5TYquvStgL9INFbjO6arHHbUsiOqex5NMNTfF6ohlFVYJuIWxbAowt512U/ofyZB4HV4bK8n6vd2yJHwCA5uDDqjUuVH4dktKdk6Dxb94r2HuWNJUgtILgofCSNK/y1XgyZ2FAQQ6brk0rhE1qly03R1zq3No58N2OplEsf19hdExM69MrcFJmq0FcEfGQwW/Kqiwf400xq7sXm6RauRUKogZ5CWJWPILM8CP/S3aPN7R35ME7xQRYZQzKx9vHl4jN+REM0oehFbpADM7k0YdI8vbn0dzdbT9VgBBrt5k8mzlffJcrRQ+VG1dYjAs+Dr8fqCg1eb3yNPbZD77191QMtG2LZ9LZSXtA1foFt+/MGCQGJoVKl+pi9iTb68ed/B+wOMtRbJGWqCpkUmD2hKLKXsOky5fYLESJO8ZxCMhEhrUn9Pn2Qi2+UMZbcwOCoB9KZdvA9PjcU8uCnqXXCSxBuowIRn0Q5n1dwUodVEs/9IuT5PF+92v2Wks0RG9Vfl55jsGtvuogAEwGI82A1H8iXqbVNNh7YqsXrJwPKipSfzbXPJuuE0pa+PktJcR8t1t5PYUuneoqw5HGGob/GH9VJvMHiO9td6BATQy/iVWgn+2cJv7WV8G7CyDxB1ESCDo1T5mxXAPCT/6Cv4WaB9qkWJEkzUojOpDI3HWZ9HS3unzAluOykKfXdrm+dr9jk+TBIov6oGQKD+qCkGIFQ0vVclPPAuCoSHzYuIPYrmL344mXgORhu2LKSttDWY8JCQ9BCfVlH51luLmrc6D6xFq1Rwjd/q0/trmU3Wwcn6GqZu6rwgA3ODDk0MDjuIUVrmkxYyNDOKtpuOgkmL/uNHMAICSh5L7tvIt2fJEKexIKQbUHxXEs3Qh2GbbalS0paNi7BUZAA669ksDZNOZwDGEc8FORZM6edV0G9S2IPDowtlz+0wXf81O2LIOp7xvoJ5aGhBMaDZqqVuluYkbgh6kHVCkM9pNaJpVFLmQ2oglKVQVraxQjQNsM2iKrjBippEZhYEGW8aRNZq1KPHL+iwjxNJW9gSMqKGUyyJQWZjpthRN2xPIyqV8Z467utwiw72PwYzrWVPnJuuOZmbNyUZoAGN5xbkc7VC1HfLzI/3EmYrt+EB0PLAsIF/aDPCiux2bYNJMXM00KoNjx1kGlD0hAa3PZHl+JAl2cNIOB0pxy+uA0vfF6deslcg3FN+FdzaZCwbQbmYBaioeObZzufFqAaVB7FVNOC5mSfzTgpujV2HEus6y2bueSeNYdmlpVE0xnh/4rOnIAqxp0t7el0nDbrXDsfzYDiZPFSCqucdoT9d9+e3IhQp620PMazzqDyMioycDDPmiwBl87o/fwohO9Uv8FkoecBS9oJl9sKRYYE8g4IKAyXffr2NkArZDRhFb7JwksB8fJFqbTaoIcDHofm+u7Rfk+1gcJw9ffWEawRKBxeYk+JhXU1/+R9TCzOhbbyF403kMShZT7D/9qkp9iaG3tCYEUkftzajYbHuHkv68NJ0f/1mY5lR0zdji8lCoi2Z/3cTvG5oT9oGii5ri/PufY5oCAbfrIm7aBcAFWcbeBKkbZq2i28IsNnuape7euMGx98BLC1YOmVxmD6U1Y7fB6oej86GRmbWTQkOm+URBuZPhWaAa/EBfJdlJrjH2HKFiG/lh5UvDgkfaZeW2lrozOe578n6kLjmgA/6bcYftVZNmmcAyKFyh+1bnD1H9td2lDlyYmDI7GanA79tBO6U+beso96wfLXJ1q+8PmzBmv16n/mautNhqNo5utIvPj1lY0cR+NlpOvgrRz2ZqLFvRsDoGqEL9UmwGyE6IXnBj0yh0BOttfH2AgwwG/qmdRUcAm5zZ3HHMUmF6hY4h+E3tLvYeDkwFyrtx1oeu+sqtNzXLGA3aQ6J6dVj4XP+VjFbCE66pvi14IH134C9RCObWX3U78k8E/91oNF3WGcoiz0MXm5CcKJd4trNrIlS0R0/g3NmcGVd/KBFa6jNb0/XlRj+bl0MVKzoMaA447ZjsImSmq2KAzOZcYZVY9jj9uQD06wwC5FJFPOT8rX/ZDPVtW9WkvwLHKnbsOd4Uq5yFwk2xbHYhlmue8SLgOFAOwBfieE5cvdvZJs5jW9Rr6+xXrJBclt7Y6qixilEY3JmVh9CIp8ze2PE4ZGVd/yZoGz2selNBqoaAMzSvm3N2Pl59rdYywxI7+pq2BtDTQoITHNmpauVkmAwB/f6Vbzm5iOJ4DW3DQCfVC3wWI0uLLm3pGnZmx3c3V1VUp4rosjTSzFdDkjnMgqRiBnsWhnsQa4cIidL2ue/WzkJTRvdjNRZDf691jurW8m35rCHKX/K9MuYFWXu/uSGgzESCc6CBy2f4IWhj1QGfis4pB+dntRhqhpc5jc01cqeiFD7gWBczKOFaHS2V7Gnwzrh6Gqdhxu0mvdvxdGkP/SQs+v2lZFvnDqtBeQhDMGrxQamUxbiRFUSq9Kz+VfuSwYFsYYLzykRyRoL5opLgTKBK+tKwmzAr+RtHocjlgNy+HNuarDFBNY5/Ew239K2W/Qyhh8XfaXMXl4di6V4oi0cH4IqODWgt+cTAwhE4B5O4+H1RTnG/T3aEAuTLSQwAdhcyBpPX2KylQoZmA7O9/Bm5GVsrYJJnBY/+f9tRs19ZFnz5bjBkUE5KxNdMc/LLUtfGTMvuNtQ3qqtdd6yZCZbtkmeUtRasinx2BxW7toYTt8RyZerOESQKYov8FT5OgDAh6OiOuV3IFlCnz9zMVqYXPiCVvce/ox4K4vLpRyZwulkxrTYSPQ45Vygc0UEelvwM61EVw54sYWRWjheFjFJLe4NHp4G6T8NFoUtCrAXeRNfTuJgTDIoZ4uKSTbwDRiW67e/qsAovxKf/czgYm4yEI95sp0/T0XCv2t3+EDdull2h9E9RR73IxsgTLxLjrcAB3YzQtgKnHjf2l+HUf2xegjlCVVife38ZaKeVfv1+Dt29v1tBFBAAGF9d9Q72GVyNvLmWY1ySD8gnDionySzKoEN13kb1DMUnessvLt3Jb1IZCNpn8QISwQFCcPYs6rFdcTm6yGo1wTWK8k+mjx0L29bNyu1W/kOHRLQhwgCmp2nXWms4kv9FsQT+S9YoLSBmtOGUjyG4gFOPXx/sAVteFg9+7oaQUBX18uzpPGnqLEUPsVrL2m2AfsGOprqCBL5G7gETnAmmUt5jZscabkaqg+gvNNwXyxXYCYWyoP0SHaL07mUvArVkMvysX5HIwUVX483g0mj17ntDfciY5bTuYhmWlJs3vgCx04Tc2Z1MKkies+B42ZmdAAU0PoTb5KhGv3bwDxuKz8JR6bU+6XP2W0bloZ2qlHuyzESw3ZWsQw5eC92EsNgalhGf91CGnbV22zrHUiWmrvAOon8zfW7dYUvSD5xmVgaXq7XULXNw0yKqayHIFUQ5Uwdu3ad+sP/jK6/0kdBzvYh2Bt8rc5nWjIOFzOU7HNFalHR84gMYpy7TIOEdNK4IvOhYCH+v0Mgh1qiGatKXzSUuxlSUyiY/YzYqkeUc/SyFmvfsz8HzF0KzNmd9KzMGLHT7wakc2xtCR0oJHMUacx5kLsQiDF7gAr+lAqsexINaZ/Eq9+zxrFeVZXyYA5/Z4n+B9cbHqZ+Gjo8S3EnUUz9823O9Oj0LzO83jH0TYIPnYuV5axdYZKyzh8lV2gDgsuc25EfpXSDc7L4e5TMCK0qxWTYJD+DxwS531DXppfA6Fiu1htxmGW/dmzHmhmuQi2Ahbyy0Pa+cYb0TWMklrsMMivaTkwq6Ho1t/af0G2g3R1WYIYv1SoXzaRuA2bVH5Zc8m1CBEZlJOefTi3jqtz201QEIHklT1TiAzkOu+P3fqTmHptVrvX+SBQixlJ/BKA4j2s3MoqNF288XCcsccclmI6ywam9wA5JiqLrx/KwPlU3lVlFDxp/9reBFw67gFq7oQx+hWn5RJwFlJAHscOlaYspaRZLaQ+1Wznv/3V8LkL5jsUg2HUYZGVjyqKeV8MTT9sxXtAJUsNlVEC+kKdb9KIw4nBciRafpzb602qwCqpYGf8nTImuZu2cKAo9QQanJLuOxux6NVypeYddXjf5spoN1JJy4UPLVVSrhUHicIelEMqeuOuFwhVy84YSJ3Lng7DMcWoJOuktcmIPTleLDSBiEtEAdflAmomsV/Fi7ktcOwJZZx0baSK6Yq9qtjnmHbEst8Yz6erBwkVnbNuWKEDpET0BiM6et7ougzfsPXpl+dXdYDwSFZvnkOrBQhRvLIYkvFXJ9t6sJ1T+fU79T3B3gLgr82yueRsk7xn3ruO6urwuDcnIam2AZn0V7Y0OFWgkfSNGJhB5YSsflmc9BVJQzB+LOa0RSuODarhXdxnoQr6D6Qw33VJePwpZTfiTM6AU5EUV8Npxvu+3tKVSPW9vJT8FgAYxDpsLyRo0qP39UbKJ+fXTGvZ/5A/XHYCCMcGTesPp5LtIxTDGK9v5GYXTT25l1tuofW/N+zazrFi5b2uuXaji8IDBxorPcfkDJtdF2xYfQUiuzBRbKBErrp/O7r8nWx4kpI1O4Fzfqm3v7QxwKItJrMqUOPn/hHSW0c6k13hXqoZxJ4XdRQXbKA8NJ9YYLbxo4PCiSj21IvBwIUyNXEdg7cNbV7FZ0DeJPhv+3eiu5K28B4MOUgq8wqX70i4H3TrTSmajKP3VDtVl3SELUCEHsp/gmvh2TTJc8dIen6irw56r1FSuaX9PN4OUCUOYH+V0sSoXOGogtMaudiMq+M7lUF58ipaJr+TqJdhbtujemQ/qjk9GohWX+JDw+TzuaqIqbCgGomHTY/x3+61GWzyWFWyE+sz6KCrJKaGDl3z/M+W16usAOF8ri6xHAYOUjvvxhBwCWLKi029pABJ8T6Lo9h7I1agtX3UtwLN9N3AAI4/NVmNCj9kpfreMZJOC1trWKjCpSDAb0DQZIcgWaX84YM7MpQ+BwY5x30QCliSD2vo8s9TAE6CiVcUw1BMJXzZH49xp14KDLBXlLzfhESnZQk+9vlEi+MVK7QEhLz7QN8ngTRKyL8HsQ98SuISYVdAbaqp0QLzX/LK2JRgi/Z+O5nR2ytJYaF4nsj167Q1QFN8pptirbqjrNJfNK5eaNLkAjpEpG6ZLpZF/E64Xy65FclIRNIHfXsfsggF7IZbrblf0221K0idqUkS7yipsTCEpwj2/kDRNguCrY+G2ttaC8Y/0MFV8tIc3RB5E41dfzU1Dz8lV9U6b9gEMp+EXwB6xUmePC5xm+WxSqEGiD2VVvPvoJq0gx2Soocw6VtixeTpEOIsG/mugIi1p9WVd4SxJ/f12YOWqz7iTHTAnyhkvevPfYj68TKPIx/26YxHYuO3bkaPenhDWfl9b/dPOTuWXRNedlRhBV9zMeeAj1M2wcXDZWyJAg2Xpd308RJeKqGicDNsG65aFI1cQduJ+/5CfTDBftRjS7RmOlgJ+cEvJbHIAZQUfvrzheaP6crARP3V0AaFkfdZ66wWVg33/qmSvkooK8wUTUjmQtMweq5pFMzEpbkKEl6O5Bqpg2UYBxCPeE9vuYb0sD5NDvCO+2DYAwU4E4hYlGnWRO0u3pvFfcByCuSPDKlldlyXxV7rRPX7c/RL6OXVoCm+eNzrOnWhchNS1R/e4urKLBkI8RQ/+N+gUsqzZREcyjC/oXaG1R/nPiCZnMDC4lWKp6mIAtNxwtUsWcjwkerSpWy3y73rmy6YHhzpkftkoCjqdzwIXoSG5u/VwcxDxy5701KhcNLsC2Lgvc/wvleohb6wnjoWDRytoBf3Z4tpxq28OdZRhqc0pcRQ/RXFmoXiP5ksBswLIB1x1S+p8Ajp68mVnYKXVWMSK1T7rm7soowp34B1aR2mRgY3PPxa8yrOffwY+aQoKqfyNyfLOVU8xe5QGoKjzJ+bnGY+4m8iGSxhc+rnZU2yPk02sKuBuqTEvbmSrmtP4L/ahko3m2SPFLV8SUokGFXxifin2DayKDBVnEkxp9DSIJ41/6KEFvW2AnVCDAPgc50HUTBuTx12fSkaIZGUTqOTB+wlnanfQ3gpApf06W9f/x3yG5aDa4u1Egmb48arIIFsdB2YLO5sIXTcSP7va+WoV4sLUFsIqW8G1X0cqqkt/2FbsnON79YT9QDn0BnSBVkE5/eJ09BHvw+LXIivw6X5+pFkzkd06fjUrYKy7lo4n3ZwoOqwfdG7w5ltZrQ7cZaXszNSZiULhZF9KZYy+ls1CiNOaIco+rTiDPkGzdwCvR03+aF/Sw1msrv3T/YvT2HUMwxz8CwC7tmzH6hVtI7Ieex5ra24uyIPa2hwhA89e/uDpJuYaK8qekb5fUHQljd/F7TQjQNmKXycivVRENtedOxI2pTNjFzpRJDG4paM8ckjZLvseLkeXK6ioWf2GTH/TILZdVFBClodg/eucNXrzrJ8qX+HsMv32oOkflJq9xKMlGvriwWCeO1IEZnoZYUxQDCWxjtE8doY3g5wkrg9rDClSt/TDbarynvj0Qh6NBGodgIj8141xNTnvtS4d/f1ioB5FmM4DKJWjazS9bhBmPudxYePZFTwBL1lb+arVHRMQozltKC5k1697lR4SMHKHbupE2XqzQlleKBnvPetj9GtpCro/ecZ8zhCoyQBDnvLQoB/2h6u+nbMsevXqbgx7RRHQbzHeRZC3WEwD8Ox7pCdPYGkKKBI9sermZXV4xWTaHD14VEnYMKAZ+FwLtTbbzoxb6V/KmbR9agtFVkhyRNimavmSKLwHksJEnjq782E1A8w3oDF/Kco+l5Xfd6TLXPxR7kr63Hgpb5w6TqabHKV147CWvF1Mx5X1H2abkR12TbVyTiIn8aSQagxnCX2xnEtcggLcvZoQ4RYSluQJaP17zfshtoEdosgTFuVA9/V3hKQcFK1ywxjKjgU+wUZdUOUi29WQ34tsJ08C8oyP4KpgH1WBejTdpolWi7OSrCYcsOxc81Uxr0VDziG/6SdK0tguCjmadAykGXQe0VJJy77j+inAwSbJAG0W6f74Au5zsTcHv6xMSMBrHTvUB+UITQTlHtq+cGauEyTAn9FxTYUoWeO3/ywzjtfRVH8g6R8d26ur9Od5e9Nyl2gSZyo0FHVcq2Awd07Ml2dFdwU74eay4X6nboz0oEg4teb1bDchfnWtepnNGjuZHqq31OWiEChdJ2RNKFYncxq8D9VGzvtJn7y37hVJC/NG130e7ocTvfZof0sQtkyOEvj762oQviy/VHcd1jNPlBtzL7xyPQqXgRPcpiBibMLh32N3+EvS+cwHs/SdMO3qd3er/mMcphtQ2t7bOsnsQW6yv1a5rofa6ZM0JxoRxTgpr8t8iUd6s1jp5eTjKnJrB7EGhJckabxEEvMovPSIMfmD2qqiaxwQTEt7uqz/ky238jUUJJLrqBD8+tIXYfqnuVZlpI1+aRlaQ/tcIgxf1tNE7ywMyRdD3wWhxapDpw32zQK7OrCofBGhCWHTlXLHnr+te065SiB6/ngZAo6R10fMXkxuNpZehQNU070LgiALFhYFamEfqr+RM4IWUZeMAbIt+LiV9CwsIGSasJLaZIqWzzQmBj7BUKckW7FUXMqfyo9E+cxUx4h/7TcL6IRYj8K29NKrDood0IqPG6VVbXBpFzX9ALNDnucrQYalcT2QQY+3B410+WqZlQsWX4AEpwe1O68vrg3bbM8mypFlY75QjtcoI/k7wzwH/nHyaOiX6m81z74t5rvYOuQCpID55OaFgWSeNuM4he2wS5C5Dx/kABRTedECV9IA5eN04RPxa4cViY88h62DtgAkOAZvl66XdkGvo2NRnc3AKgF+OphBeP25j8lJ99Jgc+8ZZwiXOYKIMoRwpqhdKfKIvkEMeF5JH4PdbnXtHvN5RP8+K73rhFcorpAwrGtwN2Hv76nmBdEAxWL3Nn5ZF2RrXlsy+IXBddDnFLqhNVDGIw0kr6gyTbb2TSK6J7hQQarhD29AIHp8tA19AWZR5WhQY9k0+QbIxUcT0TdDTUVbkBpT02j67YJvvhGb5kSmltP8rOh0kdpxgwTqBm7SUqZXY6qYoXyWn1LxYi3dA1FyJMDUa8iGuTxe5HRyDnBTQCbbeeIGq73VFAlYE7VrAAseLS3DdR6v979K46Ekzf+1sAou2JQxoDr9gnqrlfFLt4A6pcy6mEtLMCbN8myMYvpkcwgxb8xQJYtGLm2t3dfuF051zoOYfOhJJ1attTJg/wk0h4CGxiPysca+pNgYUO5s1sbxLq/MMQnfWBkBbJxyxGuN11Gk+a1jXeRZaocjpaQgSFLD8PYcxRWUwxfAy6if1pIF63knQIl0jRJCHUVSzC6yjk7jc2f7vRcItO1ZJo5JdS1xFlyyeRXlKnp5a553wM+6LeFCvkVI0fbHeJz8xlDOTRVYLPMQLR20axVg7mK76vcGm5Y0b1tuKhqbezx1jhMxnuf110xDyYp1WpLTwsBjXL/On4y1vqS0HX2NauQbeprvKsPYzIEJ3x7fvqS9emuiO0bUKVLyuf8bO4A+LZ5Fu0WGslU4e/8HJozyCaGuJZ1+0717gTGI2ISgB3KJ5Wn/vdP5KbqoPp0NYhPebd6IX/KcAmbvlkeDE54tDVuJKs0Dnkj2k+6Umj+xjLY7Lb53V687v8nTSm0azS7e/1P7g6hqHklXJVq7v2QtF+bmS2ImZLws5v8Ct5/RsuJ6UJuyl2UcOmY66BiI2YOVx3Ret1jRcfLN9knvpqPlIp3F5AkFsCoSjEPo64pw1fR2LYwqpK1H9T5o7cxfV7DtVSFPGw9SSoMH0vV9xd7TXA4kioVP9Fz7WTNl20wbRP8cgmMxHuv0K5Orf0Ao9PDIrn2NuG1UKP4zPwp1uMqxTfXDtzy3FBEGP/2SzIDWSP4rSxEz9mp7spYFPOe8eVbVC7kPmilsaGr0WLWsFcvQtDlvHGjXvK/YZOdFds83+OrlZKxINLvc3vx4FNESBOiDPKZVP0LFISArwzt7cUA60KqnHLkwWLClAp8Y5DMe0e7JBj3pNbgYQweLyMsdC/+U1nX4uxwHs+Okz1IDzoehdy7ybu7Uspb9v6dkkE5QCvzTJ3g5edr5q8Pcq+hhIIDf5q8enF1PdqUYE1kkgN/Mi6ZxUiPcb6fUmmOrefj8Vn33UpHEyHEql15nG42O3Y1ztQ8qXomdFGrfzKXINB/6ttvcayKUfYvtokOHIWAiU79pwxZekb7AsP4JW4hMbtnAa1av/aCPQ/8KjO+fc46xGLL56q6O3QwF3Brh2ywgiTtlaOcCE7JgKzyPIkpbWPS7ZUNqRK4w8+EigJt76l4IL/Kl/baxnUt0Jb432yRclTVRYv6Hg8uYSMt7Jr87Huxb8VZ4PLYEpHAcpUddYdGobVGouK1WExhnxUV6XZy/BjWDvVyrxKVQLN/0xoGn+aKLGmCyGzV2YIg6T57hHvropEz6auO2HkgAzcM+8kejoerq4Gw/J21/Q2txgOJSV+zA7yqYxnlZmRqkfba58oDGDrm9JVszIXle7XDiRr0zcWNzHV3LKHRRd6jLKNoDwDED/iY9ZekBtJEj0ALpYaIKxrQN+TWoTK9ccAUzHvXa/sJaNBAOPaZ+Zs/Z3b4cpN00V8zHb+hURO88YwPX1Qa/xSQP8LZEj97klVMjfkoDkHqwQQj53nRQ3fXDkvLYeZP78FUrYrzoZWy2w0BS4m1hMcVeuUF8cmpx55pAXXTi2HUjapTDNSO+qhZeFoXJrpl97dJweEeiSKENcDWucnqJCNklGxHKgaZDeY1HqMXKRgh/MVbrPqbAulFYSeqOsBaBJLO3Cp4zBXI373oypV6fILU39azuuK1CXcGflJJa+9YllJCk1GPXZ2m7RoXZSmVh4kjYYonksTDh3dmkgrgliSDakReImJj6gERj4PUPogierV3arlh08xMzHUM+ppbOAicMUYNlqH6b0APcsb+FUtj39IzSLVOWI3xK/VaoIVFr7UcXmySRSq2nCA1q8NDr2M8Qcs8h7p7j9dG38VfBknDQF5fdE9r5YwA9x4IhHVRLUvtIFZub7st7wTif/Uxqot93OkmXuTYZftz8grSuSwhLUzTBSO418TLuRCitF3/vqEvXMx3i6qCxKH9nU0NQjQ2HfkOsbcg/8c5tJiMqnNoRK3bxUwnMSUBwyoOfZ9YR0Lb33PEYkK3VFDaqvzYn7R1ZrSFhl3s9xksqbZYqm0btg2lOQ2JDHxD6Kc9eFdjGFxtgU/w8pmGoEoujx+gHYsfeuFwzcsK1qK6vEPiLkpjbk9syKTP7YYQzvPfPgVeWBT/Kf5a11D0AJRcBETmw2VNokH/cOStF1b/2MwwOOjAyE6/sxQMo2z+MgPp4lbvyrVaKxyphboB9R4ciEgZmCB2CWnaRLsbY0+L/qvc25tArjilTxRXBuc9TMWYg+cCRgihqC2H0byeMCqP/6qAHGrzQph/sjAjCD2tAfu53MjCxc/g3rKInAIFzxsLLHTG9YmhPnr/nGgruR8hx29yJoNZlBQDl4rxMipS5JP29YqsuHlGrJhByvwscx+S2d8TDds5P01d60bcmSOGa0/Yn08S2WGZpnhO0DPWHqqtOii6LIDNRUAjxGyqcCKI0KBDLWBH3FEhy6A11gPT9W9xB9VO6ZzwP+afyKwLMVCkdGBany8QgL05KaAvokdHgppa8REyQQT0Khb5nGzd1ww1DhmX60pQoVX1j1bv+K99KL4TDpFRAUg/I88rNNVtKKTApbkQoikSIefJU/n1Epju5I/QxLp+GA/0lNR62OyYLwzZjILR1V+6FaKu6pwI2hcvje++7N2m3ktZ35OTX6TILXww6Z4+wvjrIRgDH46CzAb+GmYoR7NMYoeQktVLtuZzWLP7ScyKZ88Ozo9FA5wX4vIXbjnXyS8D9SfVoFHY4xsH3DHlcGy0IfmQCRg2TPjXegmn2v0MsGCJjWWivniV3JmCmKGWSgkwak29w/4sEhktpjaAY/T00s25/ir407FYMrW7ZhLtnKWNV+t6ntnz2PgLpiBPo9GZFCYAcDcZZucx/oeyiUIXJzEDFipSSfxTeuY36SZi5lPBO1W9w/X2YHHNVwYqQTAWbixqZzSDTWUSnDztDHUShbAYFffv7wFnV71AOsmXKT5XE/g7vEGsNaoRmMk2g/rQx7LIIkg2B/p6arw9dTUuiJ0Q9wRMO6VuiE1x32TqaO8fEJ2ALLjxjcN4YdFz3tZumyuGWn134vkpOw9ccX4F8K3DJKY0gClD9t3s9t1JET3E21+N5YUE2F5LjlPwx0MjpcO/rRSi57kiX2FDAM0o9dvWjQcnlBIPqeo0Uzc49Os2vGNi8E9XUPhxkg6PuNHQe+gGoVpx0Y/tD7FVB01zazBJ9xVGFyuxJoEw2uut80H3dlpxs+COIVYWjMSV08FSV9cUwhyl7bO/nKhUj9mMP3PvRahUJb0+8bw2r02epnOk7cPm1ydq0/2bHg05l7PPtqVHBeTFnd1Zap6iMbsAPlDhSDqSqkORCb9FYUhTFf1JQNfuvCAtpdNw+LKFwBnMbPfO5OJIbAwjGbBSR14RROwynbkE12KYAEzzuSNfrWG/zJMRNYw8PO2yltcexKjhKDnEVT+4YiL7XOB5ntJgQtp4GOOZM66t8mGv+GtGVifiid9/WbPRmoY4UhHRVAmdNUaQ6znmLPinxz2fwCgYsrI4mVCCO47oSBjmeQAy+rHdoKBQH+XXmxrzS/3eksV9Q2nAlLj6Q81XQuwhpG33tKXD/KNG2szqARLdeJvESsJvSu1XhUHoxBAbiLOz4HcqZv5aVMz8uqATfj5so/C3TPnsH3ongauOWbhfStOgMGUO4IRftlx2c/GMKSixOn4BB29MI30rrk9CUDeEACAyaiVSETUo1Uour4QCSBYL08jHhIRAOQS8v9V290xM/URAGcFFW7pyVD7OlVNHOfVXVQLX7nLd2bBOkzmc14wAeKHpTDo3YwVqDaFuuXQHfBOepjmM3mvpOhiZhh4Vod4KKluHu/zKK0/dQlvT6LcmT2pZ7PrDZP+vPg67ExbCgngSw1s72t/wVrOs2SBrmeT1y9M0uvEnBwt5yYsMLjYRrTs0sB+tyZFaT02eCRLQgf8Wx3xPxW69wbiBxldnC0YI01yaSlRHqbNvK01CNM0pRS7CM75hbNFgeaPka+XqFhQVRvTLJ0twAULQWyVlE2jsXtEazJSdEAs1cZ1Gvrojxzc/1lswIbpwf1IFcXtX+p4FfbLfcexOwO5t5UKScHsoRhzJSdY7CwvqakCNB5uzBn/RqRxJW6KhIXdeDspNYa9dk3WZW+mw8GDqZK676tdnaL6LPvh3Z2h9U/h1zR6BOFu5/tSOna4olIAiaRDczLwFMzSFlXgMQBfWl54qeWBqGeP8+Uy3pDILize9U42lhEmrmcEJSrSx9eiNxXb5/MP5izmNdkq0bs+TP3aOViGkl1FdaK694yg0RCWoIQ6S+sA3wWEfheDoAcxltRdbkyK8IWo4l6t7CbFEwYOxPWBF7lHfztmQC8Q+0d4f48tV0LILq+siApLGDtDrVCAdzUCc5j7Hj7icYFVouCax+Q4hO7ULcVpi3Wd44e3kzfPdjLD5CwegACaQfbnxeh8zpOTB7vTft3DOsU5mHGpSvxUfJBNF7y4VvSlrjf984LdQ6NpM0cvd2v5B+rOq7bJxzZ5ZP1m9fpLYtiNuaJqO2P2gqE0dLTuSg6Qc/IwXlAjuSWHhE11kJwaa+SMUj/bQrbzzr5/3v0heqKvlZs5PVyfxFGCh5ry6N9wRcfYSBwNvlrSL6ohfWmBdLpYxvwbjOoqA2RY+Ul0h/M4jWCHumeS7ZIbWH45FB1p94tqJpOd0AFkD0w9vImE3DUNItx3AEyw915wNJrPLU1XRWWnBqEugvUSp2DZaZgFJB2azqiIrOl4w2mepyd//XZ1p3DshsTdeRyULwGxCWPX7KK2FxgYBwhxDHdot7lUrRkAY8LFvJJcg7n08PgxgmPPghGXgE/u2F9TXHQSSEmPdLSTf06RTR0uBHkFycrUFtXX18XhdZQqokdZ89P1axmxLxvSQDO2CePjFCGBEBefjt+Lh+1REV+g3rkvmT9dNSql04Va0W8oYJwH4mViQrMufZOo1Wl0x9lk68JKm4MqI7QHjzbRw7ea/oDWf8FHD12+Rv9838xO8p21SAuZELIMSlcmiMHAxQDLWOVPObiKPn2Ntp99V9fv1HczLYs59LvGlgYNbLpveh6/9g7eS9dXop8jF7+6KGjBRNm0Y9UbArKJb6KvyA6CUevkZbmwgaNB/eb2IGYCixuZrUl2kC3cPLsF/TI5I8Trgwcee3JrKEm12vXrlLV90Jgax8XrLlH1Xdz+EfoPOGdjWedRD+r/UHprIQ8qXlpGFzyR/cfiOMvnOFfJc2DdNkOd+vgVFgS1nXOPhB/2giLM6jh0qshSWqilVpS0JNUzNkOIcqF5O0i/+Oo+ZIDGLmNAbuJjPpiirgqrvX4fudvW8ZDeHAy1m12I5SBUaHtfQw31L0qIWjeFsHInt2H/mVo3IrgBaU9Z5fRYEtatVZZmgcyySHhLhLprsne+WWQCbhkFtc4+sC3cy0pddJUX9mdS2GFU0IuFIzR+biTCZK2uf10EjaEVZJ86MgjAzEqHzp9kMs60MrRwDOCCFyvaImnA2oCYY2925Tk5t4m/yn8dft8g2HGM9ARtD6TYVJU1T2w8JgnueTcZAXqAeZvWA/3mtz4Gx0on18zHzcLOp+HXNgNwtPVAPJNFpKsalvqikMn3+ahHQprZSjxex7dGFbAVSbc16T0rh2oN1VyDY0U02mJ8V3ZlVVRKd8vKb4O8B5pVAK7HOQMwfmuKq6qL43dqgsy8HxXhh0F2c1qZ76TO6ucyiFo1uZRI/ohb+V5c6h0f9yBehPm5dFT2w0juRR07gIJ7xwIjq/ehT4XJ7GFY6WtzsbVUXAUQEgYIn0CbSHan4k3a8bnQMMReW9Og5NMi8a1Xh9NiOPzC7dZw7fKrf/Gj72NNIfedoZnbQmJBj2CwaBB2btOL09kiW5EZEkn+s5vLbqLGElBkC4mhe2qas+065waoHHke/x40kHqW1hG05N39TOijeCBwSXUryV1YKoXPGXG0/R3811OXBBdHQYs4ZlHCynUN4Cclw8EeWkthdeyXsRdBwEVQuxDdIGcdsj2HtIhAXtAoOhCg3LGjchc8e3voeyGg83nxjchySK2Wm8dcPaA0p7oknSN6dglMOrsnuV7RWZedONJYDtfMZntH/OBLpHL0gU8TpagcTnqcmZdZBm+AKCyF5dnzxMfKaZLRsU0OJeH0kNLDo/JXopA33vtO+Oyxe77KAYJjMlh3TCe700EYYXc1I5+inLdRTWMGJwSJRRkcSuFJlCkRpF/hRmm+FBsvgSY8NbrKWsUxMu9ca/cG+4eIJLRgKnAJBj4JkZInFBDYjhTL1TjJHHD5PcjQ5JyZ18AQO0WgQ2og0Mh4cIXPjOqCat2E6lik72ZJG47rdmy5CB2m0Rq2RgErOctCnpBX7IlrCwh4yYy6eocOjKZz3F81mOt9DGLNEoaTHb9L0dV/Q16s78HHbzbnc6myFrhag4W2CxwGkmG9SPXYqcV2biWeGAIQZdG12JGu3JcFSun3gRcVs6ViQwoBxc1fIOjlm99KvxafqPIgGW64G4f/Hkc/n0BVro3aaffy+rgvsUNGjygkxFScWUAfM0Wuq8X4KXUJ76nhEwNoCk8BEHANnbbTf++qavCjGHaXehCOvX6wRj37GgbIGpnw92MjY+ndX9z3EswLDPV+tURi3mDWmmbTfPVdY2l1A6IpXEMI3ERnc95e4Pf2UyHSYVByzxPPt2cxPgsir9Omc99cakHkkXqzQc+LTG3zj76BGCA0XHKFuBTH1wdx5OwO+6ewvE40aL4i3xRMNb9y/sHKnR3Ko/SvOSRuheaa3tzttWWx90+NKf8NUPwsyqL57zCQNKp4VNlmosiH+EdR4AH+XYY4Ftu21/uXgMDCZ3Q5o7E7bjmmP+RdE/Jtgt+hv16Yk1a1x3fqgNQhHl/qynl/FZDTXK8zYy88cmXEnovTk7NTw0J7lQCs2AzDuJvCJt2gQGncW3/D0doEjIeRXjnLIUwjIwdFKlx5d3Qsh7jK82NE3sIMBHfpAHhFxjVnvukyp6PhONqP37d1M75CELwQxBhw2sKbLCQeMe0h5c5ci4jiEu9XAhdVY8cwfMNd3fdH0W8RmCYRUOrJm5csRrUELianMS8zu3OMgjd2O2MrmA2GCo/EH7kTel6VYLOetkPQnvyGiOpMFrhKbaAIxjzc4gfScK6QGrjELuc667rF25UNgjbu+YCOL2B395bpp4ofh6sfAg4fngwT5lvoD+R7/ifADQP8raXg/jpebrgomIsmTYYfToyAZ6dbEjqzBGp/HLyWEUzQPNUjhc+w1bS/b42CsqZxb1qbIscDqWPe3tK2P89Kf1OUFhPhiv1KUwTr49Lpi56ZGES88PVeHd04HMPd5ZwR0LrEd1sb2Oh+yGN3uPpvTiJjzojIm0xdg7i78En8Ra5nXKFcWcbiiPZ70Kl5BzPbq4I5KsO6/cm1YGomBYHDOfugUalfY79R0ifjoxemxklOuYE9ZUInyD7pN0LYQCFZBEFJUxaRL+sZMR4QuS+yOtfXXnSK0jjx7+wAWBB+CBT2t/wLr+nk8a7B1VLKEAPCNqAEoblDSbvcvGtCmmATznh4oGpiFBo8l+S4M/X4AOaoZ3WJncgT07+gaTfJG6gj4nFffdq3K+F1Qi20MgUysMSALGuwDTMc17IVYn/CLp90T6afNXtsHSbcIGWiKBxBKcfIWaQzUwEerhLjdr9YDEWOkz/tf8XQb+O6kgG/9/1xSP38FLntOJdYdCxJSiJ4+SWnTheFGtSn4ttGjbc6CP9Cix23XBTnkDiQvEHY/DLNlLUyfZe/WDGNLadYYO+l7fnN/4JmWRXipjJujgInuS+sYw5Er9WvsA6yzhXvxkP/vwrWmuzR1OGPb59/4Gctrd/+HYVlupj3/WcLjBJoiRQtxkycDWFztF/egPw9dDqgyj4KbiQPyQNVRryAF8/+fvXQAoAuFM2bzPAF57m6vfG7X1ZPtaL78/PaMZ4RI4tAcUGAbrIDfoqlGYnVj4PNUKNgPh2dmnUEOml6CRQeEmCoju0aceOu+Ii+99AfHMK82sia+0Uke5R3R5RS9lCydlMgwp4xIVeW6Q/vNc32wyBMo+BVGjPXYSfoWGkWzCtVlFHUs6lzi1q12nm0wDTAR87hnqFuxnL6Pppz860Va55bBRlkIsC8NlT6MbRQKptw9qzah6nDDs4n1v5awVD+U/Yb2ZpXG8CE4uLTghuDlo57eox+DhTpQA3nXepWb7YmoRYaCTmXLmYIZ5wdV+PTJuDFwqKFKYzHZjkyufcUA+5KbN5NNyW4N4Jrm/WwMwXaTvwnlDO2I9+wkZKnyO4kz5QNs4M3yu/hEXDxfYJhThpdDDumWYT9f30q01hT1U1L555ZnL5ML70Ga2Z5FRGc/SQHMrNe14zFvAMq0icg2HkZdoj/Uhc08XkwIOx3HsnJXzHb3nLTZvIU1Tu+TBQeGdiT4qZ5CmRFX2HgjqRlSvsxFWnvoeANwZBtd6OGMVT81Z/vRTNosTc46pO3n+rRDRSlYGXVq2zH+dMlRzov5dS3WSBkuyXDs6mR7H7TsNLVzuDq2Re2VN3yNCoOCI6sZBRKoWsHCORjZB/XllGeLoLHuCYvr/jSM/Ww6v3w6vf/RcBgf1ZbSbTqjaUZ9HtjQb6+zVhUEP68tAfIaGVcqGKd0qBfOAmqYtkFJqvCQhffIFNDjG98V230xrf7k3NZOuRRykzg3l0B7+PGUvRLEfKkyU1JGs2n2S4csF3n3sMCzbAbN4j2aQMmhNPK8sFwsOHA5RdSUZ316/u9RFbMOP37KHD8Gxe1xhjtwcBVSqMpnbyIObiHpKfmn2Xtp1PD3x95xDTZpADu09cSvsMxvdmTxqfyyHGQ7E2ryJtObhaxAO9vgugu76IbLKXYp32qZbENCho0hghaq7J0C/hJz5iEY6Ng1CLJVxPxf9cRSAosy7qIcXbxi6yseO9/RiULzav+iZkEUpeERa1oOZkvpQ6+Q4wvNg09U7pJjwRBp9Z2oeYuuCsrqa3Esgi0YZul7KdRNdOnruvu3fUQVNKLtGAEH+iMrOTxsCsX8JUCumGgbrzykZUANDd/ULNFtm8osUoJ/hTqAn9/wZyF8T5vLHLZ+1VkRU0TxC4zneziPFJI7mNz/lT4oZXN/5+5W25/zkNLh29Gf//hLYg08rI6d9Kxscdz207UDGOZYcLGIXFXSfNCMDfnSioGqPmLtVBhHbk217MzHkKpZSZQJl3LTtcUUx/I04TIXb4LBxfjgJ+CfMch2d11z8fLjTkH3I8V1cIL3HRiKgtZHvmIEL3HhDhzGYG3fdJg8G7yVf715Ogc6trRjwKl5M8/A3b5g/YtJBblN3Bp5DuH0oR7fayyqbHGWhvUoSrnXhoZ8QaQZJU3CDYHeaemaukIhqMV+pu97eM4K+AwLybu7unavzQ5co4dFsVhSYVdNULjAU82T2Yv9mDbIyobPbIxgya0xxeQkpyYnQ8WwSAkWLwOx84nxPHNSlXO3NslzDL+0Ws7f8uAqjWs1DmQxTunlLgI5fOKRQqgdCDuDxiCznkdMTxTIg07GvBozX+cU5GS3quCTPjFoZh60BzGL7x2J6NLZi/OgMcvGU0ahnauJt+HgUftdwhaaQV1UZJH+4/n9BCjtV0SnMH4omiEx4GkixYrWFEZ2Qd08/5fDUY/IT+nNKMCdLmtgZAF5xSycrP56iCp4EqHExM3JlNidICc/5iX4iuQCzZUCFHnBYX/zUV7eRJdEK07g2F9V059Ib6J446LiBfeQ534wZb8VSxAzq4IX764P+MH0jShvbRTRxopqHUc6dCKh2s7WhjWIuzYdFLi/EwidF02ZzkKfo28AaaDX+q/zUiaeJBlTKpxqevCDYDF++8Nf8x64Y+obacLfHo17qT0l06SusKIerCFrBI+FW/Cq7ULj27KxOIia2YpOLvj9PxAR6cjRTETzDaWK5X4oMFjxiRf21jSddwUH1xRNWxopnjp9pBrmsTomj8PcnPz70nGprAKkjMotonWRCAPwY47/t+Krv8N3c0XD/uy4hqY+VktZY6J/JzjIGZvlnMXdOTLcu03aPABt0ZDVNkrz53nLXZzKeKlCtyp6NgkU6+yeWEgJ6tpohIdA3myqJrckGd8v/K5F6HNXm4u+oNP5CiZzB7phogpppEJ22k7XhxlpQRYBI8wFldQvq51iQdofDqdkfuDrSQWjiKSZieucUpmeQPU2ItqqqRnYdYmqOtUZGGafTlsDtuDZSaE+gmgafxnk/jhvP11cN718xO4MtgnxNpPxPs3GdYuEYw/4dB5IF9Fjuultz48BY7IuYXL8K5CldSGT1hWJ3t82mT5BlR/EhhcUv5Y2M5D4JsP5pIEEtenrPve8ms2QSLWp8TK0aoiGpKw0fF9OnosA19/W9hxEVpW12/psY7qP8ca/q2bU1/ng46p6dwkjC93vfQW3Me0NWEsTxg+tgZbYC24DUqQO93NMGIJ+OXNfFJ5ce6t7nueI2DACqSEnW18aznTtge4CsSPK8nlHlgQi28W/T69vPAyqUUqHlWTflUhPzC6/yCLTvvdXWWHVv9yJKNvyELsLRYLE8StrIWCEmuU09BzHk4rob0Z53p6RiDrM9Wf9/7GLBCwDPm17wvInD0MHbg7zQn/Y4OGxKpj34V7neLucESY5ExyeR3m4opZCA/BKkq+cMlKyxm1IPgh9oKMTtoPp8dyc7javKCKQ8FZ9Re+9ik7+l/nA85O6Y2Zy5IemGuLw8JCdQgRVXDk7a4OUkL9pVkyvySGx/52guxoZAVq0aJO2YJ271FzVRV+1F0GE2E2BwwvZfebsNEQy1/Od2k27xJ/OqNG+Su+j3Q4MvEctKQFrzfliv9F9Is4Xkbj/mpg5P/9Ko7SY6A8q8VNp7EJuhuQDZqKiNM43h5oFRyfsBnc8WyYjbHwxfMQVosGAwTIaSolup6f+5dO1CQeIpEqkhAXU9ZsE3hhpfPykOFIxfvXqSqtDDzJpwDAxp5WtQppa8hCzL8hlm7eufa71j5mtIjUADQKCgu7kfNAN/U3WeRRKRJHQmrboM5RRdK9xUVYApwLCRcQW4h3ngxeVrssBZGLeU/RqCnonabSeG6tIUNZ0u+UMDgDfxoCNXLT7xFIgW+fjOet5EU7SWwa/Fi54RcpfF5+4ZTv66ETRV3MPcyyUtSf8XpKLHZQQZ13arJOFWWujWfDOJ09UXuQS+b+ejnXSzcyWCPMj9E+C3lzY44IQ1phzr+OX+Xggdjai9QubN5JpKZ3hFBi0G0O71Wmn7ti9pHlMbzoNRxBr3nfJ7/eFzzTAUHuYnpB6ZyVei5rxq5Ecv4bfiPI9QvtbNBoNPwezD/MWdJ6Ti1MKr1kKZKhg7QrSgDaOILszhFGZwTyEONOwf7AYPwmJqGJgOEvjoQiQsEhwKrFpTCCIYCUuo/958kKaln+gUtqZIm/0REPXcfJPFCHk0YgAC4CZfer80NG8GUJdwQ6k92I3iJTUpl7b2pAUvjdHQeADxtBWRw7WsEzBv2uKwtyGdYGrX6B5RiqjFhvh91Mzrm2XXmIUb7fuN8xDkG8dN3DRhDPuWxFvvpnoToBCYKmtzvummK4TBW7Fx74/Jy/MgzAR5sxa93eCm84iTJflhsBgVoKyCiLnxeQXS5+uY94QVGNEtC1G4c+hcqF0a/g1/GezzvuazAJeGHP9ckjXZPZShl8WEMxY+qlrrravWhBjcvMxP0lpRrk6PpGCJkM+PdphFLro2UB8h6zbLXXCN7AQZDg5XD+X/W5XV51dFXtHfr7a0qj8NxWHIFuUsNQkSRz4Su3yDMyGxpe2GRRh6F/GwtjmmyIiJygS5kISgwZy+G+VHBwIwA3ds4Pf/6xAHGeKOX7TA33YLQHm4iSeEY3RcqbAzeIzrn2VnpQdQ0buv3jQ3rsw8DxFTnlw9Ll12A6HcqrGR+ehWZLQgEz8ZuhLtVZl0iI8wQy21dsjsUfySg6g+SdlN1YLPnj9PPInf0FnNHWxT759c5Ey+Mp6T6VeQfq40fCyflypJ36fYivVaIg0nMuJFUYjb2j/Edl7DoRSmT2erWDQODZcAMbSMgKyCAvOcyQBzF6VBOscNPucsv1j76xmSeRZut77R0hBJQLetbDs5J/U1DFEJjXh4hwMzqr3ya+H/w1KcI2UF3TZdfnaOAAYvsPgXh+C8un7+FvJugRuZfnAM1018T3v3BpXixRKzxSL/3OYeRUeUU8yrC2g8wRWokvGXzTVlrbHaslD2TvPhuTQVwU0iY8kMau2/jUOwUO1Vkoz5USO7QLj88IKKVuizmvEaFOzBUuYLW6B2RTkwGerglNMVp6BTbeVDbkXU+INdpRBteGMxGTBV4ij24pej3nQdCwerSSaEGkx8b3GUOCza+cdvP65N1oUf1PocQLnXZUGwSy7I/kk2iyCN9G+9isDxA+wY4bBlCKIWpW6L3t1iNjilTtW+ingoWmVjnOR+h0CHAafaS2SfzMbfbYDzUT2RyjdpsYsW9KThXsksDYliD1qs15nkveDhbTex2Zi6oR6mL2n0/pAAvpt6/hMRDMxN5q5uJ2yKLpPizEymBxjDDkuocgmsbR1fr5sU4UVhLIRI/qCPWbbjx0kFhpAU+GVaoeCuXOIdubX4NTfhQ2KKO2WYXbp3zGK6VI/ZwnoRp8TjOJiJUbaMUEEVDDl305PC7ZTjtVi0N1onDNwmJjlVxOwF9n28LOk2wYrXiU9z/drwycp88uOgrDPuPhlGTS1CsnMAVc7eXiKLPjzFGh5vsJSn6HtdXhHm/wp1DLTjNquuXCXhCUrR1tjxXkoYytW8mA0QIm+MBSbFmYRo54aM0L+GIzwG1nPzsFrkz80bR73sg3n7e3qh5IVcIn7dAdwcdoDsepo8WVu5F9ca8G6XcmiPyUmXejKcF6pIJ/VjBC/oC+uj69//G5KTo6+C0UJa/akqaMIZ7s46B0NTkiUeW4jr8VybHs/5/S2PAaTHMXGfDnLzDh1sD/MKWJt9nmURi48ilIj7EqLS82APShQZEGhnXI/Lcfmpsbi6mH12LGV9fBi2D4DE5Ou948P8vW2X9U2xNA33hxPCAqoRytlQuvmRKNcvKruzwjJaekJJHJSpoASszgQXNPcOHxan8n/AvrO1a4INJ6l5vDwFJ1qwdohNDRDkX5ZRWaJSEHxmprgT8pwcl15dqDD8xx/DstxSPvWm+WML685odviZOECoXPOjG2b8leJM2NEjMeRgnstceio/NEbbaZgdf4nGlldMcD4rGhgGCBtYmcF2ioCI1UpzFVzh+3IEax75tSeOB/otZA6Xm9Fo+JwMtEMHczTbdx2UmwnHGgBSooFT61yx33H3LpBWHnjSbbcRunV9SufguT0PodB+c+vJVBwVumFmYgWde50w2rCR+U3OXmda1ukXdbdhcFfQBUFEkVzmvsr98Wkz+BzZ/uAQR6z63vGOHMnN+tSDNd7x+XX2rPPu5l2ybQagLyOTFh20lPrvyNMy4dCi6zaIzyE9YxRIb+zlT60PKRTUd5naqoZKcsKW+7O80EX2lJXWaZvp+QCIPrAbU9c6MS9xXK6cxDNa9p5F5hvHUqoSs30K004kWSss/94z8aILMiczk0dYTi5GOzeXJKuQ04ncE9qaYTT31zELPTcLZQ8vt8WOKHImM1QRfGRQiLscwz6UCmcrplFHg37sRSTXdl39uLQ+5HZWY/Zx40GxWvx3T4dwHpM/cQJuSnY1LbokSveOm7YMjcmwIp1Vj57yPCNpIT2dAkXTNcog1MWdiLTAWECZAcXXBdeQNjPEaRamqHCQpSHG5OeHQyVx7TEfRzKckaNVaQgeq7/dYaVe+hFRa4b2X3n0zEYnEbozI5+wfJUN5TvFlzIpGYwKir3bhFg3Hmfw04BIpGaTQnOdulh3IFWQC3ZLCpFJJRcFLibZAhFXcgKs4qsFwXx7K3IhkBs6bQz8rdOrS4BB6Iq6+B/E1hEJ8bq2i0as6pgAQuttB1Js/bR3eKCrfFcLRmN53azl/mTy5a5vszwnHX8i30R+OKCYGfweh7DzjLHX1lUitGpnoKD6ccyj5EdOdKxkIEUaDVpH1KVKtEfZN1PpVSeH1SwI2LdUZjrSlhIEJqdZDQ1FyJ1fCuT63jaOsElcGZffz8FmUctYTq1CJI8WUsc0L1AHLQlQ0poC0aVPnLRdt/ceKr7pCi8w87xfdKOpovTo8Yb90Z8ENA8glXgojai7ElLRCe8aZSc+HSTTXaAHOyurPITywKM7g5VT2LVdmTI8X58Xd/kz0T0giWr5kfPGnTROGKTKshvrq7UFetedrSvT6Sheq2EPO3vBc7RXcySw6l5XolYO8jUZe3ktZrSFOitjC2CX8AB8yNx3jjlnA5Qj+UZLeFZDcvRgETF+kPpbNQkb9uxQcplwYf6PTLwmgDY9jdawji4bR4V2egzxSEopiWMSKUoF6+bNnHkns6pjzEo8Tt9V7CcvG2esLYfHghrFfsTgA3iXKtbVhbtJQCcGfnWfg2As7vyPhM5mMsNON7py2gnmJCDEWbIIyMRfwQ2zIkWy2P1xqdnbGxg6XCxU3ONGO3oKIdy15ENDDhKXle6mbYqkBK4B+st3+iRCRwT9ub3CvbsVFwSF85NkfS6+hjDqGmz7te07MWoLerqNq4ikV29pHRcy9l+LmmP9gyl8hPyoNj/90SsBH/+zO94lpVZYB0iqBCnuu74xDEUazVGsirNy7TLJDbrW733suilx15V9KCzZ5Nk0OEcAv/iXLMGmr09C7j4PwSsK6x2KUvXyYV5aVpMQRnkXT4v9qIFeb21WBevRYHBZ7xZT2N5YZra9YhR6JDv6hMLA/id9J3CgHXne+zP7r785oZNU7Ghe8Y8IgL8UckS92f//wryp75UHclRtLYN2E6bNiBJF8WvdslipABfre99zEgaVhcFpK/5HwvQ6myHp7WpszJ0usXYtSXaKe0id72iudFPB60wg7s9VgZyYErnE1UxbrcHw/Wl9DzJL+FG1y1TrwvhQR8AhwKXimVVRYi9al1onGlVuJ3/fYTw2oMz7dGKfhzXwbS52BAPehMk5A7k9mgaKzgN6M6zD5tPHAFIPOhZIKOJxoy25OnZFntII+0DK1pASIG8h+nIEi1GtlXS7T8SFxESJbhgo3mvQdpov5W30RBL5ORBoyFNCGK/g1X4+bN30GnMW4WLSlfgAdxj/eQfOLdh6Q8NXaIb/xX3l5pUYU8g1LPv4KskSXQmfNjNFAImirUyPBoZojk/mRPBAxxZY6mDVlWfZH25RAmLI3l4IATYvh8M+Cmejg74C8mFblSGjJuQ7pYboxF1Fvzt48oZzKkr5vr22oXW5TtPpkye9lqIUzMij4Z7GG+0WRSriY2GT6msUo6V++WEgRAWTiYFIq2ehfr2MC7XttoH0JTFl2KP6em7Lb2BP7a4vmkLEdAVz4WZocp4J/cjpM953wR9FGHCzO9wEUlFx1bPPOv5QQbkp7hpefXtBz6fIgzAJuvOlLSUxYZMa8bxlaK2vaRPCtoYqBvWLCuQbgNm6LLTC7lxGT08TuzN8kuDL6r5FsDZyadNmTYMipPIBGfJiiZLtmKiHfO1KHVQe71geyga15Vk3ItMFBFVt1gQ9Tc8GuRR5xzTrIdTgoG3Jfz/zoLT2VCMRsB7oGFpY2DFEWytpParlJqhsHG5oH3+QPnn/MLWI5j4PFdJDjVLMR70LPpQ+TedzepntTEhUonpqpG/OasSdP3sGd/1EHLISiP5iYo1zB5eub3jZG1CrbChYi1hx7YbX415YjnmUEWVK1F7fqukLvxNG6o9skN2YuYCXfhpqLXm1xgh0uTK8jC5CrOSxPefWmAcr8NSNJUeo6IZTvpArPWW+dtVqkeJ1LX5WXm33YxDnGp3IAgwlrrWpw2O3zs4SdO2g+BhP9yxe9X+tAuGZ24WbjdW+qRcQZEXVDB+A60oyCEpJ/XLBfgwhQkIuNudH6Oe21aFOZUgoM76jxrIxbKm8RaPMkVdA5lm/36UC0jG5zwXc+Vl+U15DeSsoPVaZiHBa99GFo5TWMRzlTDngv7nSS4ibcOQsQKpWn+Cf2d8JFs+IdRgpSzwtTozsdrbzTeAJIcVITruDzJxLiqKhoNU/ML/BTMTDe362yWl/vyJ8cNVcWh/P8evMpy17jCG2yc/EbaK/EgN/ROt8dD/eLdECbrKd017TgSm/zSoyXzFYv34mVxVCOk/G/LUHy8MrsS8FbowG+fYAvV0LfvZGkN4FYv7SvQR9mMPd/e+7AuWD0lVpBXQOUL5q7u3HmBbabLPMr2QEApP/zBPRgS9H+3Hs6TR97sW1lQP8yCGzaurVTcDJaPA4obSyTxWMHFo2Hkvsbtht2Yju5xIlRGFgoYhygYFSPpnZTGnvTEj1xyftF9adS25O6fqHHgjzlwOUUd9ZTRcRtrFpjrDHkG6x/inR2LF8e8JYkCC6ze7qco1duxP0YbOINstg+Spa8wqEIx2pFHFaVi9rHJZMdlKRq7awzKDApRMWtfOjHWJ52aLkhj8c9jXUlpUKOwD1kgcAwcuJM7DPafsO9UWEvCGqYpWWVK2Iac67ZjdUeJQ5ucRcXGuVOyvZso1O0NnvYq7vN3sZmegaqJ5FcYS6h4Xj5yOJKJkOjph/7WtU4ffQ7jBOnKzfJ263nBkIDreYwTxAXtx9MVpxXPQFr3k37cvzzWmXz4NZfwQ99zSbm0h8SyJPlCA6d8XOjGxnjwHAihdgD+hAlanR8RpSPQwcpKKQkmfxl7zuFsde2o4QWuBfCCVtgIIFxc26wnqH3TambsnIgmnSzucPEsVwyLr1o25kAKEe9Qf5/4NY18IfkoGmP72x3pFyka0IhHTzc3ddokwP7ooZvgcJOa0225Zfuq4n4TXPHxfvmXdSDhpe+P3S+bpJzKEsnnHi7DcNoWqsbCBMJO06QHc8o48zc8e/8BtaMaWJn2TFCfDpwXvbzGS3b92R5oWg414l1w//SxkG52y1IJYtXrf81JTJJzWDIdMuxdnrO0/OOLkFEKY5RETd2uCocGfkCT5VG4yU29gE3kRusFMt8yetR5MpXnDW+NuTHmyxo6lBHEVn6ljfDDOqGF7SQZP9zQrHBzIvlTZa4CT4O57Tlx4VDxBYzUcnizM+vvJR0OODGV9roYlJ5YHzuMVuIJX3PS1V4fi/ESHE6h3+pApJZkz1h5ssaVSz25D6utOMcwG0fobZsEau0Wxi2PdSWx4cmjG0LqzeXxIHI2vTZzdYrkICXul/tIruyCzvYtzL6fab8dbsrTuFIhQ+45ptDxbBbbYtXT5lR47K36qubFonENBrWxmU4B8EwWLNY8GM00HkvIjYuGM3caRt18sKKY3tAOaJ6TXxFqrXX1+SSowuIAjeVYa95OdfAU2Tkw3HjpYvROjXh7XmMYB1uq+JaPOD/70p7cka6fCyapcSHM4DxdkwX7Nk3906WH11ZmWyGuTPIsbOP6poUQXjHig1vth6brOMl+3UUoae2c7OcxDVMW/QvUq+mPC5/NxZPatptIMBdKRb/pjqmqBnORsHkVjrlhKspmLGFg9aRxiX7U4PZu1RRKzy/3dJMd+/GY7O+dkGBqRC1qqd8PPlFiYgIHAwhhPZZfmUgSVo9P1It4LuC1VaK4pmkpAzKx6/qe3Rw/VbAnOu5CbKkVxpEX282IuSV67TDeb6iJ+B0Pex+I9ZPJnELxRJ9AuxYYafUW9kvyIOMCwq+c2lDQolN855cXWLYn0hkbWmMlkdqAO/ZruTAjGO8BR4wtImLHL+3gt+UH5e7rK/Yb6qxs4QPx5jH/lW3JPZ43F34IMjl2tEGgWcfKd2MbuZ1P3mr+s5NJvuPg/MX8nh3WSwKpRca8u48IApYkJyM6AhF3tMDgB2HeqqpTuH6/7HtJ90bC6+3mZ/eMdSMPdKbzCrnm1GvGUOunQ4mt0K9NsM7+VYdpyV58wSD6rfTbDFgBG0MYyDKMibXSA8Ygxztc7ivkStTDeU8pdePHqLgyFyh+Yb7VE8t34jQZS26xE50fTpsaxQcdWlMKZZZi3tjjrdckPCYTADSIvMA0gCbV+WRK6VCgTB81FSrOM8JfsM9zWFyvb04cs05FQzeBSH/2SgN7kgdfmhrBBGx7MHMYbleRF+aBqPTw7PSGCN0CEGZVx2c9Ti3pgWek49Okq+7pGNq62FJZmm7O4E577s+wJQgRsxjbPA3dwz9E7zW3q0cEFdvGVTcTo/Y2xsV11AM8Fpaj8I5yTZMzzliV8/IEBLeth0Eve6O4y5pDOXDF8aP1YLfkMTSwYuKTtVPxLDsaVh1myNm+AYdhIHzGT144hbW2N7VphAl20jFRvtr4uaXCM2iFVIE4A5c6ZVOZarfzjyNk3+72P+TF8vCFQe/fD0Ch/0xqT7OyLn+57/tJQ/2AiWrMM7CGWGiqr8k78OaAuTfUBAvqwngFeAZlUHKcrPuht4PtQM9BzFJsyxN5yB5lP8TrDRcCM4E3mX4H3QttxMX5XRNRyhnTewTlG2mFn37y6hapEBIT7pJYpk/olwAo7m3oAhvN2/WZulUyDwHlDmp3toZ4BkeWhwzbACFi6LDvMDg0v5NjZx1+4AlWDJ67LbdgnsJRQt4djH8MJz5mpRrqJOiS+MQ5B+ZRutOL3LZDnMT1TNLN9WbRuDYuabgXKFAPbmM9jKaQWvujyW9n5ua0L+EGjvZ5I15fZAqLgtgNw9YyMa5qClbCTOvu1njQ3pVmWWjWyjRSv0rzRyCuAPngy+6pV6/IpenWFj6MJ1E3ZuCHdWEc1aETmRENjaSv1ZsPcx9ONLZw/xAN9g5NYTBIb9C5fcLGtCPsoJ8MQIbAg7dNUacvok+EwxCpnifLEwN5p4bZCnzZP8BznIvBJj3TqbPXTxPTYPMsOAF9pJ0T+cZjZDSsgODMki74k9Jf32AepvFyWDR2HzvF7ZSqeXh6skphM16YAPdNIN/SaPkF1d/DSMYgGb3RgtvgzcTl8AECnXI8XvMJXunwP5W9BD0axiHnXtIjSBbQp0pwI94jmdZsmVzKpPMnklnaVbIA4F7lMoiLkYB0ZE1Gr1pqIAdVVUeP47fYyf/S3NfYthLUAYMU+Oo01vgFRX79+qYWCgW1Iyc7ytFu2O3vBALDrGg7Vfh/z1vkqJ6CCSMKwzbyk9V1t7lDdIFJ0y7/1cedkGZzAGJmrWLnGdTc5nR30dIHRn/InWjr5u7Y1NvYSfnJ6e88cZ3GedBLXQa8Vs1WrUVLEBX8kV/e8Aag1kuRI2m2Qu8DiGwmsxOBAH6Rs1DiVVgyOgyDvmr6IMULFaxX08mE/pHCHdkH/anQEpdobonwJnab/GQbxGhN8axGVSAs9IA1kDaTdXDlumC9rLDtXKTKYxRJHA8cJx/qa+EBRhADb1ZJGLdHDNHvxGCxvj2CAZ9+ZrcywOyDxqrhAb1c9r2rupOK3vU5RAb0WF+lJ4zOT0zAOVzIUertNPzjyQtCmIS5MUcV/E7qL6ZLZ0y5BM30gQ8wKvA6z0sBQnUjXAVadhwS2NpiAWFqClYqSLTBUszFNAtcXv1fnDpDKBQPV4nH5lSRCQu3KjXtCxet3OHIqJtrDTaelr4wcRFndaMK1WWUv7WF8VPzpHtKQT/+2Qkn2DwcDS0qN2RFz+PNuHQ59KFAux6Wf8lZ1v3MDuG/AmotMvyBhG34FNwTevlBJpK7HCRnLRN6nw6cF73zRsP4C7RDLHlfvtgEpRgDWTuDTZ0E3XTqnALryB4rHv1oxhEqCARLOJzPGoWtDzvQG01GTWuRY0yQGa7HicM9NtSLxVMIuX2tpc0picwVvyhIq3VyXlibinGlHdpSmxQJzCuswsgnK4SEPO4Jp1UUTDflgj0MqDVKN3rlGF7KmVTmXDB9fQmymKNVQaOoTeZ/P+OlMHHGPnoJ8KEqQVdztCt5DMmPLV+YJaCI148lD39nzcUa+uztf1+w5CHVWnsBm0pRB03w3CUnvS0zDyHYggf6sRLktaXFuX7RlkEFl281pCKv226WT2UCnO6eqVWxlpZMWZWQDzt1MtmOUMcpLa2PHzUtYbs1gRhwJclCEmuyqDPordI5L1sebLkZO84t1T6zjM6lV6celesX8xJM2ZBqiRlEKTbehXF53yA1DaE5e7KWdOgtVSNbdBaRTIUsq7dU8k5xZPt1FYotm+IiXhicj3HQZtn5XqaxQTBDD7RYdh+yKpcVn72E9Bvu+Bjct7YBEDbYacCCO2qN8Twj0c/fx/cPFZY044f5TdQmG9msH0dcWLkjLYVYreEc5RwrDJ76N1AzMRBmpkQCZ91HiwYODs4rVWfGC6lT6FWqunD4lyzkaCu73XWD7ixgBWsl/8oYhtfg6VvUSasnXZXExAioTZ/I4svYeHsr150wZC9eD1xQFCOkpdzhIEo9GP+Z/FgHnAKbrZm2wNGAMOdWSjHqaMFXDIfpHAaPepuWcHtgwGmYi0TTiVyA1awihzLKucut+tF81XqwhyM1dY5Ju+nWP5YaqiUc3iLyaZmomqYVRUo7Y3KL8jTYgkBIAbVmczHYZLzc43rptSZMnwSPOLqT1AT4VIwEaUR4czTxZ92fdlj6IIk5xjJAO2vcOB26Z0Lv/eN+PoiPCuKUJFZUtp3exFvxuTPVxOkowM+JhkoNdP1JcEcQ337/2FoMFRmeO7NA+PuxAwDl9wUt58Xii7x4r6Cp80wsnxiJ5Iv0tvyzyNtiM0jr6V3aliuFYRmq0uS9RtDP5droKXULy2AKscvTPlPQez0cxSeVK34jWtAV7LVwNJ1n9V9UF+ClVihiJk28YKqcjHxelB/oRzrWM3Vp9lBFP0Dnd3datD71ffnOCeXLXk8qAsPtp8aisgfFJqeIZsEdWE3fKUu5oYd+PB0npnsZkEnkYMWogSvPw/w5hd2MBHPXMxICGTOsyBrLHZPYeyIBqswfQTNd6M5LpxRSqh09igaKluXdb3Bfv4GsZb+651ZDU1NIUF4uTA6cPk9soFJKTE8W2MYHjoDdTX0lciL9J0MqcDzKX1N8ptybf/l2yCQnKR93SN25LOypF+lv6BshOrk9o+TK6tzx1HI7DfdimMFrQKa1JVI3I7vZBQYp2tY2xQspBfY5BQhnkLrvIOzko7c4dVBBOlSfxKRaQyHhwcSpgWuy2q6SgzIIfqOTltfOStR272lh1vyZ8xm7Hhbl/oCY2zwkvgx5Ao8f2hdmj/jHUNfzCdp9JTinTedELNQFHiBC1URbD85wzP5vIcsyh4LE5kx0bQTbrUEbrjuCQPS9fpVA36R2WEDgam8c4GTttNbqjjglhg8+3khvlX7uOwmeILPQFv+CRLyoOa4G5d2raN1DUuX/AIVWGZ1DAv/CPI/5p9H3TtgdOXVJNzTPXgdQrFU8OBZm0QJ//YI4A3rZ8fsWxrx3yhJM+/vSeUPoNJHlOMtsQIzl6bEv8lTeZvhgIFoQy2sfNqN5ho8ynbjXq7nJQd/bw49no20Szkpkpv1V871qB/Vubv28yNIJuKg9ycgeVV41OQg2GeDZmwInteLExpMxwpUSXhzhsiivoqgc3Jb02onYcXcY3f7MrpwgOGunHMlzmZeArku3O1L0gGGXnXbPV0jV0BXols6NzcNwLC4Eq3xsbRYt5do5N5hLJQ665IVC7w//kYvylKVBfoXmLCchz07gO2Nz0aes2x8K8MH8t+YB4kZp9VhnGY3qrGkRn46qdfnIrnWqHqaUdg3tUYVlEuHh25s/ZBfvS5G7KUY64Eqv+b4u6zI0eoEv0JyaPKnCS558j6942b3RAIXOfsuJaZLTRKm/s4u6K1hxi4b5DiifIJJciw4oTtI02y4yRiYf+urcw4ilQvLpDaragBBYwyyQGDdx6ZfG79cuxc6WTeNhlbnR4RyPAC3L3Oc+chNRj0Wj4ONdJVtrPA3lplCa8V0oDgETa7laEDM7Qj+UuppxhImCqykZcism+AVmgdCUXWMzb2lX5QTnVRbQ0GN1qstRCfyJ/R57u/SvM8oBZUV9qeQdzTKZGIMEdMhQyhPpQsHwQneJez2g7jWiJDh7GuDFpzBtYkJ9UkWrli/FbHsv4r2vtnqTWZ0yeObRykPpmmbGKF3YyepuOi5DqyYfJ13awz2veSm5wAZCuZmevO0w2YDVcB//822TET186M1yqAC3aBqXNn3CUzB+i2BQOT0t0I921FKpjMGgWMvJSdwq6q3tbmhrW6T3fL6CGLHmlzVINDfMLm0Ha1aoU0Fp26y258K1l2OlqFBcW9spbk8o0Qoclz7HzZSkTEYyvcPKAf3W1rZSOvHix2YQXRSCl299bQu0AKPU2AHnCQMUSk2xkZRLnW/GgRWJE+sJTBqWJjqJC7QaXxD0KdpHaSWdjp17gQXEF5+f6kUmo4pIIJN4u6PlN8uasfqWtvhuP4EmnzOltw1XJVJWPkfEqhEykkLL0rSf2eMJYGP4tjLnYR0TNjAwmUswKpOBQjjXaJ1fxeH/sYInodlFJgJQ/25I2o++6TPd6BTaJxwOuzSET5hWvLG7mnDVsMTkB3yKrP2r9CfmHckGUJ5ZlsQGj0r1M7cX15hvheecNNPfRc61CYoWW8+rfP89U1h0ko6I7AQ9ahhT6yLWOuFz/3wUBgwoDxnLI3MkNl1rvsd0urk8xz1KcP+kWg1oTWuvIu6VRUrt8K/e5g3UiFzU8vi/7SH5GZxNZCAxppGNPPqb4runrpDsrX6RKAiPxVhmOZTioneFf8e5SUCjQrzvhfZJ0OKSeRbPoYXbd7oRXcYnob9UMzDl9kEAoI3jgso/nGXalKCS5IGT6t6n8CvR3tSo6wU8rq/E3iiAL65W3zJ6RcXOZRFTgAfAvBG/0+3JIVxJYmT30FWtgyBj9dwu17J1buOL9kekQyKJBx4k+pWlX6Lw31xQtWbdH9aw8tEWnrL6Gap1IbQ/2hGdznCKbFQKNSa2HWDfErUhuNSjYNL2jCIQsVlOh3Wcy59/o6uaAyeh/x7zWeaqbdT8750Wf3cbltK7O1YbMvsaf4YbRiDQHIxaShH5za0mWy6oSM3mwpxjThJsP8KM4rHvjvYax8GN3de9dNM9Rz5f5qH5LhwJK7a5WvzM9fsOvIzQnqn+efEmV6VWmWrupmznihXluX0rkM6nkHAqVGzbN7u0PRmkunNjUOiVzmDBH8V6e6LAGyWqgclh6lpURJaJztkdhtbYet41Bx03V9S8PoIxVZ3RbrIsdCXyWepluoYSqeNRx9XDkxESwRqBGJFezMsinLaf5P/nJAYstuoGAyvMWthXe4VXK5gTTHoUUEZOa1hy068Jx8z25eZ4hCARIW3/fnc0tzRXENQq0b0Xq5pDHR1RH7wfBD7vDfgxlW4PHI4j9hngw/1wgaDJHN1C886VzznQuuRnDbzKDuqGUqX/teKaWQNjw8K2AS0rcz9E1BDMv/HbkHRyomft42JoM0jpNDf+lvpDQSlgt7D8yRiJVf3DtK4tmqb6pemE4UhAMuiAhdZmBTOnSYcVrx4z9yuB3MxRGl7G5/xRLqJHbQcBbxveIpij8Y0c0deR3VmBjk0DQsYcFFH/Jg8XXRyTvKFNtnw+Lswc5DTXOnbkCNlICnVYlPAxrQ4eRExR0MZNrPqAptQqwGlLwO8KQg0LFxzHHhxlW6XkjIPtfEJh8mBJ77xF422BafwVVBvXB9JuOBwa0HmnT6/e3zVd+BG1nxtJnHfGJS5DNnWmIBqYZ/4kCj4gTRi7XtxHHcHsF88P8gdk0DJxq4tTYPLEPBZBQTjwpW8yHpJZRSo6lPSTiBpSBCt9zDJ0xsTig8epO4cfu5AhFuBoh6HlBrcmGMxaFS/c2Rgc3gdDMIAA3DpgJGs8HOnLfT4Nu8a5T5c1ys1Jve7ZiRDOigIxDYPDPvetRspS4Ni40NL9q1LJq1hLn4rRzcg5hRoBmoxbxzkBqo3A/a4BEbsrEcHN0JyW/eG4wBV9Y1AtTZB4jEJpF59Yma9rjJAeJGKRe3lTs9ep27yPbXzMZ5NTIzOlvdpsn072r+mO67WnqH3xTehE3uZPfnmGDfKPZgrJOXk5EvDm2Y/c3QFdWSKBUN5BNWpSdlgs04604UdbH90wYEjA4IjYWfFdNh0S5QnkED2X1pulMushChNbINubwBKPhrhsE2rEVtrDaRFT7q57NUf3qD2fXrXSN64jw6RtQXpdlyoPifKM8tt7z6a1romiZjybogWizIC9rYruLEo4LUvhQ73CH/DLS+1V19Fl5TKzoVTOZVK7eaqbZSMiAHsbKeKvg4bwvR9UoLTnIc7tNg6QM0SXRoqMFdIsngHCp2Tg/lOGs5KGiMXS76/PeWSMWfGiYGFu1KCZfP7v/gQAnoujXFrK7J7ERcVrdKObYaHuv+LdnzhRYkEvpwNLEQwHYrL0bq+usydMtwg9DaGDzu1eluW/DJBU/dsqmCq8IxuONl/tvp/nDNOJcO0xaDCjYflWjXMXr1dd2UG8VaxLEKTjdxRv46tHcHBcjbYb0eA+EijTamihBFFn3BbqTPqom+cpvMEzvX8b6G1RUqZ2t1cc0QNYTdTngf/nuxZsrB3NUvmw75UzcxnDXfaiWs9X+ps3YEbVgGbKTFjqn5E9n8yevS/0JMPxA5vffTOb/o1SDScRQr8QqAty5FO9Ydth0iVcw38YGQonMdRHnlVyVjeUuGq/gCIU/Lg6C2c3l4Piv/yHp6tZJ97o61qW8FhVH9ldL38TAZwjFwjXgo07y569WuuRz9DsptmqbC1ZLsrQE3U5H/9dq7dFOMBEcXnJndUB65/+9Hb1jwnVm0zO1kp+OjD85cT5td6u503qEQX0zmh5NBroahJ5cUfzncvWQzQBrebBuiCbKpld11ykGbFcIsHA+Q/cTix7QyTJD/2os9RShzCyAaB0mamS4DPUky/rgWEkpySvWumafEf9fDVuXCXCtUIZulB0olRH59cOZJc1YSATZ+b6iKF4X5fu3HKQiZAUS7L6lMgTIaGAXsS1I9vOo9nj+5pHKAoGcBD9Im1GhMrntNom6BDXsO4JHPToAasU2KCLRMlloaZiEnkUUKlooJbb1blfgkZkrswTPdiZOrhaPP+NNTqaPZRtNYNUE+BmNDMHDyf8K0g+R66zXP5ldSOLk/GodCTiAAZwPg8N7hzIyH1n99tEw/r8eKG3CMWkoGeyLXnQX7pbkjrcWuDpRJmXO0wptcShHf/MK47XBmfIabzlYWFXb7xAFQG9sKO2bRRe5SSZynRvSAVn9V+mPKwXzZGbpbj6/+lfDb2eai1DNqCGq/h2kkBofXvLGHU8Y9zJjlhJcX7fACsJ371Lv91wj2HgpKC2FnUVk9OmNNhBB8Lcc7nrHQyteRXFT/LWtN+sDkgne440FphqD4uviwZi/gQmEeXsQbHr2hyeM8iOHAz47f3oEQ1OGpUyylb0rSxIJTbZWJbGLx326n/AKFDiEgmnvhm5IF1t9bGVrbu1sKUyhYIgq1Th1k4MnGFCQ+kAIm2L28/7OW496OkUwWw4M5RUErn5YwlztYVjIXD6itGTE59a37e+26o5em0bAShBFAsqAjToXYfjHLA42PxwCut4EAwy+jr3wRbmObjyOo3iBaPD5+UmhRMe6MIQIElCm53D3k4YkGFTCWZ1kOYbzWb/Xelue6eSC6wMS1RD4OARJ3H3yR7bZJ6el1Y+xKOnJnsvU5rk1k5++NgXFJzyEi5sk2/9kVWSs8CP30MzxXbczXMkiMesSoHfAuwHKy9/e8I8fvZ5xVJo/KSVs7wR6+UPjIrRstMPpOUKbFBMw72vIWEfE3Zvj1MkIEu3YgYnCBSkWHmGvP7eJtsrySwtCoaNgCCNKI/XkOs1hv5Zp2h2YtGIVzVgR6TjLXIOqvmpu5Ea50xkKy9bSTCm9fR7d8SkjFjikH4wxizWGJlREFsroh6BboLhNw+41Pztu+eOORprQB8ZGi59OAqLHBqmfUaqM/YOt4wi0tnAqD3ymVC9CxwEKjy0/8H5fsZtPPxA5+LQV7ielQFZ2Mk3oAxebFr2DJAh7OlpjsOZAUOtTVCoYfnYX3FJuFDa82barF6qeDdl3luO5GXVwRON+9zs+Y37x3Qt1SHZ8ImSyQRbJfLWQ3KuBgnFkog4jjtz4KO4JZfM89kfJD07PoHBRrRhAGXg9a7WCvNCFkRrUhvI7rVN/PyUXs6OCTCt2xFJ9zh6aaZ3trsnyx5G+46dxEmnTOX8nRBbiQ83hnJf4studkvgndesm4JIhBk17tubBSowFUevJ+Qxsd2rStp/whuVTmjeC7HLTMFtcI32z1PvDdgG9ZBc+OTMhNCtjO8eVj6WPhmz/tY+vVpvIXxYl0wtFgbDPsNqkXLoXWcQeBACjwbeI7Viw/tPe9m+wVQwD7sqJV8BGmmDvyacW+d1TyfwhXhpcVPlis+yUcc9a7Q+a9yWm1XSJ1rJM5X5v7NKIpvv6hIPd9x/y/4iIf7BbPwIaNQ9bwTbAoqtYp6lWymqJirMRUEuYJTBoaP7KPWtyD7wQ4/adwkxfIQYKza93GfgREnsLqa/vzfRouGSzqxIZ21h/aQ47Y9FSZ0PqlxrmlbQAYTSUxusRLZ5ba2Hiq+xbwLXAzTlAj1mCwn+HJpscp7yJc2KtHyQdyx6+B34ROZhOAKaXC2kkuqwktJ3htzE5QQjIhtnTRcUAnpA8Q6hRCFoeyLxUiDBckQHLotnutSuwPvd/OR2cA071s9+Uu+Vq99JvaM7sfa5gsWrXjto+jFh91Z2yJLsuczLuxTj3EP+UOoIs9QLZ4oJPUeLN6DA5BEAacu7ozi+qsXRIrPyeo2s1ny+lqEnPkuY6pXpnKswNPEmkRzQof7cmiLZkWvQEXISYynSWUq6K5SiBIzaw5tOT11BaHY7RLkoCsWaQseiaaEOeoi6EztH4vtzbkjtztvdutwh+kvSwX0LGhF2oIxDZ4w22F1XT1z1rs4OV5Q3wergDaMV1ELFbexQjIyS2cVPv8Yt3PJTbIL7JnTB8kGrQ45Ei91y3gE1sELbWvkB1qq+hLB0ZE1NCZLQ2yfymVi1sd+NWXyApI/RIk5znqtsuoqPC0kmr7+KnIp/hxOCZuXllPupDyLUQqn3iqsg2EThtAYp5+5xM8YTMNl/zAFicuBEjctulZCvpJZYuhAFmueHG8k1B0qAfAE2l5PdwIIN0drSpKLqG8AIL/nyUqQbCdJ13OTEqIRQ3XYbExNWu4QAdM6swIIHnV1b8AIXnYbIk3PJcJBnzfr3Oso6Xg01L7gpZSBscRDp+7wIvIDjHLxUQdRZr+OAq57DKEy5ptkGl9vDe6PnJ40orB5pm7Ci/Z5aAwp8tCGVq6AQR3DLZE9HiUK34sgQ2FIWN89DE8Ds1CV6Ugv0bsrMX9RiIZJeVRrPjiKqUbgFQiNvpttlCnTy1b3o5qSs9Sm9ttiUNnH21DyOKrL4v6SLqzM07/O98apJss/qSEL002G74QC0aeRu3gKe2GFF+cdW38ZSIcLpKshtWIH+bu+lWAoZulcoR9Hbl/GXZGi3FQCu/4vpXq4XjywzoxP122V/Lz/tc6uWVScZ24w2ywNsj8/QWvxyo3Zko84W5cT4Raara/KmIcipnLIE2/6GpCgA4giS4zzf8VgyzHo+9UlrcCAsiuExVXVpqizq3OJRKU6+HasWo/S0JbEDDjClB6vO6OArtvx2jamoe7f/hSgKyqAIlLCLHw6FQV5nMc1TOyeU80NmSVdMcpETc+2uTicSyl6GlvHWzX46pLLr9TPbIKRtfXbyWiOE6wJMSzybp6DKTilZEmDSPOtNy54whgx24Uzabtcxfx38sTTGHlWPyJNcb82V2uIZW89BN4P1Ol5/JSBAyVL+oA0FLuNrK//UhpoMcq+TIRdP0XJqUOBW1dqOS0qhY+tsewU+/5sInIOsE54Xx/OJ3xCRYyc5rVKkipQq3nMi4rxT9GOtP2fYh1TYLg1jDGCZcFZwvdaJRBsEEjhp5wEOL+EhkSExUrH9yLhdL/AiH10u4JagTlKm7oce+LR5Iy07lZdJS1KN5Dcg2lEdibGQM84X0zMzY7QNrgeQg1e7v6FzGYK76r0oxILig08IfgdXmWATm7Ws9KTkiQVoF2bFv9r9GSCtIZ7Qh2dQQ9zkocjNMSkkKKS2+9HaO9F6wCMTha6O6KT/yGcx5hMM30iYPFTUDvlQZrjXOc3qyZeMCFvokNxhCRpRcYyZbhbnVnI3jiutYb03U862PFX+Y+MOLaJmxXw5MRy1vaDGAIADU7fWHnoTHhJ1RUnH9eQG+DaY3L1gL4M+EdbXJuJGdSDuRaDdelNU8KNPgPmHxay0qy6KC/y4adUlx4uRcvzjV3c5iP3GrVXAJx8/fvSvS4jMYguavQNqkXZaPOu4A66DD37kb5eb2JXR6rd/rS7c9HdEeKacMQrsPm2UB7k9AEo55nZ6rkABNayOT1GU8oPf8xMDEkeXODTlZ0hSIzg1Qq9VFV5Q9KTPcwQ9tDO+pw6HzbA+sng7l2Tk1pkKtAGT95k8pR6dhrpONkt9+o4YSDv4ut4tzlrAR4WO9I8+ftq7LA+D90zW0fkHoKCAIBGlnUCh5leLsV5A91l4DEzFIDoq0oS/xvCEFiuR3q/pVHKMGSKrwWoW9N+8qu+f/fLYjMVeFz6jPPs+WW8Cf0MMz9oCgeCSMZFj2i3PQTaiiJtwlTbgrmR1mVd6gZEthH9xv/CQTka6ss7X/L62X/yle1FXBnK0meMvp8aRT4iKeaXnBv4NkA3q/s0NJKtLi/DEk0ccqBBnRMukh0/eIMZW+/TkS1IVDMqgYy3jtAiYCCFx4rAo06W6jwZ7y+qfsIDqOkOkuTDzIJp6pn18qMAmHX6a8jVdv7Kf0D8Q+41V/DpA5Dgv7KA58j1JAzkNOE6/IOBb2HnoLRZvjGKgr3YkQYnVoplnRdIdwEvDO3KKY1dbnZ3nQhfHuWrzB1zJPoriSWBE11nn7SWe5HyU/3Za6pizEckLdwUGRib2VqOjMeVf30rwUcPmyU+QhdAmK3q+EHwfNdSqwS5CwHCiSfqXb6KV7uDw9uxGPMKz0kxIF7NH4TaxtelMxjIUyKXbi6oWuQzzsVBDa8+MCtQaLJ+9hbrolJnCHofcYj/ncwHfJv7lWSMsux99AL0rc9/JJ2LblmelkGDTXAC1bkAiFb8pdQDZIK94ArKidJmPeQIHrU+LExEtFznwzUqTA+7qIWRmH/8C6NNAKsbyzHjZJnWhAS5A6PIdzOGsj41WCAG60ONeANfeMQF/PH3XLsNWivfdAroYDDhn4GuEhAgfOxJHBscEBrAQFLxFO955XhlNQCznLge8UK+jI5qP1YVqMU8VDOTrCQe4npCORUQ8m4KQ8Wi69gDUHzc+vi+IrDPEhDqI9TMG+vCvOKXcOBmNr9ge80sCZV/ELBIs7PCOHUPfZuGM6BdhfQUWmLSgctDJ19+y5uZOQqitSeMMh1iihFXoJ8/x4bKy5L8YY8czbRuwMekZlm6lGhp8f9d6UsYnEmEuWRqjxLRXdNFMRpJa0nqLRdgZJAum6rU3HEjth4LxSBmEExUkyR3Xvk1c6k62Nzyx1NVBk7L1SM5cv6FplIVUbVS6fQFZQPUj9xy72wr9Frr0IdNfEO07G7L1b/xmyyAGfRzoicVvCwbbW9q2r2RfOPdCZdGO4PsDPBdQq/0V+/pQ2purJbDC3ysyrns0yTy8w7S7dEUv9r0JBg7lZP91t0mWLHEFCnfOrHeU6t2cVC6MP0Gw+dnCHoo92p7KhlOjupypzfM/n/srKxd9fF69/jDMA/SOTgFDngoJ7zp3kiWFnV9zjZoZb1F/WrkA6CPfYJvrGdSpxyKlNhgzrXApKcop/Cb1snQRutRL6S+ahLdUMIqTC+pU77B0+2WvUPC4SWIfG2rbpcPDxv/kBhz9eREv8t6N1IPYBdLLBaOPn3IT+9eF3bMTMFHi+2bMvz2H4IG7pbRw32Z8Sd5jVmVWtjl7aABFMfQkeQPBHROAO+E5iJ6b5WX55TMTXPEUzt/XjwJjJr29kncjHi5Oim2xz2oYkob4LEga9e5OeNAeYeEX6YyCS7Qip42ieTPxB5xA7armEGo5MpKdH2XONzfNAGg9VYMeOHftPilKthlfO3tCutc/suk7OuK36hQQ761JwWas1gC0v9dTaPb8UP35s5f4UWdYP1i55kVtQcqdkYXUMbJ9g7eTEpzQyRbc5t/dWcLSilnAMT77ZKgc4/bQgK3WpGkRUo4Ow3wll/pxLVVCAB+2SRMU7IG0WJDBwf+kI+OIWPEKMXD79Hfv7z2wblOXMFhBP73TBnxSSaAZFBFY3oU8iHIly/++Vv1hi+2dMOLT/U5IEM1bH4YpOUD7w2N+McnEbhhrIK5zLZSNrz3o4UnelAq/PRtR99jWbVNdTE0EFHyUi/Kc7C9laryfcTRBxEvODd5xmBFZ7bY2dhDFQNRw2/JEHe9gnXGwY8lU89iOPI3BNaXTlkDkkbfimI/T7CEcdQDR8CP6HxXKnaryERWkaIgJl8abXp8YAA3JScf5ts9lMzsD1/Twv2FG6N9FRi8wWW4Vl2mEz0a3raaXsepLLDVzge5Tsxh2a6pe/vB4LQttI2GCKPtTHHOU9/CppZik9Vo3EWG6E6qDB9zqX2RnvRWYYXuZABjDeoIwAlBy3pFHRJhBpe5lGiWNIRmTHJASNC57QVky8+d7Ghd1UgUghPKG0z4sdBUXslHPe58B8ADi8veg2qOJDmtU/djk6JuOrwUrqcyifOD08291BG8KnwUQH0JxxIFulHFHXSwBoFfF6/f5xgkM+hjtIvpqwRv5CBzFK1/EN4OToypKptNE41OJdbbVOpxECSds9sQFKstGY9kUHfHGkDr4uopANj0ZFrofIo89+eqoPEys9GoYYFe+sQZcel4faNsAKR+aOhwOEotb8pFMAPZUzuAk/OZe5EG0lCc9mp4+geRAcbNCRT4NWzl4G4a0VbyMrx2CDAwm/cq4wXhbxJQDhTUQo80XsjdrKXyKDSOVce68vxKlhsqn1aNZeiSn+mzthWCUcXxvyHMgNT4iAqi449sDZ59lH+QYUUbPcBQEPe2sggRcJYgDUJ49l4xSoQb8gKTLDsuf+a2la6MKtsmwHNoh8+5sosTg0v5BEjIxOaMJ3d96rcb1PBACMc5bavJzOAQswo357CmpFLu8SahQr2GigzyRJ2JneVPsP8Xb/wHOAJKUurwdytbMKRfW6o/6E5yQtg1ILKaif2hzCyIcBdDJRTLbrzfwEHQ3ss7gjIjnlpjBofFJiSepcaWqhMpkPG4T0RL+0LLxzoJGjblWGiWFrbe1eOuq/kh26b2UOeDwPOXwD1R0iq74vLiYP0GlQhcZ8zFvwDQ1EuTdZR2vI/E1wEeE+L+dES1i/RKmTkgzt2LU32/bsm0EPDUI/Bm+6EPOWgMKhZf8F17nJVjrXxY36uEgHvsxNYpw8M5YYNgyJ6v06gqXnEcVs3+pIN04r2cc2i0vQmq3xytYoDtjFrMYOqxMya1Frn2x/15a0i3GyPYXKQZKgjb/uOAGsD2zkeWuzQ3mjDjMG2B0NLIJvba5J2lnwzodWnHgELaEI8FiAXjRjefNBRipM+FXypwiJxU5CgcH/h2kLAk1j1lAjR87GM0yWgvh1POmp8eXCryrp/H3u82ZxHD1VgVWoI0KWwh1YjJ9H4dCRd0lQERLtEaA2S56Lu+ZDxSuuvkGIRLSbq49E8ifKDoir+nOMYhMm0AblWkRuFPKiFrDVK/f/eqowv33WjI84PQReaJfYEsVcmPLrAyK6RIN7qLmn7ExM8YJ3Gxd9Uoogr39ebuRlUu72scQuGRz87nrSX0dI3fr9mlTbU/PZbJUD5JMdEEi1XtevW+Nar0LwVrM0+1CJincZigFUAhKwkLV9ic096YaGF5WeIbG4JiW3wVpECiQXD6LfUYNk2piOhr2FFWVFp9Hls5ENnKHxmZPgc3ehnH4W3z4KSLCXR1o/O0OwATjIij7b7VX5adwyoLw+PxivaGzDLYnDUfyKhjjjkclZqSDL5DkAACUfyoa3VDL0Vn4eE8mF7qh5jEeYpjW/OPnfXotxpes+Jbh3/uQg8g0kV0SS0t0VAVR6zhhgJ3hdrh/nHVItXcnTyBIQmEj+na19+vFIS6p54yVdQ7K5wNE6FSIeOKU8o4Ye/gVKOGMZM9wm7BjFdGfsPNv5feDqz8Ze/NT+pMg3y+rQ4tDV1VE+E9d7vFqDOoTe/CSVTf6OhyVfUmy1H+yrLArWx9OTnb603reqZ6A0+YZVXFt37grigjKzAgTpQJbBlfNr6AWxoJmTo3yQvLzX5UskIgs4b+UhUojfgge1mFq8EDzxN1PQmZqSPYURg2+cUbGTwHc6igvVAdzWPJSv/MU/fhkozKghEzchkzAOcm7FPJuUlsqmo/jvKS6uexOMoqwnwHsRMgsoQpz0w/pOfqLIt+/ybgTC2iaKczbt8TZB3DNi3HFRbe38Lm5eRdHEXb4u+c55In1s8/4S5yM7lGoFyuBv3Pon19LK3Y5yCgnyg/oOd/Vu2+mbbHlWGKwc+nXodDdFG5CjVvJI9d1AAGMstZom0nK3MpSl2bV7jia/HZSwC0sSY6wUvhKItw9pSWT0/YQqJc2keopk4QpDrji/fXddXhEzblh+oAwnGqDN8Rx8gVaL2pRGqFP1HP3tczLcVWT6eKzBLHP9LolSvMMvX9F68+WVOiFjijJPavBAq0dTcJG1u2q3H1qppcJI2Pas4Cryj/adlwZgPSZ3Xga6qRIU5cjWZxB7j9AMVkl+tJhWUqDRQc/TktMrzRXjc4lmhNOR8CncX9UfklM1UYTVV5qhGXtKRtoeV99vlbuFnEXRgKKu9ghEefaP8wsAyQQEzi6T05sBRc6oUSFHS+qV6Mw+jpwF3LDK067uL5Voi8cNooTXfzpA1IVTXQZWdBFlBwd7PMw7dPN0PO9QIjPBhyKTfLR/waG51doazLLlbgd6usAJIegWAhFja5/Gw+rXyYAosqLv0PGKqpDMEluT9HIQSBpci/bnMfYp46KfJVj8RR+DuQQ9DaDkm77Hezo+ZD6oCNYPIUDU/FFgqi+etF3nguKTSZPpHYfUzXvZaiE0WH8M16MmOkyUkX0PqpN4CNAumgsbQk3s01s5vhsMGuWx/oXAvjYcEh6IQB0DPjeo+H9usV9/IuvbFfpWS7M2jxJ794RojhW4oP8Z01j+6Na3cZHYecl7Uqys/ffdrJvdYK2j3O6dXHx1t/vmkvpQrdoiFccYNvETM9FImKG8hZaXilzoGDPovJ+AvTax1okSSbgKmCHyFIO7p6mKK688hucXIPs+YZ0wHKiDPDH+NDjB1jgM1D17byq7+i5/5ONaUveQjFY1DhS6LvBYoVGWbGAeQMtI/TkFJKYrDyq+OTzeVkl2CXt94TtlCH/yq1pVrnQcHol37wGwyuDSqz7E/uIr+E+w8wlqngENs5o1craZCjGBJ5wpbSOfxGh6+JhLUk9HCUTH5DSYd8WqdzCr4Q99/id5UJzRUbjAeANUSmFG3e74cgsm4V7AKHeuk9PMb+DE2kzFGLtIxz75c4I0RXM0wqm6bSB2QmxtOwZh9hamz4f4zqENkWryLqrpznZVDqfAAA5kUCdEFYidT6ACaUrFE4/0LAtACDPATwq+Kz/8sPb2yBtH607UKYsvGvkswRvIY3X3jzSXLfMitnJTW8ayvjWTSKfgBGk6AuR0ouzeK65wzS9cX0a2WfVSzGT7Gi7xU7FzlhkxK5MyMhKAHgF3JnjbqasOacqU9p09XzrQkxsUI8pMDe3+p1A8w3VE50YbjuXb8RXMAuNp48Pm/7ny74Fd0TmtaG8FWEVwk6OCBSoRUw+sRVja2IOpZyImoUF/3K3qvTj1tNzxBtHLqD5Z7xYC5k3q2498CCdHKZqxyKmEGECObSbdVBJZuivorcllsyqUkLZbtfu0he7mHkbtVe1qOb2Yiy1mtrDtVJWt2EwZ8j5bv5N3pVH3Fv9A0Mq0ybEkiy7naEM41EsLnbXRfn7rN4I1WKEZob/PefpYhe1O63Km6RMpyzYXtkAke9fTd8W4TJdzdufKp5WMtRD0gH1rMnNB9wP+Br/AJ9eDo/wZ1uGSCUPwKNa1wabWpJozZxNC3Si9uDBjby9aXl8PqZ2i9mp9vyOf9w33IkPQdo+eQWHB20xBUabnbTSuXIrNgZiFNYNxbtjH3kgpH435TNsCb0Gmk3+8Z1hMqSRr2MJMfNGtFbVBn9UdOYH8Ka3q78jIwDIxzSbWZujopyoe/JLgz3DdbafcF4sOGFZMT6lcDyDMCOQmxjNXJ+xnGPolwuMBVf+uNStZozg908Q8yjfhYhC/TxO/5XNS/6pk1fkZZIqQklTy94r1q31ej53lo6oQqzUaROhDiqiplXJv3azr98zw+ACS+jDsA+1wLqdjPk97DRZWGMOP70+tLD8nHcYqCERCfR26ddFr506Yhw2aQ7dTlUiJEitsX7/2XZ4eeDuCLGj4Rg5lCDm/LxU30Xz4q6oP/Mp+jtcjyo/YTFmjORFQXwORfhN0+b7/dGBO2pC9u7fSmturIQItCbYc1k6gVJ/UPbWrMjW2qAjzX/X0e4Dhs8wFJRcHZR6iZQzDwbeMxaKMv6oaRC+xrPj0Rh4KWqUTDQ7k0dyJuW5G9NWHGW7atRn86qPv/9vcbsUpJIe6unFXMoYS0h/OTKDH+KQjz/lRBOkR8iZIe538PX4U02enmeEgkoJktANKHvItkLis8YmZyyW8+FFURsI+07kh16STG9Lp/SE+6VBPuvBBq+SG9Mv1+E1g1XMf/Vx+1aiXq2hxpN/xHoocEfdV1uwAsKQTqei+kbjWe3ZEJxw1v2deBdabrAzHr3iRb7kRJWZBY9+JDmaOaxnOaaBNhGLKTKGdyt7mrsTkCeMzWHwMleUsR4Q0TNT/6BSQkedy5NoyNyLvgiUyVrjLBUc3+EAnqx0owxDf0oD+6ysgU29RjT2DxXzlGVItlbCdvix0sUFovHrjwptVSJ7zElejTzW/PQAZwit2sPbrw/pL48OhHOJtenrxGfvBLzhZHaa7eOdOT+cUD5T9DqO4mCKSenAP73rj3fvB89NTWCDFsF1KQXvmGoAJhiSLrALPF/fM2f4Yeq/W8XJn7gngeInhD7/HZiI+cC9qdv3Xitdvn5uYk/K8NoQLdUmAmDEDj173bnHEmUMJKtY8ZQeic2XRSFbJCu8IOQLyTvff73+KoNS0dY05Rql0HT6xNEWM4p3CM4D34O86JVO9Bd5q6YXAvbVe9X1V1lklxs9RaKiEFnTuppLbvorPwp/OAKeoEc2W0/bvR9gZQ7BnZ1XEfDRQdBjunJF/XUz1tlJvVco8hrHxQbIaf5lMjyaJsEQoHOjBsli9apcZXrCcauMjd7pC8UJIZllmVwiSSPDcsKVvZc/biK9hSxIvWK/3nAxDy6LrOvkxE83HS/unkZWRJO9TvuTkE6bgIkrTAKbQFyRbwNvUkssDj6FpFfE2gwKt0R2B9VYAM1bG+IFyRtBF8cEKF2ndSO6o6FsTwuDLJwpnDrvqODyPENXyDVxyP0VUEPIA8RGOeN15/HUr5RVRo9N3J5xavmDQ4ZTU41DNiFnhaIvCsA2HnwqvTEdjfJgAGZ2aTgVW+VT1mGaEtsLEzZ7eHh7jw9Qcvt8nH/NY+WzY8RkEluAAZwonISYaU9iKUKIsSGz+e9z4L+OUqORn9IZIpM1aJWJGHfXEM07tEyCAcbW6Vp2vHncd1RBhY4Fi4eS+yDlsZK4pyWbxQ302A1YpdgPTWb2B4C6l7ibnOzvapYqw0tWNeKKbi4Cml4Z1ihOfl9zpVL8/8N+ZU3NxpOvqmTZ0E1PB9mDyhpSUoYlfrOozXR279mih9KAd4BB5ybnzPC+ZzqW8fmHT6FpoYgKbQqejWRPOkndPqL1YMe3E3iQ9MsxQ1FnSx9V9t/nfohSIBMxkFROTlyFI71oUDNr+e3j4Mem19CJDoIy8FPQGFxUNMS395InY17DjvXSob3orqLx+MiGOzo6rz063YtLhhuLBDkIt2Zwku4Wv0Qsn0WuU9nNv2L9TNV1rKXN//svhzDqSJmoGxLf6SaHb9gb09PWQN0+9jjTOxc1SVRXcv+spYT25dlMBDmIUPbiLCP9gsVpNL1fgeEEN/Da+BgEFtGb2uBJuyHAi75cDnUyII9cZRunFfwikv/PcgByDQRXq2MZ5Kq3tFCnk82BJ0LKLcNTdFaVNukSMI92mXyxX19491Q4QExNvJ1b5YVFp+TslynAR67j0OeliSq1PHUxQD/EY0xmmCWV95FYSDe377e8X2eS9H/taN+fg83XVSKSe3KX5yjizg2xT5Hzi/qIevnflAsK/RD/qtv8u+pJzouzqyBx1B3yAev2iQ8bzg2Tt4ZcAK70l2P3W3ZHt8ma7Dsq1vFzOwi1zOrhZiMvWkHyO/hvkGdeZ3seod+kkxGSeKGkKEOHrPQleQvg3Qxji2WXSh88TQUcZpvf3WdFoFQV+0oMW7V5Wy0FmSsBEsr/RDiknit+1hXdNbeWGeX5EVm7D2RPC+GmouxV2BP7SKSoHUNVJRXUSYf7WLC3iO6eIWFz6CvQtV3xxYEztSKbjpXSkNIRt8VaamXqrddnnXHy+InQD5ixDynNvCt1ojoQSDbpr7HMGlNchLxvjl+8pYigH08N/OzP7RZuMzERa6WBCqolVx+LhkPsPYqqB0d72W2JNlgE9Tg5vAYdToiQmawnwaOHdjALSrQP8xHe+4UsXcfKjYKpGpZjPlZfGAF6nYmHPZpeC0RTVnrQAF2HwR2f0vE3Oo8ernrzVCMNCP5ipGwtB6eKWBFBsVw/6aJpwRyAKj7t8qqCqt+G/AAU1IsmgiGEnGm9Pl4kkVNDaCW3k1lzulOI4kUEj3Jmnx4IMRIQbwbecClGj3sCv91TfcKOonKoMBjC+is6tWQn1pMj/FXdJ38fIWtNNcAVThbzNFHj4xlSNdal/+A/iX1GinZekRWu6MeRRHkP+o42jHIhTLWmO4KUhOTjT9I4IhEv+mwy9bX00WD96WU+5Yp4cv+nE32T7vwn0f47oS+iYsEg00s1ucF9GY37gmiT10NHoE/IUYB9lK3IHObAriljoYDkndMCBb38tAD0q/g9iP7vssgnDyKd5tNiIkgfVXyitQ43Z53paKERQbJPh4fUmB3fRpZwIgYbnHdld5RAVGkR5Zers/m21WdN/ZBrxyWkIbiskZE84FkPS7g8urntxJPGuud+vqN5eFEnD3Df/p0oNTieDX5uYKxIbG7FX4Qg4NKwMgzwz8Uq3XI/PcqN8H/LQXtCRmm3cUcgDNd5zNt8Y0GWvIFOgJY2gV6kO17udt7pi8UqC4ekv9uKNTSL5MIsSjiy+l+8Eo3AbDQYg0DGQpB9OILEjzrUmZlNGQ5+tsAC/pyTb/eRtOoG7H4jip3n7VrHKQQhCeqFu4bB+grbZRIkLPkelr6dXJjnfPHUmk+gh+2azVDKuyaqB/scwLooLbiPSAfySVJxqHnt6FN26e6b2GQCFlq8CsIcuJIgMNcUt5nhfCcLKOAAZXk8b/j8nffIbFSlK4hRm1olXVB+WBCbic3V8Kb+O0gJy31ozNAUh9IGyM3dUSvMQ1LrQuDyjttjxbul6e9jFkLXTveJYYIPf7TKfDVnd8F/Fr84hGmypgz0WlZY7+FnkgLgvS2Pwr9clYgQSguMOxa6KHOLJmoM0znLpn0XKG1i2givq5WwvGM4JoQSQuAR6ke5i04iaa7hEUyAKBwVfqbsj90NUo8jLGhkWCWJbOXTYBpehtqnpYMYyByJNklIPwiJRs6j7e2Wh7wmCSseHPkIx0pzXmtCb2njTmBIGhH1Bx/RCsbJUjMbmU5nceJoZRuLO8IA25JxASoBgdiLzMgDcEoL+90m5XklA24Xk14CJJ6bIpu0n3tjJuLlnta/dSdyzb7ZrvZnNj27weJIxLna6PCSDkE6e5KEf5GaznIFj3iS+0o9s+bvxKQ7XTuqYDZCG3jWujbHzDciAbvH9M7Ev/DM8pd2gaTYRfFgMdjZm8XH/XVnKlT4g24W6pjOh81YBsrjXrJY2Gpk8tMUbkJxFE56XTQ7ziQtoqEtdH5YUyB/JIePfjymQht0KZvtoz445oJzVIA7i1Xa+CUUjObsnHJOeFgFaeQFZlRiJK2pwmc0Gt/jRAipdFqbvs+HweceYY8lpMvBiw2lprBULMEfZkhfXk8pk9SBV3qcZKSntk7r8IEI59z8Rk6iffN9+0TN5xiWV9DepPouHw9rbMCeMSPoiRHsr49s4c2NJOzIPMEHIVI4uNXcI/Ncc42flU0M/RJ8uc012x/aGFXWPWojuHWDr36XriNoL8tLEn0cIjC7rQKkmZjBQqabp+MIgGiefGa6Va1ZhBDuwPClXLagkjtTOuZHfmiTGwd0tCTIyickJOPn78JMZrFIAWd6DUt/YWpjlsKIek90y9i5FgkLWzGrEBZjrM1nweoiMYYhKxgqi57YL6bJ117Zog7TtnrYSs4rvOTLoIIDqHHlqOYBpoqUQUURxvfexlIIUVDsSA2T2ZesJVQe57tvLENgNgH/DtLW55UzEZF+iqHwXiuQXpcUckDSfehWKEE8ZeftYCeFNXzdQMHECBtEOeNsGtlf650G4IJ0jl45vkHhzjiv71Av6QzvNyPHBk+pAJyR4grpF0zD77H/qFc0TY0FEADPLZ/lxZa42OokoYybqlqiBczMUv7UyXo40ruWgPvfO/zPb6nW6jXrF9Q5Xop6W4PKcc3t+blX1H+gI3PEKBXmq36y7mUdrtyC16L1GeuaLDXiWj01I2zcQpYNa+SlWWKL7Kv5gVp5lIKFQhrB59EV1TUjmUzMoi7WjJQNqpddlKObxYpiI5FWl9qNqky2j5mgA7Ajxpxy6Yu/y20poYoghtx7lO6P62OVxUgGEOgwnBDhpZK5QKhXjOBe7vdpLP52aovsVL1Eq/CO5NRFgmBig84PCW1Di4fGgz8moZDJ4TvfGaXA0O+AgxsjGOLQkgQwjBVFtP8rs9xTk7SBfUKxrxD5hT8PhMdDbVhZ5msV8g8EjcZ7dtCyOPuL9wqdpc0325ddHerzH3jZlo8iyAY698X5LDaGCwqLVZUa7mQze+fa7qh7bJGBC/bgZJpzEm7bPcNgFIctAWQnrfYq52zs1ZJKJPZ5IzTa9x7k3RmQJCTV0tRwAscXXHN4wTDdfTgSGT8tD98hoXGA8UFE6xBr3eu44YWoootdYM7heyteGmQRAGLEto11SkViv4AyJP4BaN6xvKkRcQbOZygKYit3mh/A8o2cG5qz84mJrtu6Nzxs0d9KLAYlKylTG29HVRCbR1BsHGZNarzhcEg4GE7OzuusdiFXA5i+AqKTMZV0irRb/ZZCzsJWDvGZq4WStm2DOgzEb8+YJefubqn79UVCGbwt+ciQaxXHyYIKPHsaxpvsrX4mf1b4TAlbRvCU4kcVg1AEf8ensoj6hfgNDiM6Jmyxi6W0r794fnhLNTCQgFE201RQup0WUjz7mN9ztgnL00iSQIcp/hQ7MXHHy4QI1RrLgnxXfG6RlEG9zgAdkVBCi5qp9WLSYsKb2cr1VqzvDU4rLE4fnSg1WhXIQ2GHlH/YZKW3bDAmq9dPU7TZmtfC0LT3JWjMstadUBLdbAVxXIyOkRI/V1/O/6A9k/KTZmulbNz09Dn0oiVYH8ABiIrpWJnAbwAU6xJAyedMbrxTYoR6M5VufSMSzWdefJQLkU5+YzvUVYAEHZjlGML93TrdPVFTB5a63mcC6dp+PwRqlSfoLZ/SOUiwQvgRPFHzlDCgVCAgeAdhMS+b9mJNeQBJSTxBSbzv7GwxLhdnQ3iAwhog1FzzBBaEVzpp3d5qVPHV7YJ+VXpCoRNYjICNEiYuhDLSc86OgWB2zsom0i64mQ/NKhpSjGe1+zwmRfvepZrS4TErP6vFH6sVRT0B9mjPkbk8WmY1Mg/JBw2RfKCBYHR/hOdruPYHVRfpQEHtJWcFHN7i8niyIWv+IHBgu1RSvRA5SbRYgPvfM/Rht/H25RPfuvh0wXZlTptzfL3XXJ+j3YOVXPCWWV6MwKy1MfCLSagAUVHeUjrexKXB7ttqhuGgB7FQT8XaP9MH8PMYmDPuWVH2vgxemtKqSqgkM3hW6JFmq2vi30rUmKXsO6yRGBoPJayP8rXNE3dqyjX25LzKmE/N5lC3paX+PfPDkRkpwDJ+9QHkEVjlA9orX7lSiS9UjoUVVbfIOkFi8uOiI3vYhzXZ4qr28gO09nYWPA532S48vgUCnSwt921aa/OHl0XhakMovH3SkouiTaa+7kvIm0ojCqU1eBeOxIdrxtLmaTSg0R2bAOZKB2Fd0m8utSG2WWutYcoomIMufUVyWWm1hCcoNOMTpQ99IgvcnzpSXi9zAniufiHwZdC3viWTJOlBneaKJtxtLQ+XfY3nWM8Vo9X9syVD1KfazuoZTRX1sJq9YMuE8XhbqZySIf/UHQQ8txj1F5jq2c1lFDo/+BpD7X3hmY5JKdrucVyNNmmOL6Y5QJB34hh7BJ4lzBGZWJM24T/vzNpn9zrbWEdkgErLzO/LkepRnT114vLmhe/mfk1sFi/t0t92o55mkf/bhJlqhTBDqKNAyfyf6NrtQ/yHh+LVMxfWDMzKhFCNM2EqbYOxur+7ijAKzYQU4kEYj6HEVIhG7vC05KB0LWeYCWfdtnzHpHteQVEqEwhUVC/R/YzxZk9TdkdUUUT0Jvq2UvdqApjYl1BSVsEjCIjiCLToqHDWKWXU7jEEM5YJh0GOPwfnUS0WMSed4Nz9CoNy2ly70mdQ3PYgxS2zw3qF+kv7CkKweQ5X7BN07Eew48+Ajczd1c0iORnDTgz+e/GPEssFC9L9Dm0qol/khYB0J7X6Jkmb8T7q2Ueus6eGwZ8tol2+82H//HY3Z6dGtnVH7aINxUClkaaW28Krus+ZCChAsT3R0AFDPdweNk02TVmqLRbMxxOMt1k+aBSs+CoydvGGiVERVp9pEo0Qz8NTRq7S06x02iZmVmzAn5nubI9Z3Ig28ZbvwmeuKgL7IjXjqd6szfs4yAKhyjJeAhzgRl6v0i+qg2pFyJIDuIcj/UNl7tCDruKpz+UcOSVzCEchz6NbqCjhyd0aAzMtF4YvCHkVGrQHmgQQDAKqVIZpAusXGHFtNPueoJyvhALGtTp65qk8tP4vA9+4o8XH3Fo+A8HuwTo67fZ++fA59Kc/61Ne4dUk/Yr7SbIyau68+rf1sClV5svo8TJIifTtIUMBsw5G3d9YRY50+V8hXK82JnhSx9B1yKQUK8n3Yrvsa8dp56Zbs30uhWUafItOjg22Ni/Z0V47Wyq7ThWD3JfwyjwxtL+CJJYwyoRTQrmujrDeabifnvxxrCWlGnAxCk0gW8pzx52ocnvL4dKNTLpMhio0OKs46QX9CiibAMHBarAjnmBbUobptMxZX2GRxMBQboMamgyg919mag7+DnHERiebXRoCb9hXbabbCnYF2aRkFtI0lX/LmSnDqSxKFnACpi5RAOzTyZ9usHmsofSQ+YwDm6nEykQR8YsJn0WYUrL8ZyWvDdPbgX7uHwTvlCUiZyQS77dOCAdk907H7qoEbu560HqVioFGcy8DNz9/4CX/AwsZwZolSWNiPwzYrxuluVTWkxKFXQaAM442kp0CcFlwRaGNj4Ae5+hujXq3F04X3WT48xODAs1dRzV3oNA6eIUwOs1mv9Tj7tH/qAe1jQH+lppPWckOjdCuW0I/bNUHKx8JO00RT3/Y7eYb0JlLsqefKdN5kVp042FGmsF3iBC1F39Jamoq1Cj30jMpqgT1QmG1cQ7KgdCME5XMNxyRjlWvIg1ZOFHsOPM9q0zNjrTBvT94EG4aNUIOZegsUJB8uIGXlwetwL6zSSnbF3u2Taobda383hnAQhPjxS1D1S3Ez9TDXopKJHjGxLsgz+QEqWXLR39C94P6AH0O9x6VSiurx4kowp8nyANy1RjX2PMbRXwzdw4z+3ITTZWbkwLdHxGYItqFqoz1jL0C7FmbwQ+PKSeTdYJJKOMAuu/2zeS0lcfY6vlnx+F9aZr6uprEo22GYp+jztIUBpu7mZ3xzA53gB002F2uMk38es01jF1PPRkPeB7vWLyFwu1qUMcAZrEdjTsbUogWr+53FHM/UYt3tEKJGGLJ564wc+FT7SGk4kIgZQVm93OKhC6zYBa6Fp79N2TfLzJAGmzvWEW9S3+IRrL/fWfpeeoZ149q4jmEbgh3xztllUMpw28ETR7xpN1jbGq1NBL0cXXUZiFtgoX9nXl4WF/O+GlcD/nA7gO0NPlOFHfPAjZnE0/LKjUmgg2cKP8IEH6J/wJUzPl2NotRDU7pVpuYRHa9u21/F7VNiQfqhx8F17YXNWJd96WP8DOMukUlSGj3hz/clfukPRBCIGdNKNXjLbUldPbNVD4R7iKBuJOUYKRvCAkL+olIEyO2RNEdIvzr3TkwAziVGc6wpsBeKUhKrxFg6t5PjNHZ+EFMZwNg+CaMVTW0wY571tuxUuKMLQY5qEQMPIdZ4D/y06bsIr++f3NbLBACauX43ohRnJsBO2Ehpkah1MwidhR8ao1eZxAGGq7wEJpTs1nb4kp0hzPn0kVQCYBSf48icWY9MYAEBjoiXsYBI0nRvNN8ErrVnRAe1FbkBL7silUddwjKxMlcimjoG5xRk807YasEoV9YQLnA8TQDWg7/jXTu8I6AU+uyfN+XrIGuN8rWB85JHGwtpEG7xbPhX2QAdLo3HwqMCDpJ+6gsiTV1FcpMohtCEYIMZ2G67QPe3gso49NDIFu1tDozRStmUisZIi3K0r3ZgcwfZMXeO30uZy44+2hTX4+vIcuTJGpv2Bmpc8bkvCosCZTLvjJXGXD9JGRkuz4RWqR2s09HMNVbe/UJY9VZKXfzLIhb5vGoFOldA532x1OJ29cXhllfqu+ib3JO2JVIFjpfT1eZ9OYXuBtYJxfr+eEJVPxjJy9TzIGeTsuJzTbPkf/7Yir9FGH0fI/fKPtV6qhqG+b7KxR+Uo9+rOMOLQUS8v5C3w3zaTZoqM5sSRSrxCOz8z0efjIBC0p9TLwIOzX/Fc3gm/wi/xd4uXso2SIlMckI4J40ZcnN/YBxplIQqdLp0QEMW5sMLQ5pz6Dl6L6r9AKpbBUj9dzKum/5pXvKBtZnLn25m2HfalkwPUM/FbIEA6NZNFo/6I0wH9Tp/fi/8emFKuyCLR/+aZpTPME7QaZs2iljwW9ff5s7InUoFo8ulMD3jvSJMXJKJRhPnPHfukwxgm7QGz+KAAeH8Fyfgkc0tx6yAwEE+ZSny2Vt4xwsw6qGkEUrCJW0jyhvuPzFj5/ut/tEhR/yYwYHG8L0GNa7T1m4raLGPftqhcMWJzwE1A+/cuEZCx1yF4+Y3J01nI8td/uLeQ6rKGzd1xS4FZah0XV81zMBo7ZEwdcqYaOfGfyGsk1quJln7aG4TMyu75HMhIHc5nsgStdjTTeouYkCB8toOLPMHLR6MvLOIoDzG/11fvAC2gHuRE23LCEbl7PaTOTCAcpphjBBZU54gNA+7f6nTa4fxyIDCrPLJWiZsGqcMYg3XtHqqLCESJZmPP8KnTg5aZVUvSEdtc+dq/QvAOerncHefpq+6Re3wOcjJiv1CPY8NWqdmIFBDEj352eorQ5hrID4YuMRIQpoDC+ebKPdhYcuqLWz8tHSU+dE5ViCInI92SIPdluuBC9MvTGZCiG7OxMsTD7wt9FHqOdrT7v9ttf8SYFAXedZwS6p3IAeFPwWSc9hVUVH1IqGUWakLaYQk7SetbfCyoDJH2ialhDNDtjzMQ2Rcq1X4pc+iZ0gfPjpTwmYtD1eDnYDFqt1BAp/cRnf2ehJKg6DTz4bkf+qrIDkNWB9YSHOcAe/1juMBfG0q4DpkYwzWPpS1rxlBEZlZURmFnY/++JuZwoZCL7Qpdl0ro/vyTr/8xdIrlcP2YKS3TUkmqXZTclkXNrykpYUKKHZNN5TaxX+1muAVuCyWJWPtjFJMdJsFfCDo01jzSCAN3qjdAed5EO+03W+A79rUFOYVVZnk9tqikuxpFjCHP38RCQsCuXZUgcz7HZ7bbvM+DDUoel0NLi6M/2fsP3hGrZ1ObCGZgsBBXpYPBXLk6/cLyAphf35FEyYOKSUvrdysiknPitY278p0NGT8JJclXhAzVWYu0eGFpVFYmSwR+IVIoxF0rbe5CNi+CskX38/tdM96uPefcEYy4tQRbPeGvYkj2fZxPASST4d7T5OnGquZ9SN+2ElDD8LxGUHpbg+uTv/OiFGG/388q9XwtP9ir/2fph96uT67LGAAmRl/VTpcGdn9jqstKaKc2RvKfgUuhhxKnL9IoslxJy9ZedDOAac1V9TJLYKplFUmDNfEPPCFArEZ0hcqF7GS4dYWSr/oeRct/1ZBIuQgZhuTt14ph8JDVqcKzcwcvVP1uqvW7JKwlxgoAKdnFR4gW58KYsgsjNgbgstNN+6U+Z6/X5UzMpqz3DMaYnaj0UrqklAW8z9YTr4ULU2YtnDo5ITlVYndwvzuRuUo99pCY/l04Cb0s8cJz/ALVA4YpBwpz6hr/hi0/BtpTy357KGzAbPYJ7+yKB/5REliWPf0qruRUQZT2Y8XWx1X5Ty6M11BhpKQxQWM0tjw2WyrKZ2IwURsdAI34ifuHh84GcMr7Re/xDcjqDE9IsV+hjUJFk24mvLkBoBdS5QfNkOsh+OVhSdcJf0ea9EHYRJH90jKZV0tCMJ60vSXcjbawWo12oOEFl36SbshpHp9257e+aA8mwj6vcbZjNppqiOqcral8QlKImtUg1W/Nwy+g8LyPaxRzuJIsMCEriFhAJUyCUYxjnq+rQF/+QgDjOjHvbP3I5N41Cxhud7PK9lbQ3Mx82Vn/nJGl7ckz+SmiZomPn/RdGsrMcNsti00I+iC9Vh5p6H61wpohNjm9yDPaWuIuSJ4j/6U9Kk+5wfv/vr6pMXb6wdXDsIWuUxZxnqjRNB3zq6VrVaqOF6WodixrcczzxK8IXWMpRdFfh2jjaG9cW4OfXGZkLL/PEMChM269EEZcPrHS+fFfnoNpUywptoyPvkKjg/czzzWslLYDO9iCs9XabV7TskmyTGBaZi2IjGpEn24U+uDp0Z0j+bXowlqrjc2Hs6WhAoRFrmm62f0fUOIAsDjvTY8gOIz8LQvVnjdM9QWHs4INX6FZt0HxblxdeyyjonI/mf5aMhTUL66nBpeitkjlrLTnsAVPhC6zIumDDRnV0oTRkz78n1u91rWX9Z1jidA/4iVrlP1s0BnUuzNTANqMQd4cykzvn8Wgoxl3n4DRc12NX0KEPrRwRBxcF8+AWa6Pbm9xgXOw4VGEuJviijWgK0aYGEYEzdCFfsYQBpJ6UDFklAi1K7JOmz+GKaXu/m79SOXjQ8KIoGhmE51xwD4/f5oLbQPcreRNZdUHUW8sKqx11allmKqO6sdL5Uot3zUWop/BotJxcFYrIvTJG2zgfk1NTJQLIFWnfOyyDZjbGq68fj0ekqNA+C8a/9d43txn/AEh9G6Y8AMlSPCvbctGefMvF+GwjvbL4Hogl1f/3S79oRcyW+wU8Zwtm27O2wtRfqme4pSFNQmL5mY+sKAbkRg8Fb0xiEOLNuHOF3GEwvfouvSERX1X12/px6YEDbbwcSlw3lYGBzJxcpLpWnlQ/l2xcE60h60Z8x1F4YclzpWcWT5amC7GvOazYV7x+91insQJnVvhjMlVjihsRPYkMVAsXAN7YF9kl3v2zbRCeqLSxQH/ZJg9L742v/pJYeZXfLR6u4dCdVHzxsEcPviMEONDoSPR7ZXD3tw0UXDCowA2a4S0hbF7NLf10TJxpIOcIwpNwUP3OfRr8g7Ubp/yIjawxPZc5oneCoIH7zWmeaXZIg48jaGxBcOYre5ndU+Er7gTp/e3lJxhtg211VJPqXAiOxq4N218eMeNfZim3xtsQ9rQrEaocbTJpkVunU2AUummGmdv/iEcPjLzppgIsNwDizPVQM15nQl8i2WACUsdJUhvrj72RrrwKZPDr/4hmJYvtpjIhwz2IE6eDEg4rY8ugjrZFTyOXB63hrW+4+3oO+FlJSFicaczKyS2qMU9H0MlMwe3g2ow0IXJywLktJo8I8Zm1f5fD0Abq2crmaLHkPFfQA418go3Yhq4V7jLN5CwmratL1XQNfu99eVYNmrJFxS2mUEixhoqeT34KkXaKRKZfp0CA+Xc+KqI+mYJWgG7AVntZamqdagVp8zBCgxc7W8G2V0+i2pU0XR1z6HRNqBTYxpT5Q3VPi/tVTFF7piwUhT611jKykZGf+FFYF6RMkCraDaKLiZCtfEE2634ck4CeV7n+8Frbe3kTDD1Vh8L/hkflVtLzZWJNpZ937HZh4i+fZ1IT4zciNyD49Td51GdFniT7XbiXJfcHOdgoQFKOiQUwJz4WIt2lxumM34TCpfDqhc63h6iq9mKZrRUamU+Hc7o2MpWpi1Hnh8f+s3EeUTYrV2twSK+QN2iOlX63eMknkZTWfg2L1z78iNGcztXHKEJLXembGZsOIPsn07EIMEshOS+xnVGB+QbkdFV3vXnKjaEAnjVIu3gak86y0gkVGZFNLJSSH2Tw7fioAXmQrVu1LtM2ireSQFbnzS5GUeJFqY0R3cF9SYizJBj7RwscyTriT6hupfy9aPbPtgJNERoQ9EkpiJ4aUFR5dcRi6y6SEyOgAovhLFLxWjPIKIKHCVE4h6ZKZouS9Lht5WuBAwKvtp65V1DePx6eYGwboaoTcky6nNfhx2ITOutd+FeO1TQy7/JEgdMVnMqwD/cx/carH6E4quHcBeHXZTR2s0CiR/aeo3yszWMs9cWaAsK7JMSEwNgCMRE05cgWMd2qhJk6evJgSTvDDnFS8Muk8nxlhFRXp+ITamDSBrAxEuu0RZm4rUQ7f9leChAnfHbY/ItfMtKB5YAed1YyKD2OG/CcZIqI5+AA6vaV8LKlR4TRDvwSN2+9SmWTs0cST3u8sEkJ7fWaJrs9M7Arqw8+XsonNxDiHTndSX+TBWdrDAw76VZ1el29kVQUnDMlFx8opplGHGVxu3A0O/BN8szdWS8+y/COvsJE9H1qWkjXZg9TzCegQnYapULBLqTUydNNPawXHHdiV5j86nFDxU0t2HjaEnnWwry+lJL/a1v2FyHB4nHx+MDDjoc4PrYQkPm02CdvTSwJlt1Odic5ntLXX+dqOOCit7XPpHHNLBgEWcZq+sVNxQTlLmRC4yGUd8XC+m7NLRK4ugn9fUpm9bWIamiMZsC339aI6SX2gFj5vxZW4XBlOkRH12L9Tm+5H5C1mUY4H5DqjucA45iAoqYSGKzGwQq6wSw0wTZDBDmkDMoqWrrqmWpl+hEN+HD0uRHMm5Br57KeB0BY79SQteSUEYnSQEwhAcTtuIcqcJ7i7hHkit59/yTx5jhvbofJF7jz/Sex9ATamae3PhNBpHcipzCQIObF4bxco7HF0yFeg9rvc+CE9Dhnw8FAinaJr8+/3QF+lFrK5rLemGwh4UGJhwmjwl88RW6/11Dcdw49XOKLPnVY6vo2fgMong4dwm6B5HfV0TUUoUFgDF9uhWsbDCcvWSvQKi+7AxASLtDgFebz0dLBuSDUY+WiDl+3OMCFbkMZ3A9dXtiRM5HXmZmCeG0ftMWSfSgNdh6avIQSGQMMV61cO1PVsvsn21L7RIfP1M1EqXADdA4uuN/pzUF+YwvVDBe+jP/b5jkCsCVefxi2EQGntwdvz2SzRj3PgD/dxAPKexEsINqLfMWzQ+Pz9h2qkLYVUAjYAvX1xj+wBdNB+jNb/KVRvP3S0SE/6OLquszmRk1vi7exHTkp4ZTM5kKhxTZuI1mMIPh721BBFI0LA9cIxn+kPoXczcnY5KJ4Aqzu5f9VCtGY2WFnqPQAW6fZ/vuHLpddY61+/l9veMjZPw5t4TqvjJzEk5sjrL/m+PbAgJ0C/vC53VEfG+rf6cwfAebhWmdHOBg4Kp+ACv5GiIAJhHDDCw5C2vpQu4slm3SIHNj92NyjkXXSlJSfsrDLwUh1Fmf1BWWiPWkCwrp6OBJRSKjWEl5xsv6kZFIqhfZqhfwdw0wOxwiRi+MITcttUOpv9lHbzuZuFCmqDn9CUrTVhCMVzMjoxdj246Q/cJVeBw0Lt6NDwYY+hl38Q6/HuOPIx98TPnOrIUwJq1BtNR1kK9MA86NPIm48lo3NKcG1ZYawjmhtcHgf/RGEBDJMWaQsS4H7V61Otn8J7Jq0g/ZnypqHWo33CsdF+I8wJVKNHxKv+A/lbf2xN8QFwqW8UF2fOkbHD7ZA5aXSi9p5IQCjqSV0kDuTEdjROR8xyhnSBkdYhR5RSXPuyFr0Hte/ybh7jpNJ61HFMs4oAof4tkO4LfBMSAVUZQ+SNbIN6HlNToNRqTu0cvwqlETEfc2CLHtArwTibJ2h7eS5g2EOZteJrVYPQcGNZ3f0pDNXQiaZndKlzuJd6tLmLn0Rawa9Pv5gCM3uaju9WzdKIZlcs9XraBQdQNAoat+Y/kruYPL6UPEOOREnSg9WDYdnp/ctVTONZyoCxh4mWFrKH0t/OkC53ZgE8H7/bOrlmcxy2GqOnRH1d2B8d1TruRK0HkDFYinVSusldpsx1wbHlievr5lxdu15z2sKfPhXmbNpaH1RGHrO/revydqjEK8YneweIQwXkDrKcyvxFi1iYTPCaBf+4iYri1dz6VSgi98Mq5ma4tDb4TCu8S2Oqf/haxiVLpq/QW4BV4zGXTe9bGnNDnWOjcSxU09PjGMA4zJ+QNXNSaEpnjVb/kmJ73TOX84d7U0vO/4KX9jtuA0Ds0AKeUe7SXPFXnKO3fvJFzFAwDg2ofUGOYLOgPwfRGyRmvE5sZIT6TeTUP66CYMTSPbTeMrlmh6AeNVYYF/K8r/SuWRXVfQxBzTaU0mQjRe5v70u3DlNgztgXawp9xi3iB8PoF5RdXn0V26FZE3T2Z6fB7G4YJXL9DZu+IB57ofOHmhmhRsSMtkWu0P2ZbEC1PlJfJoScQgvRbiwaUAX7DEEIJOMcm1iiCmQNexuTx5trE38aPtpyP/+2Kj4eILtdNT/hPEmxgtnTSAhcL3ZLUvQG5g0svjaDFXmwaT2mC9diHJUDJD7RZ1gH1bZFGWEWAT54MOfkvXgqi7PglquUS01DkTGcqa5UG/E5jUcgosXPmTIhSpjqSLle1R2iHPPEDwExtZ4vm/wGgtchDJPZeLdgqoRmfdmRXQv94tu5FwLj6Fvw6qbjyYGS6UUO6CUEq9EnzQPw3afH4kWluqD5DhB58cz6EifFSSJHzDF1SLiiEa/cwOuG+tQYEO4k2q/EP5+ekKEx/t2rWnnY9AYJkHwx0wngVRzjzXIEHDgdXdEF4vJbo+PZ7wsuG8MXy+yYa+vGK0ARQcEKSzdMcpVTyPN31IJ5llqfbaaAgZAXvdzZMM9fAaIGZsRAAHsiMXQd5TEDd1HCriNXx5pzlhkuhRTkbeH6q4+eYjNMVlEVnHN8Qow2ICg3tn/HtDzU1i0uFUB7qmKMFIjXqYtjAQl1B/UqKUNDOo5FX25dKTHYkOaXUy2IGOoI1QRonBstXkfgD2BPtzKSlCPa+P4K+VqF7B9hUt8dPb/lOxmmNbWz434RDdfTvhZBGy8TLDpmSaFea3e+XtnQsu/eYQCQYBIZBOcOGp4+JCYB7+oerMJfwVfqhotCypgmOAk/0gEF7l4G5RbQbqOSpvI5bIMhApfEYl6XlpKZnMm3ivO/6KeDTONOieOPnoOLACKQnIFF4UMKgrVecACnQo0xJ8UDcyer8ClTV6Ia44mgin6gYOhcv34JNy2mDjyD/omf3lCpE6mNaMw9CQH4vbQo2BzjLe5j8l8FcbC9nSfIz4I3kov441T0kToqnmEi/X/lCRA664d4w/411oFL3gz2oO9GL9kKxC5JAGLE0RJDmuyF/zENrxuCikenjGcs3hAONdeBDebeITI8ackohjEktqOZ3CWS/mhtXVctWPB7BhlE4qyvVyqvrDQy6YACIARx1WDWJ+HcJUGTdUDbBLrp6ppbBUZoXJ20nHJtLGxGEveeo86TzBMgNNM5qnXeKyGV6bePphhyp/8w9BvbYOvLE1lEpM1YDMumh2B2xc04ua48h3rD3s/bmQ4AYCaBUZeD1+4+D2D515A3JJB5d9K+deVPt3gnTRBvKDNQajnVMqZuOR9YON+fpaHdTL10aqD8WUJckeBPLCjteWsfjpyrdNgw83BBTRsKRo36lqjWl1QfzsCe7xWup33MBknh4SoIfIwE90noQKejpqoEPInBU5sf3orSuS0muZcegUF7VzKSubWe7dwkQwUDHruH1Wcc7hwMyVdm2WP2BZTHgmZ3p2zxPFusZhFwAa2c4BhDmAV4e6do7WXUTXbWikmOirNt+sTnfR90BJuoo1WmZdWvl+JKXx8R1oc9oDN+Sivm30LMjceshTR+xrm07XwhIKO+hNDfE+mqJISD/z7RuGj8OdtV/Zuz4dFr1wbd/PFZtINQYT2/sEgq3R01TgRS0F7qlQwQRN70FEUaeNhdfys9XaD5106A/SV8VxQ2cHkudOpyPSTuB1NWParjgqUBhIRtniuQWARq02rZI45zzzzRqsAsD8Q2KiYLPe6TXugURCs5CzFK1786Cj/6Xt3YZYujJJtvbIQcWKyMkrRlGoHMZ/kZetRJAo+PTddyRiSTgwewzZurExGUxN3lS+fQ83/eq6Ba6lhOP8TTSt3NBj5KP7YcMYKBXifQvNI3C/DYrRquTPvMUcsZ4cELHK7oKNGw3U108kNYU3c2de6LNgHZnAki8XGPprZbNFDIWaNev8ubnLbQZ+UjGuRf5Mb3s0nSjCEuLp5Yros7XN98YboxcnmvAJhG16gaKi4/759ey0g1ZHugvtj+jtB0pEwfxWgBh3TqDjRURIINdamERxA+kkSNauykkUNCbTdgXZo+T/JdUbr7USRak+XKnOuxlKC5Oqfw2b4DO05cRVFfuP3nnlabRgJow94teb4tGzY8AZoqMzp8nY4aUWXZ+Gy0U5eqqbEDMvKYT7VkQm40UGlBeos9gbWWCQ51AWcxqp89vixhb6kryszjD8yBtQgVZ2FdyVaBqqcWLsKLMbiNnhgmXB3ktK32xrKe0KiAs9SAXqMDLOsUZpU5vtFEqGaPRhMKz5E+qvsu16k2SwHf/HGRFALM0DydQRfZ+JpHAMzao7ze/r5McHu9gOa7I60gHWEBYXN7LYgYLfBRa5tNibqA61KkEldKBdNLX0TB1zjQIYPIZKFlqP9miJtOzSg/19rD+LQ/pluQpN0IK8Yl+3tWoJpyiBHjDOMU6HmLUcLh3WpvKxBR5o3RYc1hy8BtSAY4qYP8AQZQItp3K1nvbf1qLFrcfj7DjgEeJrG6YB8bz9BQIHygKchLZ+p/ECjjqB3U8ir5wPA9XeVvKpAm9vqZSd519+BpOpecYgg5nc/85vpBcBjWc6mehP5cr5huenugnKhSATf98M3BCP3P3tK7PEXJ9uh+Glh+k0gsCMt4Bofg7w1iFCLTL8y+uMQUuwmXOWWQu3JGQSZAZnXkMms9A0BkOTYt4tZpkV+hIW2oy2lp5VjP0ubSIkQ//5TM4CWs3ZHTVIp438ISGkWthgEg+xwuWWZLbEBK0M/a10E1i8dgidTCubCpXdAHMxXbZs/6QWmMMVrixa4zSeZhaj/4ysoIdWH5CqZADFQ08LB3H6HLeNWg03k9PhjiGm4XHE9peh+EqOMe1fS+XcbzrNrhGbgA06Hf3Yj1jD9PJhY6eF/CdvOwlrFRUTsChjiLn5GHE4XMpLOOIfuolgczo82MjtBIgvUUvPVmQ5ZewpdPFhl/Ftz75OVKUoLoDEfpZuW1Mk5OOPGGCtfU6HADDHu5S0nwZfemfPPpjr8e+uuiJs40ZPi7Zu7nB+0WRmkQYFQuKQDUL7kzbp/Y8osYyV17UEN/AzTXGrj5GcD89b6SWb3cx93fTVtxOS6WP0oL6iSfrdQnrNbtYJrkSEViiF/olTS6SeRhA5nk8qCWLArdLOBkRe5io3jqqkMueTRqNG4+xXDPtxUPDyaVvZLpX5OM2bMEgZrCQrRUc1dblGEkyTGQv8T0ZEL+ygxQvCrEkHME5t+1+7zfN4SbeFP2NoYeLdPIR+4cbZVvWWuSSCm2LlJZzalfQf+qI/BxxkKmtvENU1OWelbuv1lglRXMWFTlDIsLm3r+m9+IAV5j6PA4Zmxsqz8V1cS8acMXcqhCYJxcbdgdFN4viDPE/dPj/VSR23G9kwi39vV/BTxdDahATqEYJbkqdVY+j2oMQftUooC6Io2+sewADJ9SRmh2dW2Bl9Eq3se7PdOFvdFaPhTUWmdD1wZvm1sk/9hBerEaDpWtkVXr/7U4PWrBdRZxm1fgcmbrnRbIjeulvvrucuX0rqtQlKLZ3CVkuKANoW+e147AwDF7yn9BSxo4Y+JdMtm0cRB7iw3IAcZsSF5UyjtHRegHR03g5mqj4s8Ak1I+c9turXysd59yWZFz8IpOv3PNMJP91umclIRc7W705JXBXShBGRPFV72e8wHaqbqg51jB/uA+LAxaDswKIMmNr8i3EuwuPmNfp9LnvGGSLtCs2cYFevRmJ9Are8qKOTCYdHUqDrDowgDy7EoCEK0eqFW15l5xH/nwx4wfMNamGQn2UjrAttUFemY+0u9Fng6tSUPTdR31xFmt6bxKt4WAVqWBIE7MsjkhEQjirtEftE7zlaMNBrQMrDVCLl1/yNdW/NE6EMiHaw4i8e6PZeb3qYXRA70wYC6ZlQtAslDR8F83CZ3jOTpoM1U9slC/Y56aejRTg+9+g9c99ClXKX3GysSzC1Ij5mu8Eu+b0ZUqtnLAO0MKOdBHPde9mkMgWY+Vldrcp7cvRpze/XAZcLFMTR7zpoBE9dzx+oG0Fpxi46/Ooo4JCKDn26HOPIC5UJRdP3yklVax31zT3ToYtJXr8Co+bIS300EGQTKuDV5OC3ppZroJs2GXhAOQvH8gO5v+UKCkmV//NK/uk7T7pdWobbyZcetppCJMHdmp9PBTG2kgnOghk/2yvFTWAcg96qaKPeoXUAtf3GVjg53bXEJzL49JpDm62J7v/YVVowx2d2cbejGUqdCWl3Wfo6QInaulG2TxzJzP/RQngTq8Dc8+Fko2K7nOOkyCenX4dP99l+Vqbxq6iHqQi6A3pRkwmbIsfOzhGGGSiDHNhRdfAJJxQc5SPVmeunC1qc5IDUN/paTm64opMZRlRsMWibhHUpPeH7fXfIinVvV+Hd6U/7TFMwdUrmCwA9mmogUjGpT9uCt6OyVS1Q1Jt8TzKRCCB9mSLyD9GN8CcmzcU5aYX5J91mdonY95FyMmy0yLeObksBKe1dfGj3g8WREQiS36+nPBOCPDeXsMUmzlaS47BRKjH78Tyeujr8IoXRbYK8Z6ORVfXvEodYaHZdKpM94wmChQqqqyu+cqoC3EqVetQmYUE8WKJsoctluSILTaeu3Z3xjtpp2RD8Y0gd2xywLtJe8Ho6+IYQZI42es8pQAzRCS13WEWigdpuloks60jFTreTKMC5XFm0DKviqdeQGTLdkunoSrqmZP42HLOFqFA3D24UoUXOE4N6W9TMR2s3bwAuj5J8008SkSzq1l7CHPcNgCBLqPmR+EK8FIB+f4BzaUbdnoqyW0DrrsutWXXBv6b6aOO2qM7TYvaZFu66/p3xhiELZoeX4fMcIyjDU3BVZsajFwOnidpUv+iRu2WaN35itaXU3nuh7s0BoQ2X2bjH7gSdEnx2nmunzmcH07Ocfq6tjp4NbD6n3BgBy2VI+DPH4UvEITIZOqC21RlRIcb82hkstlxK5vtTmQxvszn/RxH6dCt0/mGxfGN+Nk547piuCHs1rL+y0Zxh2yh66BlwNBoVXN21Yb/hkJ9gb0TKHkzT9JSuFS+/8yIs6Kx5U/8GRf5B/KJTPpoBs9UJTlW4IkGXFHeyFWvvtwIFt7g/cO61AuBzmFgUAmgmHaq/jB045L6FhNGTEdS/0WMpXMpZalvg5sqmXYJ0MVNSJr70wfb63/iD71mH1MsQQLipaBbUTcaOXFNltcLJxnz7+1oGaZ84oEn6725MdNf2mDYuefv7Ol2hELYKXHku1UVweWQqQiW7CKm1dJe8xk4znEm05QqQL+/kOVLMNesTTmblSqovE3Us95RmXwcgxZjNFIYW0oBfOUImpEejJ975N5BzjknwCRxWlVeVaRPZJW8igYekLnayQvjM6P1DbZLVvNO7OMfOnfiTn2jszqMYLP3Zj4JBZwNJDqGZ1S3A3J57Y8q92XONOIhRxHDfoCy6PLs1qVsscfnaYR5tbS3Q79wiKU3U7vlxl/O2gbTWXlcNIfhgWujepoy2LmN2HqPy6n+XbqCoU47msKlThzYvdgGjvTVwWeB6VdlvxA1EM5RHCyZa9no4YKHH/3iOicgso/Hqu5WYVx5IcFIx8iTCd3RHBt1zn2WVzWPoTnAzMqFc23tD8R3Ctph7oOElNG7fzMwVAeptqXLjDCzRvEt2mvK/wwHAx3gE3jDJqfY8in3Nc3gPZHB/yLSN4t+L+TjIIEBCKpo9Ggno8ImVIhWD+yFz1WgJ1belxjZIyPKPLGGJmjzHAWmA30xuzXA6lgaYWfxdSf2ajF5Drl+vI21HN2PwfvlCpIkGSkuk0txNaGhxSGzNtkDvuEvI9XjFM9Lylr6URGQeAkVVyXDfGf4gYzOoWYOHuE+W7kfqQRbCeMiE3qKI1jJgBYKzgt4vqYwmFcV31LM0pzuZS4MDDrtOgq/uhY4c103L1fDYeIKfynkYWyB3Zw5EKq1HrsTtFd0qhrZkcJzAHeeLGSbwx3crTWb5jlARcP1iu+WKe8y1PgMM7SCX9UZd5eDY0c5LEcdYDXulSyIl8pHB0XV0PS6EoVJrYlNQpI3is06kkMc+KlT6KoR34usra9To3/IQeezYamTeaoV8YljsfhszvFOKv/fT5jtyERXgfRLSEYFR0j6D31ymldODdJRpQ7pep+bVNBvtOpuN+f9+h9VjzawUqMyQ7QcFyA9/+P7Vb0BNWtTW9EZEDhyTVMJ1t0scZ+oYi5fAGEm78kFSB3yNTfCM4HkEL82qYaQInREJuHljBo/zapm5nxcL8EoeL+T9u4hWz3kQhA/5jKViR2zoOB7qLUnKviYVuKsVQdOQWG/ny6xl00Hdm69pLNk5W5wA9tecQqZqUzH23zroR7A9ziRfJpcBMhl4pGoi90RlqsZ7NXqx/NavuSYAS1aSNc58T3ZI2waDMqBjL15aYzwt48p+fFqVL384PLqOiWdMI77sN+3N9SsK4lwkAYYvC0hBMLZ82KhNEbMPZ/NwL2UjMqEFdoKDOVnvNFAYklz23pje+mK06JfkImNQuP6th7GQUUlhIUMpngigZA62PdAqSmKbF8x0jxuCyELlpCy1YLmR+5QyMyxT9ooappR8MQAjVK8N+uVizOtleifYIXgyhBha3WASeOj2ZJkFBM699fck3qH7ssOUg6P4Rm8k/GL0qPmdI43FFgNXTGfFqGTIz6IrmwYWbNyyV0JJ7DoBj16P8w4CN8upiEnOHWcuAZ2a+h/dtKnQtafWtayvOdioxNc9ocG3bz41GFpT+dLNKsCCoqtD+2KmSr0trISpT/UcEtbICmsqwy9+Rgbw/V0m5Ln9/7/xJYYJ7olGsR0eUKLoc36Quc4lZ+yWp0+4iTA4Tp1vMn5/+XRLyA/pUOd/zsS4OUxweW1JWi3AcZitgLjhypD96PIEC1cFFGgCYtjw/tTN2vGiFGKeYm6xHpniVtKNUJcA4D2e2+F0Joqf8UEM5RQgx0gK2VfQpJbGtqOpEjTCajl9B4epWL+IZDwmw20EI87YY+wPj+UqtOR3vSgp6+q89G7guBTeKUzj157ss5emGOCXrm9pOeWyC1AIUoL++CZzKfdPg5RXjm1m7PXxJCrnu7Ah/oHb2fWm39pLJe02Nnr1yJhi0lksNUq+4BxHhA5a1n1nynnX+i9o2CeKENckvz/o2myzIaI7JaUHpCw8WX54eGD+DGXhLfTI5Xnd7FezK1mjMJPhDwBKlbsNU0d6awKYOiOu1B98N9ie2NEIjXSwqbhdM9+pE3Nbte0X9ZVgTO05GZWUQPKEFBshbjm6STGO7k4uU53IqBwHKIqr7bwhZ0tEm9Q3Yh9PImJNEZi+O3gJWjxSYUi2H8W41X71zcAM3KocGzpeHK0rKW3XcMx9WNI8dMzK/RdtXIiBvm6KcUOUazIXHLKIDGgHndT105qO1NXLtRTKVbWJ7QDQ3OR5dkuofNFYi0Cc//jmgeES8k33VgZ7zD3mzafhBvKstMrktRkQIpmjKVYxLlBiKVdXi2jikHku+QdEM4QQkqArkxt7F35Z8EKhDySXdH6YvIO72phCyBjrbHpelBbllY0a8lN3tawwr/4UjbSd2tdZ/npgVpUMa1SHH67+KiGokRPPNAkE2Oe/Qmg0dcF/MS1LfMRcVP+EY8aa5dK7i4JQ9UBlqeAs5pcpplUevWEKgNo6iUtOATSsrqW1C9SMxqNHxlI9DXyjS5idsLErzI+I+CIUiXQKM0b+I+l2Peh3LfAPoj7EYfw169zp1I7o259hdH2jrLPIEC4wpqAmycioILefKXwJckCigqhMkbMbVI9kpg9MKTti7Z6rPlwHJwe9715HmYyuTnWmz9VQ84BUalWW4iWuEmSxC1n6tFsj5eOeIu1jEjDofEqXLGGUSDaCbBqrdAyO3vCGcubDSrNQyCmYmlhIV51bYHQTBMcngYghHVcu1mDVKrkbEt5rU9rXkrBSZIDyqVy+fRgWmb7BW1NL/eFi7DJYiMS8mGzUsK0d0FySMicx8g+fJsRiiiKAoqp0p8pXTqCRNuAvx2DxOg+y3EUUWivaIr/YXR2DTkJHeaNKwr5b7m/daMDAHz94//rMN6ZOagptbm0f+1Ois+elzbjy3A1E5ZAxXgeq00tKf8U8rV2t35OuykRkADkthLSMwyUh16wz1h12W33XjNbKToVFJDR3kQL658FPlwabCNsnHbTLy5GpY97wXepdRXfq9N+S6iCAblfnb7cRy2iGgwBg+ka6HjGGzVTyytT8HsD3iyq3PudQh33T9nZZAFg2KN9LMymrddnAiWd2hj2c3O+E5s2HoHRaDPeQ5ESBwEFGm7gT3dOyAXZ1+OLgzYNIek82bJAv9QvYDvNeD9Xyew2b+CRU1ZyLryElROJQHcnjK35fE5/RBujiNIrmZ2Y4Uyzq0Ty3InA0JeTN+8b/pFoLclUuBokNEIutFHXQBRvnQrUJqAo46rF4P7D0M3yBfE1fQSkmXSC/9hvRyv/OFrvWFWFb7JRe6WrhxzrRKIe3TgISqeoiBl2lofXdy1Xjt50QJIHPpUZKSkXro/VWnCNqs3oRU3wH6MZSkOuW4LVLLcuHrNfGN36h3yKde/hj6E6gjJzMyG2Rus3g0W+MtT7U/TCltJBc2ltZCNVNO35KbRYh3Ns0TKqljUXgiiz2688iqAGkWAwHjAgZJvdrjkZxfx+htFSliC4+iwSbSKL7VmuTfda/bJX3KEMlCl0PokywjEFT7bzBov0THlXoKL9W+xZrHVGtjxHAd9ANCllPR8S9rcXI5CCDRtMaZiO3mErMX36d94cXMA42AxmyKIut7IJIyJzr37pdMdI2bAfNFm/tYPEuBWB5DZB1XiURd5ABdNaYZjYoZfPH/lS26hlDJQ18jVaM5g401+vkuCy1Q1Y9YxVAmiNy6GvPSrajQivgGYkavk5PGQT7InGq6L1GyQsnMYWlJIbvWDr+J5TY/IQr5g7DdUIB1me1l9/sb0640ZgASM+kT8CfZo0vs2SBts+jQU1F0N+7x5iQuyQh1Usr2XBnFCvQKzDc6tOGDeFJ4U+Jrs63eIM4wBUkSJl010pASdi17gnlH6KwZR69NE2/1w5PmzINlglsgjCHbw+ZL0HGD9/ixpHslc3H2ohTM7xAfvHliD0MxA5Z5aQVtEiC4J9NwgzUsf5BNPVDuo0KnG8O2bMNIhsYoLEy3oZ1M8Iz9ZD/9mG2ZMhsqRx3z2UQXYxEpuEbQldZgessHxw/PJIWsahcZyPc5X5ZNaA+9FnlTvoH7xXzJ8wpf+2tV6JtE7O9nLbgn+i5HEJ4NFZAZhFoJKvpo7/1hYKxHR/zlE+dp7UpFhFhSDftRHL47bWOagDprIUxXacOE86YoLHK9DV0f9Hp7RU9CnTdob/3kyBSglyDz77NykyJKlsFugWUcUAA/WWuxqrAyP8w7F1TQ8UO85xq2slQCfcZnBXLKykY6+U/IxTKBlHG0JrYbRXPJm5/RgAyB3mZUos6+v4cck26ojNLd5qQPWnS73rWcgxCQt1xaJMYA5dEgJmSftoYT4HduSOukT19BAqAaxt2Ye4zCC3LWjuDJnD7JHIDXiNrmdIBEsqzFP+u5aLrw1oiXofrjZ3Ki6UcWjFmNAduFhng5AzIrRq0aTxnY/v3FHR9sOWikcKPZuuYADwA6Cn/4DvZhpHyHhQ0iBJRGpgfpYtqdCG7Pv/Mgzy0uM/4hDTu7vj2C8EzhcdJBnNA89XV5NIB2wbjEMNKOTIIG/d+W40XIs7x4KE6T6n6SfxJAI0ryht+iyYI6Xf0Rcc/jvXtIqfh8f1ccRfMhJ5XiVC7HZ4KLDnmTpczFEDL4BVrlq5aEd/knnUcUtK4KRE6LqHc2J/f8cJR0LuZqTpsa3lEmSHgK31LoaldEADrsdUATRqHG62AH/aOo7cte6iVEqkqV5KT/6m0ePs6jG0NWJHCruux/CTs5eaDYNUR/dE4XEsv6t/m3WeO56nXYdYRx29vhq2wlM7iqo8HSZ+i5eoJx+GjLGpKIxbnVOSmd5X6KF3U2ld3VxLxUjR8aouIufdP5oWztUVcYU047Dmb6EA/LwhQOqGPR8ak6TRZcnoJBLx6spc/QNSj/1VZceNnYUUGdkXGTYQ+SW4Wus4B1z+e4S1oXEmLg8VdsbNHIuxU96NEc0XYasrxKrdR8yzszgNJ8ZRHYhuRGDL+zrmT9c77Rh8kzrUNtQzM7+kA9eSA20qz86GBE3c8oBm9kbY/dgKKmYuE7pBZRx1POM1llpvNmX2VSihUp9+kMJZt7q+AswtzyoARoXZYQty0lJpQ6gnd9hU8x5vJNM79rsxHP18NSUIzXXXWjCOsCSY1qLJfZBWnQeRNUt6rCSsL66Zaqk8RkYyJvZEnYw740FFY3aFB8dJKKCEaJDmQhek1ERrKAEnelnxY10Qmux5OliSeRHAFdY7eNRxu9ac5bAP+fyIgIzhPEqxhKtZiBZIV1HcsGzKPR5++JXFUr3USJMYcocnRDmmHnt9u7SuOLPOJ1eIiqZYkNE73iDgRFN9AyNdLDVFrz+7XpwJ7/oYs5cHIYu/wN4uvh4RUKiP7uLYjQ8Gjj96xjAlT+FZ4bV9ZfJGTO7WQA6UshiQbGmZTE8RS3B9/syxLdVwRE7RWKdEoN4Xx6mgTNS8p+wGW/YbacXTZSoLJU4EJ7J6iFSsYVpnRB4cFAP/qyAGgrwzNdJahWsacwiDsSDXtoWCrAoCVJJRzWkbMQ1sILioG5mZYg/avdsc4tKtTZNFVZKcxgJVBn3QFk0/mHcD+JJ3c2AbXjWxaRzece5uxQ7nbO7VLU4zL6tOUANoG1Z5m5XewZ/FGNLkljyfJ3rb6Mwbvy5cI8weyKROZlqlzTS8DqlSNy/ERTBjCvGPjbOwyyfK5Fiygmqi3nfXPOq316gePoH3UCutSfqCwUKy1f3suc4b6qWZwypEWhikUSToWxkyDx5uqgw8gBXdf6Si+IZFHePymMTPx1p1eMHHd1DdXHel05e3lHbMxcLMEdw8Ls0xxp4Hv5jSFAqT2ercqzdaFU5mcjnXdsIOdQ2m/aXO6dtiLhmytmGT9caRDlW1bDP+tvHYFiLfh3s8LycDwO4WTdSh86x9c/j2n5kIxRhgAGDH3qvACO2WaGGrYcNXwS+0Dh01jlL6/4T8WlruAUZwxaQoi5XLKIJ0p4HPCCoXFlOvyFKzDeRw86nBIVfqYSO/FkihLyybAgVl3WUIUCUpNjdU3QXEDb6XUXKFu6OvG3YkVnD+i1GtEHzUYQrWzALimZhcAhb8+ANWGcq9ZinM/hKnE/Hs/7yw8749MziSTCv+OuRj6ESRuM38HBzlgrdfdrJ+GBMUmO2Ms/3KBRBM9Das33Tvx2AkVz2gM0WWmztJw7BGQgi+KX/9Z5+YdIbJI1WMMvzdAd6XWXRJMyTLBWBc1FeWvfjMob6zC9KLOFRBgwgR12JdkVT0i5xeRCACZMknzslcZd0WbmC66zqaXEftkXTP8Tmnz+SPbhHxtVuyfwMZ8vvetOstIvNpf0QcwaGfGc80ajaFHdrB4rKEClyAeKYOV6CP7zXPUMmzMvwguh+QkOZujI1Uo98tNuwvDpZauAgXJt3UXMERFX+6ycq+rBuEOVYqKlsGc128MjAfJYXCANQn3TfU6Ot5st5D25Yg8/r7bhxeEh5KB3H76cqz8uAyPbr0TEz9juxqq7KNTd//HUh+cXdex2YQnlKkvTl6aAcl6AkhYatoPJ6ET5RzMWiL+ihvk+9snJ8MDuSINyCHL2IUBe9ZllqsiUMeuBTcX+cKD6dP5c2fBUBj588GTCli70dCrR1l5JUe5JAYBp+zB2sGPrjwze3uyBsDZ46Lo1ZKTgAvi3ECrA0/p+xoUdva3RWLYSmdfbo1GjP6m81y8luU+RlSvSPeD5l/mwg/+xmT03uMyysasKzHzrJc4R+E3FiIQ4E/7NufuJXueOK7wU2yQrceMVXq3xxd+gtvRJIwNAFriBz+qmjpH8iPSxKchGr5qu/RoFHGWdfNTTswpCwP3ZMhICcO6kEhoQI41J32oZuqg73R2MlS/zdYBA6D0oAHIy/AJNqsgwVGuGosRA+dTlMu90uoCxsGNmz2FbMisWStTvOHNYdFgzKDQxgZ4ukBYSbDiGxxjCpmzRHU+bCR9X4HrXmlxG6H1vjdYsPVYcEr1xpDluZo65elTL/NEcAxUo3eYkAe+VG2MwJsYBr/H6qvp6aLHxd8+LlkcaMnVzWguC2olyXnTVhiAGd3fBWlLoGyipVIHy/5S2Np7cf2a+ZHaJxjtj/hRO6tr+vPbcknbM1Ox0oN3OGREH0D2UEbUbo7rAHGNJzkr6fkfD2LuwMVxzy0GS/kEr16VwIYh5vfNd5YnTlH63PhYH/gvgrEiIvtoBfTSgoNA1ARZwmB6FLvle17FNwo3Ie8V/fze9fX//7QnBhS6h/2UrenJjmJAehsi7t1w9lWDmBRX3QGdydPZ6qwczbambySjxSMgmTGmO2QNpi5UzhZA9uk2b8lUE1Hk86egJo6CdbJLKj9YDj616YsfggQXpL2zhx0+VNujWWoFuDNvbTuvBZyFdglocmNZ08tchavTFTCCJ0Fvh8o7z3vyuuWGQj/CpzG3I/WRqMrxsmn9pFKaRkdxv0f023ZwOhf+1SMgNeBFQCyf7Jbs1GLKIvpBVDeFuQkmzidqjqyg9l3FhkjkNG02ZBUrMeK0WEmJBx+Hz/nZikwY/nfdYA5aoCL5dA8vqfn6Rr+4iEr4L9fCDhGDKq9jOT9n3wLErggWT6WV1OHFUyf/eC9GnPbJUk8udZ0lqmW7vsE+at5dnEHNalfTh6Y5JjqEmcqOR7nYMm4JFRqVXSYpS1fnTSAv7pmZK3CwoCyWyjcmaV+ioEWy3YeFYDNyP+3C+GF+xK3OJKMC7J1UlZ9UEqVrAHUDSl/hUZCgmQnBvML06l6UO9Tl/FXDPVCUIZYhZtoRfP9xvBlys6Ibh9KAYvoKrL/34paxLUlMnh8P0fJXAAKsLn+4d8L4IWtK+s1TcK+BqH8fUQ2w0EfGc9g1WzltQrw54p+8Ku4c7qpsJg7oxmL0ySNh5MwkWbof41HzsQX7R7unaFgkfyfcYb6kXCa+REhhKdP8OhtTAkAeecJQzTF/ryannBrgAJr7Oo8Stj2Rx1qY5Xv2niC4lL78VA0GtJenvW6aiGaDWCGs7gCYLLumOcHWZoaSq+D2op53LJYnGZ8wUbXhKuEuCx9/WZLYGtfPwmKApruOfxXePRYLnVrmQ9zCV0CZw3H19y4rp+IoG0CJvLejOfjKxLaERAuTYZndjV6YLx78w756vjPd4cjwBglJt982ifC1Svq5SBV/1NBx+TQ68byM7QMCee5MLMFbaKmXwf7o83rvN3A3/qZM63IAEXVwIrKUSRdODk5Lqp2T7kRFJccryOl/jhQEhz017MfFACobbm9N7WVMiUbo6xOYXWOK8XdeDKGYFKqV0zVT6HTz5hTln6Rxo9I/fQalMe5tM0B/uTewQ+yZlWFyW/bWPxihjC8ajSdIZ/AKc8rXfjfvU6B0hjfyNFnHHDbHZKiMYlR1CeqXqyyJC14Is4Fm/EUBLMDzCaCtJYAwPBNzSlv7Z0OM60Wp2xzb07eeZp9Kg3MkKWCsf8bvtcdC7tZc5Zvr6qCk0PBBJVBi79RxVrv1QFUcB58Bq68VF2ElkYhKK7vyNrAhfSAaNu/275jvOzAd2TbQU5N+oZ+uAGMZEi7DI2hHRp+g1HXRwQaXI5N835NBW6+16kpn27SRlMMuBLJQc3wW+DBZO1WE2aWq+w1O0LhlHAP8CGOzEQUsjVvDR78eMmgvcOGPsRgT9byMw7HgbaOUhEkQOh5uyQKUlvcu+T6eKXbVAvIhjAzs4amBTtoBjjsWNVNgmwGdBHVeppTKPifjwXnpaCAw6T8EbVaOj+6HgKY7+23Cmfv44bwWK7cIW0nbRyprhFSwdDCR33zbeSvTWtkRKajQEWqqIErwunSJJuaG4f3RrUe3rZ1u5TBfdb8A+mInSY6W0uePwbgjOYcHdHikrIas7IP6jaJP6w8M69pcZvbHAc0lnXpRbqhJrxNafDh5WebdynjQJrVBnJF+4wHFdbIJNeFF/WgQ1+6pUSkMYVA5YKZFaRMLH3sT+LLJEV5seL1HzqKrV9ydv93PXETcVdMwGNwIvPHw2N6V+k1l72jH0Mi9h8Jg/e8rIyNv8JWqUhMN+l1EXrDay8Ma8qc60nxtx+XpiV19j7dlm04MGujWZ+gKcHxU2F1HJUFjqnSW1nQPkJAvdvpzRIBcXSZun8zJtNVRP1UqJiWxIPSZ9TS6GYEMS0Ulwh2jbhgw6/43PhpozRUxxFIXAZNJU8BZbn9U4DKfBx1OyvfiqmaO7wg0RRvLM8MV6MvrdW8Rq/+rkSNx4g1Ezls8iNB0RwqE9t7oAuW+C45kd6rCMNFa2xUa2dgSvqcE8tDxhMUacPwgSwBwg/5eT6BhP1FtYz+FgOiCFqVw56lwQTJJk69V+NUeXTD8tRRP9oG9aVEEohwgqaM9qyit8s4Fl3U5P9YCGpjyW849jOP+sjvKpSxIq9jJUmgxwzpJCx1x7yLEPdIIhKPdeQWhSERgYeF3cJusN/nM0khTDKzsPU1JLDYertsKehRKYFKb4qhYzyl7mPGEICGw/U2UTLpg+Z4k9AZxtZuVbjgKGxlvdiS4J9rUicAjjNM7FO6p3r9QynLV9eauzky/EpUBsuWf7KuT+ekzK2bMA4AQOHUnxaU/MY/oeJYJtrgxppMEtnYGwl7FpGMdBWDnZnt9LyZtWFkuGEaOT3aEv433CL6kUOjo8Y5rFTJ7EnsJ/wi1zgTteE4UOYrc9k6iq+MuMdhw9XVJCJZLkaRbyKvZbh+xhcIWMhk45DtQMhnS3SylrVq4XWD2xMrSG0sgR5eojsdsxKY80z+whDrhU/S+fRBU6uPqVnZPu1eaR7tkD3kxj6UK5ViDzhy2PERDjAKeKhV2hmxtlRyhCl2cYHLxSNDU4l10AX0wzrewrno4iLkmJB9FDoSNANyeCO1obSTbuku1AihUJ+mvUak8TfJQK/8CNDpNkFUWV2ayaXpVlVONmFNkebGfO3tjurUX+fIhVDDkmZ8ayfWayfLT4TGzx90EVKqY0RrDgES9HuJLh6jYF/irr3wgnG6v345I8Z/i4HAfKDixemFezR0KUU1kgrEjzmOIuSYpWyD9LQZj1kG6He9/GvOmgxvnuwPwRBDiTvmVV1egyP4M/NwDCxx2j6qGykT3TT6PE3TRuzrjV9djoUez5DeSYAzSEubD1/ylnWBCfe+6maBKu34iI1ebSHVUUODK5eaqOQrXAxHBNUD2M/30Axbd1hl9wEnXHpkg2K8ZaMrRgTsCIcPx9pVjMw54u/dfgDnYx9IcbUC/G09RmNlyiwYUK9pVOboR84YIHb7T04ZKrVEb5KOTJvATTPb9NdbF51ee2WTiwCiAis53U5ovsH85W7fK9c1LJfBRtntoAtwoELEY+6FBZT8tBr6pQVTveGNaK6oVpMDLJAobmKQytwcG0ytsWjTI/upt39443YS4mXZ9emumWfsobve5PbFprcO2D7bq8q3eEfK7f70bj5Q0EpxsNP4+xMNkmyUnHshbR8VoiRrbeK2+ScJyRAjPnerdImlOICEQ3mKi2euRWN00mn6EOLm1ytT15dEYlu42BNYk3vZwFKCDKRIDq2MZqES6fmW9lTmC383dy4koZaN/83gpgYGCJbWKo152rriUkVC1zVO57/qFuWDa73VsCHqjd6gmQJwTPqm7cqB3FAXq2X31elHRELpPU+vl3gkkH6hD0Y/Fwd/dWrIEMkeZz3z4G1Dwr0xZpj0nGLOYg/x5k8P8rUPoIkat7spMgwKIIxTZKfM33OcSM4tPB9+FZcrRVpxqJHGzq7O4nBVQ/4+HgYYvTter2/nTWz1zC9OZ4DX+rhz8VxSRcNHX3+o+qvcDQ2AP/EGxGdCFMings2unQCnFrHACRMJt72nsQRIuYm/g54vPBzHhe98WWaCawes/sW+miIhwmuJYlBeXpJGV2mYvAw36vdsl9FIv6LgvQexv7KAqA56WVZ456A5zU0RqEongp1RyM+5U0wE0wgP54k4FEoD6AWsxmgEuRBr2GzrbY90Hcpc0m+pHNVgP08t3lhTB59F5TdceoQmdaLy4XEZshAWaLK8PUCjbwtnfFIB+RefnBGl7qlXjSnSLJBNrpFvaB3IO+liMqbIM2M7d5VYjFIOFgxCRqZkizq7UcxlwJS2tT8ho8oRyCPtbk9n1N91WETNMtc4sSbdl8WLAwMRYPpw0v+DTJrRN4N7wmSKoR5pPS5gr9C841S8p3fWeduj/tDk8by9iLiQspI7BvzEFn/wN9PFk0VhikbdxKk5inNZeqIBhzGYLS8kCXOYCqOHodWFrxE171vGjd4IEPy70VZZCuxctAWnZmGokebb1V47C1C1g7SiCXFOUrCF0yznnN5Txo1i1+DzxTH7W9dzEo4ewwG8A3snhEntn6+tzvnNoGpZDsrWzrLjB4mpja98c4OEJNxPEWkqlbymIORVLx1amQFj2BVvpEvG9FHWn2d9cbT1uHQV8oaIzxT9B8qnRl5h3mpC9VVkAKgTcs51eJXGoaHE/huUaUTFEjZ1NmuR0HfyafDf26TU/KdkshacFgPXtLaIyi3K+R6Vf8pOdLEcYhatcCvqIXS4ONGxFUSeFaJtGVAThui8hrypf+oj2ceOIJSPDrq7UJlaOdmQduQBTjIxnYFkxigHfXUN5eU1bLCRBo/wHVrFCLC/TLyYn0F2tFSjYQp9dlJjzk6fYi93pCobOLqUnOrMoPnbUEAJJFzNmXXNYViSglkm27rGtOwvu0f1/C5aFcwuYu30UJLhCdvbEoTQ+OIgVqK9bSggj77yCztZoDml4op5mJcUsl5UFmdlp3O2dCHJYHtvmH1bRHHJ6AplqvppJmShoF4ZXj+xXDeecbFTbHqeuEt4Gzge92C2zeOjeXwnKOv9k5aB/9LlIFFx2NO8tpz/zJznW7pc7h6AJSW+8zGhzMM7JHK6epM50nm5uG69gj96SjZIpma9Qhe50B5UIG11Iy0slznkUDwaJOwffOaSMEKV3eANySurcXiYZ1WJaNQUGEvce908lkmmGzyr7o3wFa1bHE2iBfWOeEWy6/nmHfCa47OA+8KCT1zB4S5Dnx1hIakkIquABdqNVG4U78PI5KGNPSI+K/f9EbdzDs0VFzuzG7x6vmMEHUTRwepZY+qWA2uXa6lzt3j4bk5/u7cjPFWkYl60s+6usLXkZnfQjALXdQ+E7uYx1u4U5+WX3VRUsfss3OoGUfkjD3mMJEbt435cT+ggJmtijvE48Uazla22LFhnzpABjaKJ6yEPlJz4Kwzw3UCD70sTtZTLEYLrd+dT1iDKnPRSOVzZ6V7V3MQHSc8TTXB5RmPb1khRU+oncKzlU87SmGz5jwBl4o+Dzm4+XL2tP/wIoDDLTNtPRken52YP2WlD/cPK5GM0qgpyNsOA2zFZG9nL+ZcdcW3ApQVyvchLrkRB8dfPbGqopBkJWtwDTzYV6pLp3JaFRkVcLkd3fXqF42TBuia5czfdgfo7sf2EeT2w/0gyb5nCQJPxDPT50IkIDc7L4l3RcMhCoQhKU44brMLrfdPloiVJQi5FV0mTdGW+fwfXjAycB1Ly2dPskuqdsDIIZ/UBREQa0ygU71NKJU6/UMo8IKHF0HiaOGKHHa/eAukpT87oCmJ/6KmLC6M36SfzsPGQs+K4w9MHptycC7W9WK7PVy3Ra7zafskSlhm2VVe8iTrPpcKJ+4HQ/TIJsRfazgrcm4to0ylaao8jMy0VABTbZqXeej+G/7Im1VVeelL/E+CWSq+wOA/D7NiHeakzKWv6QgVFHpA3fxFld3gPTfuEwB9J7Vdl1ticheTT4VNecslCdu8ZYSzI+ypfIlfho8+UEc2r4T8oIxrXacJTspTNidR91EknQxN6vVmFl9xSqUOfF2g4C5Yj4Vruno0E90Rd97TVy/bGPuzmHgho8r96y/9i9zS1sNts1sBg8Edlp1+lwZP18Y/hWDBbdYfgHM74M0HwNOw7I4xOmfPEOoIK2PnJku0JwoJ8FDErgnoRtsfAyYEle7DAxfqeBA4wEC15AZulBjz9UN3syLd9HQJiKoyal+yIhMU9dRGI6lw8hxyhoOlIyH16ebop+hMi0VrxTG077dn3tV3efINzuoYX1q75TDvGXtDuMfFqwYH6n2EovaKVCavnHTdSsTmnAv7ULnrqrZH5gV3W/S1zUjjLklY+3rG/hYFk8SvqB2j5SnOCkUgzZOXyhF6XQjbkp6f1mI9SO3MglyfpBeKP2f8a9GWlDR1/+ef5/IdGNq/zMDUO/83kN8zYR5U856kslkhZCuB5TqV3meMEpnszubj11ncTHP7U+SesFaac2X7feW7rrE3BsPIXThOnD9mdHd+7wm7inWXkB4o5bJZ2cICY6bXeYEoQLsC9iaZ3gfvYuRaEyjxxytVWwf5WVgAdSUIve3vLf0m6BefnQdCl1XodDPQVshI9TfVT1yry9ZRH9S575yeHvtcqwxMAz+TWFvwB+7gJ7UGOOt5qiUQpQ2dGpN6hTIGWoDhVB7tSyvLg5Uz7MJa7vUvGQEGgPaTbyKy3mNTxZ/RJlrLfjCCmS4Hyzo7YWuvDR23TzR1QRyy/rSGaTTxkq/eWqcY+vXMVt0ZOJ6kMnRQ0/SwwoKjVdTsRcGwBFHEGLK/8tWM6GtXOetQuNpAUdr2rot+DWo1GzvAksko5oNtCcTQVerAkSyyrNMAl1S/2fGNebr5N5kLPCUzbfEqeIaM2U5XsAJ18b/QNbc3xEW7PLdEoX4v8+mLIzi9F5Qbp3vYOKNGQ6N5R1ygN5jKPQadgYIsW0QjtioH8zHYrTESTcdoApV1gOSz1lGWrKkdcUGyKMT8kK0krgbs+0Lz2l+2JW+hh8JpfaarqfyGJTpWcx76c4wSQjdW18CowIvq7aB46+JJBQOaNG7ZGgCYg7Xcrf29sw8s5vBGWY3jhYmti2v99IBGlPPI0Bzv1XKLzl/AppT0LjZv4sVcVfL1y/9nvZUyDcuB+1FUbWCTsKlN8jMjDo1CXR1EWCtv1s+QIdjDDaZ7Us/j/D/GCc+kuJd5QLaR2V28J8bKwquL/ESVc+qHYrsrQcvx4E7L/X6Y47TNyKAsmpMwB/S9BWbi4Pij73kuFYjACV2ox+0ZkhwcklHvXHaj7BhpVxNpkG/Yiv9FJVzUfXV6uFoKky4QtCglNfY2A7fGOBV+sJCCSvfFUgUrQysthse4bzMhI6YFIX5iPnFTKsCcPba0VHEvg2i6dCWu7F/uuvNlzC7ZaJPXvaW6MlD3IlhuN/xS0XRPc8HnNHuCrY/zv6imXjRyd8fIaANACHZepZ6/z01qi/8CISwUZXAU0UkbXUBr6UzmYCaBulqClCoRH4SUqtI2+MGFrdWE4/hG6R8ocRueqfWGV+S85CPOA3epaakNoh7AakkfE4HqX5/pekgY/UxQhVRARlYqRQGIebh24n/DEpM28q42tI/DeFtQ5oS6jVqHnveQY0am8H/4xReyoMIlOSWDBmQnphmA1Hif1bsPTnDpeJ47kl3eKZWrS/Sm9Eq4IESO4FXj1VvQ30uRREx6qAwBbqLw+VOyxyruM8Y3lGwkr3ds2dwdcmZHT/aUPSRC3uiQEnHowacZ5e0oY+y1XHWG1NGLvQ7my7gexaJueccqBcvmxEJH5mitpgIYjYUo4LIFQEQ0ZupieXqH5VuRd8FkzZUf8hqadQgatOaUSpZZmMfl1BT7EIlNc3Z1Vq0WN+iOLOb9SNbTgXwe+Sw0efxN9cr78wE07uoPDPKehrhGg3rko9HtETX2zhR7/9NWryunAOT2fXRwPHe2kmVi0EmnLcwLEtNyuNP47PBT6/cusPV+oeONZ9pZEBDKxYQYXApgAI/a1zeZjwnASGq7uKhT763UYPYuit7B3lHWoaekaBfew8LFy/KcRwhLKKcCdYuK0e+4TMNOpxELxyt+OmMhQbwYRB/ZcRkLgpdInLSCad4B79S438Fme2kHJx2zEik53QnY7jSWnNcHqdZH6f3kxC9pmDDFgScZSA7ORrNp1Yqrc+NNsUZspoXpttI4zCgEjjUnScvCAp69r10LahnDRPSvyfpwXpKivXFK/LCkqHAmjRvaR1TP3W3Hkr/Rik0NT+6n6t0Hmaj9TFBwEOIvEbuWugGqqiSgbipvGZzWWBeVu3bkkLlTmj9J+89Ifcj2iZHZWW40TBEgPfeqpcruw0ePS7vhOwJErIPNAHcE/U2eBy1ixadQ4LQgHr0itYP168cbFIozLke66zMvtWXIo0HHl9PKe3HzdcAqjsowjbA3gYpyshlUniWrx1WL0J43SgOxbjulEIsXq3jkrhBOvXL1alx3BvjE2phCRrIrQZ6OAaywVfOjVFBTAfoUXsEuSD1aAdJzd1QYzY8xMFoU8sUIaAfejdTiDgVDFomk5dnukkFR2YPjslusVoNyOQyyy1NSIlHiO2/9LAODIVc2blN5P6Un5lond38e49CkKZ/jbr/7x+jh76D+Q3o9DEUbtD1GEXKka6e1CGTXGE6T7emF+H7bX5Z3Q5S/HKbl105GchqdLtzLzE8Gu3dOxgM/3hozcfssS0IOWxkXze+8dGsOiCzSLH9gNW8dw8SLAms/lm+1RQ+jz5Aaiw6ABEXwdaBaEoS0+DvkYJplhIpD3IObDaLsoRp8trAYktT+yihKGgZa9tFdE8xCul/DtXLbg3JYt+CWLEPvEkazqCg4aSpRxj/xVknFwvMEv46PwGH7AsiSkcX+Tz5zJ2s8bwK4PagbtyX/CzAsnF6hTMmqaUNXz8tuw2v9VbL4L9ZmpELNPv/fUZO+PHHWmfXDxUO/Kv0ZYLrSHNBXEMN6x56q6YbnIoOm5PCf4oiHuhOnD2PSQmamT0hWJwbWAEYwzMDjdq3dg0JcVLKbEOcec+4wkLSRodAJJxmN7u/bG4GlcNFKZ9xJt2J6vLHLc4wmDuVQLEKYI2HecvZm0yblp3prJlt8EPQwEJNd4VuxRr0xGzoxG3plS7ccHThkJo0C7GVOxdLPEpYpeINRnMioiujcnhprNfQorjYwNs2hvEMALFf745x/mJTZhzC3wM+9lRg71XPbsmBLYJtqsLS/Uq4aFYCdEZiCSR6JspbKP4Tqoca7cbvn3y8eKq2Iw416qKnjsWOzY7l4+6pAoDCJN2YQEfaJdXL2qc2500MCoZOrKLUETb3eIBpRbojuP+I7M53oHgYGoRH6waR7hoWyuCVgILsnUYdYXBT/7HZ0hBamXVvuVLscjaQF9FQs95JJDSnedVEpFvj2Pf5d/6duZZcA6PyjWIrRO5lTJ784E+KiAuXPoOaRE3yvnRIdaqhutPcbVamtnO9u0/xi6IBPEycfhLJ9U+9VWv0umwh/E2unJ90ZGXB8GHM28krkw+Z0yywWJv50enO9DC/Rk0nTm4rNTKtBfF1YWGPKANq/ZRvBSnvCeBtyaQiGSiaMDnFglrcnDJbCIQkMhh8uE2TQxnuK08s394bS1xMjOqqd+GIgCPQifTzl0zjWb5L+WfufVr01xcSGyQA4F9LAqmO+ubGkx8Mf0sCcVK8SmzKWY3yKQ8nO3uryzBwJT1z3Yei12x4I6ZSA8SwuXZohFZurDSPI2TqclWp9pQ2AkKnVYV38Y6NX4rwaqFbM8Yh1sWy8jaClEsMxKHm0T5+waylwg9YhGhoF9lXF2CG6AMou/b55T/6AhMFDZLWhc1QZKsSSW51HvIFy7ZWXWxh/Ilzg0JjMvH9dCYFKbrkUc9kKrFpiZRA1+8tOeDT0VYngkOOusANa6LjC9BOV1PkC+7D8+EYl22RSgY5+AmiSxGhYZsnLp1q5LuWpdYI4aBuYDB2UOYGs6PA641GwHW3dhKEeNTfzi6aMvZKzyVIgQx6EJ+dBjNmLR5UV8YmqQx7oebDYqDIdl5TGBjgnn5ouo6fmGz6jgFUFZaqN9WEUsB6Cc1hj7cdhsEKlh/YbAf7VgRzJqsXJIdpr7VGJ4ZZL26PpUkHO+9wxWJc9vMpRAEzCZQFKGiu4Mt7C6FooB60IFIdlyLbhqP2razCTvpPOdN2zBRqeldqn2gi2sjj3hxbWhejXABqWCAQSsWJ2ynS9KQ3mjYBkgfOdWPh6IUYsae81ifp7t8CwxxT7YpBJSRq5qpIt0VuiAMroBOI0GCkqHMi7HmEi37v4J8Q4/FO4oZ+QLSOTf+4EWf2gZVCYI3UZq0PWwF0lC0HXYObC8ttUUgYH4KWfZBjCqJHAfIosQaRhX9Pd6oTA8G+ffhdgJpW/5yUaId5a5Up+BpEMLJ54wv4piM469ucbob7l+M3hlvpDyQ56kxADh95WixbSdTn6+Xt/Om24/ju2WWPOnkDwk6tafq3Hubq0vIN3Ff1/Q3qy9OAlUHsy/lOB0SbG3V4DvE9NYR16cv7THcsSwWupskBXIeEOMjF776X8mqP3558GtBfv8H81vY0Iei5C4I0p1t7q8qQ8kb3FPAOHvg0/lfXkMZdSp2r26iKeWpsAMgPUuCXnqY7yznbqYJmFs7YOCVDE2fwThet0nnhGnR44Zbbq3sHUT0IduEasrEl3qVIm80Hnw+YnrHxf4q0CCdnhkb1qRRtB8xxXzBR+3SJvcSSC9Z+hf/FSG8nssZouMszbEWQmOwJsm9lDqp71G4SbwGZe+uWljT0eGuUNMmVt/y7lt8PrlJvLHEWLUWmrhPajoawVhGPsKnJY/dP+/t8fzTJQPjFCrnqT+EtjTtMPyCPF+JIio5Jw3TgQrHusqeOK8vUbhVTJtFra8LuEtDuWxmUqB1oC7GKj+XxQDBigDtVaT4n8BtpWKVG98GHhVizpF9ErDF8fUMlh4xOgPJdeGOT0RqMme0HJa8EcivX7EW47vmdLlp8/Y8Dftt57aYCwK4VmW/dJWNDuqygE8Wcfi2c9C5/6O+ZhIjPhJZQqr18/32ZJCaf2sKNeEkcJncPWLNslw/2Ld+VNbH4zVRniFqmOwFfoYi0ylF81p6PmWK/IiS82LnzOY0UxVsDwUjnPYRZGp/FiTqkCnh1NyOyESpp8+fq1kW4Ek8GyDobcQgSE+NHxnV2v8x7nYzH+BicAoec+TRi0RWnvmRbqAt2uK15Jxnu2p7u7aaoEHvHZtCL3Cq/nVawrmIKe58MevbAAv2aGAGuF8Oa/9BoIONyGMTRw0QLqloO5TlqwLxwwDeIqVqiKiW/DSY3ixp6997mCC1WWGY3RhZ7URz8vx4FbKkvKz3VjPg5ZO49hWSxslQhHEjgTAFRF5d+VqWBNX7RXuOPCKfB4Tvq5tVQCHWGIhDkB8vqOregZfHtDBJOn6StI2w000GdzCez1wCjBykyWyEAF2DTNYilSfXvdBKYrGm4PD0/tA47gwP1HMOWGVPip5Se8Apo54YMm4hOK9cSiMr9xsZS8c0xQpmWabCTkKjkMXmv3aQMlqs+YpoZVUuUPkrmMGtEU7FJycuaUExgGRZTjdsEuardQbRvo9EKWtgrm97WJEOY8SaqpQJygczYF79ObGu8eAyKND4eQA4ZemLMRtS99XHq9oquU9AjaXGLrMOrntQ5SzRtVuBbOD8zjg/dwyQBNNnTanv/ggl2N+mi2soiVEjsdI8tYglpOIUU8JeTZPVn5L0x43TGSsa71uWR9ZHmp+O6D940zJDvZLPJSNUUfa0cFOCA/6IpiGwIWeRw3q5zZt817CtZ6sB62Eo6hhT4hk0PEeE/CtRXfTJLIc20BtqSYqY3+yktTNNYVQMmQfIRaqlQ5ONC9lncalmi04MKPgzTufvQjyacGiUgtBKgfCuujrTILw+kswawVtSu8kILkOTF+xUKkAjjCTKenpEFJt8VeP5zmC+VukkYkWHUarXVbLsFEc/nSE40+GxT4zLk9oNZAYhaah5ufZ+n4gkKgiqSAHFYJOiOrQX/UHXZ2xPPVn61xVGPikBxGJGtHC6xu4vWl1+azCTziXLMU2VGfpw9M8y2ZyqUXrzzjXO8gTRVEpaPMqMW/zLRovc9L4g//AQCD+0yfAlXqrdKSCr5rjJmB0r6rprJAkcqKAnNBcixiSPIBeWDSLfHms7i0xGrCJBTMm43RiPbVmbhFcCtm7lqUjbCZPpy0Tt7eMHG1S3+yUXUOg3/KqcpW5OB450q+mtRZ/Hn3a1wJwN5gVR5jl+xRVILV4lr9kH9rHSe1WOEcFtb+7swYbJqW32mZMTc325JMeahuoFQ4yKwegOB5IUV7EiLH778IP/I1Qd3nAJzf2oK31l9czJqA6MeNfr/FeICswp6LivThBaAGMn7izRcoJNNuMX6d48qwd5S0zlcpfbn3Y8oN5Zat621pJmMoGwZONjk9MJnuP1XJlFHWQ3Krx7At6fQaPy9sXlvBf+bisMs7rzuZVvOuRAi/o345mR5/asYIDk8ErPxc7OQhC92m0+9f4/RONEikvqxfvHTsts/XhNFCnsTI0F7XqE3B4bmOgupKPRvVX+vV02Q5b0phC/fy5JLGO/N6hSQ9f/lW8UDYx23AMDh8qlioFEdx2/0Hiz5Skq8024PrUouu/zcY0KDaAcOH2CGRdkblngIxw7VDeUhkcDkjgX0PR4+iKENn/D8MZ/AJ2a5AoQvk6lIrQc5EYHFUde5P7S9lxhKQDJca6vArpG07GgA8AVfqj8YELvihOPO/LcpPcv6QH1FL8c/Vej1+hsXeoupWK4I2oTm9rL9WfMM4AVh9lvR7O89p/EQJBYE5JuFesqGJsqxCZ3yepEnkxb5Klb5VSQtF4glLjCKq2yoLCF9lzHtqL9MhrxKHL0xCubGWre2wSuG4BpVRETkDrl7j6B23X9rrQKGXURHMyR78rz2WrW6JTlQpqA+uIlXGcyh8UE9LhBubkoIBqLcHGYAu6FR7F+7WAK2WxFpf0l5/ROhePxG/5Em+E7D5AXDta0ErTC8jSV2cZiOxksf+drGk9OSB0p88t5KM+EX9dLtLtYCMzioYRgDePBLCW1WrWoG18DSmkXj7FN681O5Utr/36UOkNSvZ4RfgAOXr3bSswiBTj1ruqxs8ChouXrdAgAf1nAVIL3sIG/n2xJZUpTm8LaQtmnDHz296OLgLCEG8K+Rd4JncVe6+jrxXLv/sAZDVex37VwuOve6suBIO93OO4H4Gsu1SiDtRYuOGfyi5o/UcuUq9thj3LPr0/Cn8cod9nyz/dpHr7Tlz7Vy+X2J8HHDw+ewzrthjlETy7Pf83Io7j4r822KGMlzYwQy77f7Q/QYDfqAVYCnhqWEp5FB/uzsoVelhUeYHkkKBUpSfrlJNlG8fV0CRpVk9aids4lgDuN28jjo2DsbJnrDrvZ5H9JH0f45izr+Att6XtNdz8nrBar+UsuNUI9cUM5otwv8Dl59JYoFnwI1li9TsOMYZUoirDq7n06/Pl2LP4zxrVZ7IwiTrWK/2cyEOGy1h9D5FZOlM/YCzwZF1+W+3rTMKX6mn2sCfBDCNFNo+HKU5hoIwJ97rf4Hj0fdf54DvZH4fWplVLTHt3HSEW5VtMtij+6ulg0Fc1QsdGZKd1OicwoLl89ZBz01yAsdk2McosRLISfZErvatpjcVJTUdZXgjdUag9yGEqDFDqBcbAN/GLERxtPZJ8WYCcphEEZUl69a4vluig0LNkcBWGF8UVVKLatXg8vbOuy4N/uef+aRnNWXzleedfYK4biPhwazO/0WvPyWVo1sRKPSK86p+Kq6MF6KPvLh9UbY4A1jjr427YDoTUm32nZOKEG5+UC7k61P4b4ECW91JeB0A5PombTTcqXAnJfV0pstRIYv7D9ng4NJlZu6vLqWuyAo8O/SiE27zw2m0L5WyeH7tcAA+SZ258TUkfNIw6CWclV1m4TX0Tb4ol/UEherKN2la13beg+4wG87EWHcqSdHlqf3b/jV/tXXAM/ggFtzl5bccbNAzopn51pF/jXKqyXb425GRremtdmdzZs2XJMG79/AGghLzNVGjzLu3ZtgLWqYS1drfwOHPv6mHjlpPyTpcV6DlpUcX+M4a0JvnTDn8FU822z9dw4GPCRs2LiIkmyZ6A0GvjDvq44Q4PNdYe3gLC7qoI0y+ihrfBqtPkYs+SAZAySH4nYFxwhMYoIhCwHPpYeF2GFoeDBiIpNrprPfuHU724gCvi/YVCYHiqb4678jhODY3kxdKydsT0ek6kHT4aHMwOmsSqaqWBoEU3vyHnbzA8xJRt0RGiFTqZDHF/csuS3oKrOt2lCbYlgUSFwrhB9UhpUDszcMW1pcbaqJaK29AWVwKgPqJAwqosZFkazB5+75axUpySjdFXP8D7awrYajKosQVoHsinTLjHSH6EX7fbvOuTtOA30wdKVBXUt6K5h3fEwIFXFF309KiEjqaH91/YrLhd16Wzm2eUMdeEalYkknhLkqW/45ZfdGqRrjc8fxva92COUV491YH+A+0MEFU1tSWhQdTwHFPj3EKTK8gtna6Fa+/5gIP+UjfgjUCxSdzSyjKLS++FjsbckwfCnw07Fz1rDKaBIyXTu+mD6Bp6Vsj8UXQnfFCOtPmKpHfawHVgokoBHMkRjBEC69aKz8csjhgC9H8Z0UPAWEjIwieRIEV+lQQpU+q6USFqXkTdQFyubqWwj1XsRbiCogxdra66LJ1btU0d8vdbvWtu0+gVdOSCSEYedyXHgjjB0x1X8WXKEo6MAeU+2db5zsUrMEvOulfCfldk69RWMioL3uyY5MQOEUI6jU9fVd9jhdG2YOJIPIM1tNeJTxjbcVd6kOQcPJTIHWVcHPHI9sBWwQI0T9NB3OZFGq0SYy4JBEHbeXhjHQg2mJ+Y4zrLzhk8bDR3iEehOe6pcxMLcKBvDXYUH7DQR86mFPRh88YpBsIB6W9CVweXmcKn3kJYpPtPrL4R3lCsHbIV6orOIpKT47vL8DkYbpRfZjUpS+lFWE4B8wugsNnn8K/AiogAVpGZJl0VxJnTkwwKQ6uUAdrpIJDRa4Co++ANmgQVsBYtEG5HtWBitHAUZjNQOvG44W3ZWMgd0ljbPDUqz+/+VF+ZtejXeOWoIYDcTpYrlZz/QWr/Nlkrv+t42uW9ETU3ueGKbtWdzsa3oKjd2XGAdx41C/6NN6WB6ePaRKgQkn9oXBhgf6vx7ws8+YVsQQvvxlMWp9W5Rxoneel+X6l/vCydICg6oLEB1h7tNhRsYxmHiyGzkJWVxjlt2DOs5VG6OSHvzT7bI7ts7mBpT4OGKBiIG7yAGZGMSFMOBhQV/tx1yYnZTuldmUx80G1PZ5IF6Aa2LAnZphNPeSEtD4S5ipCezTMzRLV0C4eebEA7dkHyMNemz/QnCFkf5AAJpo//g4aRwvcAZTuZvxyjEciWwANaI9Vc9qM9gBEFHcc8UkLUhCjipqvwYjAfbWCDca+BVMJggTlMosxUemJQv4ezor9D7ka7nHHYUXSOJUBYVLfazYy5cMEAgC4+zcmSZoTpvL1+F224UhyAu5GgrkvK4FQUI8i6j8EYQrkHm5D5JGydkayGFLAiMS3MM2bZoSueSv90oj4ymWiFiY3kyNXEJHIdksI7GvQY4Czn7vuq2h94jjQmZvHWGtBwfcX57L7jO4p/ADTBbrx4CzyM57pRfVYUEwK0PobHnjQFmPL8dFOqki/Fnp3sLIqo8KI6MT9fFZeiu0RMbE7+NPvJQxFUomzenKrt2UkpAOtgh0Uf/JMkXxelmx3T3wdBsPtour8DZo9QWg/NpJ5S0e5KFM1L2hnO+3mP6XFhLmjBl1oE3k1di5ZG1izh49oErJejX1pCcT/QlA9NkDwP/5daCio82z7s62jCXOyDkSZrwtrTSRHkwaST7XReni75F/NAUSWZM5ZrS7KrWkeAoEvh2+1w+eEeNiCkHiztAcXQCfiaZeAwk6yAYRpmCevyKpPDkyZcVMvwAvgAfyCW+OEjmIyHKR+3twfm4XS2jJMiZDY3JWsakljPj3WxmDsamI3nR8p7Bs1vsN6DKlZYfHHtzKY0oZ4wJBml/FgZngF8J044JTvNmy8EhamkdF8u6hI4OSdQNfHkPSKCVtMvqeWnU9938iJPlFIFqjJt3N4ZSG1rg8HXGTpvZr9KvttcAO04WzXsUo7NPTkuQCphThHHEachEwrvVDjHkIYHeDse1JJmcmM2fj8FQrWCwJMI41kFH+2C1QDeZHSFLF63mlyD0R8mGpTrNBB0bhkL838W4g8TAYgN/7rvvppE5F1CGKRY958IBrjGN2Kf1jdFuXHMPexxAjieIlZAN+uVoZSV7x91fYq9oCp2sWKdsh31rVX+eS5fGGviUWhIDM/6GTd4oRzA5fxoJ7uKjPHy9EGNyR039e0nXAUc6Lm4945pL0JLaB7R3ihSrqhqghYJYIW9GSqX0VLW45jL/LB2Gn+X+FQ2p6AJBsrWbyrwlzJdm7aAvYmoAuSY7pcHd322kSO7LlUPioJ4rxIIXYG3K6YxbQm1B5YtXa/A69fhnQbbXVF4xwSOGZ31B+TNV2TnfbU5yjeAxszY9xIu730hmBcpoYEIYYBZriC5hWEbMejm1OlGepErTFgGvxxQgFo/YN04IWXxc75zRrioWkCWi88LuEB6TsSdxtHedcj7txvOZcqfRIxjHnoNuMkIjaJ00Sb4FZJdYzj8Oer3LOUxB7cL2HsCpElOWbX6YWzFeXCuFZ9S7u7v+92rSWvLPKsix5JPUSW0TvOZoMerwgwEENwrRDiUFS8+0MQQ/8lwerM/t+XPrGKkHQiuJSm1aIl4h++l4kb7UIIPg7Sl8M9hYsMQuXzjOTFLRT5bKUozz/yyd0g4K/rmZt9m4l8F7H6YUxrtUUthgWq1r7oHrHE4F2uZsdXXZlgKu3cup9uXQpSboL5VI+/S50+LN+PKGwPLB7ACXiixI0B+6IVxjSI793WbkWTWBHBL5lAM5vQxosJONkPP7jUyUdTAZZ8R2/zTLIhjIVEz02WYCq4Ab8uprNWJ0FqTJhqjVKcAvW1wegXrhXSUyF21ZlB7kIaR4xDEbmTJL1ZEgDdgiTX7dpkwXNufgJp3JEesQ50qVnVUYuKOykImf5QJE0svA0aIF6OYB1G8b9nw6qNkUUJbI9iVdlcxECQluTNPbpOfMsxm3pBL49PQXCRHaOmPq40McQZLUIXv4X+2JoNg7l5e1xbxc40PJYy3QAbJGji6uEzCTt9PwCiuW0sOb95FwcrQMwfX99inmLv6uV+MhgXtCsvOgWIotpCY9+mZ37Qw7m/hlddE+pHnBe1g85C7dtEL4fABzV8BO9bx5SaLWlZXFSJh7mGM/rWc4h2WVZgcuvI7S0DAKR976VunrNLvpFXqg7v9h9kBrc4ULGbOxQ7oXgI9oQif7YpVBNXPVW+/r9NCrLzvSIizS24N3X2CStSstbWW8DAFUyXswOeuEPL5XJXl/36nnCye7tTssDYmb42u6izRpoXiXMkG6GQsYgla/3DWyxkKMDYo4rHplzwT2nL0HF/ppHHm2D1rEb7WumcXw7effnwSjC0R6XEGdcnR8G7GinDSdUIg6lVGykiYzArrF+u5zKRoulZ64rv0VrmB6H8ok4IutPkfY3p8ZsSGcFE6iaTm6qUDq5KSnDPRoCFBiaLNQ1iXDA61owYP17brml8tdsWKO2ZYqyjkmU3NkdM84olsdPHqtPmO8vgxGDG/QU3zWjMGd3APIFsnQKDdFnLIlYkIPKuvfK2P93quIXioqeNMC4M/HifnEuEDzEcQBObCiGp4WXfaDAGyZ9ib1fw+RZ5i5pl4UgEiy5WiCYL7XR3bbFD5I5W9bddcubGFlJeSQ8FPlTcIjZVuQ+RPyV6GSmVfc2JKeuqQCa2pipWW5Ij9niURpQCVyCvylS1j9DaUwZUN8ymzs+0alT50+fD4acm7rcdmOlXCVDmzZK0F6AAEpyeo8a+ZkamJFhM/NiYuhdjgF6/IvslIya2Wlfz666p94g+rs0ZhHh12xBNzWAOGwpWVbglEVOG0hyCXnodYspWkEFwqpO/coJv7X1BFt1rupKfrFeDHR+uhEfQgd/XzbaNMKiDS1oJdxg+zKwVLui0bO42fbBKi6AMqaCcCJtoOhYJ+4HkxHNau41vUpJBJ5PVKX8VQ04Bp9Axumanhvje0xJug6YlUJ6LnjYFTgWIQ2GWaKH2+JHTqmC05ucQLkZKDu5SZNBfJjpHw7yCqlQkN4sEEvITo7gF+wB68tn2Ap0+uiI4nW72dFoPtnXDUkUY6mGVbXT5fUNrTZAO1PAHOWNphBCxpMieGOvFQf/6SEvwoqi2vGL6awL9romaHeFsqYoEvKyW7DxJvGwCefKQeWjKkhPVMMtz4scf8ceZYNw2dUktftomSS25u1cfj/hXIHFGDrenb5rQQuBT3E6/69uxLlhZ1PU3S3kYUjklfXMmAcML5ejX7rFcdL1qKUaiW81H2OntBO8ml6YKQmj4rXE/8oFEZObWvBlhzCPWZ8JM+CJ5nTzersDw2yaqqCxIG4x+SD7pUXmFRnNl15GgNvPn94dk8ghh5H8AmaPDkbtXUNCfCBZKNrorMCWHNjDJ1/49v1qKBABaFwdWdO1l2r+7bnfLykon1rNN483lm2I6kIwvKYf5Xm87aP79h++L9eJl1veD5WBpXDYAY5NJEy1IrkoS8GT81N93NKpJXTr59M3zaXTjB3EgTTVt5K2zooj8h3aQxqH09NLcfGyPAjsKF4TGvFWCKHcLrd8wxYr86bzDoyeSou5vA07Ghz92s8NMk/B4fg4ruwWUq0HmASK7MgLQg3xwq8HSVlV36lecBIxI5ETmCzM+ma3jWucY10KKbwulcPymiKxxdzmarWY69muT1z9vKT4OqQdzW98VRwhzNkNd0Vl11sek1jjvxu03c+k7Nzx4D7gT62iHCOMggrlRBp5rG/hhfKZuhTOX5vZKb+QaPL3WHloz4MIrTRSAfcEVPVRwbRqFS2EwfaAW1PfTwy1FuXdvB3dmOSX2mNC7UH7y7WoT7PrRFK1GuhCqpgSoQ+VRknGKNcNsYLwQyE452gU6lF9jWfg+dX/0XXxiAkfjYT1dITl6yuYWoddjWAEhvhn7iE73l4ysPXLA9wlTO9YPUzBUNPHaP5+pGfnJxJACT83a9Tp69M17MDZFzGD/zWX8iCx3ZoxuDRgUZ+TUwuDfEyPFAHxwsiXuzIX1zo27ccBUdgbaLrqzjCUHcqorPrK60kzUcmevlSaRzFViGi3djpJBwdgDzrxt3gep8XKGnYAIbeWO9sVKQ2t8EZjNykRkijzXV9rCyzcBVocTJLxfz45noIxSxYTdM0ely448KB8lxpxeJsfH4rXbUt0eUr506Wow90oIL2dQIDAp5nSj+9zrcWx5eoK2MP2j/zsaa0HfPsZ9ZcUEASjC65QFIDH89Dup2lzlLcvzR+iQJrt8xsdwnTFUnNCm01jL7CS8a17IuN/YAarV5uZVeBVJgKETH4x3mVEJ857jgLYc7C20VdfeuL7aSPPcbuTnK8EAqBgt5PK0MYOVztuXR1khWBS+5UjsQNqQIxhJxa4mhqUqAVZ5PAdDPvf/eraeqfS10VBesGWNGax2KXhhaTwlVuqpRn2hbXTkXGfTSUaft1aH1aJMlSXUD0g/g9wvIPFD2xPMMSfJw1QzLiyNWXOoggUfZKZ77QK0/uYVdsXxVDHBHcZNz8LR+ImKE+S6+sopDBgH5VJj5yidMyk1TxyAZ8Glfx9ifiiVuXwPs2hXBV4r+cowF+Kv41P8IG2UDMZM4ff+C6yOSkE/QdPhcjprSk/0gqPd2urBbG514NXKGA5AvE/dT6VYJBVqAPxlxqLNiUzIRJPbOHjkIQTFVuieZU7NbPW7gdFmOEigTb2t0TbU8H4ECXrjW7ZdA4Iv/rFHbRBvtD70KykkFG9ui+WbGJoalcKIg5W2vIPHgY3GM2NT9dnipC4vD7puWfBUfH2QXyhJTespemvo2GFae3jI0kn4ib+RccevpGwZAbQPXL+yeN0vOWFrdrfPEWBd6zZhEFVJLNT+aQW4PywnUHaaAYkbUGsW/hDGIBBIopHQM+io3OY+AWkJelVoDagwucfQgTPd1k6XsJ3joW0IvSb4IhLHpOmrJKnoEh3N8rhFZZ5LUWmmIazpPBVToEHfkH97w0c024JzhxfQBszRI7b2FO3qhR1T8cg6Uq4yFLroGJguZUjS1/F3dbzYOB/UY3pammMnRgflOUa/e0wGDZ1OiYmCN3TuJ8U0zBsP/vqy0ioNNYzCi0Xj2do/MG/rO8hWlQcdfZKB4hbsr22g0W9stpRr98WGAtLUS/usWbrm6riFXdnDLm+ojLMOp6xjQVZitu8dYqwlNLAw3sShlPkzmgGPZTwpq3c9IMHQ/ePga0Bk/aWmMSn5MfV9svwMZNvOqpqdRx0FG78H9SN95sFbc/3PXJsLszDUuk9doXnPwBeCRq2aCva06P08DT2k9N7QBN07LNb8UnLlSmwG+Llea2wuI4Lr/CA5YNpzGW9h6Hcnu+31nHwSW7ncVOGjugHord2oESDEbx3Vn8ux+q6ZLRQl2b+Z1TPbwGYn/g81Wzk7624lnMoBQDrMW8ms8PQ95aVZ869P/AzB6hRVXOv/ics0xzK4dlfFuLFeWwGRiwfr83hbgt9Sgb4145hiQdWR88AWx5wCsbGdetlkFKDj+Zb5jZNZQnHWfg/lvhZmUcjDsiQAZ6ICh1xO+qH6Z300JL5g9Xju0GEhTGsYZrQfjzW2gJRUWs3GikBnt29sPlIZCJ0EXw9JAtMrD9r+JqgxOwlepjTbKmql/fpTzY5Wpq8rozPghtmloOxWHOvWXd6ddpugwx6l4rQTEX/lslqOR7mk4xmrxaFR3RIYnXB3hNDQS1z76pVroz6VVUwNLc3Za4zRJ14aAdn3jE8yJXHkv/US0cNd+PfGHfpSBVMV9ONqenxaTtOxcn4yTHWX+mtSfFG8quMMFOUyQCHv7nxM58ASqdbkN9hwOXVKDZqY48NQd2UzHDfKIK6rUjonP98MELfmgywm9m9lCcY6hHnTFHpqentIee3Q6e/hCrISwAPr7dh/9A+Xt44m/e0x3I/BliYsLPS8FOydl0ZYDU8ZmDQM9ctOzwFEYXlIOoWkNn4niDSrOlbetWQeD5RQTbGGtl37WPZid9fw0UKOUTeHt126u6cs6H/3cevZWBI6nHNUV8Xj5yQQFQyefuDPEFPLjbu9pOf7KdDtqbK2QG8pkXA4oE8wDIIuV/N+wNMaaM6zvsUXDbokSsh1BhZKvBRFyT6HQNh0HBinGaFLRMmEZoDhU4l7CIiI3BAPzFaxWt3AvMeNOuRAg87PxwqlGXRbEloPIoPDKXBN3taMt5iU5cmED8lGIk8qXN/0xZl3Ge9cU2V5YGs7aotwgEtuep8Dh/6a/jxMhXoJpBRRZXO57usqckNFSh5BICdyMRWyXmE/wc4uY/4VKEcydz91vppR6YsPMyE5sMG8ehtCnSft+pLYFF/8DF2OAUrqn9FUkdddLze/NrsdBkCpgMN1UmhFKWgyuZSo6ycfZbcYLoUwq5INtd2ojKLM+AbEq3sR8SRa4kdBRi/y7a7DgDwvNUPlVY1I43dGLfiqXDOCKw5MlGGB/JTdXjAw5+qVGc4IGAMW55rtXtuE5UDyI6+Rq+zpcCL4VVS6nbMxDAe0kcMVGOe9G2mu4ZkqG00cl7A1U/PkCNIIKwN1rG1IRyDHrFPaNSaZRTSvQPyI3UG3b6myYxCwUDzrHr8EwnplWBHUD6l/DmEOPM8quqwAMtDVauR2lSqH+0kvGe13OD37saXoSysii17lrkwd1nICMYKuWEQtfu1XyM7priLWHGbBu5wwELyDP/dnOKs3bo2LcCX9mB6PCqtXMXVcN39G+8qJSDU7xfGlyiWoswDAi3TlJdmCE9k4BckYLBpGThlmrLvYOUTAIjDROAk0Qsimd1vm6LwhTuh8Y+9pv/Grj/L1WvbVzzpNj8EP6TaZAMC/1S5LAcgt8ESGot1nBtMXh+OJI9XePZMHRxJsTPiePkesHKmzvqIFbLJe7cgoq+2Zz47NYPpcm6mMn9zwqhUxJZHh+zNiX9lNOtnPFFgXeKqUUUPNvwEv+w8VgRbjfeQZH8K6jiEEZz4roUWZd1XXrIWHej/F/jJZqH78S5F7EssIUqbqDtRFxUAsN1ED7PjQdfTsc8RDmJNAzN81P+0mgmteI4snBu5W67sT+zrT9p8AwRvvio9SwsKiwiLuBoO63yq836BIcXPAYRUAfqJkSg21376NEfkULggQ90ZwKDzQGRaqqgy0BuKbKbFhKSRVPOGX9hQjhq6TDlGWQzGrC6PJSZW1K1KSOG04VIwieEGprSTQpDtdnPW5gzNDzKsK6g1BDisdu/DuXQt8HnqIZkPXpqhYegUllmMf7ipNqCMeB7tg2jPcAOsfBrGHJR2VkKbF2gO7HGi15wPtiJl7uf8oCpt5NuwyQMBL3En/n1f+mLEg82zAnPWNK11B6mdSTW9wfPX1Yvlcsr81lK8UQ9kWHbummBUzEhPMp5+ugCbyPS5v63O3cH9G8U3fmXPJtalgJgi0CCyudjQsSZKMO3j2qpVvY1xClpH7UvoEPdJT/VB/caiFyflFsHVT6vWD+HhQTvw8QiKj/ntmj28bdyEErclz0jtutUryYwyscq9G1s5btzTxzAwiBdUSVg3dbkmqZ43ejrE7Y1hcNzUFowNEYbMDcC6uV+xpVvUoqlhe9n4c/QlCCohkHoDAJ+zMg55lPLMCUbX3VOQ1kMK8XeSPhbiPZB72o/Ng99Fr+r5N2azkGq0IVMC6bYNH9mI0JFay8zD9ftnuen6bcqUUGizG+yl+SmliEIlizGjyzkhnt7xUX9C0Depu66LHJPXl2aNLzjTgc+QXeD9jDw1uJm1VxnMx5B3jXji7Owqw9zWIF4kjKffnslmQ7IkJnsdcgWGBzuZGUQet/IUtNGvGVBq7uC1Icp6ao+00lqdMtHJIqcI3vQzk7By0V0WZkodK5TCN7aBtlhTX3idCY4u6qDnXQBK1qehQdnFHMItVCUEYFbenkSQ2zaSb5seCOM19/1MZ0bSjl2nn5cKXusB0PWYiVp0t6fKnmHEh77cvxMTZIorQPZShjT29104Ur8xYnVY6PNmBCi8yEtgDXvXMxaL42GW8RlppO3xUdtxVIdZSF9CTNYgz2MRx8QZoPRKOvGZjFN/Ihrb3rGweiod4phuQ3XuHwwK0Gg+ecSes4ekCeW13HCXo20iKTJc1aAPfROtSYFBUPvhNEdc7Lvrx4Ogv9L3rIDIT+SgA3RMp6gtx/QE7xc5RnlHoV1mOZOxTEEmApFuC5CIDK3Rbb4ThoTqdeDly8xQGlz39zfE6Qyqntul0N4T9Ldtz7pZBymjTWwXMFg3hP/2sh64MsWVeOWMgvATgdOGaXoytQ6bp06GsRDm422xQnWlgARe2jeZVpzbwVvmoEYCTdA4ai4QWzIc2Yp0j4aJyDVu+GTtrr+1DfC8r9Flh28GvPDT4ACHRWiK29lmNRFx8yIhme3MTGk086ZOrjlE+te5L7OjBQoR2N9Q4bx1oCsaxUPFOn0NKSna0Wc7cF9HsvmmXjVd1ZCtrVjWhY4vMceJq1Oh83FyVrT432P6D+gkEZtmb/fJypQuRhiKayi5BMWlhXgroRRbDSZHTRvNb6IYreiExwo/ECkjd0+BrN1gqXvTZt569Vr0DgdKFLIzjr1uDAmkjBQAHF0ySOIfR4PfqaUHZpIKrxyJjOUVWQr5JunR2sMIQmp5FPbWF9svr78asLq2JNHNU1n5ieq2HZePu3iOeX4lIn4F8GJujMv/t/SM80subUZD1Igj7DpKHfals1n0j7LVY5QsIhUdqh4c2MLIBF1QyojluHOIfjOWHo8H4CuCZEZTQOIbz6IMaoVDb3SWrKebo6CsGv1ZI9Axcs/kZK0VvSklKT81Q51dPKM8KRfw6PN4JLpJI9qn4PomjlFkXB1+GNOtvBWF1obtt1ACAHUVK8arxiIPCipjDKFi9XF+YtxUm1dyeT1BJTEyYE8FNY9nOFbHDkeAnsTmlNgzOG1/5mNcIT6iMM9E215K0VVN7J8bHR/SttT6LFlCkBTcc6lh1xhPYgNBYz9nKaCAJfNF/Ym5KGh2gwlTcr2hBazKlmTOCR6tCdUklDGs9qnNIzx9f0NVibyjl1PZCwmoSWfoH4xUSnD9JxikSoHdZE3OyupDb9xbS9KlosojcY8vwzJJA36fBrDGKdaQgT6NViYYzg3nENeKk62hUaBBZ8r67eGM0YzGoYzSwxYcoH1cG8BeAgmJZzDf24wv9r81jhoR7yzLuaDqtmPwy/L9AanFvq7+22fENxYhocqRh2pi9LrZlLK05OvgsIJwLsSCOfdY4//W1gzw9XjrFtWES4XimSiox/YFMDcVyBpvvUMY/vXlHBU90VDCVaSOFt0TsGGCJLlNPLqZxwbT4GNJZ9VyJ9fh96lOkpgOpU72Zin14Gxe90ckebtIwLBbo9MdjA+hDe9KGY7Xrs3Hz3AiykdPWd+rXstCUioGTn2lWZCdFJ8VYhDJcxvMTwQgUt8+aQbv/o62nLIgRXdIIxOJeoGCTeDfh+QlLyN8jdOm/O6DkTCwi4g3yQl+PvgYtPowBvy38uG4lIFqxAEHOXmSPWh1LfsNfandP71AwzSLoWQmJc8cdAtXuteb0l+J6h5EiBA+k4PBOFQCjuUd/Fz9mSiCzKiZ+G1CQ1HapJUM0uYtzPOWoOmW2Q4F//DxJ2BJGDTtccZqP9HLiW3sPMjw3euHM1G5xU8nOob5AM/BwAdDEvqFfDCJ+6mj/E7T2HPP0M2+qTYi11VX0K9UdLtiayNOuNNJCfw5+mvY7dlBAbLU13z1C1Epn03FEFVdNu1fMeeINrw7uTafFezk43RUtrwMniiFOWdtfD63u+zYVEpl31MX8MynXS6nEH8CL8jHtKrg33AmYAd5je78+DMCRPbYQSu/lYtxdeg4H0iV6RVtAvuymm+fa1t8ExUQHbKL9UK++8GH36uDeViG58l+DasiiYL8sqFeoDJilZXrd/LKBXTkV44BH9qokRZxXYpeq996TCWIe7jvlSFw+HJF+OqWnUNZRSsz65cOFAQWE/qMIvz0xWsjyDuqXIf0mv5X+jpI3ciJcd4FxWmERoRvfTPO4X4XSSyTczAmQGIZyjIU+y3D+FiXbuu2yEeXDO+Ha5ivMpoXKaSZGrUnajjhKDiqNbx0NAj1BpEY3Acqy/OP/5WmO5JD5aH2VPbKLd1/MtBuCBt/kUPstO5lzGC5ZIB7M0UDYcN4XVJYhFjlP5IC336C1OLY+24q6hB0NXp7jgDM554TGKzOgkuAQKhraLSv8h7pHutWLxR1nie5lPOEgTj4F9H+98SByriFEJcs9d3KpvQs/NIdx8gHTPijbjc2rOMWgUDp8PBS+8x0LBAVjz6lFgYwqPySXWYQswdHf67g8s8x7afFrRR6Wa0oT43XaRKEypISbbQd3ZjN8nOPkCJB2yW17gYt70dVGMUC+cKkh2VZi4bQQ7Amqp3z0QDoY5ptN2DnbkwFMkZQh5hMoxDLsMsshNpoBRg2IcfGlEDgD/Dt7DPofYDcZvd14wrKsgsar3yESsbNozje/7gkTsbFAMdtu/bkNEowGxZv+7Gotu+wG/zkLns6I8vXIe2gEHuZH0R/dAC36jfW+HT+GiDBi+pzdulblBmNTzlF/R2H08Gj9ewgqwYbq7CTLyyEwB20nHNnSHbhqWeVZq4f5y0xWE/4YmPYn+BA6xhQ2aSrwj518ljhCRkMVvEcr27xa2g8qazNx26xFix5iFDHZq1CwlMi+duS94GPQpF3jt0kORIbC/mvpJq3uD9hYUm0+DEwSn6fol0S9y/P/x9Y6WvFgMB9Jo/gp4lOthBYC8wiuhQJsxi9pLLOVlRxGHN/5Wu5RRSRKJx2bHzxdFilfwaZUdgbUrPv8r6N9FHYD6CYXwtxCoJsYEA34IoCduJsOFTI49LjsYbF9kQF+rGT5UKY8szikCWJDWNuvClA3f9GvNaJxXkY+hlrLfvcAQN20f0Sfwhc67i5JOmUm2N+gNu/BrrxS1EM3Ew8t3gyXyCfWXVHl/gDkogoKdjKXZSH1CECeYKi855EbzWPBeGAd5Z2bhiT2TvfzIzhpsidqNUde+vrclvH1b4sRmb9BiUWWoZVMznGhdDPgD5xr4MKFNpWshYc++nISLuNAgnnhV7JZbK7dNkAC9fbMiS3ZQeBe8xgVOaYu2wdMreC2qalJfAcEp6wgSkxKXTcVPUoTR8t5fBJWcqW2rj/Dfgme3108oTZ61WoiQlhDI/2zdhMFkC2KYE0QnViOWD982q+6l2aLM5RAfzoDbugzJY28WgpL3aHIdOtwwcSOZNC/wEoAhLrK47evWBDfaBYrc9VeRBeoz1F7b8pZ/a/ormi5jxQbSY1qXRzUJjwQcRrAx0GSNBBjnXsFDf/mpAVw2tKNcD5JMcjtWuwRFqrfGo8lKxL+0nv0//TJnlCGyHq3+6AVrhteHabML8kkAa8Wq6IvvamD5TTvVu1S1Qj/XP+R65UMdVAwoVYYoDcZPw+VQWWVKq8Ts/pcIjPufPN4DIHy8IBeHfBq9Wyh/s2gzf8VXVgGj7SN2iiu97rpZCmgEdm4gbPZt6mjSgUG8yXEaUquJotXpt2/2uUGwhY0of3/8o+FXPTgKUVhdcF3jH+RFZv/YlUMib+wJugt7sXb2BJDifKkd+mFJ90KIZUBNre2AQY6zGa+sb476fwL0By/4FLQVo8+RDRb/6RG6uLcs9dFtiZJEzjKbIC3saskld6L5LECk1LlDjlAMeSqkSXuMztRan8mEId3mUlzcWEKiWzTnKjQQwgH5t/nHnhwn0bdewT/PwfrCgzQkzQa4M3jjtry6D0JtBpf86x3DSKwLjmiwXerLhZB1yz0obKVaO2LfBSarB4FtnhOUvKfr1wfCkhoXuLnwuPvN81L6590Mbr9PZbCueeBYPE+PZPfN5JSlST7OS2qofe6fMXNGLXOQrYiVhWLppc4gC/JVCMEhK70/7VcPu+J+VAdoBq+EdvCvfq0HQdj7q1C+Vvqe6HGmtuzDo6vSQfOYyhooZ8zdMfUWqOznfb+7o66aEhX5XWooQllh/nQ34QMpYkLFNbTLmHTV6EurPIyDbNPbxTl9D7Gg9yGAzSkzff/4vCHorXa4IpPxMef1jZKh6K6SW8KDJWm2ec7lm5PF9PNarD0QmWRb3Sy+6HUW+Oa0ON70/HEQjyQQYJOhT1OVKFllFdAgnxLiQdUqlvje1Hg33ttHkvPGWka8Uu0i9SJrcPRau/J1SA3UxptDgdEB7rXlwuc2Ijc8hM7YQoEi8xh3V869rnwg7fWUpWXE3xj3NTAVH49Ip5iT+A4jXE35wVzdN8O++ivFUeNGrkJV3hqqZCxp/zEsaM7Bfi/prT1d4afBIaf1uNwp7A65CIFEGp8mmBuDJUebl65x08sqCYQUWwOBt0aYMDB9kGiSB+YE5IKYiuNhOlrdIE8YVLupSBgeYNFyOv7xDDQNhURVCSz+pDoqPUO3xYRCL+FXvtt0OavW2YJqjADAHs1l6K7Obv/KjvKbNSIyDvy00/uKmvYrFDhJDONel0lPRJAwJqs6CSaJ8AJbuu4cGbVnCNT3GMTVmhkpAtOvkDlFM4kwjiVWqFG0I3OihRji3HT+9BfeFylmlo3Ba1HUENOQUBYpNb30F68qUM+YZks+eDFcLuYqoLTjrqZqr7lAleHEWd6fBvA9/6Rm7zA8HYguDJ5tA4zTVXbSRHe4IH8tlRiS3GFptFqTvBlPGFIvccj6e9XwJ8x8VRHnX3g1xkhF+ypRJG6TVreYQ2IUN9Y68MLEXx2LppE85jhWQeNAym9Vjrt8CIHeH1GPFPThha0ta4qr1Q18afKoIuo9CDqllLvimo8NkFEMcuKiJJ2HNfaL719Vu+CIDZ/9LfLYybv1acv2YQ+8tMORrf843gtYydo9iaAi+wpIsqFr18qvQ91Yd59T9MsRTnNiRdiJNtecvtvBHmc9hoFSN+n9YeEVzj9bpGI0u94FJNthsjCYfH8ez8XLI0uBslCKgH1SHHF/y7EywHDKoPKKTasR/fY/V27BtCYVHBgiJGJj+xvOAVQmSDPWEE5y/wfgS5B79NDWu8NytMECpQi29U2J/ilONlHpI1BWJJpRgwxXuscs0u3RQ7vQfXQZme0bbbKo9cAX1JMcRcs3Z69ziEW8l4cvMjMuHvUXXLX91ckVXfMXKhwpcggUhVKSW8wdgEd7KZF0uq6HF9iTusdTZ3JZIgyC9PWPwXr1jjFMHk/iT/HHrb8yBMrI5hbxoufljWhgirhYSGzshiXBKucwwJYp5y/IPv3JdsPysquCdTr6S9HvvTYkrHXu95m8+Brw5aRDg9NKOUQDXbIjyiu9CaGCirb3HmstSZ23lCkpIfumBvVFhVwK60bI3HEIu2Rs+QDXO8xrYSmU6ntp2iJcEey2x3ULqF71NHMLmdR3sO0jVdwxAnLdWB9Xk9+aYNWjNRfaYeCv1dPPP4QbtDsAguCtO6r0/E7spzgKiCwfrCXmNt04KJMYgzo9wd+r5N4g==</script>
    <script>
	Object.keys(localStorage).forEach(key => {
        if (key.startsWith('icon-')) {
          localStorage.removeItem(key);
        }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       data.ping.responseTime = null;
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       const timeout = data.ping.timeout || 3000;
       const startTime = performance.now();
       try {
        const result = await Promise.race([
         new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve('online');
          img.onerror = () => resolve('check-fetch');
          img.src = `${url}/favicon.ico?_=${Date.now()}`;
         }),
         new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
        ]);
        if (result === 'check-fetch') {
         await Promise.race([
          fetch(url, { method: 'HEAD', mode: 'no-cors' }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
         ]);
        }
        data.ping.status = 'online';
        data.ping.responseTime = Math.round(performance.now() - startTime);
       } catch (error) {
        data.ping.status = 'offline';
        data.ping.responseTime = null;
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      async function checkAllNodesStatus() {
       const nodesToCheck = Object.keys(NODE_DATA).filter(nodeId => {
        const data = NODE_DATA[nodeId];
        return data && data.ping && data.ping.enabled;
       });
       const batchSize = 5;
       for (let i = 0; i < nodesToCheck.length; i += batchSize) {
        const batch = nodesToCheck.slice(i, i + batchSize);
        await Promise.all(batch.map(nodeId => checkNodeStatus(nodeId)));
       }
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         zoneLegend: ZONE_LEGEND,
         zonePresets: ZONE_PRESETS,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            ZONE_LEGEND = saved.zoneLegend || {};
            ZONE_PRESETS = saved.zonePresets || {};
            loadCustomPresets();
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       canvasGridEnabled: true,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
       rackGridEnabled: true,
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  let ZONES_VISIBLE = true;
const ANIM_SETTINGS = {
  masterAnim: true,
  masterZones: true,
  animTypes: { sweep: true, pulse: true, rings: true, spin: true, connections: true },
  animCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true, connections: true },
  zoneCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true }
};
function getShapeCategory(shape) {
  const map = {
    "camera": "camera", "cctv": "camera", "ptz-cam": "camera",
    "doorbell": "doorbell",
    "motion-sensor": "motion", "motion-detect": "motion",
    "smoke-detector": "smoke", "smoke-alarm": "smoke",
    "access-point": "wifi", "wifi": "wifi", "router": "wifi", "wifi-strong": "wifi", "wifi-weak": "wifi",
    "sensor": "sensor", "iot": "sensor",
    "sprinkler": "sprinkler", "sprinkler-arc": "sprinkler"
  };
  return map[shape] || null;
}
function isAnimationAllowed(shape, animType) {
  if (!ANIM_SETTINGS.masterAnim) return false;
  if (!ANIM_SETTINGS.animTypes[animType]) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.animCategories[cat]) return false;
  return true;
}
function isZoneAllowed(shape) {
  if (!ANIM_SETTINGS.masterZones) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.zoneCategories[cat]) return false;
  return true;
}
function applyAnimZoneSettings() {
  document.querySelectorAll(".fov-group").forEach(g => {
    const nodeEl = g.closest("g[data-node-id]");
    if (!nodeEl) return;
    const nodeId = nodeEl.dataset.nodeId;
    const node = NODE_DATA[nodeId];
    if (!node) return;
    const cat = getShapeCategory(node.shape);
    const zoneVisible = ANIM_SETTINGS.masterZones && (!cat || ANIM_SETTINGS.zoneCategories[cat]);
    g.style.display = zoneVisible ? "" : "none";
    if (zoneVisible && node.fovAnimate) {
      const animType = node.fovAnimationType || "sweep";
      const animAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes[animType] && (!cat || ANIM_SETTINGS.animCategories[cat]);
      g.style.animationPlayState = animAllowed ? "running" : "paused";
      g.querySelectorAll("circle").forEach(c => c.style.animationPlayState = animAllowed ? "running" : "paused");
    }
  });
  const connAnimAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes.connections && ANIM_SETTINGS.animCategories.connections;
  document.querySelectorAll(".edge-arrow-forward, .edge-arrow-backward").forEach(a => {
    a.style.animationPlayState = connAnimAllowed ? "running" : "paused";
  });
}
let ZONE_LEGEND = {};
let ZONE_PRESETS = {};
let copiedZoneStyle = null;

function hasCoverageZone(shape) {
  const supportedShapes = [
    "camera", "cctv", "doorbell",
    "motion-sensor", "smoke-detector",
    "access-point", "wifi", "router",
    "sensor", "iot", "sprinkler"
  ];
  return supportedShapes.includes(shape);
}

function getCoverageDefaults(shape) {
  const defaults = {
    "camera": { angle: 90, distance: 150, animationType: "sweep" },
    "cctv": { angle: 90, distance: 150, animationType: "sweep" },
    "doorbell": { angle: 120, distance: 100, animationType: "sweep" },
    "motion-sensor": { angle: 120, distance: 100, animationType: "pulse" },
    "smoke-detector": { angle: 360, distance: 80, animationType: "pulse" },
    "access-point": { angle: 360, distance: 200, animationType: "rings" },
    "wifi": { angle: 360, distance: 200, animationType: "rings" },
    "router": { angle: 360, distance: 200, animationType: "rings" },
    "sensor": { angle: 90, distance: 100, animationType: "pulse" },
    "iot": { angle: 90, distance: 100, animationType: "pulse" },
    "sprinkler": { angle: 90, distance: 120, animationType: "spin" }
  };
  return defaults[shape] || { angle: 90, distance: 150, animationType: "sweep" };
}

function toggleAllZones() {
  ANIM_SETTINGS.masterZones = !ANIM_SETTINGS.masterZones;
  const masterCheckbox = document.getElementById("zone-master");
  if (masterCheckbox) masterCheckbox.checked = ANIM_SETTINGS.masterZones;
  applyAnimZoneSettings();
}

function copyZoneStyle(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return false;
  if (!hasCoverageZone(node.shape)) {
    alert("This node type doesn't support coverage zones");
    return false;
  }
  copiedZoneStyle = {
    fovEnabled: node.fovEnabled,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovRotation: node.fovRotation,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovLabel: node.fovLabel,
    fovLabelPosition: node.fovLabelPosition,
    fovLabelSize: node.fovLabelSize,
    fovLabelColor: node.fovLabelColor,
    fovLabelBold: node.fovLabelBold,
    fovLabelBg: node.fovLabelBg,
    fovLabelBgColor: node.fovLabelBgColor,
    fovLabelOffsetX: node.fovLabelOffsetX,
    fovLabelOffsetY: node.fovLabelOffsetY,
    fovAnimate: node.fovAnimate,
    fovAnimationType: node.fovAnimationType,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  return true;
}

function pasteZoneStyle(nodeId) {
  if (!copiedZoneStyle) {
    alert("No zone style copied. Copy a zone style first.");
    return false;
  }
  const node = NODE_DATA[nodeId];
  if (!node) return false;
  if (!hasCoverageZone(node.shape)) {
    alert("This node type doesn't support coverage zones");
    return false;
  }
  pushUndo("paste zone style");
  Object.assign(node, copiedZoneStyle);
  updateFovCone(nodeId);
  return true;
}

function applyZonePreset(preset) {
  if (!currentNodeId) return;
  const presets = {
    "security-cam": { fovEnabled: true, fovAngle: 90, fovDistance: 150, fovColor: "#f59e0b", fovOpacity: 20, fovAnimationType: "sweep", fovAnimate: false },
    "ptz-cam": { fovEnabled: true, fovAngle: 60, fovDistance: 200, fovColor: "#f59e0b", fovOpacity: 25, fovAnimationType: "sweep", fovAnimate: true, fovSweep: 180, fovSpeed: 8 },
    "motion-detect": { fovEnabled: true, fovAngle: 120, fovDistance: 100, fovColor: "#10b981", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: true, fovSpeed: 3 },
    "wifi-strong": { fovEnabled: true, fovAngle: 360, fovDistance: 150, fovColor: "#3b82f6", fovOpacity: 10, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 4 },
    "wifi-extended": { fovEnabled: true, fovAngle: 360, fovDistance: 250, fovColor: "#3b82f6", fovOpacity: 8, fovGradient: true, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 5 },
    "smoke-alarm": { fovEnabled: true, fovAngle: 360, fovDistance: 80, fovColor: "#ef4444", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: false },
    "sprinkler-arc": { fovEnabled: true, fovAngle: 90, fovDistance: 120, fovColor: "#06b6d4", fovOpacity: 20, fovAnimationType: "spin", fovAnimate: true, fovSpeed: 6 }
  };
  const allPresets = { ...presets, ...ZONE_PRESETS };
  const settings = allPresets[preset];
  if (!settings) return;
  pushUndo("apply zone preset");
  Object.assign(NODE_DATA[currentNodeId], settings);
  updateFovCone(currentNodeId);
  claimTheImmortal(currentNodeId);
}

function saveCustomZonePreset() {
  if (!currentNodeId) return;
  const node = NODE_DATA[currentNodeId];
  if (!node.fovEnabled) {
    alert("Enable the zone first before saving as preset");
    return;
  }
  const name = prompt("Enter preset name:");
  if (!name || !name.trim()) return;
  const presetId = "custom-" + name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
  ZONE_PRESETS[presetId] = {
    fovEnabled: true,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovAnimationType: node.fovAnimationType,
    fovAnimate: node.fovAnimate,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  const select = document.getElementById("fov-preset");
  if (select && !select.querySelector(`option[value="${presetId}"]`)) {
    const opt = document.createElement("option");
    opt.value = presetId;
    opt.textContent = name.trim() + " ‚òÖ";
    select.appendChild(opt);
  }
  alert("Preset saved: " + name.trim());
}

function bulkCopyZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select at least one node first");
    return;
  }
  const firstId = [...selectedNodes][0];
  if (copyZoneStyle(firstId)) {
    alert("Zone style copied from first selected node");
  }
}

function bulkPasteZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  if (!copiedZoneStyle) {
    alert("Copy a zone style first");
    return;
  }
  pushUndo("bulk paste zone style");
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      Object.assign(node, copiedZoneStyle);
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Zone style pasted to ${count} node(s)`);
}

function bulkToggleZones() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  pushUndo("bulk toggle zones");
  const firstNode = NODE_DATA[[...selectedNodes][0]];
  const newState = !(firstNode?.fovEnabled);
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      node.fovEnabled = newState;
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Toggled zones on ${count} node(s) to ${newState ? 'ON' : 'OFF'}`);
}

function loadCustomPresets() {
  const select = document.getElementById("fov-preset");
  if (!select) return;
  Object.keys(ZONE_PRESETS).forEach(id => {
    if (!select.querySelector(`option[value="${id}"]`)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id.replace(/-/g, " ").replace("custom ", "") + " ‚òÖ";
      select.appendChild(opt);
    }
  });
}

function updateZoneLegend() {
  const container = document.getElementById("edge-legend");
  if (!container) return;
  container.querySelectorAll(".zone-legend-item").forEach(el => el.remove());
  container.querySelectorAll(".zone-legend-title").forEach(el => el.remove());
  const zoneColors = new Set();
  Object.values(NODE_DATA).forEach(node => {
    if (hasCoverageZone(node.shape) && node.fovEnabled && node.fovColor) {
      zoneColors.add(node.fovColor);
    }
  });
  
  if (zoneColors.size === 0) return;
  const zoneTitle = document.createElement("div");
  zoneTitle.className = "legend-title zone-legend-title";
  zoneTitle.textContent = "Zone Legend";
  zoneTitle.style.marginTop = "12px";
  zoneTitle.style.paddingTop = "8px";
  zoneTitle.style.borderTop = "1px solid var(--edge-main)";
  container.appendChild(zoneTitle);
  zoneColors.forEach(color => {
    if (!ZONE_LEGEND[color]) {
      ZONE_LEGEND[color] = "Coverage Zone";
    }
    const item = document.createElement("div");
    item.className = "legend-item zone-legend-item";
    item.addEventListener("mousedown", (e) => e.stopPropagation());
    item.addEventListener("click", (e) => e.stopPropagation());
    
    const swatch = document.createElement("span");
    swatch.className = "legend-swatch";
    swatch.style.backgroundColor = color;
    swatch.style.opacity = "0.5";
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", (e) => {
      e.stopPropagation();
      const nodeWithColor = Object.entries(NODE_DATA).find(([id, n]) => 
        hasCoverageZone(n.shape) && n.fovEnabled && n.fovColor === color
      );
      if (nodeWithColor) {
        claimTheImmortal(nodeWithColor[0]);
      }
    });
    
    const label = document.createElement("span");
    label.className = "legend-label";
    label.textContent = ZONE_LEGEND[color];
    label.contentEditable = true;
    label.addEventListener("focus", () => label.classList.add("editing"));
    label.addEventListener("blur", () => {
      label.classList.remove("editing");
      ZONE_LEGEND[color] = label.textContent.trim() || "Coverage Zone";
    });
    label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        label.blur();
      }
    });
    
    item.append(swatch, label);
    container.appendChild(item);
  });
  
  updateLegendVisibility();
}
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          const fovSection = document.getElementById("fov-section");
          if (fovSection) {
            if (hasCoverageZone(data.shape)) {
              fovSection.style.display = "block";
              const defaults = getCoverageDefaults(data.shape);
              document.getElementById("fov-enabled").checked = data.fovEnabled || false;
              document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
              document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "¬∞";
              document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
              document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
              document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
              document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
              document.getElementById("fov-rotation").value = data.fovRotation || 0;
              document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
              document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
              document.getElementById("fov-opacity").value = data.fovOpacity || 20;
              document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
              document.getElementById("fov-gradient").checked = data.fovGradient || false;
              document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
              document.getElementById("fov-border-width").value = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
              document.getElementById("fov-border-opacity").value = data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100;
              document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100) + "%";
              document.getElementById("fov-label").value = data.fovLabel || "";
              document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
              document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
              document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
              document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
              document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
              document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
              document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
              document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
              document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
              document.getElementById("fov-animate").checked = data.fovAnimate || false;
              document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
              document.getElementById("fov-sweep").value = data.fovSweep || 120;
              document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
              document.getElementById("fov-speed").value = data.fovSpeed || 4;
              document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
            } else {
              fovSection.style.display = "none";
            }
          }
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge, .minimap-wall, .minimap-rect").forEach(el => el.remove());
  const frag = document.createDocumentFragment();
  const ns = "http://www.w3.org/2000/svg";
  const dotColor = PAGE_STATE.minimapDots || "#94a3b8";

  if (RECT_DATA && RECT_DATA.list && currentView.mode !== "rack") {
    RECT_DATA.list.forEach((rect) => {
      if (rect.lineStyle === "wall") {
        const wallRect = document.createElementNS(ns, "rect");
        wallRect.setAttribute("x", rect.x);
        wallRect.setAttribute("y", rect.y);
        wallRect.setAttribute("width", rect.width);
        wallRect.setAttribute("height", rect.height);
        wallRect.style.fill = rect.color || "#666";
        wallRect.style.fillOpacity = "0.6";
        wallRect.style.stroke = rect.borderColor || rect.color || "#666";
        wallRect.style.strokeWidth = "4";
        wallRect.classList.add("minimap-wall");
        frag.appendChild(wallRect);
      }
    });
  }

  EDGE_DATA.list.forEach((edge) => {
    if (edge.type === "custom") {
      if (Array.isArray(edge.points) && edge.points.length >= 2) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", edge.points.map(p => `${p.x},${p.y}`).join(" "));
        polyline.classList.add("minimap-edge");
        frag.appendChild(polyline);
      }
      return;
    }
    const fromNode = NODE_DATA[edge.from];
    const toNode = NODE_DATA[edge.to];
    if (!fromNode || !toNode) return;
    if (currentView.mode === "rack") {
      if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
    } else {
      if (fromNode.assignedRack || toNode.assignedRack) return;
    }
    const p1 = savedPositions[edge.from];
    const p2 = savedPositions[edge.to];
    if (!p1 || !p2) return;
    const routing = edge.routing || PAGE_STATE.defaultEdgeRouting || "curved";
    
    if (routing === "orthogonal") {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const polyline = document.createElementNS(ns, "polyline");
      let points;
      if (Math.abs(dx) > Math.abs(dy)) {
        const midX = p1.x + dx / 2;
        points = `${p1.x},${p1.y} ${midX},${p1.y} ${midX},${p2.y} ${p2.x},${p2.y}`;
      } else {
        const midY = p1.y + dy / 2;
        points = `${p1.x},${p1.y} ${p1.x},${midY} ${p2.x},${midY} ${p2.x},${p2.y}`;
      }
      polyline.setAttribute("points", points);
      polyline.classList.add("minimap-edge");
      frag.appendChild(polyline);
    } else {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);
      line.classList.add("minimap-edge");
      frag.appendChild(line);
    }
  });

  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode === "rack") {
      if (node.assignedRack !== currentView.rackId) return;
    } else {
      if (node.assignedRack) return;
    }
    const nodeSize = savedSizes[id] || 55;
    const s = nodeSize * 0.5;
    
    if (node.isRack) {
      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", pos.x - s);
      rect.setAttribute("y", pos.y - s);
      rect.setAttribute("width", s * 2);
      rect.setAttribute("height", s * 2);
      rect.style.fill = dotColor;
      rect.classList.add("minimap-node");
      frag.appendChild(rect);
    } else if (hasCoverageZone(node.shape)) {
      const diamond = document.createElementNS(ns, "polygon");
      const points = `${pos.x},${pos.y - s} ${pos.x + s},${pos.y} ${pos.x},${pos.y + s} ${pos.x - s},${pos.y}`;
      diamond.setAttribute("points", points);
      diamond.style.fill = "none";
      diamond.style.stroke = dotColor;
      diamond.style.strokeWidth = "6";
      diamond.classList.add("minimap-node");
      frag.appendChild(diamond);
    } else {
      const circle = document.createElementNS(ns, "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", s);
      circle.style.fill = dotColor;
      circle.classList.add("minimap-node");
      frag.appendChild(circle);
    }
  });

  minimapSvg.insertBefore(frag, minimapViewport);
}
	  
	  
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         MobileManager.updateCanvasHint();
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72¬∞";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const lockBody = document.createElementNS(ns, "rect");
        lockBody.setAttribute("x", -size * 0.6);
        lockBody.setAttribute("y", -size * 0.15);
        lockBody.setAttribute("width", size * 1.2);
        lockBody.setAttribute("height", size * 1);
        lockBody.setAttribute("rx", 4);
        g.appendChild(lockBody);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const plugBody = document.createElementNS(ns, "rect");
        plugBody.setAttribute("x", -size * 0.7);
        plugBody.setAttribute("y", -size * 0.6);
        plugBody.setAttribute("width", size * 1.4);
        plugBody.setAttribute("height", size * 1.2);
        plugBody.setAttribute("rx", 6);
        g.appendChild(plugBody);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const speakerBody = document.createElementNS(ns, "rect");
        speakerBody.setAttribute("x", -size * 0.6);
        speakerBody.setAttribute("y", -size);
        speakerBody.setAttribute("width", size * 1.2);
        speakerBody.setAttribute("height", size * 2);
        speakerBody.setAttribute("rx", size * 0.3);
        g.appendChild(speakerBody);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const hubBody = document.createElementNS(ns, "rect");
        hubBody.setAttribute("x", -size * 0.9);
        hubBody.setAttribute("y", -size * 0.5);
        hubBody.setAttribute("width", size * 1.8);
        hubBody.setAttribute("height", size);
        hubBody.setAttribute("rx", 8);
        g.appendChild(hubBody);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const vacBody = document.createElementNS(ns, "circle");
        vacBody.setAttribute("r", size);
        g.appendChild(vacBody);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function updateFovCone(nodeId) {
        const node = NODE_DATA[nodeId];
        if (!node) return;
        
        const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
        if (!nodeGroup) return;
        const existingFov = nodeGroup.querySelector(".fov-group");
        if (existingFov) existingFov.remove();
        if (!hasCoverageZone(node.shape) || !node.fovEnabled) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const defaults = getCoverageDefaults(node.shape);
        const fovAngle = node.fovAngle || defaults.angle;
        const fovDistance = node.fovDistance || defaults.distance;
        const fovInnerRadius = node.fovInnerRadius || 0;
        const fovRotation = node.fovRotation || 0;
        const fovColor = node.fovColor || "#f59e0b";
        const fovOpacity = node.fovOpacity || 20;
        const fovGradient = node.fovGradient || false;
        const fovBorderColor = node.fovBorderColor || "#f59e0b";
        const fovBorderWidth = node.fovBorderWidth ?? 2;
        const fovBorderStyle = node.fovBorderStyle || "solid";
        const fovBorderOpacity = node.fovBorderOpacity ?? 100;
        const fovLabel = node.fovLabel || "";
        const fovAnimate = node.fovAnimate || false;
        const fovAnimationType = node.fovAnimationType || defaults.animationType;
        const fovSweep = node.fovSweep || 120;
        const fovSpeed = node.fovSpeed || 4;
        
        const fovGroup = document.createElementNS(ns, "g");
        fovGroup.classList.add("fov-group");
        if (!ZONES_VISIBLE) fovGroup.style.display = "none";
        
        if (fovGradient) {
          const gradientId = `fov-gradient-${nodeId}`;
          const defs = document.createElementNS(ns, "defs");
          const gradient = document.createElementNS(ns, "radialGradient");
          gradient.id = gradientId;
          gradient.setAttribute("cx", "0");
          gradient.setAttribute("cy", "0");
          gradient.setAttribute("r", fovDistance);
          gradient.setAttribute("gradientUnits", "userSpaceOnUse");
          const stop1 = document.createElementNS(ns, "stop");
          stop1.setAttribute("offset", fovInnerRadius / fovDistance);
          stop1.setAttribute("stop-color", fovColor);
          stop1.setAttribute("stop-opacity", fovOpacity / 100);
          const stop2 = document.createElementNS(ns, "stop");
          stop2.setAttribute("offset", "1");
          stop2.setAttribute("stop-color", fovColor);
          stop2.setAttribute("stop-opacity", "0");
          gradient.appendChild(stop1);
          gradient.appendChild(stop2);
          defs.appendChild(gradient);
          fovGroup.appendChild(defs);
        }
        
        const fovPath = document.createElementNS(ns, "path");
        
        if (fovAngle >= 360) {
          if (fovInnerRadius > 0) {
            fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
            fovPath.setAttribute("fill-rule", "evenodd");
          } else {
            fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
          }
        } else {
          const angleRad = (fovAngle * Math.PI) / 180;
          const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
          const startAngle = rotationRad - angleRad / 2;
          const endAngle = rotationRad + angleRad / 2;
          const x1 = Math.cos(startAngle) * fovDistance;
          const y1 = Math.sin(startAngle) * fovDistance;
          const x2 = Math.cos(endAngle) * fovDistance;
          const y2 = Math.sin(endAngle) * fovDistance;
          const largeArc = fovAngle > 180 ? 1 : 0;
          if (fovInnerRadius > 0) {
            const ix1 = Math.cos(startAngle) * fovInnerRadius;
            const iy1 = Math.sin(startAngle) * fovInnerRadius;
            const ix2 = Math.cos(endAngle) * fovInnerRadius;
            const iy2 = Math.sin(endAngle) * fovInnerRadius;
            fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
          } else {
            fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
          }
        }
        
        if (fovGradient) {
          fovPath.style.fill = `url(#fov-gradient-${nodeId})`;
        } else {
          const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
          fovPath.style.fill = fovColor + opacityHex;
        }
        
        const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
        fovPath.style.stroke = fovBorderColor + borderOpacityHex;
        fovPath.style.strokeWidth = fovBorderWidth;
        if (fovBorderStyle === "dashed") {
          fovPath.style.strokeDasharray = "10,5";
        } else if (fovBorderStyle === "dotted") {
          fovPath.style.strokeDasharray = "3,3";
        }
        fovPath.style.pointerEvents = "none";
        fovPath.classList.add("fov-cone");
        
        fovGroup.appendChild(fovPath);
        
        if (fovLabel) {
          const fovLabelPosition = node.fovLabelPosition || "center";
          const fovLabelSize = node.fovLabelSize || 14;
          const fovLabelColor = node.fovLabelColor || "#ffffff";
          const fovLabelBold = node.fovLabelBold || false;
          const fovLabelBg = node.fovLabelBg || false;
          const fovLabelBgColor = node.fovLabelBgColor || "#000000";
          let labelDistance;
          if (fovLabelPosition === "center") {
            labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
          } else if (fovLabelPosition === "edge") {
            labelDistance = fovDistance * 0.75;
          } else {
            labelDistance = fovDistance + fovLabelSize + 8;
          }
          const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
          const fovLabelOffsetX = node.fovLabelOffsetX || 0;
          const fovLabelOffsetY = node.fovLabelOffsetY || 0;
          const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
          const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
          if (fovLabelBg) {
            const bgRect = document.createElementNS(ns, "rect");
            const textWidth = fovLabel.length * fovLabelSize * 0.6;
            const textHeight = fovLabelSize * 1.4;
            bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
            bgRect.setAttribute("y", labelY - textHeight / 2);
            bgRect.setAttribute("width", textWidth + 12);
            bgRect.setAttribute("height", textHeight);
            bgRect.setAttribute("rx", "4");
            bgRect.style.fill = fovLabelBgColor;
            bgRect.style.opacity = "0.8";
            bgRect.style.pointerEvents = "none";
            fovGroup.appendChild(bgRect);
          }
          const labelEl = document.createElementNS(ns, "text");
          labelEl.setAttribute("x", labelX);
          labelEl.setAttribute("y", labelY);
          labelEl.setAttribute("text-anchor", "middle");
          labelEl.setAttribute("dominant-baseline", "middle");
          labelEl.style.fill = fovLabelColor;
          labelEl.style.fontSize = fovLabelSize + "px";
          labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
          labelEl.style.fontFamily = "system-ui, sans-serif";
          labelEl.style.pointerEvents = "none";
          labelEl.textContent = fovLabel;
          fovGroup.appendChild(labelEl);
        }
        
        if (fovAnimate) {
          const animationName = `fov-anim-${nodeId}`;
          const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
          
          if (fovAnimationType === "sweep" && fovAngle < 360) {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0%, 100% { transform: rotate(0deg); }
                50% { transform: rotate(${fovSweep}deg); }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
            fovGroup.style.transformOrigin = "0 0";
          } else if (fovAnimationType === "pulse") {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.1); opacity: 0.7; }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
            fovGroup.style.transformOrigin = "0 0";
          } else if (fovAnimationType === "rings") {
            for (let i = 1; i <= 3; i++) {
              const ring = document.createElementNS(ns, "circle");
              ring.setAttribute("cx", "0");
              ring.setAttribute("cy", "0");
              ring.setAttribute("r", fovDistance * 0.3 * i);
              ring.style.fill = "none";
              ring.style.stroke = fovBorderColor;
              ring.style.strokeWidth = "2";
              ring.style.opacity = "0";
              const ringAnimName = `${animationName}-ring-${i}`;
              const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
              ringStyle.textContent = `
                @keyframes ${ringAnimName} {
                  0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
                  100% { r: ${fovDistance}; opacity: 0; }
                }
              `;
              ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
              ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
              fovGroup.appendChild(ringStyle);
              fovGroup.appendChild(ring);
            }
          } else if (fovAnimationType === "spin") {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
            fovGroup.style.transformOrigin = "0 0";
          }
          
          if (fovAnimationType !== "rings") {
            fovGroup.appendChild(styleEl);
            const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
            const animationOffset = elapsedSeconds % fovSpeed;
            fovGroup.style.animationDelay = `-${animationOffset}s`;
          }
        }
        
        nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
      }
       
      function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const flowArrowBig = document.createElementNS(ns, "path");
        flowArrowBig.id = "flow-arrow-big";
        flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
        defs.appendChild(flowArrowBig);
        const flowArrowSmall = document.createElementNS(ns, "path");
        flowArrowSmall.id = "flow-arrow-small";
        flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
        defs.appendChild(flowArrowSmall);
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);

        const wallPattern = document.createElementNS(ns, "pattern");
        wallPattern.id = "wall-hatch";
        wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
        wallPattern.setAttribute("width", "8");
        wallPattern.setAttribute("height", "8");
        wallPattern.setAttribute("patternTransform", "rotate(45)");
        const wallLine = document.createElementNS(ns, "line");
        wallLine.setAttribute("x1", "0");
        wallLine.setAttribute("y1", "0");
        wallLine.setAttribute("x2", "0");
        wallLine.setAttribute("y2", "8");
        wallLine.setAttribute("stroke", "#666");
        wallLine.setAttribute("stroke-width", "2");
        wallPattern.appendChild(wallLine);
        defs.appendChild(wallPattern);

        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         if (PAGE_STATE.rackGridEnabled !== false) {
          for (let u = 0; u <= rackCapacity; u++) {
           const y = RACK_START_Y + u * rackUHeight;
           const line = document.createElementNS(ns, "line");
           line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
           line.setAttribute("y1", y);
           line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
           line.setAttribute("y2", y);
           line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
           line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
           line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
           rackGroup.appendChild(line);
           if (u < rackCapacity) {
            const uNumber = rackCapacity - u;
            const text = document.createElementNS(ns, "text");
            text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
            text.setAttribute("y", y + rackUHeight / 2);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            text.style.fontSize = "14px";
            text.style.fontWeight = "bold";
            text.textContent = `U${uNumber}`;
            rackGroup.appendChild(text);
            const textRight = document.createElementNS(ns, "text");
            textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
            textRight.setAttribute("y", y + rackUHeight / 2);
            textRight.setAttribute("text-anchor", "middle");
            textRight.setAttribute("dominant-baseline", "middle");
            textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            textRight.style.fontSize = "14px";
            textRight.style.fontWeight = "bold";
            textRight.textContent = `U${uNumber}`;
            rackGroup.appendChild(textRight);
           }
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else if (lineStyle === "wall") {
           poly.style.stroke = "url(#wall-hatch)";
           poly.style.strokeWidth = (edge.width || 4) * 3;
           poly.style.strokeDasharray = "none";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const animDir = PAGE_STATE.animationDirection || "all";
          const shouldAnimatePoly = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
          if (shouldAnimatePoly) {
           poly.style.opacity = "0.25";
           const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
           const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
           const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
           const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
           const arrowCount = 3;
           const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
           if (direction === "forward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
             arrow.classList.add("edge-arrow-forward");
             svg.appendChild(arrow);
            }
           }
           if (direction === "backward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
             arrow.classList.add("edge-arrow-backward");
             svg.appendChild(arrow);
            }
           }
          }
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const edgeDirection = edge.direction || "none";
         const edgeLineStyle = edge.lineStyle || "solid";
         if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
         else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
         if (edgeDirection === "forward") {
          path.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (edgeDirection === "backward") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (edgeDirection === "both") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
          path.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
         if (shouldAnimate && !edgeFaded) {
          path.style.opacity = "0.25";
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (edgeDirection === "forward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (edgeDirection === "backward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         const nodeRotation = NODE_DATA[id].rotation || 0;
         g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         if (hasCoverageZone(node.shape) && node.fovEnabled) {
           const defaults = getCoverageDefaults(node.shape);
           const fovAngle = node.fovAngle || defaults.angle;
           const fovDistance = node.fovDistance || defaults.distance;
           const fovInnerRadius = node.fovInnerRadius || 0;
           const fovRotation = node.fovRotation || 0;
           const fovColor = node.fovColor || "#f59e0b";
           const fovOpacity = node.fovOpacity || 20;
           const fovGradient = node.fovGradient || false;
           const fovBorderColor = node.fovBorderColor || "#f59e0b";
           const fovBorderWidth = node.fovBorderWidth ?? 2;
           const fovBorderStyle = node.fovBorderStyle || "solid";
           const fovBorderOpacity = node.fovBorderOpacity ?? 100;
           const fovLabel = node.fovLabel || "";
           const fovAnimate = node.fovAnimate || false;
           const fovAnimationType = node.fovAnimationType || defaults.animationType;
           const fovSweep = node.fovSweep || 120;
           const fovSpeed = node.fovSpeed || 4;
           
           const fovGroup = document.createElementNS(ns, "g");
           fovGroup.classList.add("fov-group");
           if (!ZONES_VISIBLE) fovGroup.style.display = "none";
           
           if (fovGradient) {
             const gradientId = `fov-gradient-${id}`;
             const defs = document.createElementNS(ns, "defs");
             const gradient = document.createElementNS(ns, "radialGradient");
             gradient.id = gradientId;
             gradient.setAttribute("cx", "0");
             gradient.setAttribute("cy", "0");
             gradient.setAttribute("r", fovDistance);
             gradient.setAttribute("gradientUnits", "userSpaceOnUse");
             const stop1 = document.createElementNS(ns, "stop");
             stop1.setAttribute("offset", fovInnerRadius / fovDistance);
             stop1.setAttribute("stop-color", fovColor);
             stop1.setAttribute("stop-opacity", fovOpacity / 100);
             const stop2 = document.createElementNS(ns, "stop");
             stop2.setAttribute("offset", "1");
             stop2.setAttribute("stop-color", fovColor);
             stop2.setAttribute("stop-opacity", "0");
             gradient.appendChild(stop1);
             gradient.appendChild(stop2);
             defs.appendChild(gradient);
             fovGroup.appendChild(defs);
           }
           
           const fovPath = document.createElementNS(ns, "path");
           
           if (fovAngle >= 360) {
             if (fovInnerRadius > 0) {
               fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
               fovPath.setAttribute("fill-rule", "evenodd");
             } else {
               fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
             }
           } else {
             const angleRad = (fovAngle * Math.PI) / 180;
             const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
             const startAngle = rotationRad - angleRad / 2;
             const endAngle = rotationRad + angleRad / 2;
             const x1 = Math.cos(startAngle) * fovDistance;
             const y1 = Math.sin(startAngle) * fovDistance;
             const x2 = Math.cos(endAngle) * fovDistance;
             const y2 = Math.sin(endAngle) * fovDistance;
             const largeArc = fovAngle > 180 ? 1 : 0;
             if (fovInnerRadius > 0) {
               const ix1 = Math.cos(startAngle) * fovInnerRadius;
               const iy1 = Math.sin(startAngle) * fovInnerRadius;
               const ix2 = Math.cos(endAngle) * fovInnerRadius;
               const iy2 = Math.sin(endAngle) * fovInnerRadius;
               fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
             } else {
               fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
             }
           }
           
           if (fovGradient) {
             fovPath.style.fill = `url(#fov-gradient-${id})`;
           } else {
             const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
             fovPath.style.fill = fovColor + opacityHex;
           }
           
           const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
           fovPath.style.stroke = fovBorderColor + borderOpacityHex;
           fovPath.style.strokeWidth = fovBorderWidth;
           if (fovBorderStyle === "dashed") {
             fovPath.style.strokeDasharray = "10,5";
           } else if (fovBorderStyle === "dotted") {
             fovPath.style.strokeDasharray = "3,3";
           }
           fovPath.style.pointerEvents = "none";
           fovPath.classList.add("fov-cone");
           
           fovGroup.appendChild(fovPath);
           
           if (fovLabel) {
             const fovLabelPosition = node.fovLabelPosition || "center";
             const fovLabelSize = node.fovLabelSize || 14;
             const fovLabelColor = node.fovLabelColor || "#ffffff";
             const fovLabelBold = node.fovLabelBold || false;
             const fovLabelBg = node.fovLabelBg || false;
             const fovLabelBgColor = node.fovLabelBgColor || "#000000";
             let labelDistance;
             if (fovLabelPosition === "center") {
               labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
             } else if (fovLabelPosition === "edge") {
               labelDistance = fovDistance * 0.75;
             } else {
               labelDistance = fovDistance + fovLabelSize + 8;
             }
             const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
             const fovLabelOffsetX = node.fovLabelOffsetX || 0;
             const fovLabelOffsetY = node.fovLabelOffsetY || 0;
             const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
             const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
             if (fovLabelBg) {
               const bgRect = document.createElementNS(ns, "rect");
               const textWidth = fovLabel.length * fovLabelSize * 0.6;
               const textHeight = fovLabelSize * 1.4;
               bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
               bgRect.setAttribute("y", labelY - textHeight / 2);
               bgRect.setAttribute("width", textWidth + 12);
               bgRect.setAttribute("height", textHeight);
               bgRect.setAttribute("rx", "4");
               bgRect.style.fill = fovLabelBgColor;
               bgRect.style.opacity = "0.8";
               bgRect.style.pointerEvents = "none";
               fovGroup.appendChild(bgRect);
             }
             const labelEl = document.createElementNS(ns, "text");
             labelEl.setAttribute("x", labelX);
             labelEl.setAttribute("y", labelY);
             labelEl.setAttribute("text-anchor", "middle");
             labelEl.setAttribute("dominant-baseline", "middle");
             labelEl.style.fill = fovLabelColor;
             labelEl.style.fontSize = fovLabelSize + "px";
             labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
             labelEl.style.fontFamily = "system-ui, sans-serif";
             labelEl.style.pointerEvents = "none";
             labelEl.textContent = fovLabel;
             fovGroup.appendChild(labelEl);
           }
           
           if (fovAnimate) {
             const animationName = `fov-anim-${id}`;
             const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
             
             if (fovAnimationType === "sweep" && fovAngle < 360) {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0%, 100% { transform: rotate(0deg); }
                   50% { transform: rotate(${fovSweep}deg); }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
               fovGroup.style.transformOrigin = "0 0";
             } else if (fovAnimationType === "pulse") {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0%, 100% { transform: scale(1); opacity: 1; }
                   50% { transform: scale(1.1); opacity: 0.7; }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
               fovGroup.style.transformOrigin = "0 0";
             } else if (fovAnimationType === "rings") {
               for (let i = 1; i <= 3; i++) {
                 const ring = document.createElementNS(ns, "circle");
                 ring.setAttribute("cx", "0");
                 ring.setAttribute("cy", "0");
                 ring.setAttribute("r", fovDistance * 0.3 * i);
                 ring.style.fill = "none";
                 ring.style.stroke = fovBorderColor;
                 ring.style.strokeWidth = "2";
                 ring.style.opacity = "0";
                 const ringAnimName = `${animationName}-ring-${i}`;
                 const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
                 ringStyle.textContent = `
                   @keyframes ${ringAnimName} {
                     0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
                     100% { r: ${fovDistance}; opacity: 0; }
                   }
                 `;
                 ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
                 ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
                 fovGroup.appendChild(ringStyle);
                 fovGroup.appendChild(ring);
               }
             } else if (fovAnimationType === "spin") {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0% { transform: rotate(0deg); }
                   100% { transform: rotate(360deg); }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
               fovGroup.style.transformOrigin = "0 0";
             }
             
             if (fovAnimationType !== "rings") {
               fovGroup.appendChild(styleEl);
               const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
               const animationOffset = elapsedSeconds % fovSpeed;
               fovGroup.style.animationDelay = `-${animationOffset}s`;
             }
           }
           
           g.appendChild(fovGroup);
         }
        g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         });
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
		updateZoneLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          });
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
            if (hasCoverageZone(data.shape)) {
              fovSection.style.display = "block";
              const defaults = getCoverageDefaults(data.shape);
              document.getElementById("fov-enabled").checked = data.fovEnabled || false;
              document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
              document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "¬∞";
              document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
              document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
              document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
              document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
              document.getElementById("fov-rotation").value = data.fovRotation || 0;
              document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
              document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
              document.getElementById("fov-opacity").value = data.fovOpacity || 20;
              document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
              document.getElementById("fov-gradient").checked = data.fovGradient || false;
              document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
              document.getElementById("fov-border-width").value = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
              document.getElementById("fov-border-opacity").value = data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100;
              document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100) + "%";
              document.getElementById("fov-label").value = data.fovLabel || "";
              document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
              document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
              document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
              document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
              document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
              document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
              document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
              document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
              document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
              document.getElementById("fov-animate").checked = data.fovAnimate || false;
              document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
              document.getElementById("fov-sweep").value = data.fovSweep || 120;
              document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
              document.getElementById("fov-speed").value = data.fovSpeed || 4;
              document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
            } else {
              fovSection.style.display = "none";
            }
          }
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage zone");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  if (this.checked && !NODE_DATA[currentNodeId].fovColor) {
    NODE_DATA[currentNodeId].fovColor = document.getElementById("fov-color").value || "#f59e0b";
  }
  updateFovCone(currentNodeId);
  updateZoneLegend();
};
        document.getElementById("fov-angle").oninput = function() {
          document.getElementById("fov-angle-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-distance").oninput = function() {
          document.getElementById("fov-distance-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-rotation").oninput = function() {
          document.getElementById("fov-rotation-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovColor = this.value;
          updateFovCone(currentNodeId);
          updateZoneLegend();
        };
        document.getElementById("fov-animate").onchange = function() {
          if (!currentNodeId) return;
          pushUndo("toggle fov animation");
          NODE_DATA[currentNodeId].fovAnimate = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-sweep").oninput = function() {
          document.getElementById("fov-sweep-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-speed").oninput = function() {
          document.getElementById("fov-speed-value").textContent = this.value + "s";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-inner-radius").oninput = function() {
          document.getElementById("fov-inner-radius-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovInnerRadius = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-opacity").oninput = function() {
          document.getElementById("fov-opacity-value").textContent = this.value + "%";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovOpacity = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-gradient").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovGradient = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-width").oninput = function() {
          document.getElementById("fov-border-width-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderWidth = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-style").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderStyle = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-opacity").oninput = function() {
          document.getElementById("fov-border-opacity-value").textContent = this.value + "%";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderOpacity = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabel = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-position").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelPosition = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-size").oninput = function() {
          document.getElementById("fov-label-size-value").textContent = this.value + "px";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelSize = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bold").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBold = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bg").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBg = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bg-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBgColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-offset-x").oninput = function() {
          document.getElementById("fov-label-offset-x-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelOffsetX = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-offset-y").oninput = function() {
          document.getElementById("fov-label-offset-y-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelOffsetY = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-animation-type").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovAnimationType = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-preset").addEventListener("change", function() {
          if (this.value) {
            applyZonePreset(this.value);
            this.value = "";
          }
        });
        document.getElementById("fov-save-preset").addEventListener("click", saveCustomZonePreset);
        document.getElementById("fov-copy-style").addEventListener("click", function() {
          if (currentNodeId && copyZoneStyle(currentNodeId)) {
            alert("Zone style copied!");
          }
        });
        document.getElementById("fov-paste-style").addEventListener("click", function() {
          if (currentNodeId && pasteZoneStyle(currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        });
        document.getElementById("bulk-zone-copy").addEventListener("click", bulkCopyZoneStyle);
        document.getElementById("bulk-zone-paste").addEventListener("click", bulkPasteZoneStyle);
        document.getElementById("bulk-zone-toggle").addEventListener("click", bulkToggleZones);
        document.getElementById("bulk-zone-copy-mobile").addEventListener("click", bulkCopyZoneStyle);
        document.getElementById("bulk-zone-paste-mobile").addEventListener("click", bulkPasteZoneStyle);
        document.getElementById("bulk-zone-toggle-mobile").addEventListener("click", bulkToggleZones);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        const currentRotation = NODE_DATA[id].rotation || 0;
        document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
        document.getElementById("rotation-value").value = currentRotation;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          });
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           });
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        const statusText = statusTexts[data.ping.status] || statusTexts.unknown;
		statusEl.textContent = data.ping.responseTime ? `${statusText} (${data.ping.responseTime}ms)` : statusText;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        document.getElementById("edge-animate").checked = edge.animate === true;
        document.getElementById("edge-animation-style").value = edge.animationStyle || "";
        document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       hint.style.cursor = "pointer";
       let hintDismissed = false;
       const dismissHint = () => { hintDismissed = true; hint.classList.remove("visible"); };
       hint.addEventListener("click", dismissHint);
       hint.addEventListener("touchend", (e) => { e.preventDefault(); dismissHint(); });
       setTimeout(() => {
        if (hintDismissed) return;
        hint.classList.add("visible");
        setTimeout(() => { if (!hintDismissed) hint.classList.remove("visible"); }, 4000);
       }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         });
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         });
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         });
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         });
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         });
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
		updateMinimap();
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
		updateMinimap();
       });
       const rotationSlider = document.getElementById("rotation-slider");
       const rotationInput = document.getElementById("rotation-value");
       const resetRotationBtn = document.getElementById("reset-rotation");
       rotationSlider.addEventListener("input", () => {
         const newRotation = parseInt(rotationSlider.value, 10);
         rotationInput.value = newRotation;
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       rotationInput.addEventListener("input", () => {
         const newRotation = parseInt(rotationInput.value, 10) || 0;
         rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       resetRotationBtn.addEventListener("click", () => {
         pushUndo("reset rotation");
         NODE_DATA[currentNodeId].rotation = 0;
         rotationSlider.value = 0;
         rotationInput.value = 0;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
         }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };

       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
          const oldShape = NODE_DATA[currentNodeId].shape;
          fovSection.style.display = hasCoverageZone(shape) ? "block" : "none";
          if (hasCoverageZone(shape) && !hasCoverageZone(oldShape)) {
            const defaults = getCoverageDefaults(shape);
            document.getElementById("fov-angle").value = defaults.angle;
            document.getElementById("fov-angle-value").textContent = defaults.angle + "¬∞";
            document.getElementById("fov-distance").value = defaults.distance;
            document.getElementById("fov-distance-value").textContent = defaults.distance;
            document.getElementById("fov-animation-type").value = defaults.animationType;
            NODE_DATA[currentNodeId].fovAngle = defaults.angle;
            NODE_DATA[currentNodeId].fovDistance = defaults.distance;
            NODE_DATA[currentNodeId].fovAnimationType = defaults.animationType;
          }
        }
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.stroke = color;
        forgeTheLegend();
		updateZoneLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animate").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animate");
        edge.animate = e.target.checked;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("animation-style-select").addEventListener("change", (e) => {
        PAGE_STATE.animationStyle = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-direction-select").addEventListener("change", (e) => {
        PAGE_STATE.animationDirection = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-speed-select").addEventListener("change", (e) => {
        PAGE_STATE.animationSpeed = parseFloat(e.target.value);
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("edge-animation-style").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation style");
        edge.animationStyle = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation speed");
        edge.animationSpeed = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         });
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchUpHandler);
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          });
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawToggleBtn.classList.add("done-btn-active");
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        drawToggleBtn.classList.remove("done-btn-active");
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
		 updateZoneLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        });
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.classList.add("done-btn-active");
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.classList.remove("done-btn-active");
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
        document.getElementById("text-rotation-val").value = textItem.rotation || 0;
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("text-rotation").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           textItem.rotation = parseInt(e.target.value) || 0;
           document.getElementById("text-rotation-val").value = textItem.rotation;
           forgeTheTopology();
         }
       });
       document.getElementById("text-rotation-val").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           const val = parseInt(e.target.value) || 0;
           textItem.rotation = val;
           document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
           forgeTheTopology();
         }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("add-line-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
	   document.getElementById("anim-master").addEventListener("change", e => { ANIM_SETTINGS.masterAnim = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-sweep").addEventListener("change", e => { ANIM_SETTINGS.animTypes.sweep = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-pulse").addEventListener("change", e => { ANIM_SETTINGS.animTypes.pulse = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-rings").addEventListener("change", e => { ANIM_SETTINGS.animTypes.rings = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-spin").addEventListener("change", e => { ANIM_SETTINGS.animTypes.spin = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-connections").addEventListener("change", e => { ANIM_SETTINGS.animTypes.connections = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.animCategories.camera = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.animCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.animCategories.motion = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.animCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.animCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-connections").addEventListener("change", e => { ANIM_SETTINGS.animCategories.connections = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-master").addEventListener("change", e => { ANIM_SETTINGS.masterZones = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.camera = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.motion = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
       document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
       document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
       document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        rebuildThemeDropdown();
        updateDeleteButton();
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       document.getElementById("add-line-color").value = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.rackGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
		 pushUndo('import json');
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
        if (typeof updateZoneLegend === 'function') updateZoneLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       zoneLegend: ZONE_LEGEND,
       zonePresets: ZONE_PRESETS,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       savedStyleSets: savedStyleSets,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false,
        fovEnabled: source.fovEnabled || false,
        fovAngle: source.fovAngle || 90,
        fovDistance: source.fovDistance || 150,
        fovInnerRadius: source.fovInnerRadius || 0,
        fovRotation: source.fovRotation || 0,
        fovColor: source.fovColor || "#f59e0b",
        fovOpacity: source.fovOpacity || 20,
        fovGradient: source.fovGradient || false,
        fovBorderColor: source.fovBorderColor || "#f59e0b",
        fovBorderWidth: source.fovBorderWidth !== undefined ? source.fovBorderWidth : 2,
        fovBorderStyle: source.fovBorderStyle || "solid",
        fovBorderOpacity: source.fovBorderOpacity !== undefined ? source.fovBorderOpacity : 100,
        fovLabel: source.fovLabel || "",
        fovLabelPosition: source.fovLabelPosition || "center",
        fovLabelSize: source.fovLabelSize || 14,
        fovLabelColor: source.fovLabelColor || "#ffffff",
        fovLabelBold: source.fovLabelBold || false,
        fovLabelBg: source.fovLabelBg || false,
        fovLabelBgColor: source.fovLabelBgColor || "#000000",
        fovLabelOffsetX: source.fovLabelOffsetX || 0,
        fovLabelOffsetY: source.fovLabelOffsetY || 0,
        fovAnimate: source.fovAnimate || false,
        fovAnimationType: source.fovAnimationType || "sweep",
        fovSweep: source.fovSweep || 120,
        fovSpeed: source.fovSpeed || 4
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        });
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
		btn.style.display = "block";
		btn.disabled = !select.value.startsWith("mytheme-");
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
        if (typeof updateZoneLegend === "function") updateZoneLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.dropdown').forEach(dropdown => {
    const btn = dropdown.querySelector('.dropdown-btn');
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!btn || !menu) return;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.dropdown-menu.open').forEach(m => {
        if (m !== menu) m.classList.remove('open');
      });
      menu.classList.toggle('open');
    });
  });
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
    }
  });
  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
      }, 100);
    });
  });
  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
function printTopology() {
  const svg = document.getElementById('map');
  if (!svg) { window.print(); return; }
  const originalViewBox = svg.getAttribute('viewBox');
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  let hasContent = false;
  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode !== 'rack' && node.assignedRack) return;
    const size = savedSizes[id] || 50;
    hasContent = true;
    minX = Math.min(minX, pos.x - size);
    minY = Math.min(minY, pos.y - size);
    maxX = Math.max(maxX, pos.x + size);
    maxY = Math.max(maxY, pos.y + size);
  });
  RECT_DATA.list.forEach(rect => {
    hasContent = true;
    minX = Math.min(minX, rect.x);
    minY = Math.min(minY, rect.y);
    maxX = Math.max(maxX, rect.x + rect.width);
    maxY = Math.max(maxY, rect.y + rect.height);
  });
  TEXT_DATA.list.forEach(text => {
    hasContent = true;
    minX = Math.min(minX, text.x - 100);
    minY = Math.min(minY, text.y - 50);
    maxX = Math.max(maxX, text.x + 300);
    maxY = Math.max(maxY, text.y + 50);
  });
  EDGE_DATA.list.forEach(edge => {
    if (edge.points && edge.points.length > 0) {
      edge.points.forEach(p => {
        hasContent = true;
        minX = Math.min(minX, p.x - 10);
        minY = Math.min(minY, p.y - 10);
        maxX = Math.max(maxX, p.x + 10);
        maxY = Math.max(maxY, p.y + 10);
      });
    }
  });
  if (!hasContent) { window.print(); return; }
  const padding = 100;
  minX -= padding; minY -= padding; maxX += padding; maxY += padding;
  const width = maxX - minX;
  const height = maxY - minY;
  const grid = document.getElementById('canvas-grid');
  const gridDisplay = grid ? grid.style.display : '';
  if (grid) grid.style.display = 'none';
  svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  const originalWidth = svg.style.width;
  const originalHeight = svg.style.height;
  svg.style.width = '100%';
  svg.style.height = '100%';
  setTimeout(() => {
    window.print();
    setTimeout(() => {
      svg.setAttribute('viewBox', originalViewBox);
      svg.style.width = originalWidth;
      svg.style.height = originalHeight;
      if (grid) grid.style.display = gridDisplay;
    }, 500);
  }, 100);
}
function exportJSONFile() {
  const data = captureTheQuickening();
  const jsonStr = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
  a.download = `${safeTitle}.json`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent("export", `Exported JSON: ${a.download}`);
}
function exportCSV() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
  csv += `# Exported from The One File on ${timestamp}\n`;
  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
  csv += headers.join(',') + '\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
    const row = [
      csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
      node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
      csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
      node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
      node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
      size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
    ];
    csv += row.join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported CSV: ${a.download}`);
}
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const str = String(val);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}
document.getElementById('import-csv-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    const lines = text.split(/\r?\n/);
    let config = null;
    let dataLines = [];
    let headers = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
        try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
        continue;
      }
      if (trimmed.startsWith('#')) continue;
      if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
      dataLines.push(trimmed);
    }
    if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
    const nameIdx = headers.indexOf('name');
    if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
    const nodes = dataLines.map(line => {
      const values = parseCSVLine(line);
      const node = {};
      headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
      return node;
    });
    const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add';
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `‚Ä¢ ${nodes.length} nodes in CSV data\n` +
        `‚Ä¢ ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `‚Ä¢ ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      if (typeof updateZoneLegend === 'function') updateZoneLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
    if (hasConfig) {
      Object.assign(PAGE_STATE, config.pageState || config.page);
      if (config.canvasView || config.canvas) {
        const canvasConfig = config.canvasView || config.canvas;
        canvasState.zoom = canvasConfig.zoom || 1;
        canvasState.panX = canvasConfig.panX || 0;
        canvasState.panY = canvasConfig.panY || 0;
      }
      if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
      wieldThePower();
    }
    let gridX = 200, gridY = 200;
    const spacing = 150;
    const perRow = Math.ceil(Math.sqrt(nodes.length));
    let gridIndex = 0;
    nodes.forEach((n) => {
      let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!baseId) baseId = 'node';
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
      NODE_DATA[nodeId] = {
        name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
        tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
        notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
        layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
        uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
        isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
      };
      const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      if (hasPosition) {
        savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
      } else {
        const row = Math.floor(gridIndex / perRow);
        const col = gridIndex % perRow;
        savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
        gridIndex++;
      }
      if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
      if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
    });
    forgeTheTopology();
    updateViewBox();
    logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
    alert(`Successfully imported ${nodes.length} nodes`);
  } catch (err) {
    console.error('CSV import error:', err);
    alert('Failed to import CSV: ' + err.message);
  }
});
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
    else { current += char; }
  }
  result.push(current);
  return result;
}

function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
  md += `## Legend\n\n`;
  if (Object.keys(EDGE_LEGEND).length > 0) {
    Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
  } else { md += `_No legend entries_\n`; }
  md += '\n## Nodes\n\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] || null;
    md += `### ${id}\n`;
    md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
    md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
    md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
    md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
    md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
    md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
    md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
    if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
    if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
    md += '\n';
  });
  md += `## Connections\n\n`;
  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
    EDGE_DATA.list.forEach(edge => {
      const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
      const toPort = edge.toPort ? ` (${edge.toPort})` : '';
      md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
      md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
      md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
      md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
      md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
      if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
      if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No connections_\n\n`; }
  md += `## Zones\n\n`;
  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
    RECT_DATA.list.forEach(rect => {
      md += `### ${rect.id}\n`;
      md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
      md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
      md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
      if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No zones_\n\n`; }
  md += `## Text Labels\n\n`;
  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
    TEXT_DATA.list.forEach(text => {
      md += `### ${text.id}\n`;
      md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
      md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
      md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
      md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
      md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
      md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
    });
  } else { md += `_No text labels_\n\n`; }
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.md`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported Markdown: ${a.download}`);
}

document.getElementById('import-markdown-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
      } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    if (typeof updateZoneLegend === 'function') updateZoneLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
  } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
  }
});

document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-export-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-import-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
});
document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
});	  
    </script>
</body></html>