<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
      .style-row {
      display: contents;
      }
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }

.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

@media print {
  @page {
    size: landscape;
    margin: 0.5cm;
  }
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: visible !important;
  }
  body * {
    visibility: hidden;
  }
  #canvas-viewport,
  #canvas-viewport *,
  #map,
  #map * {
    visibility: visible;
  }
  #canvas-viewport {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    overflow: visible !important;
  }
  #map {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: white !important;
    background-image: none !important;
  }
  #canvas-grid {
    display: none !important;
  }
  main, .topology-panel {
    display: block !important;
    position: static !important;
    overflow: visible !important;
  }

  #map circle[class*="node"],
  #map .node-shape,
  #map .node-group circle,
  #map .node-group rect,
  #map .node-group path,
  #map .node-group polygon {
    fill: white !important;
    stroke: #000 !important;
    stroke-width: 2px !important;
  }

  #map text {
    fill: #000 !important;
    stroke: none !important;
  }
  #map .edge,
  #map polyline,
  #map line:not([class*="grid"]) {
    stroke: #333 !important;
  }
  #map .rect-group rect {
    stroke: #333 !important;
  }
  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
  .draw-toolbar, .topology-toolbar, .legend-container,
  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
    display: none !important;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                  <option value="defaulted">Default</option>
                  <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
                <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save</button>
                <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding:4px 8px;background:var(--danger);color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:12px;display:none;">Del</button>
              </div>
            </div>
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="canvas-grid-enabled" checked="">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="rack-grid-enabled" checked="">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Connections</label>
              <input type="checkbox" id="animate-connections-toggle">
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
           <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">üîí</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-data-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
            <option value="wall">Wall</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none;">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">71</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none;">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">71</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">71</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-5.584863670202822 -99.90831573327841 4031.4509771376233 3023.5882328532175" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-5.584863670202822" y="-99.90831573327841" width="4031.4509771376233" height="3023.5882328532175"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">99%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Test Environment</div>
          <div class="details-ip editable-text" id="node-ip">10.81.0.0/24</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">1U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">QA/Testing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">2</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">IDF2-SW-01</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">idf</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">distribution</span></div><div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">IDF2-SW-02</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">idf</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">distribution</span></div></div>
          </details>
          <details id="fov-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Field of View</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Show FOV:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">90¬∞</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">150</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0¬∞</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Color:</label>
                <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120¬∞</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="30" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">1</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Internal FW</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none;">
          <div class="details-name" id="edge-title">IDF2-SW-01 ‚Üî Break Room AP</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields" style="display: flex;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to" style="display: flex;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED:Q723tC3tDOqZdbh2LeLFm1WQ/xYsTWHZS8KSTowEzl7eYFkIa/wlynw74c4atzmHRATsXltKZQ+aPwM7PHdhHlCtgmYj8pNLZtG9Oek8tHQGt2yLq9cQ7mcCmFGjbgmzohPnVz1tOzReaySpqEpUMUGmsnVNiiFLeP+Dro8G5Bh98HlhR7aAUo/ZqAZs2uQ7LAiC2pW21dydS9sXeLCahUL4LsiUiBqm+Z6vlwjTZRyWLAyLOBBZLZ/dDbRTp6vkfF0e5RvVz/ytXhAEQEdTtsi5UpzcYi/bxt59bt436SznrxfG6IB+TZbPQr3w0O08iM4IV3/lYPRgwh8tyo6iWaUKqnrAptFCak2rcs6cRvT/og5rtP9nN53fG/rSbmKJ1ffXFWVGysoW0ltTXdUKSp0UJOK/eK4tgg8QfMecB7zfMclkY+EbKN3FiKObpsWhKSfKjeU32gg4zzS3+lqxL9XqxyPbu+bFVH9s2awM2cJ5hvnJzK9b8/4kE8zUZn5gF/hjmWNRBivr/ly/XIbpNoO6Zor+RYENqtH3j6ksdvA2gQs8t08x9WLAyAgEltMaBmiK6NMpMa2Mb68yT4FzZH446Eyl7l2oJl+4YpPOjKMkEdItb3kz7hGWmGWowjIM9XG2NZo8XBLck4i6V9DkJlV3S+nhF6Auz+bh8aRn4nbhmVRGRQ0I38bfFwObaRhD6e6u2RRaWIlvDCeV8+wPJenu7IYPQ1IXF7zdRZZHmlYwgzLP+oJ4yODZ41pBpsleAxI8VF2p9g3N5/5IMbOxbHrm6MKcLATIZFQWf2CWCGEBdDoxjVrYuCIj4UOciJbwEV+uUc/IlLFr1HzA20ICQU+quTotKs+3b8H/3zze4iqGRFtZP+UZmA2p5k8IhMI2ymwqXDkt47B0q8gOr/xsX3FrZV2vlPjBe91POADNjd7y1N2UPlv2cwfFq+rHfZ3FxjeS+yc/wlTJLgQtvXnymxdO4+VL8gzAlmbDL26DqK/fTHprTj9oUKGRk8sB+vZseUMKQmzo4XG/Sj+D1GPIuwm7p2OMyT50qBzPm1UDfD15r7rEp4IskQQAo00FEtJEFrE9onAAC19amL5aGtx5bg5kVm70OKSsMsLZHU7y/EM/AhQ/8h71Py2rjX8rgQRgSBHByFogc5j0lDLpFXNTeJwtfcSz8Abn5ksLxP9GE36m/42qOHSDWb3ni0zXziIHOuKu4meHD5S3/vuSpihFMz8kGV0BF/a4PGYy3ivmhSu6cuOsz4f2rNg2EKB/G7XRU9kel1Yrhlrl8oh2uDtbB1WrnPwUd10K8MuHGSgy20UyDtOSxDnE4qP8KmJSHoKwoCFseVKEwZNX+4Bm9KgeZW7UDmT4a+psfg+uhoOxx176FieFjavWCaD1/1270aQkyxZWpf+2zD6i0vJ8fipol7RtPhCOBDiAHcQGmiXU1t1jxUeE0E8PhpPqiSlv4ITe3g4gZlTua1+WmTdXXpwnEpFcj9AyEKLWjsFvaTXB6mJQeteQUHU2yC6irUCZMzp+Bb/1vq6kBv93nTUmmWHCsetEBZhkWDnjPs6ot23FH4C0xP3dlmMVQwiiipNK6WhJ3ploNmDgBK8wm+oLu8AGVcyQBXGKxN7lF4TS4SH1eb35E/SO/kndZmKyCSgosgfYxujLAl6KTYpLLQuh+8Xq8APyoIcbiUb1qwfuB8E4cFZr7DMgBfM6Jum4frLswTpTuU9rtb6jcyHObgabRBqo4ttlBgZ3MtVcWKXffySyutkF/rH5Suzrov1tBesSGGX7GdPZNQYAzOxha2/+816qO/oF4wh3A2Z5uwXtmExZCmlTyvzfhlhaQmRb61qio0kqxX/tpSvqyQ5gMYlB8WXeNJVUrP6EhZHBFZm+Yo+H/AYhUa6jWlZUyD1VZrMamU8lGAU8qx3HACdBNTqSEJ7e80/5NJQ0QWMRhpr9WS+TPiHLptIL3GOzaInen7Wuq3FuKvtA5ZvCgHv4u4dT42nvPImYery0bbs6iImReX6YkVKfAOFTZDlDdh6+/TjO0gt7HjDnCumPywraHQ2uvzwfZSx9rlqOa4F0pnwuDqqJ++qu91CIC5NjvUx1N+ohIpv66F7DE3NMGJzHWt1/1yqyOsGR+rpZjokJybv+A46C/2k+va7ZTrR5jUSLf3Zh/ATVKcuHqSmyhXMT//vxWJsRGNOAKuuL+nieHgvU4RugSDwCCjl+IY33VQ5QkdPT4AcxPm4V5QnLQVwjUBRNEgLRD+hJannNKaWlTIerw2QFEsVjUXbROedADZpuC39Q76wFNwXlrltoYGmK6iElGBQcRSo8Z471Qe3t5uoQJxGS4LOnuC4TONa+75S4IEJhywj44XPWPdnPILYpOitLP/Yz36570NagKUS+n+6dKfrBnwi43QgEfisrcQ6g44fHwtVEOoYq5gjjSuYkxiNkvfBtGcH0kDwSqIuWjGgsuA4mtDuHnoQvcExUpLQCRBNl5tXI3/qKYrV1Z2y8gBxFU15b1q4cJtNfvWU7wH9Okj90zwGXaPl6gHqj5+ZCwirEarmIe3zj2/cEZcvbXWDj5L/L1dLsJl/Mfzi9ZKMxOvSIZEoprq3fpUCx+n8KeiarKQpSfn4OnOaGpOgufqjgdGL4QKEqMe3fs56MvQnlJ+Ile0HjtnCgJ3puldDILN0HXcPcUiZLKQsQwiOE0fIIyeQhCpUiEzQyizsZTLScoCBvfIYgz1aIZwLwZBuHmZ4dBL081bZJb4+0TU410GgskF17g+0cjtIdkUWz0dD9oIGhK1owiFezWZZORA//zvUYU6KNqTwUPjcJQ/jw64lx1/goUJo7SfLWd3R5bMyTCet2pRn0tpZpSNTjy6DwkB2MZpSr/C1qaisr1o84Md1B274HmrzlGg2t9f/kRrqYQnnUEdxAVS19hgtNL4KjyilOXZlPJu6hyYDppAhWxEFB2rKpj4FttZ9H5TIbeBPtqfmp7oLeiLTOtRkEB400REex9geNcoHxYoAQdx15O8BMB2TazTPxmSjFaxp8dhZXS/pkp17fMs6+JHgwqZ2RNyZ2gdMWotuWPPe6rFbAGZ0a3CY5ALWJJKh2iov5T0w6cYfcJk0h0Jw3W0pUvzFZrrP6mW5NC99aU1cM/8ZInL5qoHMoPZBg/xFbE3iG/W/KpCQO0kDs9Sy9GwoBUNwdr88WAwduaps0B2LWT2bJIAk4QG4miOuMTp1v0+VghVuim/3438A/42SqXcRtlH6ucEp3LWOTz2OPaHUIPwdQzf+GyDPgSteHFQszwmLQEsEg5f850CUxLx0BXfkvZxS90JCqjDWl5PYryIOePBBSc5vVOVaqTbBpbouYS9DPUAEwpRhrbelavuw5XXAeGdOgYkovfdWn9f3nVmGB/QOYDalWP13DjQrm88ZbLUX0qcenjtQdid7Af38vjn4lVABZted63oYvTwwrOqfNHNuwAuy8DQv/L+MLrtDqV7k1Re0iDBIWWGV4nrLEEL81YPEl9ChtZIFZ9r0p/TfQXSjCFQ8D/yQ1cOja9fh961t9bO2F2AepdJ6eqDKeLc0Ik6N/wHUle2u1P8zs29mw7PEkalDYhUqBTpB4Cfg4u8jezL2QRV7rgt7IQtwEZgkDZpp7HvYtAAgypUOdmto+oIarpBMzAdY9dKeS/XW1/YRFo2/DgCm6HN0oGlwDv7YI3q8DTluv+ZWGpT0eyUYNoa3m9vvCFVJ3bUXhiPZaR94nMGr3s4Dy87b75b9AyvRuFljBh4d1BhCXw0dGP//WoE2FUvpbxiPvxYQSFrhCMUSGgHoPdkYGoeykJ9KGCwT6xgfP0gX7IClkQGSnzV9ZOZrAZzXMccvDdHHyIi4iEIHtcAX9uhH8OG0uSWrQ9bxO9CL8u9l37bjzKGhqyLXX9S6ND4mX799VW79zIzGxuAU+kNZ95XY8IthoeRvdKworHq5vWhyjdoh8YwlonQytIjMYMxsosNg2MVb1EIVjjdNFOglDJJECSFLtp3eefxLDTKQc5pZ35DNdv4asrPuSoOka2b7lDxYN8yIfuNhcrCxdJKxYETLtSL4WsjXY+x8Pw9aSmjgzXI+8/nnMW8YuC8x1X1ncXyhxDWzbG2JPGOicquLzHVdx1HjTAAYGQksH/qVi0t5xOfJA6yKs//O9e31vg6cxLqBbZqKf415Zf+GAWZBGLBK7QvWxP37p09YZVngcvyqQXw6GYPy67IuZT+OqXeBYfvqkTxborTcVZVsdu4S92AneMizllxaU7/zwOTcS+GYeZLCTjd2RiSqwsal7INJGfLEgAWXBisqoKMitQlH5YVfJXwjgnyP7b7eG1JSFTq13pDuhezzMo0P9NfLE4lyxXEfnB3l/EH9Cz1mpMJpfoS5g01WBEvMbFjuO0y5uOMN2bJuM5HFBjUbGEyQ/EhadKHP/9GeE5QXGor6NYSAjiSmWIyJ6ViJcD9TiB9COleG3Qja6CngTmmAbeYY6lBhM968TaSPkJKTqeoCoI/lqvOBP2687vbqsvW6RYQCs9WfkuXG2RVJLjC5dy+bln9v4Sy4NiJjfSqctOP2YwjFZVMzJJQkx9FDe3jqqqgPyLZQa7bYwbTY0VpqvQ3s1hF+Cu467PWgtEh3WstcITlH8nhaVxOsnC6O7jhEopVTTEpZMz1C9CTwp9Yp3BB9nV4HHHLSVe3YJhxXSyo3jGwsmtxSAIzXVFXkqPtmEZHfahkVAEmJer6rISBCXDwhVouY1cy//7+kpFVdt7vdd4C5qkEfSaDVMsGvHuB9KnAE3iftIXWZLp6LNZU6Mn20nvX59vCx9tK+EzKpmCLcjIuDmL1LKML5ghk+ca7UUZT0pA2P6k+IslP6U4YpjxdZOIUddoGEliKlLYMjDiEjp50CuG8qwe3kjTFx2Xh7j8TWerM4rSbFF54pt61lCSseyD3vO7bgJ08NaHvsezzXQK2dcLk5+eN4vkklFc6mu7KJgqzocgQeoEflBm7D0QUZJyAzVTp1bv/zZtqEkEBK2ESoJgVpi8zpgOEtl0rbRUYH8PZSrACCvDACJOuEi3OVH/6Skt9iNYZRS6xC+Dcu99NJw7SNxSO2vYR4xgnAuYuYdx9+S4Uk50pHgUakSsBWLQxbbq8r/86wNjFLuDV/QjH40XU7EoNNJcmagyyp0oFJWDcwzoN6zB95IylTrPFkroEBT6TQ77BZFIyBCQRDXhE5BHUMo1CD/bVToUZ+0TDznKjEGo/nbrR8WO7G3gTEviu8K94Gsa6whE2bCZonhd7+GWxPcW+lD11YTFtGivxwTACgLK1a4VAjNGsG2GthxLFQMail/l11ZAJGKfQXc5Ufc0remigmmOps18DCsMJvEs8ZBZil6kwGJaCbVk2K5QWlXUdgAoWB5WO+lojwo8fuCSskXQoT6p1vTAr4pLENtzSC1fWRdOR+ya7wMSYSJ8aFZW45YCk/inWbNMM7qZ/rC95PgHY31SE8BJJ4m2emT23sH02o/USNRIPA1SKuMjDYisvFulnGuZTgeBeACplBm0L9peHdYxYshB4aH++r5aUcPgXb4BxzrEgNDrie6v0QI25eemyFu2fTOEZqwAW4JfeEvVAoxUexWe5FJoVFlBh0QKMvxO09PEna+DrWKxvV1XItQCaw/D9v38ML5378BCaPpp70IOEKoLIkV5yDUzm7Jt8P7itG97FVeZtgBexW3Z+wKV/Dz0U1X/mfYRcWAGdM8EZ+2brNIH2SidZOoJFF+KfzE0yikA7Iul8AAXPfcR7vkTjOp5e9iKRlPIu23gO4AbzWjexFkqMJfvNbBkgJJ676L+BLyW1WN28MLGuGKVPjSrJ9MkVm4wOlIy2uLwnH2LRNKj2JJHA3GG2Jso2YeQWXxGAbE6+qVhwDorIhcrXXguvDmFfq0uvpu9jIizMErBHo1DouzeAsCM9x5t3FhF7DGBM6maeTn1IVEmNv+msomkOjuCWl+J87J4+AES39CM0cqwKWUNHYaqTtFBczyz7gYk53QW5DgdAqKQZh7uOD9tZQO0dLMU0kNS/4Wb/TBpX25MwJiNO12Z08ix7aLjD3IbPQiiRFOyG2LxRVUy4pZgKIkfHkk9Kzy+C6iIH80Dr7VGBuWSL6Y7kpDgyGIberCIXzKOZbgbz55jdcnml/bT44TG//uWOsCNCgfrQq5YV50/IZhaARQlWPjiWRhhw+NX1ZDi6Wj3BUabj+mNpt4IuKpnOhh9Y7H4Wv9CHSqbn7L/rydzrg1yL4PUKtMrxYU2v6RbLIL4/8WIyDAniQvBCGmen5RYrOPdn3l5koo0F+RGl5aZ/TakOeozo1p6tu/A7lrNmE/WKEkNbyEH5vJyvAfZP0fbUm3dSWxvYuJDjRQZ4sv/PY/O+IsMKiwRSnuFsdCbGreyLyeBapvvHMl1ksf5hWiRgrRAJ4JpedSAclGpEp1HVQaxD9WQE8L7KCLSTa1oe3DK8x5DFHdu2xGjFFIZFMhQesbFG2vTe6U17/Jr8Q81RL0mdOtW8K2BhxS5t6nZ07ufNDjqUNeRD2neDV1YKtv0Eq3QlZewObMfJZ20AcQNHfVuxo3zh0TRi6al+i+WB+wyUdFBwwtT1PdwOZO6Wap2J+GjZtNJl1qeNQVT9auPfdm+sA1PNtQ+8X8As/kUiKyMFKw1ktzoblYUpY9EvY18hQ1ndP6Wvvc7A3pUA5iDgjwYC+rXdWe7o9I/JXI8hnuW+nt5j9cYdrjICxnnRlZLszhkJYM16c8re517VomdeXyIuNr/Y6Vc0jqM4CUPx7LA39X2t3f9RhVBC733A7hCeT6WHewWRGD3BB4X8Hg7a+UYaGp1ptW71pinTb2dZdzsTvvXvWMrB0dWNLyWvWIv00We1R5CTu8eSYslADEITqZfw+OdOuzizq4+Oo2pkvV9Ob6CBDZvvuOnpWdj5wpQxw/atAhkdceNZzbu/JzEVNDL2gypjF8Hl4gVQ3ZoaXjiydZG2C9GgpDEBJ8cZnULALfIc2Bog2uImHAq6pty9EBuZB6NhkMs6Z2lQ2BeakGVACbnOQK/+/bC1q6YliUg0gr8JT3mdSeYDkPlqzSUJ59Bj8ROs4OgbnD/o9NJxkTxnu2S57Q+4914STvNg2RzeaOsbfBLcz6D4S7aNZx4F5HN/FmbcLD3QCP4qfn6wSMzj41K0wMlhb1/cZDFGpQHeK0UelokrFOpzLo9p72jVtjzVG3NM9Zq1zBZSNRc8eAcDEaaI9WBOJY8aEdFyJY0DMsVGIxrsL+oTib/LjB4tIv7y8/JitVU9kSAWIcoQJmN07gihOUoRsD+qxkuDV620fBnriJ4D1RkyA537GOApHq1Yi1Ug2BwoeF58R4MtD13IGlFzrDQJgmvOD4puMp8RuMr98GcanDM24iTDAUrmG09oDH1+I8EZXBJiolP/aBMyOFOBwcVsXbMaqnybCsoNftN8VTF6GNGz4svGeOFTCMw4x1GTyokaYRu9kQOKD4xgjRpJnCi9C3U9SDJ8TgBaHcDAr38mSasHKmxiNE12ZTTGIkQnOCnK3WJ9FITjvT+5YbY7i9QXPurRfuiRUrcl9Oc+1/8eyYLAyU2Nw+deOxvL+iqBjIfbR4YGR5MOj13hcRfCoREiBrdwv/uCp6PpPRMXpGOhTmJ4WgOdEsygxFIvBQg+TuAbRbLS3m7Pj4cgMS4eERT+MD+kUu21tT2Ucfix1Q/KBupW3UVwuTbGwTeALoUquux036Ly56skxcMGVufzZWYf2fyrurw9IEkJWeIUuENR2OBkgmRoGPbF+K1+nJVjJHev5399Zk7NjRbkUapPhF4OTVdjrn8U6OklMUa+uW4NwSPGLWgj28NGBaP+DJaEy2zi2vfnD7q2rPwpzcbtrCChJH//SbDvjnRYlXR+4sOnHkS3Da6PnTi/ZEA6SGkWtw/ZWqFbJZ4n8xB4jvsbia1AX0+9rBXsDq2BSgNGIML7EtTOL1dQ7NS4RQTKWKwTpi1W31JnVLu5LidmBTUAl1yO6CrWYtjaKqNbBpg/vFWlblGQMnCGHTyuMuCpToM0wyVwaqh7+r+OgB2pmRxECDCOaPVlNA3wKO7VqhWMzQTu4sK5ovObbNLxOHJQI+cGX4B1fh6fznksI4cVhTtvRmhVG/WfokWmRDGjqxsTYVr3+c2ZKvROelDbu8pbCv4iILqVstoCcwjvbP1I1Xqoy740TteEDfI5V/xwNGyq9X9EZh0/L7VoudOLPc9nTvAPWmLP3zBVJwJBXR3lbIq67biwHFxwknJQUj+CABPXUvTnlhL363izPKX6gcKhu5h99X8ShlW7yGY085pxiiLdpYvpTS/b0VqBxAzpPpS6eqrQG5ANM7HQllzqFaTN0+UwIWzQAIDTN7OO08r6Gn5FPKmfUEhLaplT57ei/uly/fsY6+r77HTfyXt9WgVlVL81p0Bi8t4ny9y/iSaeyH4wS8PGKoyo84lm+kPi4lg+iCk8shPDl0e9GyWSyVcz81BB3ROPOY16ymWkq7RbEFwO6vBTn3YiQk8V3MiQl7e8WM8RDCtF5GZDMawlcy+Pk0v0xJiIgIp8g3xBcvJcOZmHtXFTSMjCRV2X0kDPvvWx5HDG7HAziCnihiHkxNWuqOs3Ad4s0yUu1f7oaZVz1XTt4jPYE5MjQxTQpjEXALWUNlyPhVH1Hvx8FaioPaotVlcrJmiNJcYGRYA97TUyopFP1UEyv61nwGJ95QFykmt+Crgrre6RS98+d4tKIkXYvr94Cg4MNla7WxbREelVqDZ9yttUm0weU0kTh4XI1ivgUf5Et9D6oUoNDylkcYlRc/5SA1nIKxureSGZy30N7TQc41lSBEbMQ7ctM2lV6Wh4i/Uvgu/3hZqouY9CFYZkZdZFanb8jGUW8GTQo/QSBe6BfO/XJnrGFs+SpIA23eF1f7oIjDTGlC2NQWdb6XlWH4etQPLu8IbkaznRfmLHMg2gdLBWCRq89c5WF7QkK1nNVvuG393RBog9W8b7xsuRKN+KzxDhh1pv/1wYxVmVHyq6RXXDtLrjkBTPAY8Mm/R6lYqRPcWF/PVJKqzljkGIqxRbb5rFH4to85i5YrThtPx6axT+0Zl7mK49K9qsRj/cbgT8DbsJbCMW1HYNk8xSaCHr4d719oy5sH0rcJIhhTtlc+KIqsFsuoivO6fBHPV4htteroxIj2tmp32CsZg0cd9VptxcDZTy/lqit9OMPAGKsMMwXgvx1gp3yucQ0P23wk+1EO6bGxNS/Pl57BpJxsr3SjSi/eyPg+2ICygwJeIwIYAA6xrJqRQEyCDy4p7jwmFKS7X7Ma5E5P5SQkM0Of178PWaa2hwyQhOKf5mmYpRB5c8cwEAD9WblDsVqw3zSAlRbaRYte3BMTyXUG11C0UIpoZ3nhZqd4ITeB5xS6UzF8MRR/a8TLGVby2z0J088SHSc7jGKK4bHQJS2p0sUZLdK9qAKgFMRB38lnkvP4Vp+exiEqe39At26/cD0Jesy4nU26iuMk+pOaBJALrLl7NFt7nSxbsEsDV/YJTJB808igQRyaytOokfQHGXYeLaQRiSM/eL4KgvoQL8BJ1B1MuBfdMXXIxLdedD+HsYVttssIOkdZXmAcgqM2KruuTGUh6M/Lk4iS+eX5+DnrSMzFSZgIJqP0GeQlaqbHRB3kQns59/0YwuagnsLlG7k125BeEf+Xrx0pVVxpBNTHCOaMDvxsFiOaXdDjIRhU9j8FxUmZEkMCYAaekNvAa4Ii1AmsNn6cY5plbuhfwLTbtJKj0cDNIR8/rZ/bhI3RtrA/yRfoQAUKkNM6R9EbX5TfsydJQZcWPdJt475Qsx9HcYO0XV8amNFJMEhpHrn/r8zRkmGmVDNrcRn/wK8G83K183swxTp2DJ9tHaPj0rJkeBjupM7Qk3o17neuJ1KreQihA/Rdo1iRhXD5mNGD6H6VbmC8yn9sz5ifq7ITzth/0JOoaqrgqFCsR8FjX+tlvixXER3wAnxcTMOzfts41JObCkHjVFLVPTFYGwQmKPIpoxp1nuLNFYD2baQQa/2KbTHwXzeyFGWraThBcQ4Bepwzr7h4IHb8hN/ZqUvKxPibwUexe8A3vbOdpuUkJAQxeTt2gtQRgro497EvIsMksmSM0zxRzJUBvxo1EmpptDBadbTEN/k5zXPi/E+iYs9HNGU7fAmHRIfWtzhac4sZRpUl4zfkt5CmvANJnSBRPtyGsur6TbwU3oPILe/JzDBpHhww0kpihG+d6ENU/wIUpfQHSogDcPme4dDf75M6U8OWUnXubwetl5XMgPDNVk0Y+eICRvMn2LMhk5arM1yiGVfn7L51aeohQmaCTO41i3ulcmLm4eUbl6BPlsdlVxhKQ+9R4RvU1fDIhySZGxxtS0lyR6IatYM2CfoaumxhT4Qe/u1NLTxB/U708eE9yyR9e49/tANLyW5jOw0nfuYtczrBSHHpuPEbnaYKMgFA9xoDbXBU5yn9NvEtrCke0J0Sc1aMR7GlrJ+juAymlEM2pf6eEoQwmTmVJOWRzpJFjPDCDYyEjVCNKRXnq7hQ8DLSDEKuOqgPU+APglZYENGWZqn98GZp7SWXBTTTdl4gUmuewtqq6n7koLZK4Bpqc5UKEwC39BjF+sQ6r+Y0mq5kBCpHc/sPXaWupE8ZteyTN7Kgv9jnAeWDB4W5uj0m6zm0aUCbTwTYgutFfCk80U+GI/U2cVdmZMvCvoduGFBlPiJlSbZeuxIPC2CyjH2pUOZPMiOtZ+2x97gD8w238BG719FTNCx/9rCTKaSezSHp/t+cdvzXi7CWA+DdmSJeEydVLSwxlBYE2aY+//QoqOeQsGNOIALeaIEuMDVXICeFDcqBQ6XBynCyB9HXHLEk5y1C0Rx97L9phVR53qM5V6plndzAW3Zx5jZJdoD0j3yRY7b1XPnVg/becGbM4XvKx07mDUlFxkSbi2OnpFPTRnO0XgkJZElq3hfLXltud8TSFRnWd1NKxBpkVg2z1Ulz0uvCd0XGdq3PTu4jGcwhqx+nJuXvSUbqhAfNCj3iKexmlQdJhYJ1Lyd4KJCtlohCIf0P+ytMk/cL9x70WVzOzV4/q+/dosGwj+eKmHOZPsbbtHVM4WDr0aTuHNN7d/9MlXt3j4Hul2WY5JzM9Jhp1gVRePPNzTM12K3G7msX8xs6wi3FBA0Ir7QKkVVyS44FtfpA8I2w9k1XK9kHdWu0ef4ZxIBW6k0HzBiVQeG+F+fpunSz8qAIC/hX37+Fv4tr26JhcPMGM/vEwCtZNovdvcFmraWxiCGA6mbnSr/ESMmmmhJeK5y7lwUJPHwkud+6XqfUAQ9beQ4Q08cJ4CZHSpQyUTWLyK/9OZ+FCXArtilRFAHBtJQr/keOesj6Uvya3VMSHIqUnNhJyN3uEcs0M67Xd9Y/UxauLBEAcMPigKeFzaz7Oc1p6MQ1fZ9MpxeQNDf43xXkrgxlhEi/qt4jlq0yWQyDpetM9oaMpwya4SVL4FdKGVvBwllAEVxR84OEb/D3B6jLHkcyxAo5QOlDxL4Ts3LSOPut531IRJkDEvKaqmyGTQfKCo2TaycEvzDg65xKmcY+WoD7pHlyRXpDJX/sfK8ApTppXlcxOlb4PRwUzdKUcLnvVBgrrQW7axfhZS2QWNf5UzshBbJabNgvtq1Xq1YJXLlUC0P77QxqzuJWDkVHcgrlxNCZgTE65ojnPmx1B9lk6WZP9y3te567xxivjXB0JtbpOSsT5q0IzDt0rZoEhREcMaiAEvXjtHdmlon3Mbr8aWEgVMHPgxnrk7S3l6OS6ZJMrl70R4uQu3d5EajeN3kIortY7oViPLK32X0kzqtgikiFdAtjdTPZyftRZu77wcgNyYlidX2L1bToUHWfFVlghmDbk06+YFhAJk5MdLJcn+tN6IxRdm5vVAQsbyeC3pF4EZ50UDokxVX1/GN3mUmsYBvNy04e6oFOczJKXcPi4YIzE5b9gvbCfsttkOtdP59MUPMglRlwqoDvsA22FnePr0qaNRIFxALimgFGCsBfQX3su+0ax+6B8lVJlTYrCWzpb2zMIEGUlJJV16VSgIl1SICk5c/zfkSLjsdgob+e2ne0Be3B9Rdc4uZH3YGozXurCqPRMKXauxA2T/v+JmVr5Nj7mU4UvfrZVt8Japn1e/ese3G8wB6+NQnbhSSYSSJ2mvhrfvCBEqiIFC7vG9ep/2xCnFnkINAUbFc6msNgC/ABqScV/dYnSlbTSe7kZAEcRjsbvqXBQUoCbVGLp8ny0TL30QMAhVo2zWBQVgr8R46mRwhZp+A6IbpfVbB+LTtXwcYEWkbeguQ1DeimYkRYXcZ0EOtJIjUoh0hd+QVqt2u7whrkkOipOetOyZnCfvSNL9TCImVEyi7mhVpkYO4gk15ZopQQanqp1mlwlgotBZlGPrCpMdB4xD3hI+S99zVOZv+Cy1Fq+EjLVFHwNMgBcWafaGA+R5Rc3PN2UH5YinWNVH9NABEHaYQzT6rwZwqekOzfNtvZzFbRtL180/rRBxJ+V6+cpp/clH8IR241J7SvlChCZ+bbpRBKsPOcU1u9lZ27F8r8ardJ5l/D0kKk7qfozEuya4zcuzV9dKqmIluexm7YAuUIWaeWeGcRSeVujHeeJsf5oGcmEidNqcDIJJwuzlNrcyVVDsXhhVOTVGfXdVJxCg5QyM2mqKzzfxKqYwv4nsGDqpwoDxqe/Es/Pbbp5BPclxZi7ZbVv7IuBqjEzUmq1N2MaOzI4uPhJ/k8Iep+9yEh3nZxHde+VU/W69TtUmn49kPFNoyY8bsa/4Olc+AZr+yTVawkGTA5/ExlK9Y96dKzNnzg0AdWt3lGUr4ysc+s8xty2j4sdF4N6Y4Ox3Eo8fY5KS3A1o4GFSZULSHPTmUG7SWc9BnCzUnyGnU9hBAVAI/PCMLPNcK0HdE+yl5tDME+obz0S1HKQ7UqGqyG1kjikG0uwXTFc6E2NkgqKZW18KO57i97215C85XpZX2tGCLjtXt4rV9/sfLuH4E0eKD+lYtosihPB+fNStUcp2XfbN9K3xugLuvid4h2GA7ySmH2IK9fSynCWWws9PdJjLpMZGP9j4Aso8sQALWTJbz+ftfu4r3Es13IJlt+O3Qw1mGjiWzxkdusvRVao0YRBpQqEii3dzHfq7lf9pV8oQ+0lVZAkn65RJa1uTXAye7uxgDWQ/Py+3nAKUQaXyZx+pVWdzASFwXe/LxvAKskO+lRvJDEEe1PdPZ9vjGgyrLDArSFZQFjjjQJon9wIlLEtmPZNkxMIoGwogitYGsJvtMEpJm6RnaX6Ic+dH+oDwVudGxSX8L1JqUDLknnPiZ/UxklnlGQNzdpp86v+mgnpgogeuNaF6RmwyhlvBjQ8ENMjTxA90ZD8VC/spJa5dCo0MIrI/oRJbHSimBQGdkLTlJ4LIcOComLak+uHHQI3KUTaA+OfQjv8cM4X1PLjQYGPwJtCEHFthePxG0PlZ8dguXmlGejbiESzPePsXrh30EYEoKgqaY2Eya8FxvL4lAKirw7gFE3r3dPqAplG425wytWS9xejnDQiVCNbQ0zvpmTHW6DuTq8ROypTRUFipPhvvhpopShO3EcYbnHEmz/LKt6AtAF4om1YnYmiQU7QxD5vMu4TNG4RKxvv7IVWPkINKtnmpqgVyNsFvkfYHkkbgIdxgDnoTN4T+1dCJXGQnT7Bcn9NI+3tlWvkWa/RYODZAfOYYZVkoiXx2AsWaz7cKDqjGT59521daCJrle1UO12ZHvhJwQ62jtbLYOpgQda5fCVbD2V9eXFGD1ltIUNUwN+7R8kvAtexmG4mmvBCynDIhyPMU7kKaAlfo+DUFOn03TpdJ7jhO6sAURyEGHIhASOMDUT3F6dP0qqfZ8VCTJwxn06lEQimOfgbsuQiECZTPrQiXr9hHaJHT3xpGLcgsZEnixNM9TjipPJIHbl67bdEKYWGLkGOCtzFyvMWPUIIyvi/S6vgK0Zic8+2ztC3wAhDZJEfs0G3CEZmLAitNB8ua0wSMebeRTyRBNKziM9lbXg01D5UxkdO6wjRiMrU/XFpclsG1CxiBhntCvhmibyXlF0VkS8lN9XAC9D9Pn7ERSOVYHhgEqfyCrzz8nYIvvXc8gwUmmF6+aT/0W2cUQ6/uZWiuCl7+8oxZCuq+TdujRBt+4rDxvR85qicCut4eFLwtuHPcKoX2w4soiKrRnwYIW6aXG06PM5D0FO0HOmTe+M/dWJAscVtAIM6gvzA1nw9G7AIKuElThTOBEd3SUKYRDeo/9Gf89+Y/dPasOqiUboa4O2L8p/2RB0BNBVh6SQ8DV/CSRz4IH17MhuNGEJFHnAKhGLvjARb/AgfGOXvFnqU8wPLsBl/me4+LJRFVgscbXb9SO3ZjTLh6lE3xusleOFPrzRk0Z70lZbdj4VZJNo5Z6+jF6NgBQuwfd0yZh/37j9IO3p6cEEl3QKYhumOoWGGppiEgDGoNlJw7eN9GuXKpHfC7OFYCf8ff3fax+yHYml5pXammvf+DvkG2Gc1quvrSyoPMr+CASwnTBOlUWFdlM334Qax0xxLdypI/y6Lntq9NwlGOSk0TG+zjcSrTw9JuQOugvxiKH4rv7KoCOVbmDl5FKKAe81MiCeYCbbsuBRWQAs1U1CCr3+z9wgJbgnZMHorVgBJ0YkTWAeWOwmtMvWLEhgJxxqJ1njwS6XagWqIdPHwq5d/91xelZudUmNrEkxyfZXjq4i63Kg9jwjwd671fGMLtmgV7KRELnuK5Afqy+crXxkqtw4hWWOBsAc1YOH0KrrU6hBr40Zz2ak2sljsvghizWv2EXQFdfTOO4zIIVfPX/Ds6keNU31VvYcv5AzFT4U+djRY9Y+BfFtpf76uDomjBXEYCExzwB3eYBWp2Rj+V+PiBqSi2x3qF1eEz361LhOvrdiu4YWFII/cuz1Njyuc3HnhkJ2UqUH5jQecZfwbHfMN7psEWmbkxsqFgMdOEzxEeBznNLCZMU7eosOBJnyKqMwusdVLcx8ChdNpCXqHSazLG9rgxyZpclp/ZumABO0kghyveAMB/qI7bVFPUZuFzyUOFG5zCAYBxNr1HwQZRWt1AP0DI64eejo4HhnocjojFz6zogdKWUkzJBIwfO/1B/WGj4wGVQmgxenB6HzPYYbIRj3F/Y2FQo+JLxVgP8tApq+wGHL866jEgL/naITfBD0rkCTdG3h+jO5wVlQ68eyE1RfMVxe57X5ufW6m72wwdcyHpN+Cg+IhpXHOO5G3+4dZa0BeVfczYx+JQEJ4zuwFctfHs8FrezjXqU8Y0r2AMOAIxwN4bzLO4PkadfwTAqqLepSlmK1wIhVdnYIBbAiTta7x223A/V6SRFi3qXZQmkM0xjx+HwMp4H/hvt8iBzEXQzclorGiLw1hv3HNOI+a6KbhJYAv6NMI6urhu6nyNUOozOWh1HempgdhkIaMp1MZbTPj2S6x2mtHD08mwL4A4Pil22EuKfg7xMo555q+puZPzwX8eHj+gVazhPxdrk1MDhRaC+i3ad1r0A0uJQRNdkJnULQTxt3EPDxCTlTaQfagd84mmxlaoOgmRyNNBaWNLdvZRxucgDYu618TtdDCV8CDesRJgM40co7k/7NFKyFs+c9rFTcHTeg6jscF4sZsNJFFjN03KmZeBTel5ho9VKHBUYFbeNv9LLTYwS5FGXFP5wXMr9dJ1rec3KdErMCpzknQjeydRwCJKQ+DfsH8SoOpgmmwuRM0ASTzdHHkRaoxvdSFTI5a1BeNmZM7OGKRgLSinf/yeMU3ZBtNJ+o3808fnBr3Yg/r1GqnmzMBZsU1F9H1AtX5J74GjX3XuhgroMB3RSOuF4zCtSdHa0PbNe3X2jhEiASFQ0TcdNru27aPLpLkUtkOALl0piWiTTAKcfjtIDJDFX77LnaMK69jLFY+ALXkrhtLWm17Os71AGM5l0miOcCpCmfBG4iLpV+ZqFr96Sft+q73ZrWlEZckdT9o3o+98aB4QMprcWR5mWF1hbsthKXJkznxwFtQNNoiGx9kpIQ4/6YJe7TpdK5THzJsUXuD/H4S3aRIl6P1I0qspPsDle6ZgwogfzA90TmD6dxa/wFn8Gff3g6p1saj9a6ujO7y/A436dwovyi21r0PX+npjy3eQY4p1/GBXVUwcAe95nfnH0+14LQ+HYPxWYGFozokkYbZVIRuKe8cJd6zdNCs5+ncIiPuSeeo6VtXwrl3tE+OuaAyzp1ODxalU2AzHtwNuqwQ0GZSSWLo+pynO838cXwkL9+92EV4Dp7/7kQTc1wI6gbllLHKspW3gUYDbJEFy22fYjTtAasVWyxSpJEYEeZan4MxCBb/ASnOBr/ciZJMCbpeqdV3lPDy/N2CYfUTJRfAS7Geotr5MrJsRgmA1CCU0udjQ//3dFrrZ1RJ9lttTWMIdqgHgdCwCFhenQC9ysr4PBHG3htaPwdDX5CpX9O5K508qMxGmMmz+jwy+xjNqugQgL3Oq8765SDsTdVQPWV8zr4dVxDqoZUpJqx+jjacEsHwKXvzqd5Fl/3oKnK5YfEciW1X+ShJb0CbkUbPjiQlp0gKLZin/qAFlH8o+AEES4eSQWspT5Ndw5dVIYPpDe6QSss4fiiD0by7DK0y2MvkUwKPfsf2kE0UDhj3ACtGk604Nc9wLvHxUx8dRETTi/ZGIQaBZdLWWE+7Hyp4br7pxsZSMYel2KZcSYw9x4eFkd+lRdEZKyDw5a4OGbdNAmhca7gOjQY+8ylKvbMR2smkNwU5SF3V2KBtcE1g+4ApbMtThnW5La4FCHu5mLNmpmgcYMhMZ2pTDfZw478EwhPvHVKtGMjanfizi8a/sXcBQzlBeAN7gwu3J0MZONhYTIhPMeYZi+/vKA9ROMYm5Uplz2MKHSQPV9BxsFw8t4lz6icGly7C8518t7twR6waBkKCRSYyAx3Fs2VImQQLNSFjhR/VBoOsJQv4lcnk3T9OwyS+AsjQMKHHJTkCFr6cCU3/NlCLVpAhNf8PJN/VIE+HvW32qT3k0wNoWSdMFFI/AuSHkgxNs1sf9LkE0UJRUXAWvkdDPyg8WT72TCyikdOQRN53nKnin8ejhscBrjYclOOgQSWr0fpbs+HL4/Dpjk3Nn0O34heO8oFv24qV503LjJKflIBcuco3H61gaz4Ft0t3In+f0pOZdW0nQSkATl+Inu9TgByp+y7+pS5+IvywyVTIHQFfGUabyrsoghW54AeTBF4rZSkcDFvjVpTO7hcfpVEuXaWlnSn+qkaAUukeEOp2eeKyvVNwOk6xNhjBL9xPCzYLoox+RvrzeKGB9bxfKuPtmg8OLgJH5D0g24ZavB5iUSjQTop/iFbW1yVkIcCkeIPNuVgbBWgZT6GLe8IJut/sVHNO4z6cQr/BG/7BMhpYmErt3WQOguwSAtMbA9LB8y4wFWCgvJBnZikyMTmllklMVZgU38qKwvAc4HlRz+uxLYe+nlDJFDFk7YHNEV4EWIdVDUqFBuH4HcDG9G1kTR7vcHCWBYuG713OHCBRakn0FWtboR31TDjpDnUtJgqRf/bOiSCiLmzWjgM1YAOmQ2koRNnP1/xPWJnGXOmFR2gBNZGdvy2RrtFnG1Amw7D9snKnbw0gOmAxTIWhQIjROxVfv3UyuVwlYXwGXh3YqtEgKD8DtrfS0jpO2mDSZQgoJo35TQPi6e2hNyDxcsHsavz6gsDZ0gCUlQtpxmC4HPl9cR7o+mgRNNKqnd42Eq6d5q9SeH2geRGGThZSE8NXHQCyfMfmqN6jaToq7545k+O4DIBW+1f4W3xBhuE6gvaDUUV1TQPCLD0uT1BiZDIxl/e31IJhx/2n0tR1jPdechG9x/UsjqCaraIY5MGidtCc0j050ys14R5dtj22xLSbMzSK5ecknb0ziZS+03BwpJSt5O1IhdQbAisC2YUnAYkTZoIWlqF0RLp+uueFs4CPU3VUHPz1NTfYzwMIGkIWGrsctsGEOGsCwBsxJGIOis90r1SUWmKyYRNhVgFypnzosjvByjv1AJAEd/K7ppIwXQDnSn9Q/1rp5250w3aWVc2wTMeGxnORu4126zY+8kN9sMOFfZnMaPezWt1lysSk4ZrdoTBKNTpe7MwhS06IZGeOkjazlFb/v4tekzlSti2UEBMlcJHdCOzqbVMt8Bv9w7F6vBDtiJRSp+G8Eignap/ryY8ETq5jRLWK3axM8naEx3ZQwf7CIm9r1+/G7cJNkgsOvndRJSlSagXUX/9zPp0laDWq15Yf9FSGlpmx4DB6UdpEZ2+BJQzywLyMPbW646ofW0fn7Qw0L8g1FvOGlB2n3LV5kNXbEUOf6orEBhxYjUpKLbvbAVXOuf/cdtEXzjXDqgB5Xxb3CqwpbR/z2adlLaMp7pIq+RKBaOlmRVWOWUTAz1ADJ4b4LVW0AC7kWYjuA+gm5VEHHq3pL3vZzynCgXO7Zd3D/ZGf+PBUAiR2gKkdwhIBByM1lj/U0TkkTWvGjF07FGcDIFQfD9luudRl2hw/s1MCCbWkrj8vrR7wrP2e1fkTentqqSveDJLmOsVy9U6dAqpVWQZVUSSQlWTd4NZvej5gLNqmS/9elr64MYao95RquyhHCiFjP+SkQj6i/ow0uNqAe5QhYRDzC2XdR5DEuzpM8rZVmlKu1+fDj06qF7W+03rrrWHpDzmaDTckgw4PjVzao61QL3ycf2MG/DDGUpUXMJ9bynI1jhN3PPPCwaw70oA6496UPPrtVdD6+Q6rXsU3M8+1XVY29+4WUVGltHqV9fUGGMs6pShAr2ZgVJHzgi6vGLoaKplClVTw36frNhUa+5FKLOvxwT5MUh/tfMSLe6KkwwXa0Vg6+4XRuEybOw7AX5XSQyEyhxzcXyeZHXOyJz0ROTp+Tq9qAmpdXZCrTNKM6gLbWBdt2lMUQsL83RHZFyOzKfLqD2+PXveWxIVRZxeEuEk0F7Mkxn+yfiP71NAYZ9THeDrwK2Ow+JtGm/zL6PO2wi5ew6HgeM78Q6tWPuNJwt5YVN3fWwbXhtr+TsXmJyIcwGN7vmuILHw8Pg31kXZrsSzLC8R9hAlIlsj8PEwcW8/yoTr5sKom2wdGpRDxuhnb+y6OhO6kISm+2bcCMRH8qPDnrCd9qdUKRS7kvSqIjgc1BYjgvm+m0rt+y2uiiI1WnKgrbmMgAox4WttsqWc28vEC7K4g0mIKf9QbaMDFAZlAkU2z5M+Uv67o8Vwg2Gy+0EFGB9SLnEsHD9PBOAH/TjLSg/N6aO6nnQRXYxwtxZBlIroXovUgX7hGhlOVFPkOy4TSnPzD5/SRxGORTA3mz7IFELzfVUDVnVicgiSYT9B4DY4hrIdtKGWufPMnOTy/R6TWOXZ4uEg2vTlONicJv1xUCfrlovymgfNZ+8ObT6wllIHPYDW87H3KGOKW0Adnq++QIJ7VVsk8gxCfC15TRH+pvq/UZ6+A0rPUf0GiOmQ/Pc97834g34CR3N2YuErVHMvrM8NBNMG8ywe35QGDbju5r8FHKnX0lGjiYRNu+iCLtuNf8m8gCqUPBsZIVMLECc8jZkwYuCfAFJP/qtSHDqxXBWYLVdyICLijrenVZSYlLSEIH2227K4OVw4oWalvsxS96heD5Z9tMR1ad7FH9hXVe9lflhxv+mmXI/4Fiz/Pni8hrkEdM9mTUgKN/cmHV69zseJ9fTpKAqgPsILBdjzjiSQazuIC7+Bs1ZT6lmvRgLl+3120WMRBSm/mxt3GXuQjwV5Q8vokDJe7pEZu3W4HzIAU2GEsV314UTAaXmOvubIDUjNRqayMdsgSDDYD6EkCREO1RLM1+tA7Tk+TR83byW0fspRgC3Bgv50GLFMlntjRklSeh2HanKx+FjqAVlcekkEbSUF2dpwBTh+UDLDTVOToY6gGMRrxXsbn4T7j7Ytzx9h9o8trGV0+iYO3d6cirDUsPrj+nh2vCPDgXPNLavga8JI97wZObKsTij8jIydoj/XHtUs06iEz4cBk/22rIgtrEZvHTTiI102YIjsVZiBTXpzibvqelkDTdyQN/aHr9tpXp0IyyZ/juuYwWdCWGp6rTPH2EpwOE3t4w085EmZrX8U+lsDn1cjBGWeneokoo6+A3ljoKLgIn0vL3XG/5WrYkYBoPEpVN1G1rb0fzuWxjEUxfHB4D1QgF8+twToaCuB5Xo6rdOxLTtdIzEVMXCWkCT+EDrOMZ901E4qHOPo8gqO6l1zQ0Fc5Z8Xgy3uTDi6PzUmjlbnAQOVQE/k9RZxjf3wU+H6y5SwaT1WS8DBqVvkg3pi3jTJvARBf2lABXfZWKP2P7W6pe9Wf9To2An2uW8qXOcbPI8GER+je7S+RqTVeD4tJu1/bafz10tX0qW3CbpC1mSHARmJU+T1sf2gRy1e4ABTsXJhVByCIATRaJ8SK5/GkHibPiLLqnrot4wqV538sjwqfmA+bRgxsXgbaKCCN2QC/WsiFML4wEIirrY6FxA9S1DIF8MXSsAUFWQXMfZFVQjUNMcE4vchwiqXiTZq4/gEXzACUEllgLbrEAldGmclKcaTjd+dI6JrDsfA+6eu9HvskYMUAguRYwUdgmpaf+kM/WcMUW7KL7JABpCRcrt4iC8GBXZJ/B1ms97DRIQdEv7G9MjZCv7XZszCS9kHCVsfS8sbZBn4KTJQJAgEUKDsjdUkM7IMDmrj0Zocna3GtoF018GqzOoJUX39GQUzQEEgfyjmu3k3nHg4xGBVSUrIN3hn+slTr7JZSJ+iC3pqN9zb6aK8baqerx21AbgM2akYnsZxpTkl3ho7UpUeK67VueyjPNE5Ie1BrNscPtlzKgBkFF1in2zFmkKhu2juWlioiSGkpf0b0FB8EP0P3yRgRidF0TkITy5d58NS1d+clneFmNDm64xmvqNN9msTluYiHuH+bCMLzqo5fr+fG2+b0v+APfijwfjX9v+TmFfEC5Y2cc+pW3yaY19ogSUpC70qeegs+nUKNrkxs/q+EsRiQI3jLwSmjtg68pM666kfeC57Ze3IAf2sT4ZPEt9ajSUFuZkkvdzx4x9q7+QFHgc8INuo+63AJJC7+M6BoIIuGf+2a3W763T4L6l0nm42N6TSbS6hAQi/mD7D4n4xr1na2EMzXKrEUPYH7kEVvTS//O4QzApaD3CnG8xQjmVRFlR0WjmCRwSlbpXCkq/Rul16qnhw+1RtDaagXjmivPltbP3gconSWkOvqql1H9D85w2SC4CKkeCiIB30et9Jc7fbQBdg/Pl7kW1HYlNIkLY2ppuBvFpDCPpwtuMBDw7hbG/hvWQUwbEQNjzlqxSzsDPrjpsOOqYT4Sf9MtY7V4tjcDhWWzfgDZDeg2ZdCsKKujRyK8ykbDSBMq+1Pxw04Zs5+RSA0yDK5BbJe5KZBtzhdjT72TzHEHmfPVemqaTlIreCczlJNh3mdqLt7f5LG2f6OOdLqonGQZAij1BkIBZnrXCQXkcpjLAfi+uTAt3l2WN7klb1yqAQjmGXklabce5E4OfV2VMMx4twoRvABMabFthkvtwzbRz0tdMcJjtQ5+O+uYJvjasQlkScKDeOd9uqzBJ1EvMlLu7qovRDJGyBUJ7Zc8iaq8Qct2RJF09TcUdYzGusjCTahhjeTJ7htc8KZ9gLem0KCO3Hws7n1q5J9dWbVtAe/GjPOm43Hy9LB4q6/0dErfuhO33EtvATJ9KAi6viC5QZXFXp0Z02Zgc6OD2DRMJxgezkykevfuUcWX6S+YK+KKjenWDV5CjQQOWHBm/AZ4XK2pOe4/3YOOiKVcoo9s4r32g7vhwzLesDDqq7Q2gfw4VeO3ti4rQegoiT/rz41qws4FIGoFjmZM5NB6NMT3SDlrD4WoAbv3R5W1gb+c03qeo+KhXw2uPTD3AOY05PXEClR+4fg8JHUHT5w3UX5QBFcRiVAg0xrrI9FhwkvB+T2slaMDPFCC8DdKurrvadUhR25Xzar5lgLdVwVn/FJamnjSSl7gjJOSl4IjGqq4LHvf6HeXe00dz8hb3WPiwc83GsYHFEwkLAZiQCIAE8FYe7/8y8MEH5KKzlMVUnYcR8FtIYezlfuHF/Bb3RVEJrR28EHPQm5kk/JLGb3dDFGCLlVyP0OVVnqIOcDISuAdiN0iJj378qm+8sJyC2XvlXp665Kyz0yuVUSPRUyIbYwC4RxMfVHkhuovAH04OAMWJ2T7HqQI9sXTl7h8LkODIgz7Ov174UZp+kXaEHynREBp1W7eesj/yFEWErUvfNY2lNyPy0wYlBtTeWzT8cG1+vK7J24YK+3pUYuDmS3+ytKvgKaHmHXQgo5p9xo+jnSndJDFDxiXQmzCoGUbxz8rnSP2iC9uSNwa3KJyD/kJ6pGtiYPdcfVwyzsBxyaVnOMep024qzO9dOe/q77oqkkuf4Hqb6Lr91i7DXFR9feAJO4qlypK2akp5PI8cslXi/gf7EN3Jhcn7rmVbQUKyezIn0JCNk53h7J1N9z3aj6znEk5sFsEQYUekZlggI5iVOGJeFJ6MA6OR2rlZWc3fo8sTCcREdK2IDjpDM2Oh5muBHLtv/nTVrlooz3jObex7GuLkUzdegkk6u/s7qMS+9XDIJQCdYq4VZ+xmHTtnwidcFlEEyD21CV38GLu0WLtD8wC/s8qRjklQ3XC2OCBbGVwzXRD67JkEtl/K31HDw4IBPvBdEPLaJnJExEwGNavpySVW7QglWiIu6JcHMe72UxbBt1tCm8QvM0QZ2fg9pLWE8LLKmC0NA6lcqr86eUIVCAw0uD6AWKMG7jH2Mg+CgzwVa7lFlsflffywEiYYbVE7f3iXQxC/1IMx2rYYuf6E7jdKvlxBmzuKayA5pcXIkrBvhvafmS2lo5g/zqrXP2pKMNK+Wo8cHqflGqpUNx9CuxbLZAMvFY2soN9lxDPNznfT0lSGIJNzupqhGllB2iGrkSZ72MofGvv9Kd3c2M/KSVicPZ2u0FEemdu9wtK3zr0OOhDExIodXgHCIONaCLT3dxDa6pGjKqIL6NcuqLsOjHTpmHggzeamV78yr1IujiekJBFkCROln6XbO/nQD8QXneMVH7XjtT2qlTNdTxmfJJ3vv37Ma8Ry7eRUuANwrGQZeeOneyyH4aAGEQK63qsuPv+4tu9T6/sV1jPeN7CgPzzv4qMoDCuG4wf1BMLD9MQ5/gmbTJf6mlz3hMLowfOHnbjuZmBdG+NOMgtEgzaaNX1g64aVE8JSMedlQN2l7JsfIzK7MObXBgK0HgueoE+vuOYz2D55P9J97RTvv/YUVNrCgtw4AzCL0wHYv1KoscapthEA8Kki8L2BVOWLHoMJVYXRRZ30R7gqMu5D5xy0AuTTKOL2s773TZvNQiSZpny8xZfPlrYOvJUKo+ffCt7qI3iKB5FjCQZvYm7+NdNK4R99VtJzqLXYXarpUpvcmQNtL9ocI03vjJug3+u0lQqDvm9CQgOMT6yF9aBitgms6pYYjmHNa2QS5Gc4Bn9pciGZnNmp/0vG22Dk8+KuYZzSGKoBSQto133ZNEqCe2u+mD7RsqUQaiUKfydRgCHPerxKACCJ3mG24i4x/0+tTgO42VSsxY3vUwrl5i3a0iu9RWBC3JAiVlop3ZjNbzfRbpQ5uDQCqqVebtVa0kURlDrY0GB/x+7UoLFzTTj8J4StQnsgO/ynEprH+sjgptJk6EvKCIwmpIg7+EtRdq1Ct1tAGNlYHQIjG5rwnqvFrSrQTakToJSuvHWubUypn4J3T+kTEXJDQUWE+bM0cAKtcsf/PxDWWMmHGApk9YNC+uIkWZd32dor20jcpUW4CgY/zt8SrxRo32AukNQADjuu74Br7eKGc3jOskffq6MkNOD4MfVS5amX3WDsHA1qj5HBUDINvXZyuujohq3g1BoWf0Cbwlfmmt0byLHTOJud3l+u6Idg2nEziDZwCv7iSwwmlY2fYje9I0T/r0eEaxLGr7bMzakXwtWG6L/nRQ3K2gY3ex528Dqa4jQm7WbN7qV/qM+KLmA8COIZWlIZGlj/4w710R/DNoUVKNYYs0Dj03bOxZK7yfSxxjVCXslf7LziO0ZGM/z6IpUcGcbpesXPiNY3JZVRHzNQNz9TQWknqv8DKoudXhGWqnP1VgY22tM71O/8jy/isgjqHmbPjaaem38oYOOf/b3z+sCWokbZTkWRZXNjgKMjv+V/Wnehs9Wu7gBZnkZ6GRcys/SYPRZ9isbdlo6LreD/7x5nKBhD7IGjI5MW3qtVzQJNSFNkeSmVLjfoR5xSKofVw+C9hF2A15ZQT9Ft7OLOhRmXTJDXoLJ0vZJy4L0SutHwySAzGO7NgDtEeH/w+v96Z/fhqA7YmDi7+cvmiNbiN5cyLKbplCx6V14o0TfH6Oe+NJVj7xpS/e1IwNBZLE+aWZxn2sq9OH6pLqzCtx5TIjPLbRmZNBVm7K5aiZnYrp0beUUAUDtdbAJFj3CzRO27fRHZ3HdDK1ksh4uAPFSvb6aWuy2kaDI0PiObTWbSpnjyH/3WBGcAxrhBZcGJt4lKl3quiKtaS4NmT31n7eIkrKH9Ro8KpiohvjLzLo0Cpm/Yxl4UgtSpwAKIKSMhM1K0bkeBLuVrZdfOgosJaI1UwFfo5xfLmeOQaYdbXb4pdVZ+IBcq9I0f8NkA4DGxe6rFgGHEMItlZliK2W05qGcscKHXgXiDMHUuEj8aobAd80pKWrUV9E6IB/78QmUCEp8kHy7OyGYGG1dmFUQJT3gTaAKbnDGxn7ZqACLAtXVI5ejMz8ys+sxv6q3aVLPP4Jcvf8g/gY/ccjh36QXvB3CXB8/eZTWQ5tNj+UNbeo74ab8HHQP9tzHZkxaKa58dt1PcbJBf9o0SejRoYmWPU8li0kTmS43Pk2mDMweN9Zh1bHQft6VJlYWgg4Bxqyt0OfpAh3c24YQxd1pEek0OHvaJHPmOldIX29L+16h5rBgLThwusiwlb2LgcLchCxCHKbFrFEx1gLdRGrz5NJM86E804MP+PwW/NkGrJ3djZQ6lXxRjWXsWb1eH16fAy3c4DbsT3M9fXf17/dGoNGIajtJCLeSAVFyhyvTzjnn3AOo+zHdWe5iZxbHAxEJviFN8citWt3o4tKpRXtALXFtAW1RxEnFnrb2tA4ad0snJlwSC0thS6y4TyqO7oYX9ELGbny2QELmgLyN/d2cFlu1pxD/pc7Y3pOFqaGFbuJovRIqG/N5UuBLcCgvw80I1YHx65BLRG9NxhEBKmORq68EwTW5vNGLbt89q3EC8dm01Jqs+jv3pxjiCdY13O6eKO2oVjGISyO0VQJ0xy1UkCqANi2evWRXsctstY6WA+/3KlGHOCwdEoCft0TjBW30GBlnIFyWVvEG9rA9P90Y1bbqonVBfwrKP9rJoB+e+LloU6SAzmQvnyf2bsSDx4jYC3QJg5Pn3aahVMY5j58aGethNpFhvXwXxo2553Iv8KJQxEQh1gL1acdhunYkWwt2k/G+cltHLm0sJ/0yjnLWXOIWzWS7uVVFAN0H9ZS9Sz4f1AbwzRpVhRcgqPPUfcnDYDrMx+8p87CyQ2G2FpjOtyXTFLHIeZUUFa0RlN6jXEgKVDpK2JVlCjKcKwJYpwhhBXKoKfYECSqCBrwO9YlVgxJPp8HMRylZQvMih4viUL3EGCykNsTyXaLvTRI199CFM0BKWaCHP+Z8wdPiCfGPE5lH+aVfm1mARE/XywP0YoB7C2YEXyfSWK3cyTAsAqIt2EX6tZCNSkTrTHPaYcGmuvyRwHjmxM86gCX+nboKpUlrccgf5VUS1+9uUsfhXbADZRp+IPnxi5CK7kJr5X4LtgY0BHGqRQW75xDSeZyREmv+o2GcTjiayLSEJ7mr6q6F9TMPIly20J9zawt71cSXsd8UuqlPjEc5R9kbCoS4l4C+2L37nUpwlnegzshfVRQ8D7oQhjcQ/NUqv7f2Oe9mzFGDXaBsznBoY36M36yx9IvMxruN6YmUJnu6Em+1RFFdF/fLlPfGdrTGFXqI27hESKBGuteByrJijIOUo6dGAeKBz8qGcyFPhzah5UuwRwwa4PJzl4EhHIkc4wmziVd/BmNubywgT0VrTU9ddIyI4SfYi2VCDy1RgQaR5b6uC/oQRc/tjsVh8PnvQQa+S9e7gJCNgpLt3V53tj4lR7XH+H+ym5VTCyKmOxkypb+3Y9RWJktkDbInEAgjKZfqiRPmyrbbo6HL8fJaGVfI9FHKfAZZDY7K355WtJVBERxlLFh0BmPltQteqItgsg94evYQoz/OvlsDMSuLhjuJmx10lROSOl8/WmnWf7DwxXTG26JqyG1Wov+ZMWuWyf7IL+NhnLXKIeCYSRcODQ9D5vji+2fKZLt5WzLzwRuOBKcfPTqU1dhq+89yll7K0shrvDIZ9iNUk+KAkPy4jx+Js/VHJNemb4C/LmuqNXsFRhNLwekTjVoiai5lhD2nLq/HCpbirlhktNKmkysURmL28w5ITpqA9zKHaN2jgchkwGrjyNQKXtRk1Ni4PulAOHPcflsWVWeJd+ELlugAdu++hnWPi3BUu//OQgwtgJDoc2tCDjq+257hOkoPDdpk7N+oS/x2BgoMtyWM661twNF45kKoIGyJrjjFH+W2PyQ36GM7vbKRzmkwimTsle9xbG/2L4mHeCvlLs8vSzHVdwLL5HcHhn1x2X3vOuELBoh89QQvq+XFTbV9WV/YWQDumbRhpovrEDhkwZWDFZ/7rDKW+weHwTWGBFFlH4jOnybqYFM9OLpa9AchVSbu/9sxvr0mzBJY/viGhg+LGqlZQTGYA4kmr3JdEaKZBdadKZQFt0NuH2ryBDwqlCwJAQJtZA/lGpn4ZBgR72WaEnraGc1NJL5KegbDlq+WEfzbIn+ztUIbZQk+F+t+U9dHMfZBTWgjLvQ98FyIieykmfLw6Ak052vQ4tMADAQ0DJEN/kAPSidfJ1e9opF7jcBGugPsm3m+cK3z4yn2n6ShOBbJtFMOYC6LDILKgyaUS9HteRcF5DCPX2IRKogBdz6dRlD+5Rn3HOTN8T2V16OwRWnHd4laOG5qHcdWn2j3X0FHhfvNsM0X2I3Htes5uhCSvxzvet1Lqmqa7kN/8bUITWo6peNC0qhQgDSdWdXcAYqLk7XByBg5TPvwzNVTgFULacTGoA/JqCReRoEnRtwlS0csz3ykW25e4QqA4xHwaOKNQhfVUHiZXYNoobcK1iVg2ZJ6g+kKmi9/UoSvbvJRhkSLB+8PDv8qUuEwt3qr0LZZbhwd9GOYXaWj2H4rPUaK7HOO76Pa1193XHenTwTWlh74Fqzyn3NK3P961BOZm09gIDCh/Oq+eJ5/pNZ9YN8wDpICNUfCzsBbu55Fx2XIqtpNGoo+3YYxnlTWkJpaNKpk2Nipk3UcT9sVFzBSzyDbj45bcHnacfMNzafLbDj6bMak+Zcb4RDXcT+Ee2sevNAMfeAroyFT80EMnHYCHkKGMbW32acitYz1J8LodWMtoPm0M09cbq5sbossD/zYoU/YECKMgZk7v6VO2WW+XfNpUoWbn9sYy1YfAvec97ZD+obbrZ6fcaH5bheLkWjYQW6k1z+UENos05IjkrNYZnpasUwdYQ7I2dOrEN0D5w0GMNy5DES7NnEKzBoRrbHS60Id9nJl24sTXiR714X3vEA8sEIohJMAA1alXtzzG+umpv42YsondqEC6K1QhDLCdZeb6HwWB4ojJyGbC4rT485X5JAERZZ6xdZDZh5o7TJGWkBBt+PYNak6/Uy2oxlL0fQbOmUT/4x/q79DjtlnbDiMQrLAsay2aN9W7fmgR4sU2fa2Mad8XxPHMIC2ngCOWpaa+gyvHHFS3Uexe0aX+sO3KryiPpJj2aredwsME0wzv7NHNiYJ+GaXZlZHpKmRaa7etvsnH1Ep4OjtzYTBo9qnRhpgloITUPE+Dwuqdlz3XSqr9SCOUXP5PuT+YcUZS8WSV+5pDOWzCLiXJhMy+TtlX7MexbHEbuvbcXDKeTAMFWORZBAfEOwPo14A9rOxjIGHNKgbOlEv9+Jgz0wGFN93/NHZQ1yIvr7bfQQPN4IIiuE6WPNva9m17mgDsP29MZpK0pKOQjTRkwtuRg2UqC8S5p77QxMnkP7vBAKszAc4aE6xm10T4YVbIgMOEGHwS/Uj6LZGCyaOf+3GayUNtk9N9jFVOhkbdyIxCWzc90Db3DARNWe9GMCG1H0isYhb5v9HQyG3iyFxePH7TUSETmy+mVeLuDN5wyDZXRIMQXzjkPXlwMoAjs6OPXZ8p9kXevoJmaAmr+UjlJNsApFhtC1YoH8OfKe5g8CksrLhTvuZXpbtYntRJdH7//5p7FL/LHDwgtTE2233O+EuARa6sNO5MAQx+QRa8ohcAnicW059ota8TxTYJZtdWkYkE+Ks8HG/6YJ9a967lyRvB0VHNFMN4OutHdxUjVLbyQFtFoJpX/Atcwd66Rse/v9slFAQjmxr36PTRzTPQb47nLRi81XuhIMSbcwQj1MTmUYIaAoEVGHkZHb7XDJ6mp0jfiItd6OkvTtvIDJn640umToXjUujVPLVYPOtIQdELxShwBUxERvUyOwHfEklhyRPoOFQ6kPO62xdBkBDWF6tum9hlj46T0ldtHwPiVrOXRSe4qHPEEOn9vLBCN3qCRG0WYLZ8Zq63ehy878tCNJe4zM6ttEoHHi6H8w7X8kzHL23iMLRVBKkTEE2BWzjcgNQQgjvdFbP/aLDD72IOR3pjcUB5wMKT/B2wkFZzZ3+uuxS4BG+pT/FXVf3QFoPszmjPWEF81g978cEjlqc71tRlYbUOJqXTbaz7h+yh6SB4Xlke+InTc3s0ceVZ9mmL/2yta7Ud9itFZxkaGqQxA5oeCui2zU7JPOfMdbs230DbGfvGf8g4akm/LFsd3JX2vNsALcJxV4aKYe0TXd2IxnPpgSPOhFi/Cv94J77u89Nea3g0e6l/CNzJ7l9rLooRIgxgn8TLzT+dCTb0b2Yy7RgagF1tJdchYmDu+PlvqFs6X2AZFWxhiqft/Cc3LSvog3IC2+tKuZhJLcLyUVjWfcid/2iB3V8lGWVNqGGM4jH6X5BxE12zRoaWoNL83ygFoYbdniYTeCorUVcORt1vgdhDsfs8zh41gpR9amPaROp5RkYZh5f0SjexzZ4vnYD6IjUnLaMVGFV9t+lyznlzbV0glawJRNspX5lHIvwPF5qH6FKupdvZ8shmvCL+5i6tVEKxjpsJ1PjEHPDwvd5859lkhx2/QdfidiFe43FOOml7WOTRXuG/igRc5ufs+ln+c1s9iYXMpWn86hNxZ02M8NIWsLcnWeiykXo3r5WZPV/IOvsejY805sFgEWU29tXQ5k+U1HX3u5htABw9qCegCvoSibGUsVGybnwvrjpNygAftN81JfVkpdR6G4drVycRaiOiegW/29eEtDXlAMMHT1OE/zi07PZEx5tnhPKj9kHnhMb7AJqBfPX38MW0pcD2yWTEPm80IDMYGrTgZ+PGcLGTP3hrjKGqdQi9+lPVq9GEChs0TOja5cVPEKU+e0JGPP5NMswZolRYiihgZtEOhpt1+kTq8I+VcL2u92aSMYQQvaNcrPrJaUheqKqvTzarx9HR8TrOoqEkiRwTg1z4paPPSOaAMNpVel+rbb7NzcLlT22IKtyjaEAo+1DJV4FgTR9DqRNe2LQ0VUD29Hsb9zAFaAKljSrhDUw4mmxv3jQEuwZqFDEKPmQDBGsaxoS2Law3oEnNbct675JpdWc7wQzNBzHymKlkpUFGhSyppTsfVEQet4nvmMb4G6U2ZGFYrSWua2wMvGs12dvFxkkdByPKAQLwxMEx3KLOx3iZxWq78P4oiXy2QrJEy/IbiwFXpREb2HJVZ/j9Mv1Gp4BLUWCjaqJR5OlxbnyCO7alS3OSpb5vmEiN/gfRk4p3RdSwX7HGvEkmeQQ9y03nqbl1lVItaQczry+g1+sAZD33APG7HXM9z981PCRLRcSgxXvVY9/pvC6/2PjkXwA/8TM8G1xVCNi2+t5fQ8oPtG+O4W9rIenfWF9160+tJR2H/iIqAyfAj/8atUeOSMEUGb32CfJajbZ8JyNmFfVy4pEtEMEdPs5jwumLiObMUNCwadhwKjpwzNu7bOlHy0kWlLEvxMBHCqaaeO9xsYQQZVHAQT/bjS8UVmzpN9YLWZEYogGBQipBAN3LohHuOntqMoi/7VFqAXOyyeh8zEupLBiKvYwAUQYf3PrgAJxA5A94/liCiB4sEdykYmPY1COPQ5igqKMlIksSBg7wgBq/LKMRUqyGKkkJSEZKmcDgWc+EJrhSYm4XFYHAWb1qzdqDgWa+yJWz7xa8XP65dqQ/I7GuUuToizfS4O2wCqiUYKXMBFIXRM6XtHfgo7e1bp8nVYNsntwTA/kTaoyrFK5lM7MXLG1VYMzNajNt98LVq4aeH36KLszTsowMkMiSGtYavRzbGA1haYaTTCHFKJ5GTV5qerU2RpNJvn1zlTgJLixJy1YgdLU8Rkavt5EvWjUytXJw/s0wckDAVSz2eLaxgBdcFtua8Uoxy/eR+bm/aNXDlD+0yaSsW6BKCkfPuhpXiycLdMmJ4LNKLys5Kp6pnBDeUxoUEE9qleEQNsifKVIlUWoedB9R2CHlA79eeXSTE4W2UPLTKw89cCSlwTnwir+D6Tocd3eOqqhnoDF56smHTCS7kiKkDioN3bojKyc5RhNO1l/3dzct1TWQDuUfnCJSZyuplV0rDpMk3I2pxKyL51Pp7Se05/7uTxjwGOOULUzL6Q8OVMnKc/1kGCNMSNmGa9eH9obXBH99v1Vf1506XwjULitbGIzTBbBewAa7KW2oRF9EUUGFu+dqqtQjIFC4ebdy1lp3w8FGupamEDmiTh515ypCleq/C8dLXYEMkAO5/UeO0XU+a2bEEdo6R+2UMNjz+TsW9yIDjNQRI3MmhSqZBZZ0rB/d/F7asIwN1OllgN1kR+e2aCd8J6+EGrRXJKBugj8yi1fjQEZW9av8siGwDWCgxLZlF7emgnXay6jVL22g8LcNga1AB5gdxYEZbQLUaouw5ZgmoQ2EL4tRnjVHbQPNfrqo/IjaEJ6mPliz/aUfUCan8lj5S1J2CXoQdBhnNNuLHe6Seqm6AhKKB5NEZxPlYesmVy+2NSWVHp6PscV+KKqq9QRYg7M7XdS5+quArf2i/uJTRtJlBCa/aP7/lMCWtEt4a2eNrW8YZS1a0DIOry79vkbBxmkJIL0nBA+G+BqmuGqbQJQOpnEyWBENqWo4ziQobx1OzJCSZ8CpqZ3JPO35m8pNdLU3PBJhpTC2WMGbqrexFZKx3wV8rGs9mHkoDUs0he3ucHqozw78uj7unsa5UPAHc/CcwlUEOkozCnXuamGvLLL+lh2ScM+o9EyTsk173RIp4PncKF4U0gLpxRyguQTbwRaVeR8izwfOq1WTTIpGTWeThGXuqOqIioatIojTUBrOxatmFDKLtfgBOFxWtA5LAIr0b0WhCFHyJDMlV2F3F7TMUXnJ21Ic+Y54eyEUyNd/uSZF9vEBUpXiwwcdVhTLwhaXa3NI1dlNBApTsVPO/hRQU/sI6DSJdrCSJvkxm0Tq9Vwjcf/nWS15+McqhrKh1qVbMHczAvqjTv4B2ptL6wBdMnTu976NkRAftQW3M9q0dEoi7uTELFBDqqRGbDSFEm77Dg0V+8hzbTxFZkXpWnId3Fbmil9khXBLyFRFnXZoobIZ6ch0cBIfP5nhQidbA/mScdmbbWF6/jDRitm/Qi5Hpmd+yRVG3ANa6f3EPNiMQlbWmwX2/6JBHaoxdzRBjRu34JiS6zTh57mKR+Q+pAYpZ0kgXpHdErPVpBoeno9nT9RLa60pJKUeQG+xYjr0ljesUwamI9zny4Rx8/b5gYcdFUOYNyamvbChnPcF01Iv5uirfS/sbsdjjyBPO2TCaV9j3nzhjZ4cRlOkqEguvCIFvUrXPtFnsN216bLhGSpV6BaWIAf36h1d4hMOPLn1iDEZIzuN3K6aYb06ALH3mnAiOyKPV3H+3nEY4gdkwQGmwpSks6ZbdY/6yJ6gSGRMCJ9z+bXpKX+RtJY6QLu5duazLn+PUbSHGehqR2GahgnVzEDav6R2JVdkO0Q71hj4eQ6IxC3Bm1WQuGOCqh3aokMZYdzWSBgKGHsr/MJ8cEm+xY9PQsjRSbbEwTiN216DWLKNsEMEqzmeK0NscY4y/8r2KPZ6ck8hh7XOHLWjhls6UAfeZcei9QDrHNn0zKTFDTitnHtZ2sqaGmzcu5nCuq/9PlKclBWbQvL0VK6L/TEdovQtsYsX7BCpGMs5CagXtP6bg1Qtl+32ZjKXwCc7kw8Z+VpOhwFeGoAvH7y4VYtDFrJVeVEpemV3spWfw8/eduIv5NgFStU1GPPHFPzYZh6IYBUBzYmZZcVQmKoD5ayLWo65QAVxrdgvn4F/mHpYrkHE0y3uXY5D7mMpUz5+zlwUIES0NQymMPFMWkoMIweAVLKxoosYBITgkjGaIDwQbK0kXB5eJgCCrB8ZKQkqA241Fmgu735XtT3cqiodiBftuvaQ4cTcmqph/JF8rss8dEgBeVTze+3tG3xzncTo6TJ/NnOj0ku0NpI0AJ+qI0aWCcpjkeisclSMCShIQuaD+VuPHWjshlgTah4lTvxGLF1yGa4EnDdABS5nECPstweA6BU1KlsrgedWO5V0ITghtgqi3m5fpvHkrQfFX5dt7KrGrFIStnKLJtVuCFY+KoFBMPr3fGUc+w53uA/EgfmMVQk1BpYCqJRMRCK1FZCL1tMjMvr2qzaZJG8Gs1Sy5CKzDZpmS0Mzpsmo7MSQ/7KtQKio2YK7W27/y9Zg5+1gIVZJFV/K1+iez3Kw2Ar0iiZp2wmzfTDIMhiLCUVOm8HeboFtUu1GTDcxfw+dm6+pV5Ej1107wjSYXQX6vHzC/WJT4Vx4cvN459qP0e2jB/RmRXfXJRuJst28rAW7+lLT/RDSMs+9KDrxBN/Siylj42fzbBXu+0iwtjVWcbJAb5OzChhlwQEJ+kMqPXR4lbykf8rZqLTpwtqZ3cWAL0azBbN8yBZlsJsEANLpwi4DiB18Z/Oek9dfSSOMcs+3JPgkLDcOTwji1/rM3lLhHM/pmI5k2Drpn39ZiUxQMGxD4wMbOZwK/8PHmJUOB25LCTmuCVncNhCEKXOlgfOKt4QN3X4OzlyCm9VAqTzWCVZGhffa/wLluwDw7WuCAsS8SBdom+w/F9a3m01O8c21Yk3yxi8l5bI0megFs73tLWo9My5VGtInso2nRdMMifs+UlF+IAGNSnP8waOLwX17bw6YGF704dxIygltGEhCPG764Uns217dB8NOTzYkbYJfsXY8B0GfJ8WJm/MsBwrAYnUKbruBdRmsMmBT21yds0DLIdlZc80kzCgn2dJd8SS0FLFbKhhRv0tPP0Xpr5UmKbvvndjYrvj0krmY2Dg1czY54hhSU9Nox6kyB+XIvxHLmQNPk86sRp0TWgs8OG5Hm7w4SlCJAmkl6I3+wEDTPidYw7SQiXD/+MMe8lDKAQm/c8izKve3UHaTlpGiA1fXr5sxF0MC81HMAjRb8bpOx3vD6PDzf9CXLryqZKd+rr1vZLFLn58n+6T3D4bYrgHVnpxw33gnlBhjH+fBZ2mk4UtpEFcqP/dP64Y74Z7O9y7BRnvXs40l/fA0HN0lhVtuoiU+ImedKicRw6Nh0nbAn472RVLPJYkhAn6c/HwvRAWMoqmBhqN7zGJofetkwKah5VvkVMH8aQtt3azLVW91heixHsKVkK5T7km+y5SgKSCeToj9yKnYrc+haFRUUqchBaeflwy1pyvwjoXHukICRJiwZSPkM5NIqbWt+lPCfpyGtL9d5v7txeZA6zbobwFNQU/Wpg6BRoIj4zJGGfvm1l3koXj6o+2ocXXY9OIIkDOsCZF6gziZn4AZVUaPzJ/nDfn3htX9ge3tVx7nnu9RBJVqsaFaPyeWjKSy+lBrya+SyBgAwmPK729EoZkQoBArHgz3paP/2+cF/Myh5ci73/qwni2ShwGJ6HctYXZdgqjqJ00MisME1h2QDkD7CVo+nr8opmCnm4fJN90IBHsX0UxeJIcwQoOXlx1dSVBb1lDaNCG/kpGO3lNbUHaOJ8xFkp8cltZcd3XliwhWE//mNljSn9K1UfFPkxK73LwSm6iaeyb9pEicgnEScHrI74dZ69hTNdG/gXv3tunQk82W/hemMqFmxw2QKqXThGL9jnqd7LPkA8gB9fjlaJw0l7UDSUyII22GeH+QPNYgFjBMXLsst0HtYYayMiW6vxHv+2dA5U+diKDaPAT8UPQl485epEYsmKMq7FC9I+Hts8YHO3UuiaKzhgjf1Lb/dMavi4zsgk848muCxqSPDRUWmoGvbBKYDoYWoOnu47MFRDPPhwcOxMij8s4L6DiLPXs6wA5ZWQaJg+96Cpqw3oIOQEMkaAnkFLFTUQ3YvCpz+R/shpEKYI0+mBwAzkDo77kb5TkDiY62spJJmqsJ2G7xvA3YeToSzBX4hkkstSH9yMOs3jkWevYaj3MdoVz8xAF1y8hFr0ya2Qe6a5HS+nw5yRPC2gTI6nWXWAiMYU/CP6YIwPVvxQnutrqxBUlb8vgrPGoEjL0wN4pTX1MWXTibdCJUppiRyAcPKnUuF4idwO5uNmAq+jc+/Z09esJ2HgqjgvwHAwtyD0DJkpt/tmY+8hgLThDGwSmphtMwISpa/nh+vNgUAx7PSQgko8vrB+xVrEEdsnkCHJ12ODFD/ZqpcDarRz+pWByh/G6kf9cMo/pqwQnwAA9L52+AL+XQKHvqciqAr3X9VQLfEVISnp0yA8sIE22NlVePv1utQj4Fz9xW+Mdr54dVj2ztcLsOuX6VPEF2XvI1PqtaLb1K+aJPxWUmDKaCvtgo6Al+RoG8NwfVbyL5xEqWBnlgVEy/EbvtYWKOf+u4cdhLoqojL5TJLks635NAVDwlNv2sISXc0FjQvBDydIwsDAynwu57IE0qRrHCETM88kTXDHhT2hu0bw+JJEVvNcw6RwSHIE2ygGvzjzD+VNBOvA8u5k4rquADJhSSs5dO7fMtYX5gTw3Ji4bbEPhyz4J5116TacCzviaEcB0U2JD8qn/7VFQuv6cHTly+2UpY34f/z+pOm2JFB4p7oUO/jOdLvLsP9qshnmwWjYrU9Bo1vqU40i3BwXrEPjS9hpHklhLYMNnAfeB3JEV8CDOBjO+fq51aRDY0tSpey5XJ7i13Um9m38AaT4adokTyNgCXLzkucKSqB/isfqtg0V7fQGF4MKFwL8MEngR3ZT3w08cq3wglMnRQRAs00aEow9FUM+O18tHmXnQVADrzjRs0QnAqZ7KfTK3q/SmFza8wjgvqsfFKD0+BRDSX9akc2/ZOhfACArUXoJ+lC11Zwpxn13U3AWANq8WnMbvJX7bqX7TYm8enYRUF5GWO2K6S/eg3OK2xKa++re6MXpciRp40AjLDnHW6bY+QcGpRk+yuffphtXnj2u1eSRBgkP4cSvAUvdImSOTLxiyfvNicDogt8NUNJjioCPdL0JFaRB/9J7gj3sLCtO6JXkurlhysQhzphdA7jHQ+PB5PtDKRBSiDp9AjHm96anvI+MDTaD+5t7WY3tQ9We0wK6BnhToCp5C6olewWaEefRoMwTyE/p82mU+plbC9hoRhwT1cabnoGSl49PI4BIjYonMCz+8NhxRTw5ecuSLdiRLAgQxmCFfeRr3EjgBT+1unOxHXY5tuN9K22UKP0eVb64ktdKxKc9WVw87buo0hOKozqajz1cO1u2tqD/DryVZl8dGV3kW8h1xKr3aqc+bbhM6TAhus/8nX4qZvQMvixSyjgUb/gsiuPbZD4Yg/QWCxb3joAdcTwQEAypLKbSu3/f74HNYlqXIiJwFMtfAXU17iiwohiTsMxMUrD87Q+dYZndjmjqGlVdbiWhIPcdJWsF51YdAWXpg83G5wwuKadoESP8qFiJUvH2qucD3fDJra9wzPaY9FOkAX0+ImUTJ0pCAQ/Ltm+Hdh7jlyYiKZAW4th8zKG9QeRNWusSK+Pk67nqfvsOGylRL2pLVoZGPlnnEqsXbZmxpL7lg4/7qCuGfo6PQbKfpcPIS5bfHbwrR8RYzFa9xD8n5SsSQ9UEaEHsnzGdm77OcJvgZgUHTAVGDN6ZHVN1DGLX95r0gyyx+PT4iquKw8BpIWZMARmS7FPw/d5SsCVVPkhwox3MYjZfDtfMxUSrPY+jFiGT+F2FTQ7gA6B5IcUtTp7YkbbdBPHwFWzMK+HmHIPJCjeq8yU98Jcw22OyLPvhfAgL4xbuQxOz3ix3+e5n/OAVVA91VbIKt/lOFKq95A6ujbTzoDLVsvMaEquYfZlfSev/uuX4JcnQPHxZrVkDNg4i0ifzk5X7fxhXmyG5CpMzIwNzEoNdYjFfmJcMrAULogebPl9ZdmTt6IwOhToVwZPQjxS6clj9nKL+VXHGJPh3QM9Gfm8ib3XpxhOczpPcoSUsLzeBNsRxbkMfltqGNP9YW0eA8JXVPTKlTyP4ksl2ulXexeYGtW/QgfoNRfhvWUH80m30jS+UYHso7URnQVdVfKT5fRZSN2dfxZb2xdNlqGaKhHJaF4ELOT/aCFIQwl37bwkbz9ZvEAZ333JagMak/MS32M4OYsGiZyk7BOoPo1sxmy0U1PtB5L9G8MSxpazp0miGqoa7rrcDc0XOiZM+asrhg2I2pNjsJqHrVeDm+SjXDpZAJbVx3Cqgu8nSkDzqKZf4HxzFwaRN4vocd7f3eM8eQMfzHPIF8/k/wAb/14Fjy/hN94d/WqzwQJlILMy1xcXzl5TY02Y0rEDwbEOG9GSrInJjS4/XZmTqTDNJ9KsknBMGpCbx2X1Ew5F+lvrDjsibxgNOe8cB5kbGtBTgtMUtTsW4D5Cw+tyF+uamowzKFPZZsxXV6JZNlTHG4B6+BDRfBMaV0vEKklScdhcozukHYZu/yiG5KGvkeH3lvSNULpmp0cmCI+kvHaxh1u53ndIyxmjmNAORYQ7C1TuuAGKXDC7K+buagnl/ZWmzOoUc+qlB9c9BdEym5G0zmYVIkdLvGphJWR92KGvPDOs6QwRXqEYv8mlQtRzVxfHNamv2r8gMuiJDx/LHQjL+mzWOywWlwWC2VQopDCPFiKKgMVn+5Pfqa7UV3YPNwY9/xBOzBTcZhwqxA1ItsE/PvAlleFnoko64vE5BAFN+RCCr9T1Wpg97cmkQgzEg2bS8EygalhJLo6rd2UjKBo/XVu2a9QF7s6s6woCHPuxnaexL1ajIL2V+h0eGYkTFliJN93BMbiLLleKPFTqriuHyHTQ84MXuFmUSV21mJu39GEGluTOtocetMC0ppSornOxXfCt1KimWkjeNw2MAqcGe2FDitRqVVvYE806CCVqTT8zy/0k+IOdtXUvxDVwBs3rkxjQhLbdq8BvHYMSqIRfsgOEFxlBODh1QvHKGTvs8Hui4FpW3qZdze/cj4n+MApi5QvkezU8jhWKdTF+fw7w0/4TPrVj23mvgzTdd48iRQpY+OqxNjZpG+ckw89/YrHh9XXXFKElRwhcpsBQS3wzfAR+cUl/RieMNK4+A72oe1fRIrXfc2an7sPUUDPzAtlYpjWYQoqBe8Y8/I6BKJ3lteJypcqFEkUZ/RI6UFQmYdRgUPFt9GI0+xMb10mHTUssVyz9z6FCGSj4fYiNa41QRRiWnLCCyji5yPl/4FkiW4qcltVDLrZuA9LtMguWgoNh2PIP+TahvuLNjVcaVP8O6zHKUjvw885aMt44bet6nu2GiAZ05/fdo2hu9Hmkq2diMQBnp1sfKa9IKsCOe+h0/VPyfaaGsGPEQnmeVtVpvYr3a1j2lZ5hzPtTI6Mutft7KncpD2nxYs1m6Tvvh7AQZ5neurrgMj+169lsYQcTXn0rePyS+MnyOyUE6GN4nFpXBl69zKiHRLPnpF/A8wVe+S52kdnM90iR5l7wUJj5gWTUgzbx9RLzTNEUcQ6ecewt76b/9VJxgPYGy0WPLlPi7UfE2ww8Z9psrBem8rPMl10+maeDg9HXXBT9R+GG2XJekBverm9JQ3JpYBAxm1egU+eE4LVGNB0aNWIi54KvZo5xUjg2WZTxvavWpdiN566xf7ehSlzufsVh1eCYUIukWf9UmMjTX0w4EVKyXsHJktvH+NQKoG8+8m81z4UUK+DBehORK3GFyEdqUuztLaJ4p1tWo9AggFNvaJObPDh//yjERCHDrX/zZsSUykApO+rhM2OslHbTJbktWEespfENnnuiRCxr7K30bjWulAQuBQOFNuSguEiKfseqBfcrqMSI5MwR9e3hBgMm50GmXSxmijoeXnu5oabHX+KxI1kEiIldU9M8MS2gAcaByhBXegXXpeaTtB252IGa/RPbOlb0Ij37FBr+m8dtNlNofWFK2KjLHtnxLFsUU9XYsm8dNA99fL7ch9mbNjSJf5NFkR+IvCrxDqwUS2LVEZ1qcBdPxH59LUsebJI3O5H+oTGwQD4EjF+Oy0Y4ZblUkX5OWLoJMRlVUETRIPaXcBvivF67VNqkn8egMrnhpq65kKT2ocABIJeRlLkL1maDREHKcIIzNq4TSVeNoU+xdeSN4GTzN3KzKg+lPF10wgjFL2lvjVY/AaKQ4R5psyl01LdfrroNXDaZSxDNIVtwJs/TAGjPoxkS6XGsRfq84X/DE1gT6IDy16vxF54vLcq3Ed+x8U0xuX6ovqCF+wjxBIEup+KUT3ZZfses4UA+wMnAoAppfGBENenHCy2hMG27KTrrRYtoXFc6sovATWUr6PqnvSZzd9z9VshEH4fB8x0RmjhKL8jmpcSCf8M1y74N2VH920zGMcJPS9sLS6nJhC35yD0h/cfvS0CRQ60P6rfh2zZdY0swMni6fWGNMsftxuFVzmj2EZEwnmzrdzuDWcT7LN8syyn+kR4uAL+EJw3CAToOSAUoiKnKMn++lnp4bucekDVoJ5yhzqNis/TIIfoY4Yi39vm6y6f5Wc6kOZdiXE0q6YpdTmbs6HrVJymqC4Z9BlLi5zlOfI3xheK7iM2I3aA8JQyZ6qbgfAqJC323+Lc/j3wErGZfIMxeH6zHavpgXlESiL9ar0c1brPoli8Nt8z6foxzQtCiI1RVIgiFDfcBgiweuebINbOrhQPRAppXbjSZIXhW0irt/4xYAoRwMnJbZwTWVVU+XhiZ8zBr38DbVRFNArEasQ5hT3D5YH28PbyRfmB7P50+hSyzGjOH1Eb7DwmvflpdwV1xTLG3TUMttaT6biI+b1sCGnC2B8Y4bDVikSWe3p4hMJwvRTDbxvi+36pa0vWB3P1j4OfXoerve6MwrqsssoKmBl+yB8tPEid9eTIdXRMNdMVh63tO5JUCrLv4Ql3320+jH0yY4nPW7PpbtJuTjPNv1EF2s4ubiZGnNhoTFEf/DurGCZX5uYDVokQnAedcQlVt3WAsw1VXiTdwN9tpnMaKoaqJC6J2LA3jD8IRuYEuQcNZWpnxSvPN/ffdJ7ONcMaegzafRnEfbZ7YfseI61Gv302OQ9SjV6S4r+UMu50ynB7uTxVHl/8ig6tmHNSAu6DTH2PG0M0HsaGi7SPy7yxYRp+hZfzj2PDhdcH/Oq2XjOvnOzGmyKTolw1k+LaNRIUupp8NqGTyZrqRU8UmPHJiyVDJeDB+vejJOcgB5vqXy2iMXiVzqN2dTFX30AEcQgK5LVcVTsalhiLnrQwUQSemT+PPyTn7ZJ/0CbhoS29FE1ekRyWLf7g5YOjC1FXxju19PrdIy9uTsNTQkh+Os37wY71o23z8yQ3VaBTBe+ldkXCu+ZHQRsERBxDzkDk1xLOSwQEPOqqNt1w9q3k+zScb57SomxGe89dUdWVm69sUZE0mUctz4LrDQ5NMC1ItxM3mbO0rOPvWNRgeWJsLKoRFVLVb8l72Gc5HyIbl6ELAgHjpJRbUrQf/+QbGxcTdZzux71iKIaexcCOlUTVLiI2Pfxb/RGyum4NCewHxIsZ0zgtwldirlFIkztPhnP5xLPBNQQuGIJPUeJNDUId91Lt3wjfKIY+9kppyiSU/nL0k+VTD3nO21IiTwa+WmujPdASLe/h13w/6CkGrZbSrVkCgu6BjXa/Z9i7YbyxRmNXpUsN//dtF3VLcaWZ/YqrroHBEFQvlttoSZ699q0JWoeV1EfqJkWglCm96jCccoJwbMZDQM5IHvm7S30Qxq4ZShme50pLzgRSvCSWNI+kNOnIrg80qr/deLVkeXBFBpbsbHQcuR0eCVdXhr+m8XyBPYLA/j/y6vjd46OT7PBEshlLVUfBwlCzr/mU155xgAMXKwm2nffoTuWgRsouZ3poZLZh9zVisXwsBGmNNKAC2/fOjH+d1zNmTlJmYAOJ6En2Ymz5QaG45uBVYieO2NxxB1kGCt6eRxE4fnC8PpE31o/r3CMMq4BdEQmgXaPKu1aXm4bo+TiyWTz9n4SqnlM2WaHHI2y0sIFhZEyyqWxqxJq1SGvrUKrokmsRakVJKnos0t/f5Q2WGLChwojDA3c7r/BwLfS5X7nJRTyVU0vasvPuZmSWFU02zoeBNDvUfiHORAaplevuHLP15PMj8POXmsSErc1z4/lRpHOv4oBb4TBRDKmitLp1guJ65Gm4xpoq2r2quj53636saJ0dL2vHyWGVQnECRpu3KBpFGAcdiIMfihQ7F3NZUnGn2ULMQy1Zbh5TGLijTDxNdzafFp8I5Sd1BxZlDFAqMf0C4Uno4wOdPQzMyFgTWeFSrXGx4TM2CeutFdkRQabn7H/JkKKgeMVLRhpJFuyVt0865pwT35HTVruAmno0e/NECv2P/SsJCnTGPxHwNvrapkWIFzuafI+T7TcW3h1kPXOXK4LjrTUWetCpKh5inYrgU4SUGhDlPx0VCVHN2O3y2v40xh1XQpOKFzYwL4WM3zj+B5lsRUAnG82Bnl37z+WpBYBYQmI+7KlbcwG4KsSl/pXkpckzWtSIx+3RDre1yArh//+d0jXxcbMs5C5vGPUwtrgUstIqFzjrAjDusmkRqdIu0h0tmAtwI9ClahGmlK5ZPZqaMATE1QfsanKTy8XZq9WFDRwVau5+4hrACtJkyOalmhWAd24Py4GWBhvovA1q8ASFDpaAZID4f/pyI0cZaipoZeZPtIi0nZ/XGQdM6HE/1tSzW1dnkwddcVJg/gK6UV4CSVi6Y+TiwtaKGxlpspwQsh+UbPhOcO4FIOSMbUdfbU1qX3WvFgUv93leH/nJ1L4bXVk5PxUi8FPR6zAyzgoAUKdYPTqwR1E+Co56ZkLK6wtjJL02OpmkOvePpSeB8dnxqcDowSpn5ylYqD+3PJ0VLkAiR/oVcQw1rKFLx2jE/z1IpSzzkHHNAtFPIRh4fvz8Gmm7Vkmv2jjlcL5+mZBLB0Sk5y0CIWen0G/lUCE/WHcX1YF8V0aBl5Az5/2wrENBW7A+j8Z6Df/t92TgTI2QdMMBFmscKKjPLxN1JVJCyDVKGtUA/wGDyQe87vvKYqk0YKCzrepKItwqd05bdlnPq2Gl3honOxEX9H4fJA15lSVFTkFW1zREhcrX2mp4jVxDFap7/zBRCugiZLM1DSKZH3kWepbNQJKcptwT6ToFf6BGvfHSXct2Pn4yPFPwsa6lGRPhGMwzb1J7qlC0QTvyA1iKM91sAd2WWHZDoEg7MKOsnUiNOo3rS/l9uyQgy1Uo6U8pThYl2fgsb8l3/16GipT1vjAYaGFoBbhBSbRGDrmJnABHV5e9dlRz7WoQCJENXUL5p0QGdxNVs91FsYeU9meozivF69n83fqOQtLG9lRQOe7k1spkyCxuf0hvlk/Sbq3PTuM9owDb3wIa/v2MnKFRuLKjviOYga/w5tl0WRZYRosCMZRwd4AhfEtqb4VBgmbU7J4kk9kNfFZ62kAj6nfOnxmLEG7IAh9J7gFKsRb3ixm+1zHSeIa1grXkWncnP6YOX/AVwYg3s+ATpKev63DKXccIQP0+9erixqKtJRaH1V5/aUioXxY61mOYPdVx8U4DSabBBMQSfk2Qu+RisIGAr1hwHsECWRmyTNqRE5k3Nk7zXh/Bd/g9J81JK+QtZET2HD0mVOAvuBoq0GXzv6OfXXD1vglnyggUMT+Ct17EsaTMstbTiGg5edmsMbeJjl0voS24Z7EjQuCwhchDHWFRA0HJfFNkVXAPFKIFphiBhnvV64FRACOT2weqXpVCg4fZoRkfkzTu6zxDfVI0jqKQoVxdT6UJz3V6XcaQe/o8JwOl3WOkWTW3k08W04UdRTdkpM0SUS85sa+W8O8rDYTX9dmgQTjAXXrVoFaqsiTwYD9OgaKShtJJyAuIemokvyNjDxqK25RDV/C3RIcj3OesuLBeq4KQ+1bWL8FjGDjxfYMDzy+Ng+3+Gn8LnU8eyhavkB8O9tNuFb/xcuHSXFovrNXKAVHs9sFjuWW3XcEizWBPYiU9UvF4jBm1iNJCT5iGZGmT7kWpT3pIScoZjg+7hVU/LNq3TtK+uDxUCfw/Iq8fowYLT+3w7ZrE51LALBpNNjdi/tqbJWq7Z5fjpP0Kfs1wfGa/rwt9Bh1gJf0+3kxWol4CwuLBcia6OZghjuWFCX36vzV2h+BL47lx5CaOvnRohLLHyMBpKHUnPR1P5gtuCXZqslGX3B85YFH/180emtltS7Odx8zz8x3UuL0yKH05VF83VQtU8G8pZCa3jm256x3uaUPgXw65esTntWOEESgKLqu7ZMz2kWA33Q2VTp2cvrsS0c/lppdQUJqJSeWv8Vi9E/H5GeZh+W0rg4dXDYz8GfXrj2MYl+dQJMFRGFQ0jG02tGulxGvU6YknaUTQJ1s+N8Kt7o5jZ+wBpDNsUYhDx5fViVT6zAk9vlE2OXxb3BNlYNM+/1JvIgAcm4wCXPvY/+FYATDEJvu/GXStEA5UPDhOWQPxtu5WxjiaqmL5y+flTFmWsTkhONN22sa9pLxxkbGUGMO6HUy6DcU5cSj6wr17EipUdiK8bWh2NpZFXvvap5PZW7FW1LjNufmR8dV2q6qDl43MCMeZY3tNrQN7WKQvYvI4THHxE3ttmiQC2zyB4dLiDk/ylE4yLC/F9NhqgUvATjfwv6j49dNEEN2OAt99fpC1mTn8RiokREdL5+mKts3a5cTc9RtRO7uTU09rEuL5Xw0fyLhKYv4x6DxqA/XmQ1DlE071noJyiaS8mUNFjQmkFLH2DjBfF3xPx8gRXooAUVoxSTbjt6FWw/RvvIlGctDu0Zg05cT8gbbO8EYfu5/2A+BIBWI+UXTrm7RJeY57IBfNzxVujq/h55g1kYkL9auQ/7ipBDICUuKPymCiwAAQwGcCeN1kXTtpRoz9uosa/kRHs8ngcVvGxQ5SiSRTxZrsSd/YZb6V0oMABwL2xSuWFIdp9t4SjpYpZoyZSIZg2ws8iJGEDk7TNO9JZ6bmGp+CBZDsx/45DGdGW8qBsrSS9FeXWIAoXNZzuiRkKqYXv+ihMNssLMsxtWD+6DnKAay0SAExbUsKVMvgUG8Is1rGnVB+4DawA3nGIMLQMwtJPjj9u7ezZJS+weE31tV0qhVWzMBmnR7sAInGweRjnvn+7Ew+al1E6WYAOAqFWVQkxKBpRJpfwpNPX5vKou8hPHIsexix40ejB5aPxTWLN89LzWKWa90sRQUVFxXBLB6MItv3hdzoWLTD4bww/9UdVe/9ZUrS2BS0FPM0yYcEqWkLvx+YbRUdl+IWFcpCJV7W/Y/ThGRNxaSGfdVBY11QYDXci5PqfsXvHmBLDsnZENYzs5NCC9zpgk739W+YQGJXMBZXfQLYANBvGAQu8UO2ieEYZy3bbM8unGnTG63FyGBnm7DSKUYZKOGwdkVKFOm23fYSXq5U3/DD67UFYyTajaL5nW0iunCzwt80hAkv2lG0bGE3bdgTx0FRrWajwTA31Fm35Fd2MUai6ABrnfsLUp9Pb2G3TFP88L5Mfzo8F2AQQqQcPgeq4HXgeOzZuFCgQEZ6iufuRlYjhPqUt12GOO8JtO6DXNWY8OwowxTk5bToTFrYe79XfcP1d8TtM3749fSCvAC1/sFXHOGNdfU5xcy+UTsUNMyMv8vq+GaFfmRe25UVfrxGrMjfFnwq03XEeoPO/v9zvwbsUhGp+EIx2r64QTmaR+h732Z4PFdZzb/t+W5YE+fGkKCKXdp2b6CpyJaFACPmQ0e5gYCSzUp9xWIxCZEb1hEA55nlCOOLs8/fBJ595TNIrcNi8F1BDtZ3R66Wv4UZDD6qPQaV/OXd0st3A1NNhPCv5TmxBCGQcNfFQSsuONjoRgkNq5H+KxvtNlB2HeExr3FlyR/vZaspT7JNfRBcVmO5PiwvrHWrPVLjfa1aY4iAMs0CBLzma7wiEDYwCCZjj1BkAE5rptGt83LuTks7nhq/xZi7d55fD1c9E/AY+V/SaVYKdTEDLPgMtJLlJ60HxRGqKt9MAqazNuJmYh1UPrs9Fdz9VCSfUH+/8J3yc5ptqVdOgcrDkji923QkNvSmXO2ACDFWxMPBQrmD92gvi7F/qk7A3qG/VZOIzMlqjx7nZ9HTp8hScYxl2EJLjHEp7e54zEe8WfTcEYB0g3JRKKuXU4aJap1VrYHp6duOhuSYJ9AR4M37YKj9y4AqkrQ7QQFeSGR1Rp7Cgc7VGsxIbbhDMFpScDnrCsNjioLUfLj8MwcoihTNtauTWJD4Wt+YO1h477qJLUJ7aj0fbgm0Qxv8kOL9F/uXMmJU+dD4f6hB5lPthmdpJ1fnMp/8MX09zOUWyU6JsyDkrWitrXwA2BTt0SbvXlPjjsjMT7YCXFQvU+2NbTQA+Ny9jHAzsk4cvGxtuYfDM4rSjL0pprR+5ImR/y/Ao4nKh0/fwEvOx8nIrdzrofoIIOTy3r66kr8KqKvq5VEO1QxQgWiiNbwGQECRU3F5Cqgje/0gUFsA0kCxURHPCS0hUJf4M06N8hGKxlu++jYsuDSqW5pPo2ED7/AO3rOPBPb1oU8z+vvdr0ybp2wIEY/vmKJa/2w3A4Hm03kfT5wXbhpJ/omd/zpJYwKzRNtvNpCP8QDh+e6jfYAGxf6yl+gwvDWj323oIMZT23UXMb0zGFKiRZXT5Tao8VeDlCxrKwUoEBaz5DvR4eDztSAWnlC87wifYpswibtjGwpZNHQN9QapDwJXCoC4wcQWv/OWRwc3SxglXt7SsYeD2Zs3/OzRDytvabwvHppmkI0VGrxgun6fKjol/MxyX4jOST1H3M1kzI6gIbOgqI0nxIv5DCyI+l3J2GDKw+pZd1sSw86eFpe4GA8vdcOCTncvl77k7MpHd0Rtb4blfiGJyw0PHQaDVV017w2U7vhM/WJHRR+CTHdnwIZD5pdQ2Y1Row09/zqIROM/phYJJZkcDTYyxOHMS7hKXP9Lge3zdCPT80trsJMLJD/ladjaPQB8A6cq+vITpFx+s9wnFGYJrM/s2QCFJKhoyoyxWtxn2e/fbViTp1uX6Tnxsf9C01qCmLr0VH07b9coeVARBeiFh2dJCCz+bwOt72o3x6vamEdeEaAFMc+lWcGmDbAdrB8ZE9/V47Nnf/iBIfcBE7ikdgfZ90x/CFwXr8sYcqjVlzMVyIchRAae6RxLAbQkuD/jkQVQ2Tg/j/KE60nO+VxrWlyy/TZg6LQphw9TtoPlqiRMQTI5eIk0MniowOYtWzplEtaksK/2kMC/K/NMITO40aFmD+G0p0laOZlEuLQI5eP8dGTESsw7dxrAaiPiXXCH2/l8BsqlwLWu0dM/DwAtW7hglApAUd6CzdzZFa/iXcqWvxI8dMnc5V7Dmt6ddu18nOR4ZQM16IiHUr8F+qAHG247p0YvXaubNXycbAzsJrYsL5dH0aNdUdQnEJB2p/ChUbxcgZD7laXKJBCqzNpsaRHnjKtehIirQvCc2sWhqsKEVHyzHmfsuLVcKtBSaugfotXJY80wBcrK4hQl123x4UY7qWt1HD7W7CmtEFLOLmyz1gc3srduxaIymNPqWjhs5EPbe1QNBLSBNkgLhtxtqsRt2pod7M8Pg2EFM5+fS6Vj9fiZIcWrsfEShcKGPUVvyQ+6Jz6GsqsC5SXA2nzaeW8hwuerGIzib+6ZZPmms9CRMcmyFQniHbjIerM0ceqBaxuEtklCIa0p4BkpQOEjZixTz3WG2Ny2qNoAFf7dszICPSfxM+bjN0uxvPjl4nkp8s0EJ9mcp7ZEvMWtY8Ki91yZZTToNb0Mi6SfYXuSzKiE/l/pc6erGIEY0z0d/ocr6ZQapIEMg2ceI/9z/8FNxuguNJKR3MDgt78CQuWb8QbZONeyqZ1rGA6mgC/XO9SHFxfYSXX8fBGH3dwJcIdruOGYN+nNidRQWtvqhYsSLD1ef4oHyA6/EvdU0jH1tYwevByl7aFPA2O1RsWHBqVDD8DPha4SaKHBhyNfq/Qgwjpw6sOaAX4JKj57PHkQHhgxqZFT1ENeFUrGgnaCVy4DM12Op0fnzvyuZXDUSDG6+aX2NiHzGe40TjegluFo9L//8BXLTvlLMO1n3rJ8XDZF18EZ5awGef0gYVNCVA/V1hz1xMDOBeGGYu3PFLw9j2W09phu7dZIR98s+0u05NsTxDWjzu4tjfdlYT1eWSSlzxgvj5XA+/fjDMFd4DcT3IPAoOjGMqamQ4DCfzZsZY/3ilmZ0C4RsSRyyiQqXK90Sml+vQz5v48ip/ethdf3ea0ASeoQnAf9STtbTGCTuEvSZI3L6EX0nvq9SoXAUU93ovbSv9fr4YM55N70i76bGpqmJ42r+U4d4GFbCiFWI85xzWvqR+wBYBtBFc8ZCg7QaGk374LIjStQMbU15F342g9CflezZI8r8OT4up1B9ZoYyYyCn4AuKf4IAmrGWdBexUWyETPwbWkiX4nUhBk+fHUoR/ymNouxeSRB2effx9NKOXJrQT1Cm5jkcQJBh6gWTJwf0NKvqMfPCZG3NoCprI69zgfkS01I2s+Y3fxJWf8QD2kja/Zr/8Jx1l9W/yTiqJ4RfIy3pm8t/XRPGcsfuiQJlJYH9WP0I86IJG1Pefen6zWc1blfioc9OnsSuKq3PcOaJZNZtLM7CcV+uJ94pjaj6pJ72ETtqN7NYitZwczaoKY7g6UaTnF6Nhfwy1DNer2OkfnXqqmy1dNXT3uzvDh5SM72BhAc8n358tJUmBtq4892fRNtput6/SgVIQn3zTXo3rakpvojnLkfJKyZvGfHJsYERYYYJ/O0E7F4gC38X8LeYSpN1zjTGYZPTorS9o2bM2YyIhtceySp0bFTvK5ZdIlsJ9e6mQttBzGvVNeS684ADxQR7LH6nF5+qe/l9Z+QECgGo8ANR7FNg3VXXl0AdiabdWpX+F93ank+aqAXRV1GCNYfeQnxV23pFdQAR/uA8sGfYdebMpbLkVb/mgdK/y/pPCzP7qGwVrt12Db8FJiOFzWRZ1uM59pProUqvr2fe68T3OVTzMbZCyTRiADtWyOm4WMSbXQalSeJr/WFiHNiWuRiEtj4RuaK0fVrb8K72Hw5HLcO5mPcNaCS0W2IqZnsfQfzGplFfqzZ6IYfy1jo5zEHqgZUOcmCetpPa/J2ywSwiQEgnMs97fIDHxZAG8Cws6wZG9VJG5QRJcOj46/Nqd+B39LTnaCRiqT7YqMM9O15xI1TlV0mXnsilyau0mHyOaX2hEZxw0N9dxxy443BO6lz1/EGCH5pW9QdFpQmvzu7fVzhiIxdcpUwdJV6dEojcbHqJtJ6pjk48s8mJty21ERaA4IlLlB/1trhPzlyytzsp/d748X0ePBunsqiP6EA4tWKsVJKg2KSHsAwqoG6YlipdJzm0gnl8e2I/IkRgUNVjRVaLDURJcp/VJWeboGkrPnCaIfFo3C272Nm34bOsBA/0QpdBAB/E/zc+VWVTXovFHmQf+GkDOSlI9hGjA6/7j4zALqjjP7zZ14SPo9nMOlIlg8WGGLUNiAErsnfIvYrBcVRf82L4EOj8SGo2EHDOrrbMjOO0lt/L7EgQNz4K0cimEykRAEKTjgXZ88yUwFvqVT7rfQRMZj5LYK9BZDfj11gkW7cVv6r3Gqj1whiAjdyvRrtKSFUgyAgBegGNikNXOWDnb9X0ju94CXFLgLe6dkDwcEbDvNbCL1uheVL7FdwRsmAeGdyLMx4vLcOSSewk2lgcrrTCqaBpIgXlXRnuqVVLmljYdn0HBprInkuqScw1ue6Bt9OP8ciWG2wmu2fNvZhWBXSL8zp1gjHcF4k3qX/MU3Qp3mCWnBwySr5UPwieXa4R7JiWlk2QS0kjKRCmaSZvdiU1N/Y7oQedOXj9V50z18zhQjALUrzpqyMTPZYcTPKA/U+SiFi4GJqq5MKijxO3Mlg61Ti0xVfYaF1Mt2J5wdLqecTUxTldXzC18bpAoYeybGFSR+ewgx/U1HeviqMHbM/93gOmZ+/NwkZcpcFzjEV7Dq99GZCd3CQkw6XsNXI6El02XIWfGgHqxcRyftLZ4oWmddQ2hCbA4/67FdQtNtpo5kKdDLDOQUQMPVLcXzFPKskHiAfMcIUz7M/tYkvXJY5tsxv4GYSWD+TefVL7vJJ6hVvJrGD+Q2mh1qRuOIV1Y80mEpy1Ymcz9y0kjPooZom9E+3sJt3YvoH+/4anqTCnOPnLwbUcz2zin+789BpcaUKI82nzfnDgQy83kD4795SvXOrZfRpJ/9kLC29NCdXkyVCp/6CYNdoWQLNXLVgTvuFH7n2iatTakEJKDfCOFMIkZGI2hUSGFiUXY0WbLjAJfemZYCIZiqhIcQIqPKOB13IQTdob68hTOl8+0uFJtOlrx6PWmcLgtey7634M8LDiTbIiblGQTGR158BjQLP78vtlOBBcxLwhxGlfG5Nv0jMCoxO9+xU+4UTwB+6AzyxQ5lJxq7O4CZ8tfNhh8CPmyXsoICXfdqW+Os1ZCuiiGFcMCK30LmI08fZpsivkWSNZnFJK0H0nqbHAZuZxGGEupfEp4Pm54aHb3ZtvboZfI1nZDjLfN2woTx4PmjHMTWmr54lrvaN8wMGm3gmFGYdgt9GIkvC7UnAfw63wNrXqmY4Q+JKzRXvakWe2sGRAcfsoAiS0V+xCl65ykHZ3IQwCKk4KeHyjszC9IUrUo308iE5NHrxr/qHwL9pdfZKeSlJMn215C0NcJ/WR1b0X7PCEHvwAxYM1ycq2O5WTNQxDSjD4V13bJk/PZcdSNw3OrJ4DaVLf20B9wZjmXf2xPPH5qTuVvKkvwIoqRuryDafahceNMUYm7RvAIQN1TQpwj20zdhmg6VrpD15pfQgFmlbmrTA/fDPsYAdcvLiXzGVoBOFnt4g7m4MAlysw7TXsgqttXZGYXd5wzvfUOtDhYubY7yskUEUFMcCpZty4h7R6mtBXdxXfOhGYtWU7C4WJEXX2xplwfxDPzBfKcnekngWQ5VF92HpmvtChTvRImvBSU/fe96fCrJ+IIrL+wfJyoVybGUoxQd8NJJjPnHUnvptE6WV7vS8NdkCXKaYb5nnDz3lieWiVBvza7X3uHQKuLlxbI6CnPId6SR0lRRfDpM9ofSSus0lPW1kW49OI8gHJfIKK7b+GvLGWJ2YX334x6n7pY5KWyPiHES0i7sAJToIVUn3HgfNk7+KVIxc9C4pKQHLyGYc+ZfHFvPD/fJXIZotrZDVOHcz2o36eeUqbC4GdCUW1gPTZ9i3TNlX9hzdzhCwfwq1B0G7vHZ3Fb7xlPpQJhclVVtd4z9pO/iKYrWLFxiG75bHf3EOagr5Vbcc3PPeomxEj+k4CQIVaXzo7s6Rz+QmhsduaDbKpLqjsVeqWxBn3DYDmciHN5plyzjtbeBtiG6xyaAKUwP2RYLeZ6YfBtgFSrBD0lvUBjgR1Kh6mxsMH8GaXKwoE/K3upP822hfEqda64QouGC+gdZsAKp+tyBi1EMBiBwuU2xwnAoM+b+ynYmFcE1YBELkZerq/UxeWrvEMhByXRzNmIeJ6o5NySLx5nJuxHfkoGrCQcFODOdZMNlwCDoH8Zbp6TLtsTIqY4YJ5A22LBakMMOb9cNpXQjUQUfGXUOaEnCjHqOQQYT1L8q+4rShvg5oaXLC/T4Vj1zBoGYOAIRP4TywZtVqY2qdj9ikj8HzMbNV4Re1TK+ZWtk0yXdeU45gjxN9PqjOupJ+yMo6obhgu25xOaD3Lm4fzPHIq6v5FO4U32ZYhZQeHGrsPCgziSy1/Pymzlg7GRV56a9x6Bw7qK8LeVgkPs84kp83aQt6gt0u9O5IYzc4xPMOd1NYmviklu/IIDy4NM+ToLGB8EF5sZ/menF/9XXchSVmNLmjFpO2skOKQY6hRoy4HIgqsH49ZchmFxexpSCaLTm1wjpIGGABpHtptRCT0c0RXqKhiIQbFJHPQ036PRnWwGPaxfYHqLKhwkFJRMrOjrLH7hx0lQF0wlRTPnHiSeoMs2hfGf5sD7BwT78kDN8rTYeRwx8yQw3mRPNJQwsWTzfqk7CnBFE/QXYLA5ce2rOfRP2F2uCNQmCQ8ld/luH7KlVYrlayrv2vRkUx/HCR4NubFJq9g1E3w9Zp2klz15ID5X7dXVqfZrlhc0ufLK0cHj28U4c+nQxhuMOVpbJWYiJb/IiqGgKXqPIL6ccQC8zfLxY/gFxUzIu3VOuLIrkGTmJecVg6KTtHAcask79NnQjfJC5NG0286gMabR/NhLYdWM1i0UT0amuJkrD9anaZ6UUvPjUWf77qS77y0jwzebuxi1JuE6zQN0g8w+c7Q5ws54nIbsGtN5+LTP/X29Bl1Zsgj2175rN0IUZ1swDFfSPEo9i3JEpGo31hPTcaIYmxfP6mxaGe3EC62MUe46Iz/2dLLoQtt/bgPEyHV3zGYvDjsmMdHQGATqAsSBqcRdg9Ca8FdhQV5tMZ6pVlerfda6v79te9VNh8yMntCG6U7iIeymfSxqk2eFfWskxZD/zuJv+SiMepUx6hZgRRvUfvLAOntcnCS6sq8+oO6eF3Z1TB5ZMJVVAEZxUwPdZtfWsz7Tl34UD88JVeCnerHykpPFuWNXVdHsWDWxpcM3k2oIIpXn+X4iRe8ZAwtJF8oVEpFAn0s++jTthiImIMylBJWasQNVbTzKFWJ98f/M0BWFT9xBwWE1dvF9UFAmRntbvWE4fkeRUR8uEYHZj2I0V21CAsvHuDVwzBHGKX9Vv3WVcsn5IFsrG5MZRiJEz/9YjL7b3/EumgGvK1N58vDWy6ex8ZVleT5tKog266gQr33XY+1jCFPruRBVarQhqhFRSLZOKyp/y9fdgAa4ZCbB9OtUCR1+m7br4bqsIhO/nILFSK6nFwi/xukWdJrcdsnjf3z94ygO8sMwXQr90xO4+3DrbUNE1KPXhhIysQ+Ovxq60l6pshDx836Xg3vT6cp4mbOEBDjepsXYiaoTseDwFJAkvalGoHjTWIs4u45MPuBejipKHaAO/aON3NLPWkKenrJ75JXw/ejBoNM+//Woz6ZDA1yqwfrU848bPjQRxan9FwnB+AJEovpi3w4ZBQEMQ8nGJ0QMCMTXHDOy5rSQKD3ryphwPeSDpey5Df/4QoDNud1GuozkmWNbioxEUTo7zhHZXGcmb/LK7/hhWE8SCOgbzBsjhHekEsedDZb7Xpg1g5io9hqyHQbzFFKU1EOnIpwbkuWcpTfnYbXKdoG34fyvGpCuUvHVhKmHfi133avk4nW1KmYs3whyeFTTOlJXTRWJ87lA/CZf4+8fYzSPyfEvNmwz7KNd2+rA08svMVC2KwElWFGMyuOOpn0LKB1FND/JtmJyFTMJw2GyKy4zB5mXag9RAOhZLjJ4ENJ+gfniMfdl1gzlhWyRKja0ECIwHemkdELNEaN+g50O038KOcDelZOpi8oXIau7ImTAlPVDUS5DHvfAzUnosKG0ikPbZIMhGMdXIXS3/kUUSMyzqbFxMQLsbOJrcjf7BFsAPz8kWyvucR7CfQ555PumKPbK/h45rWXxN3s9fk25YtrefH21JDwnLmECtkrdR34TIBpWQxKZpH3gueHf7ROAPcNatZsc8Q3dTn2zNqYOcTzdf2q1QTBqlFNqWScZV5wxVw3PAVqgYumOX3IAPGbWSm1/ahc5fLOYHUeJDO3XVt7ayVmXbEz/pPREiqgoEOEdnmr71ATIYzwHAcYyFEYjdN/kXDxRuq8sFA3QYwvBI5uZUoXh1i58SNK5Ve/wO4qtQX9Z1RUDHkl/YPW3VbtmQ8+LYmb5+XpDiMAApQdiwegFNYDEq+diGchGHFChsCQstUT4brWbyDL7SMlG1qb9YhnYHqJyoS9SKF4tasfSUUxt+WZGDUYv7DS4G2TKvuTqVaP+xjIEk/5GYq7SlEZ8+cdPI8uddivQKaDG7dZD8bz+IAGPBEcQ5P4qpRNQAC0ca2Edl5kynoZNM84ZfWBerL5Tcu7/s/SaD3Y81bk3DX6/C+HO7GQFQCTfYroGmbrLOeyoOBR9BxQ7kBwWjQLZgE0/gEGwqIFeFmHEk4lUblOI4loilvesHSF5GUmjSUd/Tt6yvJ/p4sAvhBLpKgzAJh5apCLbh3o2AQESvh1baZqw92nOpEHTqEol/o++VFN8V/o4NgSVL0MULbIB7EPBCC+Ijdv5itWOPZ6J6GbZIrNlgK0DaFJdYUh3Dpzq6VcbeNBLOcgLs/CxWZNkc2aGB7EvZpp4yU7lKGQ7r3e/RvUqhhXFWiCqzIBrab1E6wnbCfZncIjlgX44MSRl+R3lGBr3nghiZIrSyeAfmL6+zlIqTpa/koNRfwBD9dLqGJa1mW09eN/OQDZ11W6Sc9zDP4a9HPXYhawBDiXNQdD6Mla52G5VmukuKdpHaOQFyelMCN/xGbVSlTieSJNQcOKDfNYOpmUGFfr9f+FLHch1s5zXY0900eytlt1TXZ6tUVTF8E6PhdIVShldJg7ClATpVq9AOa7+7HyMraDZ2vtRAdAimE/IPmO7VGXoQZ+dEE2Rm9JWM0pKseW+zYRqyqY3b2KTLy0vOFWu2QVJRySeKa34iSQMa+vdi8Ei9SNmGt6wsQBkZU3FIgakI+3IwFytBjkZ17phi8bk9S8genfWO4fYuRv9mItLYCOdtMjLXheDYxFMZ/XjJLRBLvjdzVOXpInb3Inkn3YPA9Pz434OJGW7VeTroyjHhy7NnYg2xSsWNu/N4l/jmFzhXrLeTc8ePVB6JNLsySxXv2ziPAsTvJmBdxzTAYIZnTTlfTAI40cKw8KIhqVhwF3eZfIvjVbdHrYM13r1uG85N1BVlKpU282aQDyI7kfyVhvfWWqGGhugFweFYMPT6RAQY+fNE+RXTSKlFL35fovFoT+QT4ip7CFMVi+p8VJlZA2QpXQFwhfqVDWPvPfjO5ndNopMdLm1AdVs7r80R4aFihjPm1bGJRAVVPWSXCMlLlR2GVoYaZJghFrB8sS/OLh1vPxKqXKWpr9EDanqPROhdtK61tcAROMsqUfgEpiLzfl9A3HMHxJkcRwyDyWIfR2vVekq2np5AajJvLbKHrtHdhstd82qTlWCju0bwZXk4MowOb5PdDnLm533ZoIczUn7XTCg2ClMZBZRHsIUiayNGUUqrWUFVoo7vkr2Y2rWWtuGGuw59FtUA7acdZvIkWo5SwEKc+rtnR0C758reMEufM3qDUGdwJ58z48b83u6MrW+dmh2Q31TpvlFRYCxInB43h2Mkj6JHZdBvks+T1cNsE5pwSHRSvbWcn2oMtpKQttuFwQrerwNstCzhNjW0aY+dFbJUI1xQJ9LDoEKUyGGnNj/xyJVmM+rWOZZqPIsOzh9ZrZmSySaMLtYV2Lbgj7LiRL/VEvnKbcFFIZFjPPh2cIHDHf5zBMzPKqjPHLU2w6fkLAAF57/IiN5WerSBkdpvEyIEBpvwoXGP1vgLpATHnBjQhsOFoRpiT4xggFFTrKg5CdqRzqIPUKL+A63wZGsomyyiya33/GwUQRYI5lOycOLmyZNaewYEykV8hzkwP7Jh6AhuqWe3QW1pS4iACOnlHpT7991kPcZzDJzjIbTeXKCtCyiIpnVVqb0BDwlV1P0Xekr2nTNhGqxbsrdqd0ppe7qSizdbsS6wrZDnHHLlK60dBv/piAQoMzUWCdYzX34nYE2WD5HHEIPRXbmD+y52s6ITV/GOI2V7k7OayiEcxD9DOebe/7Ly9t3+rUSn0XiRobuROKb4brhYS1T8eyUfwcHIjmYKuzE+rHKJJg9ioN6qN1cY9gFeqdDt0WFYCSjY3n8wISmKmzy5M7kyW2fitFjzQaqNmj2NYMIoNjrKEnpfhRkVpYBvEXGQPSnBfpIheZzWQplWAssvZiiU68Y3ZA/8V4dqoFj386GtvqDJ6DD2FIvD8wv+pIZKJbTIoOknOaBD8kTPO7Yd58p/S/6+Y1j6S4Cr2wm7LRRzFALnbUu9+0fIVGQxcl0JZH0/sDikBBQ28Ik2EdG+E7Eki/+MpTRdpNl9O6XYvncJTjG4pOBuMe/25Xz2DpVidTYTqM5ABqbAnqViWTOm/fXWatRaNPCcPKBTkFgYIb9CuXTKqFmhBwuW+ZyBQpVa9xBpq3kqXC65g/mQ03D0T1gcEU6H7pNsolGudxeD3VulNdSh1+mkRgIX4Hj8Zb/JjwrgDJawC/0Eyl5Yg3ytrTqEKdJXt00yVZ6LbgV85ezNAlSrISz+Meox5URY49Isv4OKcPcXuFGXh8yKnEJApYr8BHkIBZyGCM9s6+tsWBYvOjEy9qNxnygnFRs/gu8Rkk12U2JM1ts2u+vkDiZlP7J1KCZhkcMa5NUr3FcbkE9k+hA+pjsN+60mclsE1saeXjLjluUn24ABy8VCWcgnH3PvdQtC5GlTdLl6IOGJne1iHN8LfpCT2w8+m+UcrrBvFkqx/Ss2cx3dXtPk1bfWtrxwlm8W3YGTLjfw773fMhOJoIo7t3kpBj5g2ybYxbvsAT25xjJ9XrYZkz6GZGayWUN72bJEHl6IOCD+Z3G0E1y9t35FAvcjLvbOwQ7V9xfo/TfbpE63S/4vXw0ra04hyxZeLaX4I68M9IClLmfDsX0hmN5YmO7QtejLZP7RgSVKd206h5ND/FHge4xWWP9nqvI8kDbvq41W4RZC65w3UkFjtN6QDACZELXqZ4uUaUr2TPjx7i+o7rWZiaQtPKPlv9OSuBwZkfu3ieWD+JzduqJn+USZRyB9FZx8cNyZ9/A1Ncrc9lbz89ntNKz8r7k7k3ItG9Aqb8SWE1lF+/XOWG5hVrymEvs9ObJDMwQCWNY5JN1BivWgMVjwzMq2SsiKAUjAOD4TnsKzMn6Hp5N8v1PM9I1BbHijHe4i0m7krbeTFGgX3D3JUcaOIw3Y1jVDTNGkmN1pUM5njCacOmK7nUonONN5qW8GfhV0lJqb3cytFSrdfI8fhXz0dewoVrLcnneRque/BFu9ztHvnzP4d+YIpyZZGnXnphramRR8JdW2+e/JlSy2RN0b6v6Q96whOdMV8zl7MvNj0nNhOonpCEY/xI49IX8GSXtzZriAWhrc2Lg7wkztRLUv333yNSZMvXXFEoSq3pPbcEfoxs7EF41gzcF0KJdTW2zCgPr+IT7EtCO77xnSoSIxx8UEr4ByQRSVm2hlUXXPJpgL/StnHz8CCpGfkf/BnZWp/lpvBG4ZkQxvaX13IEArc4gGcyxOg8NBH0X2GH+uPCADaMEVu6Uv2hyGyQoIErBnceEwL7ahwkq+GpTkCB4F0WzUd0Osb8Lk7lEKE8435gP4uci9spfObVitJEoF4+XiZnLupbJ2mZF4IvUAZZodBZBIxow4RJuIWozzlfU58Z4RVxX/UGxylZKdhZg+U0DEsShfZ2HZRTTcCBZigJC+ac4q5Ebooe/AwtalIUyj6U7emk/JRIR3KGEzEzh5a8Ob+BVr3WqS1oBSk2jyajrEEmGm2oiS9hgA7ETVY137XnwyDgs83izXj4Yi28rsPb45DWq5ZPPSgfCj3kh51NUu98ctkEcEnFJyAOR6D2OjiI/vGgfTMDOn/EccRWa+lHc4K1hP4KGM9ZTa4uoNwpQ8hRu3P6K2z53KqcXyJCQbreIvslFXFgrRSKR9t/aI43jc5wj+70yOfiKpcCetcp36VfwNcA7RmbMq9rLSvXYM/nQ57VKfsB9ebBjv8i0cGJalstbbs7VJtUqENY5ms9ZyMElbzXuxKD0/t5dDGNuXc0hvQdeAYj4jK9Aa/9N/mBYwgdIZafP14IkzatG0FyPuGHPNJdFODuHXCw9QhooneIkQhCcO3nOmhJ5dYB/IFmjY4Oeu825TfyQZJSBaxVu1a25eSy/iuabCh3/OwNZWhCuFjQjSvTGRdJWSHTTb4ENa9D8+CdU2wM9iyle/lyKZZ2umc4StRqQ8rrVw7XKPmjF60F7nxkmjMGhL8tTcWIx201C/CQ0phMG3RWVQ7tCied6Ge0W3IRBuYITw0zRoVIZjXqsqcZcNYGH7DgzGd17p1anjpBr/xJE6B2tw72ggBzNhQH/67mjGsukqcHIllF9epjjG62mjxug/rQ5T57uhxEGabh4/bUgYSBY0G4rxUDkKT74aazhloLX359ovWyg6LByqegt7vY1IEzm5ssdeTHZFTBmKfagQsEIRxVo3mSZoYlxcoeq46dFmt8JUXBVBz4OfBfSDrEV0gEgDJpZPPgn1eTIYGdiTghBILVnHJ3UyE3J9kUOXCBkpEUAZdRTqbHoCtNucEA7BdTaH4wY51Biw56TUhpv1ywO4GYlx4joN053u8EVRaFxVn6BXs+mYGl6glIxY80oxiVdGYBpnZbzHW6gx/dgLP3iBUJ9fMGtiu9xBwN6gDWSkv8/hyTOO77J1/k/1n2lXSbSFtMZU3XxYfZxhwi0G5jPON12GSLE4cyyRqdZz+yqH3wxC6KXn2deCh8kP/AdlOoKmuUUr5CQX8WNR7VTSUv1lFdPymltxGUudWZNZgcq4SsyEuo82UTGgEUkBGT7u6KJ5H3Z9SU8CYXwBjsJYrzDqBqFqQxGf0MmR50iDmRa+hWbw2nlzGcbgVkMtoI7lksw5mTpOuMw//dO5eRcndeXtw/FZZk960cD6NrK5EFyVS1bD3BzLPP+NuxuEn0dfS6EnElviwV0yfyieZzeHpHZXJ+PuSTifDr/nSWTSuGqCVAlKHvHwxdR9/q11Qabh8zfp3dqiSdQs3BxHz7kjbD4DaamLERq2uquU9SV2HZhtgTaIbnc+bOc2Z4wzYCJtvoQBj2im+0u/dd9ehMqiOptOYOzbkCl2taLMwoDGgz3a5dYQhSjDMBQe0y6oQYHpLLDRbori7X6/VsoCIAZAE2b3hroQQLVLJsa2SVko/Z1jUH/sgwNTZLkXgkNhE5ne1WWZbgdeEnDYn8i7qDEsgwGroc+Uj03NdGf917rCUcqkFmpf6QdmgDFF1h6JK4VNJUPZUMxqH4rrcKoj1wOV52yCeF+S8yjrbILiodoymTosQLticPMYMBqOyB7Coxf7DMD4Q7uN4qibireMAigBkUQ7hSZpOZF7G/zLTKRmvU1bSWjw5KnALN4JDVB2x+RsnLlFmm9GyJSEeEIEaeyck8D+qqSMMwzIQX2pHZfafUeCP1yehrN52ReW1XZvKRhVhimHDDVCmLQnWl7p7YAhVoyo1QDIyv+tUEk+C4vZJvyWIiztTgFBo2strzMiwblJb9EevpWzJWpUPlN3YeHZUASIiBuXV9corV19hiGmfWTAxKb2zvdWlXs+YVozEX3wAcJIHyxsbs6Px0b7roKx21JnHAfGNzMy+RP1nhcjVE79LvAxINY4h5DK62TQuKa+6rEJafGgAOwtHdEYSVfC1PZBFg11CuJ2d8QNW9IZSJZgCoqly8ddXyOyU6cCbpdwAbpOMo+RaeEsTO5gd2efhJQP5ijCBdjDr2WNNpyeo1jHzgYEdO7Dvr9Nbbv+RpkyE2PsZRNbInJA2+3+OA/gpzxcJ8Nv2fBL4zUu4HTkw8EFI34PEogWFhpABzHamF73lj1ifv+2+Z88FdTaQU9j7LYQwPzFbGENpPmHvobVmvtDFHm6x7BSdMQirusCCr08Z5Ukgrfg1YIZPgKwYp+sqoJxS2VgzoPkm/ki3n2LxuQk30LCkgb74RrUJkuDUXGQWX2f48tIorQKkPROJsYXagoK3rd5UNw0z0l1qtzUj8oS3+Q5HznIyXjVzQodk9PhMgWgaUiB2ZL7zUDG7R6QI8EQd+l6wBI0PGHqY9QykVwLy+dFueAaZ7fIDkf6j4LAU7ho8YjZke/XCYCgrSYY8RQyj21kzKUJLCkV3eKWV5wvvcBvH2d1NlskMc8YJZbyR6J0hkBqLUDlNXLd33CPXLqK8g83rqXgeRUUWf0VTWqrSEawFAHPjflrptovQSDPYfwBjhi4+rjqAuGZ9+BByonVzwiXM0tuSdXmgUG4HIGDMzhQ1ukmCL/93b7VERA5N3WVk5ii52FEpqButV00HaviBpHmiNWC/PJQFMxzmZVqVg4ccQy/Sfzj7IxyQvNA3RWqA49OmrI/726qqXo1vr1ThuaA17BaNBF2gLh0bn+eE73h5nrQnB45oCBFNC1tQJuJH3IXn94NpaiXLfi06Vy2W6gQKZ93sJUGzoXuISiVOGMFACOCXBV9WGWRqFqa3AcNtQZ67N1qrCHRDEGgGRbDjr42N0haIhH5ZmkcuGz7MzqmoFM2mom09iP5wKa20UZ4YOoXxlZRXNyTPIdXAW5RRP1ZBsHYzfjI36mf6gpxEDbtytpAzTUHqSFOs+/qDIKnQUrgQIHtd+Wu5kuR4va25Y69FB4bYnelOzwmSl/3wW1iKn49XGjVHYnnRn3xWR8jV6scCDCLx+HnU+7sGB/5jSRAAaOMzvl5JTH4TZOOTR6U1dIkyWOYN5thxUhnjezgkCl8rKOW4JeRI2p+hLef7hKyAD3prpHkok1oCHvDpHOKHePzGLoYtsnNkanZnjtaJlv/KswCuQrrCfTugXCCokZrnh003wS6gSJaXI2AgwBicm0w4hDDtACdeVB03VAiAIFbJHP7HbTy2+lEIkLuFM6fRz/kz7FaxhUn3p63p+AugE44vbtA5O7R12enTOGRZkBdLiNH+jveojk/pqBMA6y3ryJxshvLJNc7W7bZV3bSR2CZefLawfwrDw6bB6s+09CE84UC68rMUMUdHdoFj2TbIGBxzI7hbzqMIaD7N16ORwKL5uM/x+VohKc3N/H4+kVZyLkB4mrqCE5+wSM2ixqtAmgRXH4FFk0ISu7hvzq4KkGpc88R01PbeS9dtdKdjRH2I+dcNHpu1/c7fsAyJsxK49BeuwCAd/VFVTDYHH0ZLEXI0FpR7xI4JFxRuqbY31VgIWuL2aY9PNQY2nNLwWDZMGcsA+pdi0QOiRz0h5XilWIYWJzvF2Oykz4vLUSgUv5c3wyusM5Pd7swXT1joyj1mGvtZpy3HO6AaT9xPZvdWIxEvOMCj0LHcvkVohWJMPeRyAzcz/T/KJ3d+ZP6a0SvgpOsGwSGhWo2cSTOjLuJfs0Xey16Owa1Jomh1F5Z5veypZyr4zCx0c+SiHpSJv+QA6HU0m2AWNUnuBw5xu4Qf2obP6B6RKcbXzDjPTdkicNO4MyXzCVmJmVNp20otCmSGjdymlADKdODzYFmkjNAe11BiADmiUV+32R58FWfEv9qvYknDmduqECHSAW98wuITr1X+N68RK3Kd1xSpPX/PnQe/jkQCWI20cg67/pvRXcSE68vrFq7SHKt0ALdBGGzeQPNOCOEve2gD3CW4kfo/vzam1Z5sg0FQjWseCSLG3YsGhxbixVWXOBNYa/sdfH+iZiknp06T5/xE4t170bfYl658v+yVGkYFvmVLBZvBf6e+BTtcOp1rbE6/gbEvgQo1GN6hP9v5XPBtQ0vpVrk7dcNQ2nLQrIKlwagdSlRtFcw9F+DRRM4wCxAHSKWF0Pq2q5oxPRnbMonHLj7xaAxxx36d9FAFzDPfLRpQIQXH3Kf5lMJMXIF0S/cEanfRhRXSgCz64IYydghRwb8k/2bQ/byFcOWHP5mtGXOjPfGI7tGcXO56TUjSrcwmvZN4jtvrbe3xJ2xe4HH953le7hB+n0pmZbNJqipNGZpvRm2mMz7WufeBUpu/UceJc8iMX39MmDrT+FFyfUINiWwtb+gaG6el1jm+m/zlSVmzL8Z0CcFnuLYlAe3vrZWezgHk98He/GEene9RpOhiAycZtSNelnec44zP5oW6StWDb627gzVX+NxUvgRd+lpFZTzlIrx/f2me9KhCgPMsRZW1gIOAHku/iXSuqoSbZtm3n1rf0FvBuoGCuY0DBo0PnkcU99TlMPtIHSRBMjQTdzgq6PjzS7Z36riKiQU9HMO/XQHSuLvlxZGATWkn/cNd1PxwuZoNTT5Ph350dQTbAfHp8IHwUKuEUeZyHe4QGCYcsvi6EA6+yz1hId/Cw/ntftFDMlQejeSdtXjQxuNuE3jFLSaThm6QkHSQOMqX7rn9qm5WSil7pcldlMXAOk2oD99WPa0YInL4JiTQR1Ns8yeO8lrm8pgZQD6iko511I3IF3wA7y8IEpkwP9Yd5BwH34FTRDwekGwy7wtpyLW4/esx17Htto/bbbNM/xWltM47nTKtW8iRvaw7wUvPvCkVspsMr3wk41G67OqsEMYOWMsRsDgQWTtgpkAsssbopp7mOVnvj65SyLVLFuKmkqNy2ALrQ/KId8dctSp3NftpJ8RIJzhR8zdEqYAVRmyUcnqeC59kP3KHXhNX2QCrLmJwnORvDQTYw4sH35sgslIEpmXCL721RA6obWGkzQVxXaRIE0kqcnn9TQi0dXzjVtibJRBfgARAOWhFLSoYj6QWzofZ+LQkafsCDhF0IH4fIM1nuoPEJnrNoScRHUcc+c2nfeb2pImTol7BWWp9Rg5j+ZTtNyxfeZhdQ8++LIjXcsbTmrJzUM4dJiHR6AuHXQckWxtH/UVLfJ4+M3EPbUv8+EGsqKkVN2CU6wk9jZkwp0YSuZhBI6RhE7r5CKIHDA/WArOZyA3NjZp7gUJ+qZ2Ssu3irxsufxWzJEKSg6+F1YBonEQmCnTKsoWkeSIcNoz+TsZxa85QCU6UbPEYRBtHVQydQa14IWpSB4wapIcTgRrm0rXlhNZMQAabHGfpjcR1PLcUQ0KhLs+A1MR8hOOWg3ROxaypYKAlCcSiyRwYL8qbvTJQBlwmyzWJPT7gttP+EDpMoaxn15HcRJPwMVcWgQ8W1AFFley1DXbXc7oKW4TO277rbINE7+bJ42MD9deNATenQFp7UJfNvf5zJ0klOlIgEDa95YCEk3JmnU6dKZKxxxTwTI8eMyKFsV+r2X8PtINa3wHArM5sl+hl6Yw4l7Hgbt8BEG6q87Sjl9Ento08U1Sfg3p8ZXriAPdJ+IHjmJze7sdTfkKWs2LGxW001vqvU/6y97g3kPX2gaZeOmxltEjHPzTMQcRhZTY/99Dk9nAnlM6LhBVygl1sur4FSpA8z8PVJ3BXmosBVcJDn/iTd4WDpDbxjPF7AwIa/dfwX1IPGw28cf45eufkIbdZgzqgrEfIUlr5uIte6sLgRDtLwhCHOV7gMKXUfAtEnHRbL4sgBL/mqm0WLtM2kdQWDYan3Kgw3i1a8wsaOeIooMmDKY0bg4pHoNTdekn/p4h5FvCyWw6RYgFZmfjdplNJVJKU1e+prU+5s2p1vgjcz4MWCpk3m0+hjtDdKLMQgiuHyXWC1Kukg26uruDcFK2Sv41x0pqlBm4mpdVXlY/Xlz4Hqg7wFseas0wlrW5fREeawdbLrUK3W6uoLYU4EYqi/WNVm/LV+AaGywCSrqtntCvct3UaE9/YCqBrm6ynPPb2LLgco7A88IMbLnOJcHGL1e8hUpCxaGcTrWmoA3SlOcdQ3T9oUZnPy5FWe1D7+ZWgMhX4Mhj8Y3u2PLzuvLE+OoLlGsd+pyaDuk0EiYc/Hp0/3++uMnM/jHKx7NkXMMvPSE9iP2dPpO2bBOMOOpxMZwgQP3XpubK7wz3Eg4X9lpGtY0WJ8Km8xiwEanUy+yv6uORBiJlql+q2SFJSNB5mchQiqxorop8mjqgRJ3SYapNZpanGbt8jCxaMs4Y3bZXxYxg7vihnc50gnAi0/dvJyYx0liiKVOn9pn6jBjm8yA8OfpM4Un88LOtj3Hr/eBcVUxAGyG2t+mL3rjr6aXyGmbpB8R/JJ4OOwoTroCttIvUOyIedpZuYNzbZMssUqBN5KEjIlzhzD6GAlsFUaTjFtMQX0h3729VWyobVe6CP78YgMQQk9tcL9yWrd6k9HonO9qkVA0vnaJAsVV7RsFyiAw9lbugVgVpIgFH1nqOGlBmeQeKrulJ47n09Wuud3HkTrQKR6ljifLP5rys+pJGkcW04Heeq2d3jilzLJqFMJIg3sqhKzDYtO4sdr8IDqtWQGGb3fESiSkxQfXVu8L5XEdIY1NdchHMdoR+KJZSBPqtPq6K67Fx+iTPU9Avm/gp1mwS6sXtIesoMYPnxeB2VTgkZZNUHeNMnlK0uFe4RGSUvZ7MKpqZwA+lnLC+euKs9AtrrnxKWOpz8cX+fAy9ufFX4jga65q+2WHKbyHJe6MvUxhJstDMWb4VLtn8B3AywvskGqICEk2zJoGuCjMvgRH5WRNyV8RdKkZsSBMp4AbCH14aZw5tti4xFUpU8XW0VqzuaiccZscNCVszDN70Lo7X1MfLuq6+hgKAPAeZbfQ0NwEcswLrsKKRJNWQ0zNG11W5QTgfC4I1zHesJ32QSt6jGFg3c2vGAuJ2POH7t72nxElAkUiSJCk5fkvGyiAJ/P5mZ547yChly5g9sXzu6xqbtgOmNKvyiVqUABzvDKrqveq/uV/DY5DynQFb0+GCDlDwYwPFy2VAW/AAlIzg+g1NSKMIWmh2jXILvEATA6iT8PvUnuWEvXH3rZCCs79IywFmyoMNYRN9M4UbJ/MpeuYk2NYk3d/yMlA+vGJ3itkRVAAwgCFJcJM9c7ZleH2AKvbYxUlEatb592i/8bLa8z9chlKL5EJ/rdFsxDVAU9d8UW3P1Av09zne/KNERPqEgCcES5TuGLv1UTygHrqRVo8EYLLVD9IMUnX8Yk4TLSG4Gri9QYevp2biJNGXSw2N3RoTBEHznr/PUB61oVRehwy5TcVuF+YyRn+UCdI1mlxauu5Vx3Vz192zbQDdF5CFNg/RcrASUueKBTxYAPCiJ2UQ3ohvy7iNI3TVNxzm2lFJpHMwb1DQql0j2RDpe7TbuKqLb7F6FzZ7XJAyBfk23ofIj+e60zl7QaTietI8IcPf/ysFK0g8lSreXBPmUk/4dswYqMoVy5+rzZmxbexjL3MCkexI82jUyuXIlQBQa+aXN1Ig4NbiBG7Cx58YS0d2DhqQxQFHnKHxK7BZSYEeOwepeNWU+xkvVcLG511RXz4aud1LsX3aXRQLFBCCOXb4C+qKPz5SXI+5IrP1Vh94wefEYqHALjmY+l/e28T5U20G32ed22aA5Q6Px2nWvDGFM3nKCRuW72m/xSQeKIjFGtb25EAcL+Xz285+xW0Lys5nPuo1ZvkajEvbfZri97iTU8u/VYph6BM/rTMSWrdxbsV6BUyNRQjDMY2+cO6ErdO6uCMp9gShviWmRSZfrB6AanhpkKERouPSxihs8LQA2hXJwTmrR1Kzk06CpecG6wKdz2OxMExopB86S2zwX+1palziA/d1zqbEtJbfLt+EG/pScxiJaxYSpmDkbWRayxjx5vg9EX1pUJKztdbY64qW86fh4zaE+cYdUOM9lBRu3tmvvysHzn0/3QaItHuCKqrVG5tXZLmbkpUJoqmue8JjQGxJqz9RigdDMuk3J7ao8rdtK2RvqNvI2Gr5CZHEkxG6N/iUwyLvdDj/f3Jk7vJhrIWYq7p0KC1EC+jl1znzxK8IrhHxbfiJIZUgiNeafg8gwqH6RyvEhflo67zqcGQgMPoJrLEh7cwhJLGgYhuN0FUH0qPlj68cFqu8tzahwqIPBMtM1pY/o8FryysBxEc2yqqZrTohXptrPGC8Fu53XH+ggEaSS9v70atHIsCC1c6Qkl5/Iyp/XpFD0/I/TqE+tj4qIqd2j/djhEI8+vQsEvtVROtpbiTXkQZIGUMNa2Ju4buzW+LTAJnyxW7qDIoawfwim5PUJsrblaZzQEhqrHHylJQrxiSUQKkKQgufkCB85pyGfYYiUnB0VyfKxkPPmzGpb75rQuO5Zs8skDrb8YgyGc+EoaAwdvI9wRz04nDxrKuF7GZ9x8oA0A84OviCtMioSB1TjWweg+STRdInfFlyG0Wq1EbRL1i/ODhnYN5znqAM6MajlKndDwbWgog/FKuCtAhIVkSyCxp6APMzsbN9ussvV+4f4+VMsQHkODDndi1jmEkAUQP/Gbhvct4QeApjgOMTQSbXG8oFCxvVysDkIDV2rjtWXnDZrc+XHJZcgVBqsLvsYAOaEX5ggCp9vpU5gZZIl3B7ulqeEt9fg3LO4XddFBiRdezAdGmO2n0wq55D4FwKpiYpszyaoVd4DqrrOK1rdH3XkNTlbSEq8X05gApQTBpNiXOh65SLF4YcBU5izxr2nrnHhB3/a+8/3AsrMv/WnGcRDZRpETPu7b0+e2vQ5lw4TNcgd4YK0mBTA702ljnBHcAIhVqDP2UZGvIlzcAD6w5Ch+9JfnEKi3BptWG5NYSHxtpblJkgOwPE7V7fervqOWJgyQp3jXz0UNbqZGIar65rZE/yD3bGm08qu+pbY0/YL0h2VqsIF6CCSShRvYXRF46r3yUCJ+OuZBbfrDIAk89pYrGhGpCEY/iroFJnlJCcGYjFVi5xR8/0Tu4b2vBF1Rz8qkEd86cENDzkPjjyHibKm5NtsyHFCYwVLS2ResAUtwfQDAFLaVHwKJnknQEpE330e4s6CPwM/jQbIB1dojwaU6n3ebi14ACh7Mg9jycP91DAzjcIF5cvk1fK5cgApIiu5IQa0jcE4isdnZg11nW9j+Z166IGteBJ7mdwWxz6zF5QE8IBSwHb2VsFMQMiGLoPiyKC/tE2DOVib2WDUSVTy806DNcm9hWeltPACHp6EXbfZmOGiuwCtzGolhPFi93wvMCG1WDac5aW36vcCVvbv1q8d3/6552uBrUXkUsoLDK3MCgffQ4FfseZf/xWPW2Ri94zjJB4hKSydwn3luxG8KIoY9lv9+BmYIEdQaCX0TkD1e9GpyRMTAYlwMnIImLh7OLLp2FN46OhFK5XPmNhL3t9/x5O3wbdOVcsYl/YUjYKvIsQtSbcHcq/54Cg8FZC09nvVUV2ucluMue+JquM8tPvlbi66FRonWG57DfayA0WtN1axkVKRRteNUrVoZmSTawFxSvARMOfI0cvc5ykWcLZfISXq4rMu8dBTvtA6FXFm0jno/dOGy0U5HoKmpcPHq1RtfGMpl8cYT0rvedGb5UC9900QUgy/+YRfNLVnk9pNjwjYU3v6wdMDxu6KGVHZh+57G7VN3l2VHjphfUoHvjPa4e5CDSnYyzfiFrT1OPAkJ4UlyTbjImpsr0oxbZELg3gBJCaA45aMHvmBf/dYHxjcoIUtm453UjhW8KnN2KxA5rzEjA5+/qje+OF5OUsik9tjg6wdaUIDyf1NRvwdmdWbLxXpO28HB0kRbU2A0RwViq2D+FlAtXKH91i6e3N6r6ubnQRjfWnx2i30O5NQ3BBI2kGuzeJggUXdODd9ZEe9swPa5u9RCRWFbiHBRAHiBefgIkswsR2o+A8IKewx7u+sMukXP/0T/gJ0OarFK4BHLy+ORsZyBGt08eUfxJH1Cn8I7SEEbmCv94MvFTSB4tHM+csXqivi82aVQ6gpWoOqOHOedRxZPw6NY6tC1PLjrGF3ejD0bgnFlh7EhabILgZ9GQuKdbEEN4jHFrZAi0uFZo5J6beHgFcuAh+66Kc3ZJbgoWqwXHVsoSct2UH8DI3Hb1i3abnnQQBvbmn6/2xVSQJrGjRxOc3GcnXoQeC3s9twgesMDaU+m97Arn83yVyqiuVY8wkqyOBMCLjBua7M6nauIB2iOgOWS6MFFDAcp8BRnq17LfpV0yzvcwTd/fPLX1lCStk2Biy/F+dtWS1almbVKLtGuyJfZrBG4pFbxg8rLyvqOZugiM/vG9ilBAjqpstl77s3Ox7u/rGrmqdU0PNbQYDYyRq6omP057HLxJse1QqZMF8pjD9h7G0wpTKTZGmHl4bp7cBtodtXMC+z0eJ7EdkBlWXUx4n9vQrMcASQaUeVmkrMwP30h/wFFw2QCgV+76/HScSBf4n3lSjabtyRalpABd50X4GH3S+AL9TSoUt/cjBMB9+1hpBqP/59QWxdRbMNCgOaq1ABhrWx0q2rKhXP8h3Z13m8LocBOVHBLlQTtCr2W4Ez1dn3gvRXYF9V08Rrh/Y+xkVnN3LVS2f9jCIdGDqL/2e3jiJrO4mmo6kdca9V9FsSv0fap5bD9IRlHeh5l3nJmOQb4myjQGtPdTU8CJ3oLXtsKjtv3/ePZ56Hx3bsCYUO6HPHxvLQJGzJxfelx0nwUC87+aybWQzlWgK128ueMQiD7Xs1yZecxk9yTduZrgweZcTmtYk9J1WvEJ7eLu10ljZjndZWtPHLqP+kiOxbOGQ+LIXgflfn1Ud1OxqbteEkNs5w1nVMqpQKMYtyMuPFxSYN+Z8bKQeRL9bjCcryJfQG9dtyL2Yccbo12uydSYstw4HlxtqNyufVS4hokDjZXVsqqom8oKJCYMeiSvtbzc3vd/0sQGXaWFbEGCZ7r+7MX/pK5o1PkaaMufQvDeZz/gBuJEpnzyiE7DdvrzVpe7W8X+XsouuCLu5K0lrrX3DV4YUbXV4L9GoDGx4XBxENTuuDP8Vvt66K0YsoWgVlSYDbGVcL1LLpfRpOyQUufUIl6UvNM0wwGF6hOTZdZ92P3y5LUMrMXAT2NOixrHv9R0wsNw4QVEFCmUL8bxM209WL6cXLGhK4FsiSY8xvLuq/c6b8TgA4INEQmoPCQ9Kcwqc/nOtDBD7IJcKc7ieF7evLygHgzwMF2k8FfLtp1kmRBYG/GjTMZbQzVLMgSwU/doYeLBstWMDytV6wTZ8I/IzTd+ZOHQzvoLeEPSHC3hvBO+Hnlmz9KKEDt6OtHPwAKey7cmbCkkiZfPG6cNbX5xT3DVi18o/1bP8J5DHhRh5KmysntzqXnoeleZBL07O+c2ckHggQ4nu76P5NppxZPg0XATHqjKypq+bcoGD0urAYXQ2EkJVCUEdzlyYyzs/bWx59FrTD+KS4SNnRiC5U0sf0SjCeZsiOxqQyUERwoTvo911Z7HLHlnSC8FJLDGIv63k1wv7NiMJDU61pozVath6JgS5/Z6Tz8st1nmjUHnPJwvqJt5n2kCo3nocYciJ0N9bjv+gBIEJnAOJfnYORSwk7MhuwA6X54RCuEh5lzFWIrvGgNr+sPSgA7Vjt4hDSFozTDTR6t+uQ9pozxZD64yErAbNXr3U+3iUenqHhfPR0ptrqUOfuvdwN5IyG8tHXR0LEsfz0vrDrAPComI1hOk4Uc4J85eF9RXb+osJHHpglP+FbsvWPAW2vtiz6q/Dk3CnSzjLWLN16iHW+9WX+9FKZ7PfcrfKFBSYw1SUXrr81tbBP4fdJbWKlL7jNOknEbJkOC+MnUOAKrJRQPRcC6Hi/bjyi0foiYN3VkbYRimhiGABPx2hPaB8UEmZIAIUmPRPwd/dAi0+UM1M2ecge6OrOPUFSb8T+cZh1UivA+ns/0RKX1j+mVJdwLOzGSzLTppifZDUiMeuj2ilRaxRqvmIG/qvCmgSXqjplhvSVxpK1Pzb7WaS7b8IOJQvjWwD2tw7VLQnoQOd0OKSBj7qCp+m5cfLf0puA/UbN2rravedlDYVhtv3zUbAZMkEzivKzxhfjuIYJegIS8O9RBXB7I8ZX5wCWL9Qj+ptrbcv6GpjUU6JeV0QTrnXblwRJX10GYEuVLjDJ3gpExjUcUwK8kFvU6adY4nSHJyU3DIOoi6YMU0xFffX7nnEhrpEx/jiWsR+HrLM2fRaCew0RKe3Pa08eHtcGFRvMZLFnCOK1dj57tc1ayYKq3OXXXibUWd75Cl+mshAmhjUtm6O1oWbWiqciB4k0i1XLBr0S6pcFVz9GXJkxb6tw24RzypDajFKkuwGT1at8E4P1RZk6DOiqqgqHSqmAofCyWSuGkJ7voAmcFo9QUZ1q1NPcVKAySIhcRtQmb4CYxS9bH24kWFVwmD+OVxx8IEdfT1xFdFB0iWTSAfEtwMu+jDpR+oU4tHFf3LHjOOovSBFv7KDUAgNlqoKl/+dma0Oeo6D6s34D/Z/qzJ77eOsc80fD78+FTYWaN5CO01bsQM5mlS0/ZBEj7ElfIiNoDrmSofo6BV5NeZZo/D3lBzTjd5dw7eUeHqO1JdY4Ebw+r2raX7htTtezhohUOlVeBQ4x9cPoB1EwRD62xAu8v6isFAj7aKa5AE+Ly8ySN3uaa8U08OCU314hhYtlB8IY7hP8oWKlrvtS8GmeKCsCjLYLEcEOCWSC3jeINZiC22US3u8OxygtTYl+sV1fYAlDSwgbJHXcJX7fRUKjkh/zu3qYmUeTMCcCGWikdQaCmak2Jp1yX7ek4Kfqt+JcsioePmtGba0KNmCJfO19Srtt1y0iWKJy0lrBcR0f6TNhuAfWd/56WDj0fwQMdOIktqfGH626Zyy/f2ih/XazHNwSre2fwSYx9GWx+NW69RerQp9WjRgaDWjJAYXdE/38Qcj3Q8x+M/x7k5OpW5KKQJZ1e8Ri/sA+tCATmNczUJvEZwH9s6GFoKV/CHv7PSpnlxo68lEnLFae9sw+oARSckQdhmwo6vkiWoDfmjLlKVJ9VvDOcag9bcpYPl5J/2i6xEO0As2xK7KvdJTK8QOzgLHvR819pP7F3XT1V+YzOMdSRhIrgVdwLaYDXWY0g6ArfiWNnYN+Oo1/L35VhjWn/Cb3REkB8NN41crN0xQATkIrJv5LdWlmetw1PVCqHYTo3IpraZ7wNiVDoay6nwR2vRd0rlQiePFV3iaMisF0iAxqorv3mi8E0xkGqJC+zKV8XhCabRk+BsOWTgCnt7kfDco5aEBtXp5Jn2VBKaK+qH59nZTsu14UNn8MJpb+NQ6W7Xi5er8fK+yjMTBQCFX5BSiwloQatlBoGr8GGBus61xIYJAF5TOaSYSsntgtQddzYSbW6JHLhX4Kd8TuqTfSm9r7G1fvXZZgWr3WnpYCkXj6aR6JP9/gMJn5pRtG6OAqkBXkGF+V/ZfxsxaxvgPpa2R6QuVcz/O7h6z3ajCGl6kOlgLsz+TB/PykXOOacpBwAPrO5PrAjezZdTRWbfPkvO9Y1MCtryDuIzfRAFJ6Erk02V7J1OLm4QNs9U1Cq8DKWDZFuTOMvV2qhcgv6sdxB1VU9PffBXgvdWm86WEhsV/xgUOaVh/L4OwMxEXH0LIh4M99xZFBHgkx02pQNSNeykDrBKtDbjpaNt7NpMatR+7ecenbQxAgzhNi4QwESg4Dacw2Cef1yXaGzvesg1Hx656g5BlxxxMZr8XLnBwFIJ7IDZIkSA/cMxEqClmYDpU3dce3M46N6z+/1CtyhPBXbRoVivFUGsatO0Y7pzvu6VBV9Mq4hXzAAPmHvKi3D4bZD12QL35y4HiplQfzF+drM+pX6VnuJms5uPaSldcYm7/YqO/BxVwRl4ZrQTHgrJI9kx9ibB3MkH/8cuEYSRaLBdfTadTuRt0Gbu/ribAglJz1m7fUK2vRocWxKni1D1mngxvIEhhNtSvac0BELlT6lr0/XQdkrdq56nPdALS4V3MxPnnWGiBR2UhDX3Wq7TpdVgfrPU59FgDsKo7M0Zd5JqPifPaf+rwbkFDKyfntseCFk+f1NrjZH1o1GZiWsxrUk81+0/aMfFjYKnzjowddOHrcpEHQa4C0VKDlSZEHNTw1OBUEJ96SiAbcg96CkfckhWyoCM93ZbYQOKbDrx8jQ/UNDalxL635eV51FIQYAFB7PFJmLtzNJkwaOz9cB4Qq91rsDewSnBGHJcQIWw6ZVHygArQy6oFTMzsQlL4s6ql3GPQ16ZbySyR0c7kmQHrUpVO1/Tc1JmwmhL2SYbLKJxUqLZFqgumTh6k/WcaFVXKdgWn8d40sUu/r9kwXdm5JKmBx3kGZu+VbGQewz8OhKX8r26dRdndPMyFNv0562AOCXplJjbh7AprzppE9NkW1qdgxpE44xFNVTq6kYrceo9Oacrd2ALeJUHFLxJCRtnT3txkejIBXm6B4pBdyoA8Dh5NXT7MLPGS/4VGA8RVIOG2BXEO/DkZF/UPf+lLIGDq80CK7ej9DoXWgapfNaXu84xfg4DDFe9fQfpwJh2Nuxjvczx2GbqaDzkZyCgXw/8Ae5DGBHLoh9xHHJCgBdcP00WAa/yNv0MVMTMiVqc5ljEksn9gt/m5cZNJqYjBbHOMfuIJcM+Z9DyJxaEzHkrSf65TZOBK+Anzy9/V3E9lC1qX/b1R/fcqGNWYcDgAQr8YlQ8ZtSlfvvSN9267kb07tUpX5MTadiTa82jys3NKvZfJylv3jRTBBMIkU2sQEiE803vkEZ2weOZ1PDnUYhJXJ5QLySKCfxS6H0Ac6Oc/3hv4UkTqVa4cPgdHI1SlRqsDT1bfrGT7IxQ1HcAtf1EADsEk2LALzetiFGeIyFGnIZB6sOCIHnRiqVcAfuT5ITkO8ptRCx7sQtOXDJn5ujgFD98OkaLAA6Dml5oUQ9+MMTMOdRz/mTQ2f8lK7TohzAV6xZu5SV5SBqv/Skg2bLG9VRxtGbEfQeXsXo6HGdfY57ZxnhWmkplpNA/8Ll5KsU3f15pOKSrhB8wT4nZHd3HHgGdRHbhuWrZ7Nr1ixY+kzqMaw0ZHDfZoApbch1pNwCqeyg/ESWt7UMFdrNivd30aLEdZRPWDzAZEJvUKfpVUromYRXCEERktYNiT2Dt8MpYueDAKgnOcRHGZyKSd66hwBZi3KlyxoefT4OXaD5fIVAJBSXgJAjqI/tTKW53FqHiIJPi8jvK+6T33ISJIHMXTmKUSnvV7zfZmxMvf600kS5OLZ+tRPn2sSgcU06Mrg7JQiYXe/hIDOkeYI6M4dSJks+SVIvaP3SNwT35z7tCZ0VPJsD3oIRzuN3DlDJZ1fe7AIY3zsNb68++YwQoMZ7qLew9fMsWGoA5l7U9NPxLVwCrk1DaNctxPJHqLYhPtYtspwmUmAVZxjSOrv2pADKcS6RWZn29e5T+sviDOnBzyZwue/slWRlj7tqWXquWr8eifeJIFxgVOHTKwLElxx4laKRl0veDLNlhqeM/Y9T943pfRw0YEKtZkEuWs4Cwstf1yUpt1w6UzwUloBMAKyo9Las5z1qMdC4wJfj/8xMbjZymEv/LSco18Ia8+pJ+gufqhAtOGhDMYT/nKSdoINyoYksxZ+IiEk7hTbBb1SuglJC7Zv21fmyXHgq5sRr1FzdxfFO6UTAE15sKO6HokjGwUZoKVSVWfvM19mT7z/cOo5W8jp5Ct6M3ZsC9kd5uBFT4zrE1jSoRrLd6p66aFO3MOtqtaIP+Dv6EhYtlxxSYE4h3lXWg4Xr7Cn/qxiR/QoLULzSa31taCrAAaBOceua+LSmVGrJECkgfft4r+UNlrbPB8lJBb32AFM5nfwgyOjSlt0ludhKMngWMgH9CnYTZFt/SCv5BoIrWbRKQP3iy+Cw4mQxAcIahafUEVsYbapfWGyKwBd5BOxZCyJ4j4TfRMBzrsf5lDPseOuN0A4mhu2l6g3CzLbdomd4k+kNB70ciMuycAWv4UiIjmFe/xAfeAVEO1dGYQ3W57AjrcbkTd0xi4tj1M6IoWK/1O8qG4eg+Msa/VAQ58I27svaZhWP/OvRczD5ijA4xLjDLZ9d9C/wTzsVvxz8es3NUxozHVwN6DdxuLFmao78XEXQxgO4oQ0l3z8NtjkBp+Qytxbq+1XeoOhAAYA50iUxn2xpHbNrXLsFxj5uIXuiSW3h3bZKhmo+h+GWTirA5yHbFSgmto0gQsjhsJEjDQTqaJAQj+BIPLk9R61FrbLrXpE94Sn8McdHB8tnCqWkaDA9S/edMN2cUXV1JOssLD7cR2APGmWU8tYxoWQD+FJrFFgFde73OcjmlfAZAyaIMeIl81560SOY7yd7ZqbRt/IF6WONNCoH12l6epMSFA149PbmYXkqcAiqX5xh9FWG+XiF55YHb3cOGuvw3Hr+S2raZOZpuulHmP1n+XvERiJZ5fuwoZFpo/VdHtBQ83PKZ794XOTn9GxFQG9ZMNMt1/yofWqia0ughC2szms8WjhEjvOBee6dZWzUWbdZePoOMbcw6P41gmJhsfbW1V8+bBi4nAbQipGMjNMNMV7mzjUjRT5O4KY26C4VWr+MyfPsOtxf2/mSMQj0eHDV/cjIev1w1EUaYWB2EmY1bmiLFPdR/THTV+KNU7ExWAUCJbJ4+snZPZmJtazLLYZby0RLPGjFoWxQ627HoYKqO3VOzR8n74Cl6iCdauiJISSYUtsyU/b/fZk9YfEnEyHnlWXBAA7p60ouGXgWYd7VGNov2MOU9iWJcWIdUoZv/VQmA2Fm39Vx2n6GahACo3xLkd4WhpeZTn0VGzIGTyJYjPkUul0xK4WJKcu1Gdb9Gj1k0IPi35l52B9wXIKAvThard0MkHc0WqlZ2Vs3HbSVCDnvbehFstY/wUKgG8CctlcxDSl9S3T+KwM3/RQBVN/UUmFLQ3jQ4LcMzHEdUl3w4xLz9733X6aPIWgnDK1ojfXf9NTX4QBt7ctTvJJwgrBWoSFZ+9Ri0U/u2c9WnBg0ofPAe5U9usAZPla12TIgX9VJdn8y5V4BdmVRSgvdVWeDMkCMfMUrHYEzRWJvWw43vztmbl6ixKGV95ZsCvHcvlAzpsaAZ+XRdzXg2JU7yufjV80oSKB7hBlzWryxLy5Kfs/RwFcHtoOhZDSiEkYzy/l3IDyKUXE7t2+RXcaPt8OECdJM57Wd2l0yUc6DCR0EyaYEUzq/flTiMwRu+W98Er0O43dx0a+9wp1K+b0XLsvwWH/ESkTGlqomIVHnyLfVUuRPn0ZKOloZJ3hAgvkNF099a/Gbi5DJ2EUUIhHhtOvJGUlWmVvWr70xTvbD98wULwih92OO1XRhtsLm638HuXE4Ax0urXUePwd5s/QlzGc8Bl5KZQADMy3EjYpBnEA3ziE8Nx3s8q3Nq6IIukqQtTedE+7+b5T3G+P9GI+pQySxS+SIE6OKEYuIJw87cVvGMe0/a0Nu+HCpHgIgyR8/sbxUisMHLUkZKKpYHUmxxyPF53b27T/VPbKeymTEA+iDr3e+humtOIBwsL0xPVoLwFLIYiA7Yb34Wg4Z07PPamnV4/HtU1RKMXU+dZC7HUANIL8BocgoqaIZ8ijxYGZ+vdI0OU7Wtc9yTS4fA0DP0N/OVkA4Zi9Y2s34iobFhPMVAqychhGUePEX2POfwLreiclrMDIU+uzAMkHh3FLxW0MDESxEojUgNMgDxKSB/xAgCwkZL8Tk/rrEn0nVs3cAbDMp3Grx49PhPXZXuIJtUYbUWlEuNZ4VjWL6cf3sBc4vTi+j8E/cY6JqszIQG1kAiB6YrurXKQ2lwKIJCUJSd1c6EDUKraxOIYylkEpF+B7TqDejNv66DEZ9AM7ppu44fXv1DeZnnWRGbBZhBB2UmvnSlSiyAH+ttwXNSD1r10ycrWPkzvKygR8pIQVX2gO9RhSQm/xlwq1Cnx0TPEJl2lP5jpog6P6KMr5s6Dv8xzGzca0RgyALctpkRr/pQ0is2ypxIXm6prFIHaQFc8p64o8nDYY6z36H6RLS9ZvN/4+nLK/hcQgF4QQA6KCrNWc8kvgE/lCi+DnwVZKUdhW6v81RUqiEmotK1sCDT9QJEw6I3rFPlnByyzR1Jr6RSEh4sxOe42PArh5dv6PzHRA7HwbYxsS16O1COTrjIHhflmeJ0ugohKTpyFF/SUjY00AU+YJpNIDmNN+3aN2EJ2Iye8MfIz4z0YWnPSaN9/qwSI8vMvC2GxV59Nbru/zU3uAPFRwO0aYGKzGI0nskvyrLU/hPaT5HG5xj8FZfh0ILQtR2gBY5f8ERpMk0pWT6BMe1LPbdaf/tg4F76BVHKdnrv1eiQ4tn3GNBGHYezWAXzb3NeyL0oU9RbqOulPQCb1XFdttLJQZlHSWdF16ChYvEBmVkl0Q+fIAhWp62AiX61UjkhCl9OQoOyx7Q0eHWe3qRnmcoL1VWqVoDId3PjMWjC+UpDdtKYeIKhCgm7mfeFs1oBckw1SyBrmVtSBflZWUkqs+g9dlx+aJzWwHIwLVbZOrTL37jYsLQHWqnYuOguUzZmy50sb/20zOkjxEo634UzzJGaFDthmKEmxsJkWEdpD5jxW5gO7q78GqFLajn8gWAiiW9VOIPhHXwwem/Y6XN9+rkmyvcbp95UezEvQTHPVBTyeW5qhnMYGe8KFNmzl3poO3HqRN7AIcoTz/83WQ+1LpXhV5M+kqDPg2c3SuUjON7SCuDfjmpwnLvNB2uLlHJPd0fu7Lf8ueAmumN+oj0hWZ09dhkxS3BiPTW+pHCt1Dux2PSbsjSRR+3aON9CiaGlj2oCD7efSQJ/a2dJYP/EeOQd/5QWTUccMzApdaT3IffJJvgUhoRzpk865HrbChXpOM5H7mObwH1auYnOiWC55YAliMEkKpnC94HHPmS2bJcgwu0RsPd1L6UJ6rCkXIvi6JVKzU/dYFz+4+1hkLlETKnwZpf49bAxAANLA7/gQmUc1SmudSpk3QjyMrOsKnO3CxdpzKBesPQ/ijaDw7UGiBaH81iZJV6IUTyN8e9UARiRgm8GXV0y6oonyaBztrFda8/Cf18faXYx13xPC3/k6PZAgzPn/+aCyIudh/g1Cl+JoB3V2rweznZLBr5KzuYQXoJwOJjp7Db0a7hmWD1EG+PE2n1l5ipGw3UqfthDadUhUOSXK0lrYsrWUZNZ8r9jJjau9H4FnDXxsY0h47kcbRB/33Vj7Yhb/B0mSrU6f2h4FNsmBN94dr1A95hEtdHAG41xgPfJj6O/ISap0xYoO6fFfPWf8wT9AmG1mKHC6p2600jo8TLF1/x6+jbyH8r1JYnu9Mn6t+/jFpDNSAqqeYWunEbO5ICf2/Z7HfkZdSnukZnU/XsJ/Sa7LCGwiEmS0SZb6/5xBWOmkqJAe9iK1ynlcmeZO6rvHkLL9zLI2UqWqi25wmhX/Lx0apSnFJlyYwXdaitL2+oY79mCyebfwNiaitPPae00xpwIEvUNNUhROADQnsZzBxciqblz+6iXCrdS2gdlbk4X/cRVlM0rpSWHknDEFMK8hgx/nFkuQlm1hNeobhzTSwYDvniPPKK54ZFWvMlDBSTIi2AuiqnXoyLSG6oS8juD08j+EPXesv/CoUnfb+Frp8THWD2PUZnGozfCZSKoLqVMcukQLtxTIlK440cLxyA9NoPHAicR/TmLgQ1jz71qKSkJyRqIRpghH4l0gr7OKiW+UGi+Y8/VNQQfeXbclz3Kt2jOepBnxybrIh/GESPXm+psZGtMH44RGIWiVExnOFuNYKO005TrxXrSTO03teaWjh5Hwkou4upcdoYhHGapFsf10Fm0YUaiSXClg4HviDjRa00T2Q40ZZIcOrhrBvSVHHGtH6hLye9KQK0xdmTBnqdrFCm5MmkoWTexYAHaRocvaIMI0s2khF0c76j0xY02zIZiFmHGbcV8a7Dbtq2PNPlI0w7TRpkao0xlWBWsdWt/8/gOgKqiQgRLXbBJL0eFD70G6wBnj765Bskl2MLkHnbqk6CnB8WkvGjGf+QTUvFF2eeZzELrJLGEDra4iA5t4EMmvnyo80UaBqMViq3i27COXMgVLByu54DaZb/nYWr298usepJDnF997Ow0tf15N9iERsO/8qBKWZRMW1uq/aga/BsFqYkjecFs+NN3gLJWWVObl1mwxyQYoPtEGaLQY+sUmFnazS8ViUhRRyO8Z5TU6ZLFNhqx9ynhOr8tUBhx1RcLASqTY6hELFSCSDyNUfzzpOF1qY965WzI/PPYZFeHrUo/RT6upcuR6GmxtNyuUJuK1a5ZvB1EGArC4biv2G0oModNTC9XRV2s74GZD70Q2IH9FaRekoDQfqW+LNlfB5NSjP+yXdZYqLkUk2Ks3QvYm88iK6c1lvIzFYHN6WWpJNtJ4ijUmrOpyCUhT0vQ0Pp03K4LnO4Swh3tDGbZcqkvMshLB2gBQmdaWiFPM1+1vV63FOZz2s1l5/rz0NBxbx/xnpiKf8BkCDXAk0AkcXhP5Kmi5TTVyESs4hihjaflCWhFYbDm27N7qBk7QKzW8t+/7BkOym36cKtZ/kc4LHnMZWw8L1QPlksBi3H5exiX5REjNFDaOTga4Z/Ndfva1hI1nFFu1yCDQoHZhlSS4+AxFKlzz/B7IC7ryuRE8pAgjCoSqqAJaUjxhe2VJ4pVNPuFSn4aqca6Tw9IAFBZJNtokIuvc5bLhA18XKyP/7NUaaF0lgDD134PayrIfmpM35Ti4o0Stht/s7G1gIWfoNoAB2Mm22uZi3Cn8gHObjfWo4x0CVIYjWZCD5FAkoABPlboP51Noc20oYJUe8cwbLByVCE7Htkd3du2Hqh42hVra8JuzayWlxDGgMX8TJw7l2JdetDhVhM0D52gn3hWCong/RVrYj8dtz2lCVLzLWfoOpQxEiFH+rsgpnmoz+AFIXpXh22s4zliQiGtuaE2X5zFMt/drjMk+yE8PfMNuGgUrP8lgL6ZkNIcb4qYDoeyfeGGyiz9EDuKIyA3Y9fElrw41YFMgqq93wHLG4mvfKoKfUEiTHFes/ST9JEh9Df/PAlriI7NkAS6IZIAeGXkwOjI4YibS+viPfu1nxzyeYStuQnwSSkYXPGe4CV/+4Prk3RP17xkLi8Qu46BUctgUdavDqgt9visjy6Vlp7Kx88WHZZDy7kVBCay1Hrj58hsxWA8+Tp6jNasRSFPFOfV0uWHmriWg+ifKM6F2Nx/HhE+kIvkKAaCG0OVrVPNr6arl2KZQPOuDaZcbyzlT6s0p0hYs3rQEun8pscJS1eGxrhR/nkubhwwcqhK0Aw37CmLwWngkQgAQ92pm10KgJtVNjK+xY8Ups9AG72l1z0ijhpmgGBJarFiIt/sfXuhrId7dpgKiHvr267D5+fFu91mYDlB3J8ySNyaLZb3BuaBY3vjDOPuzGYq4mcOUt15yLD/hpgh7nQn3zZtgwlZMGSLtlpEKLdZvcLF4/JA7vfeOjvT7i9btA9vz9/5mY7Xvitj4poCpuay9Ho2mp7jwZ5E2MDf9QaHb/EphRDIEDfU5mSpcmfHS4Q/lqyR504FTtvr6oboomGGMAMSVPSKzT2Zrznbk/kS/+mkh2WRpJ/cg6rGxl2Xs6fK/5WiEtFbNZ/jKOnXkNJds37WJxt0be0Kz99x1JWYdAOwxwjzldKnAUYL1exna3U0lscNbv0y9/hUinWm3zkrPrGWsm+9GJ0FaK+8FXTtL9NLxyudRYvKlCmBIbZVtTSNpALwPXRjrWS7MDOIHjxYN7emcWyQtmskJNP0TCvV0LmrwKsX6XSjzSrP+X1Khw2oDC6fVoo3NOXhCFrD5Wo50kiF1daOuU1eTPbOizb8mok2COK+6i0Tvi2uFdq514BMSJajSgr/PuT4YHGdtaOAkyDhVNfNThw86JJ1l4DpNdr7Kw9CpsJ64l/+yIsy4D1sHv11XvAUIlxHAkc38YjG0uALVmUr1hMaK1+N8Hrb/CieJwTCBhuMiOTMcp57eSfvAJXJ3NL+oMNR5tlRB4iodGnleRXdajIcvjRGOXMK6GeQSbFZuVT4BE0erMuuwnlh8h1lr5wkB6fLTGzqIs3V4lrOzOiLzFgciWNLq4Tfd2rmZyO+HcHBgvj3bZfeAlydYziB+pjLUGb1gTn0rYyId8dBNeATQ/5R3/VTkcgNWhSH1bwPdaZeVTkQMiMh++02SOUAELPxn2N1o+GTufAsTnFXyMxYRuYVzicH0BRFQg9QqsfZ5T+Ugd9PldOdwAlSt4NsEx10OGf4wcIfSR/rePzkEdlSsQWO6JUDhSrL+udqFwTKDT3kHTQLmVS2Je3J0QgXV0c0m5meAaD6svCnZg+kVfPcA8Pu/NP9UVmt8MEy+Wxl9rqQTQGiVVSSvvQCp8fytrFmGt4kpr5xFbpTKvjn1UVWO6Mxc8inoPZxHoqgkBFLiAoOKVGAzgdWWTa587Xi/EYpBS21BYRiLaWnhPnKPGSeKRMHDu5TkeW39jaTQl+COe039TSlsiNRvEtTzOYtY2GqH4qYkv0SstVtV5Ty8G/Q8RSumliXMeAEXizMy+QY1OdB0IxAiBfh0H31b4Qr76eY8D4HSKS2KzmRfnLzRiqOOfxPsyt8wbnpRmv8bWgbmubKeo6HhZv/WY1Mvq1UtBc6oigUuxcZP89ke5XBXn6FQLfvCz4DiGwtYCl8AXGej+fF61gyLJEi0dfu1TDdtWB5G2w2zbUT6B8aut1Wcp0BWxGAB8xgeOh/h8lncsSeTiLwhNF6Zk3f7DEUkZQ/GH4kfaQ4zLyvLEgAYL9HxySy0zl/HQxqiH2lkXOyS2fpJ7TwLAXvEARFdTrK3qC4zQU/nWH5syDpNRTX3Tq/m9S6JMVorX7DrNt3FDf0nldpC9dW2Sz+vsjhZjTU7gqZaMLgi85/3mi+88ziqeN9HdbeOqK8SXMNQJ11YcQ8bs3FIFvivRPb7RYwGW5/+DQBMLjD+c7628Lu1RfVsT3S5MO34IsQI+PtWWJyBUuBajBEgTbnXBX8eZzWs8Xt7Xsr4e3TuXBUjQGtdyq4Ht1ZlHNOpCUhHpUoXlNnGm1M1AKPCsdb0dNUv8lF3ebXLT6eHwbrNNXAnXvisQ+T1oz7FkBPb2mn98S8jlRJeu9To0DXGv+3qg48qcmlqpYw2nzN6XDvtZnXYO2osZEib1NU6dzjp3ccXueF2/gM9yQHsi4MCgM8cpg/nqlY0aoHpzE2jF2NSrDuycRUqyraa1CrgKsOXMlcv/1ciNaQlWWSVXFVw3bL/dIBKmFeNf3G0Jfj+U00McLgzFzOihwBStKCiNAALO0PjlLOZ0WcgJfwftKR/SXsDhyaJ27fMZ9I/RO1PFT108bhJqW/zUNsMIlRAX/PCNh12zbT4Mw0tTgALB5Z/s4QL9/0GneKMSvRULfFH6bwFXcnga9W54NppVuWD4h7bimkfiaDv1ewbfqk4ii8rj8vopXWZoFcoLn+IUW9+leiv4uw1SOKjbIf6k6kYx3hePpvB0On5gMlly5+tRRiZ6VUkHOeHIhxoXl0RmVWL7PTNliYw3DjbxZ4ortuRTLR/3MYEnziuosddm7q6iQbfgWws5n0+PhtsmdOTFQOQ9/dSqAqTPDKByiDcltVP4L1+tvcLUMXREKSqs0brQTrZemo8tFZBssKfIGu+quhzNVOYsK0xv/krJPS87dFfBB1WCRn8KmcjykzwELHNbIMPJfrUblAPOm6ujNcczsjGVZk3oKNRZuqlZMZwsAKkrzSbcz9HxDChjJ5z5cYQOW6X+Y0E2l0vZdDybxt9tBOA/OAQpsfl4RjhYjwme8jXiJhSfsnjhfGO+lkhCWpuZaJG4xI9OtbIWXY29e0EBQA4SBP9mKZTZIJtMsqXccHuPS2XhuOMmlDN+WXCqdSbKo6AN1FE0O/6HKeROwy561LNL+TdPp0xQzUQqOADxhpp9EtR5J8sATPcM0iuI8XiKH0D/CFLVY4zkJoSZqsuTSj4hK7+CnePgc9c5ydyPEQDzEKup9a0FcOf6uQGWv8WeeeWrKa0WIY5FTh8RFzF9LVb4Ly8H1gpyQk8bEt/ZBmuGBTfmHyVeZc1FuVHHWJhacMYiSAJVUt/ojmDWmu91+7DJ3nyiNmQrJiFu78Rlu2EgW3QWoIr5bxiir7MfXrLJCJjFCQDnWPhNZOGubaZQYZK5fYMT6YT2IMbWGgzxthamqvKMYZKGE0+hvEi0TgL9w0ebYbGUrECQuGv5wzuZAlieaXc2AqfAnJo8dkpfOuQWLKmKjvofMZKzj6Po2WQKzCOniT3p57Mkz+IpMV+TzxnQqnikffTmFc3keZ6iS9aqQOU08w9wLUfg2/Tld94litvP1IvieEwk+X15hWugTvIe6eUinrT5+h1l+xaSSRHeKVrK2FPfyJL5mRrCJijkw+AKDxbvDfC7F1N2l1zafIIwoBq6GpCthN+wH+M81aAH9oh+1FxgEA/Nxn78O78rMlbNeKhdPpxXoibeetnssA3y0+0rRS56cm8p1MM0b7CZVj7emGZWAfkX9rCfQ/f0PeBGYvi/1dcigbuK468/yJZVvti4r4MazWnC3PGNYxnpofSD4adWnSR4jzzE7lc3yj1VOqXFN+YzuP/jpqL7B5o9KlytfQx9OrDH3oJKpWuQ7y1Zw+Lbz9ljKq2yYa/UYYKg/Qnco4ZFXcMdaaHjGpSkQ1hqKemhGvlCUO8BiT1uwr9qJ74hbRMW9LNPc6WRaKgCy/LV5S8vu79wOOAGTcHbCaB3CSGzenInDvL6og2gowbmYd+Tt03eq+ldie9FrjklgEQ7Y5UFKDJh4xd4Qf04BvKG/QbEANGLgeKxyDS9KobZCcCSkTpCkkt534b9N2GOaaFqG76PUdNm7dqJfaotfRQzVx63KbtQuUg0TDj30MElAAsOxR+nzv6z0phiBR6NJkUCAN2PYjwLAdPF0dl8pc5UChvkGhJQm/L3GFyAGscLgIkgdXWlhiXuyuCYvTQ8qCUjCv0jNtlZsHW32poSCnBh4bVwJyG9qum2rIWKiEcz5pd5Uwgj9AtB5Sq722y+5lCTychOwXal/JblscGW/7bVZDfubQKLZgirPmu+/otWC1ZeDtbylNRvHViHk7KqPNBaeLVlSQmQ2Pps1WjJVO5D43YxhL83oQc++51YBFLSw/IY6jcy5GCHGz95ru9tinVRVIPV+I/gvZW/OFk4V8Z6Px97NMLwErPaysW1VClJiuoNpg+8Uhy4JWp1jjDk4P3p4u0JCsbbAVgETqEHT2ATfhCFfi9s0QkhZ2WqNFpLFiK/ETtr6nCZnmKACN+ML8np7Z9eex006oCroZBP93N1xu8gkig5S53YXb7vu3ADCasyDwS6+Fp0asvN3L1mGPRm2PO/P/Ozvs4+8Sa2i4MuiPU2TsZiXiPR/+AgrwZ/U5EkxnMbzqiDVfJ9jflMrr5adpx/YJyMEPaekeB+k2crMkdJcySb+1fct+7YAfYbjqDbmHMRADRTUmrjPOuIWAIJXlKnN9muNJzsCPJfqEC+DcMS+Eeg1ZsMwKn7qRrvgsRaM4227c0F6Wm+2QRz0JE0JL3Y0W1nA/Dwsg8gQ+WT6yI1UplkPZ7N3AqVC/xBZHoZNYfnRG3Q279zAwLuaFzAXeSHoo3mpIeE9gdj4sqnwLHLYpehh4nn/fUxZE/25KWYRzbl78L/+oweaLOPsZ9kUAl55dKedtuyJIp9ZKeJeFiCo4Z+bqgj/qp9Wx9jWf5ODTKPLGNsW8r/AjIEyNp72uQWH3j8WdpCsQmXbQh7+u9te1sOWCZifDp1fX25MJ5bElSeHo3yeaIRwby6FZQt/xOYGspCZv0wuvwR4c3EomtbJxzeg9FuxB8GfbxlaewLX18LALeFscULlFh1HSNE56SUOfR8kPbquEopyBONto6gBmISxmw3QScAxHDCCiVW1ps09LPclFvlJpXLvCzeSbAsjpnOqH5eTKELm+EVqoDBNo9kH4UC1Arj6jTQdkaMP84knpqxk6WGE5ZJyNWBIg9ufKEpbAb0KudZmSS3XLSqT+gjiFpefYixj0A9snWnyS4/G35bC2NVYbM8ZNKP9N7aFd2cwdKAqcfFzNTLhySDm7Gx/l9nNI3guZjt2RZ6loTcbFSJnt3K9DzEY/fsKIdnIY2MSan3mARuwJ9j4vQ1+dRqgDQ0XSkOMr2xKTBdITqAqOxRBYGJljyPfMzsy47tSQ5+PYm/eU90Nc4gYI9WxXdumhhh9y4IyKXuiLPGOHgO3/xsmD5EmfpL920g0gEb/r344/odYBB0AomhomOrtSN6KaADlEdvD/A2+86XzQf0kVTUBnOlAnq4kbBVjAJFV8VQUyymz9Ia2Gfl3NgtoHCrhW8GAJTGVXW2gbWhhvTm+p45j632MaE2nHnD4kKBSulqXtS+30mc8wR8v+Qu2tazL1jvIMlAgfNQmelL9sjMQtBuvoWl/pqvk9RFVKoKeXZj0U/39YoLd6gtsikyLz2BYfk7zFGZs+BxKJ/X6p38VmyvrAQ0P6+CDiiu0NVGXzAaj6JgiwGPkPhlYTLPgYTfqMn2fg1sCtIrD55ND7SkRa9z0p5ZBWn1yC8i8ZRFW3or2SAkT/yNuZShoph5iYcGjrDnKW3JXxdrWDvLhvNrEGLWmUT0CqOvyp5rnxs9ZeIxgazTkfX88nO+94jIO3obabAbrrhoA3YC3RaR0QKfqxuuPHmKin2NRkmM5cBM14YMNuFsUL3ay3wTy/7fFzGv5mVc/OVD/VB/NMy2E0Srduypo7i8twyysr23CYHrK2FJE/JeY+uXv9vedvRSqR8FdU95Fc8XNcVV0UcRNHJJPD+8UkaA/blqWQSYKUldYAfVJBsEmXef5re2npWPitJYozTyziuW803sjCJYm5ZUpVu/82B/3bOxHxcDFOgj4Igpj4FsK0XOoXF0EjtEJU0+8qBOJLzOglWl6dvumKMO8bb7lRIsVPbGKDPJtqackAkcP9ddmyQYu2mZCH/UI/h6vKxPIpWvc1DbrxYc8Eyo++SMOJgO/mE996w1ysvxoe/hnSRc3eGCtR7ff5WT6weWKSQDXeZ5tW72Kd3DCUoYJmjsUvYiq/EMwanWA1c0KCH6UIQST9qFRD0UkN+pjzoq53r+5G/ukoRSGFQP7ScFpQrinLNO552UYnOcZMtYv7jKxx+xj0zQjw9locL2YfNih5mfNhc3H8Wa4OwTEu4oH1CdapxfJBsDrPJkwj4X05TdfmXf3zQfMoTcak/d+CgRQiXrtA552LeKXVoXK3F9Z6oiFJYKpiizQwIwI+v1etP0qtWSD5wMBvJjQdkHhasFMbM5WeboYiiSbWSjK1v8KNXygyci5LU4mQYIiiRqnKDYCSZ+T0BBBYrmtEqUAzeJN33Ut0d3w6u55vXn7RV6vZkpkEb0Bq6DBNbq6DJzXsEn5CbhK33Eqs77RZTVATzRew9mO24h/ZKh542dpxpNImqJaBDrS1jKm8CPP2HTS2g99eBNIrpk3kUjuVx0gE5j9RL1hL8QTASjR1CS9fiy6DO7F4qG1682iLaOI+wdxELAH5SPFACL84j9DcPUYD5h2FNYsUmx9XeO6QTCcsJDFuKDlVxd/RwmT+hz34Bu4OxRfzoVvAV0p6Mf/d7wX3vl+BMfpiq4YDMduqkv7UpasX4GSReIR4KAGj42AozUHPuL/LXdggheldDsgKT09nAUvFUReC5zOfJ9V9jMrZODiOQKKCkjcWljNwvDrxa+CVPYudM5j2pZgRtzDT2WuhqPGPRH4Ziu2Yy7h+Q9Akw4/PqJV6edSHgynXm86baUWZg75Tt3kP6mUh22x48Dn5k6RwH8dWAX+2Z9+Kht5SgaEEj+W7sXE4Raphw0e6p0YMa0I57eFARwJShlw8P3GO5YyXfqeRj2YPpqsCdhxwua2OCHA1V3KU/GEL7GO3vV1TnWNafBIwQkV4jOTj2e9cbA9a3Thwe9wgIQKUUxE3RZOdfpuAd0dMQV399XfwWcvBuKOTrFIPzywH/El1htMY6B3DaYhQQx7Ge4yx/Ud8u0EJaloGZRn9zTTJmJHc9wOuIjLpc9Enb1LkNnDEcyVV8X5ZR/MoZWUAMQg7gr9rgHCFaseY6oltijFL+Pa8fbTwtbN/krKmYCyXgxINJUMBgY2Dv3SI/aFMrbbhay4gY4PQwBm7k9wD0INraDG8Xg0Kjb5J/3c9SaxrzC2TgOYnWRha9GcvRWGqeUtFQqj3kPcq8caKrMk1ei8EpU77c1VYG4U3irFBgo1YICnaDJdsaoExIXQ8meXYbKG+5v7VUo2SfYV5PbQGdLrzotz8gGqk0B+Lnc2gn3WgxFr/Ss1dgXx3ZFeYrYMbm8CSvUEvib0qKSo0XR693MUONbkhwYkzQJZcXVBqAZNzl63NmSONy+8SdSnC5fs4y6ckBTrOCNAgjOVnReoyKmw1/BtmdqMCel8hdpv7UxNY+J9yz2ip/6dAzFODsRb8j3RaMnNPI8CsITqbdxJBl66+yJ5HsqrDXgb1525mXiZ0Q219/Plm7ImYaQdayQd7Rkk4WMsoUJWO64uTla9obWiEeWcP5BDwn/VWff8W1oYQLxrQvc3mCkgJFpQlhLu+FvsiwDwFJksHO+JiEhSfbhC5PGq5sB/8YDvRwATt4uyg1ug0J3p7PLLpiUpQt4TzdWNCeVD0a3Step7jo7ZeZz4wpqk4oL4lljbq+KQM0pbWO05aNrPfPVCvKfIj3OqsiMaF6eXLGmdoDUeQbODHOe9knXiwT0i+JpyCB6JXgpvUsC/DaFZqzWNQ+BGYV/Tb9LXGryLgGZ7sOgjP60f0i3HFggFt46hgUaFVX1wzSyWlAE+Aa+mjyN/d/jZUyOkMMyxN5nhrGG5I4jp3+58Pjs5Xk/8a75/PbTWbK7xeFGo/u80K+5crOdEedxO/68cxIO6nolh8zTE3gbUey8+nidI+fYfu3zhFvZakMASrn+AV6wEckb+iNHlU2BAzGfqDxIIedz90DxH3Qthezwaxvfl4Exzdbg3fs3e8ADsTmeO0Jp4CoDHuk9BQYmCA3mNpA4nyXZMTxEgXtZFNTToShcHWmziNngFktyxaN7KofMSljbWLfaF0Zt0RZU8zWJmgPX9VX2vmNQlrD5jXnCAT18xaCIp/YkISiSQxMmWwNWXvLtvWLHwCInXN4ua4dH03Jtc8UlV3Q7LQClJhZ452EzCbJfm1Qkp5Ga9bEJB5EBGZI5E+nXIXmj+v4QnSxuQNDVVhVi4dqCc0dWk9x0+uk2d+GmWqUaibzissMinr4KVYT7PXAeyoGFog8H8eHPaz5PDEoXIfFSfbH+ZO9f56J+PaPHDC7tTLxrskbLQnNP4R41zxoqGTl5bV7m6QZWIqO4t0+DfMMAXQJ8StQV0CVdG3CVwrOWjP63QMYLmNH0KbGRPa1elKv4fuNVnXyT4UCgRpC+0ikDB6vqMc7iEA0ANNpEYCKvGeSyxiuuqJ4+ploiWUc1tUl4R2mNZRm+bv9SpTD7XnRc3WrfdrL5Is+9gC6RueVagGwwyhR5nWOruoV0TvhuAnXOaTGxp73cUxJ1i/QQ0IsEvAN57+4xrsrPX8IE3OcBAuWNfpNJ5S1WvemNFPlgW1IUkPcjgUpnXh6O+itRc4XYDY6aI8HUS40I54UdruiQEJxg40lF/G5bDyrVZ9JHm8wmkSWFq1V/vdCtH/ESrifcCc0bD92uIh2QopDS0pCOnuvQ2X3tYeSGrUaOjD65J6UTcm6xM1x9oDK4cJzzhp+E3MRiEP8J9AU9fDpSFQibAO0B0Vr9rMcFpXvxNdVItEZy5i0xM7W+jzqVpBNBdwt5SIfPW08U57+RtiuVF59lSsKJwr5Xs7L9wCJo6gzbAQgE7DFD93WBGZsvNE9fjAtwukPzsg6d+x7DGTqS2x2DiNHwY+XFsV1pBvX23G9FMH1xkaQe72g0IHGEfaixse2DjfgUxoednUJGDbGrfCoJN6QWiE6ATjXVTcGyCKoIlhJdVfiGu65uOVPuyxs8nLilQ+0E2oxApo45/FeObNhhx7hKTEinFaaVoPoSfa4+iovNwxZowrm4RqEIY0P1s8tThtRFZz+CbxPkMiBwO1GINf2NLUHkxyEO3yuHEfP5hO4kRJdGcuq/+mieykhTKO+3rlxnOyrfzcBEyad5pI4HDvQBHd5JRZ/IxjV0KRnwEvA+ueZMVISFpLbFBPqZMM5pyM50KrGhiPEtwwZ8FJN7Zf1RCZkicXmqsrgEcdIKUz9ejlZc3Ne0U6RYDImTCwSqKEDhx1WsxWN900zu6CXjRN76fFVLEUfydqcYW/Boru5UElZVrAfmSxG3voe+Um8T0ou1ReMOcEBL48vwo6u+K1Sb9U1HpbObgtDN0OjyOxrUvwW5Rn2lD57czp0gmRB0r0gl93AvcxbmUZP/MF0CipMmX9sc2zKg8jVR4BiMN5XfYF5fWvTstOtlcLivlgpcX6X7/5DGZdvacAdyzlXe3KD/g1abMO7cc+43TgevfZJHYh3Bfccq3L1QzIDXcx7VbI6wn0s+szd9hRpSdm6U9Uz0HGOARcinvXwatLdeDXzuSTKBOq1ZUOrZhgik2QE8ux2MKHuSVG8VI6AY7gBn0xGCmhddZgFWSEGZxBGQKE2R1fg6P59Jt9fvr5dzeY2Bsw4cZ2bqD4jdShb7tjVf1DQCvccfT97ZJDBa+Uhm1SrXbvOKlRUzVSeDCRZxjI5vWPBhKWbzjOi9MApslZBh2i/sWWkw6krVbeyxIg+gW4WQxb2GuTvw22foq3wQzKzSZCPLSzFGjxRarcce7P05RCNChJufes/+NNYfZS0p7XnzF+gb04H035g7cha8ULKwd4UDllq+6vZIwryvzMPZaGdzaYm2hIjLMQG0Gom567+KnWmtFZBx87O7/sBkE1Ee92jmkbOcOEdaFxdzRgLgDfQ6NNJkBMf1Dzu3DVO3L1jSrioH0Pxjwksz/l1ikSEH8yMwE2NlyGLKH3n8PmZqp+f5vyITfem7FH+8PJddyr8zSNL4/NY+l4TI/hf+gj3mPoTDUZP/dBGifromc1mZAdffQa4RzSC61B8sSHja4jrEF7fnUcxor2MF8habQE5aKL3Djj07fwDeLqBCqRs8J5G9ImYFaIH5wFnFWR0SiWkWKR3nGEc9gPWBGeCc9sjto64UUBq6fuJ5dHXQja4Hc98LpqMiWmG6SjhlXknub/Src/nD0ytVKZS/oBCRP4ifwzyiMxHvRqBdmQs7wlpDU4xFNvMbU/gbIn02UTlsizI/GmVUh1gLNcWMO8vmZxA8s5ApVl3eNGZmE+P0MhKUBK8646V7RJq6OlYhTPr4ODxm7SQjRWbz1QucBkaN+cvaAgY7L1vP4LhRr7aVhWpNmn4LpXZ0pzBnowtq8JT2CUHPvzlZza+kzWkCLqXFyJ5KmWWrlfKF6Vi5kRYQCtYl+ui50yM6nk7Y+kebD7RfzGUq5XyXJeaGfUqf0xPPQ/QbHcOF7YsAiiZQ4MhT7QRHyB7Xv3fMorrVG0ZrnFhdoxmyoDV4d3tsdpLt647oZYayUasQXM4GdXejaOBsklif19dOBzx+Myb/YR5OpqUGRyoeGSL0dJs5yu3J5ZLO84XqUEIpZJELVNWcZZBkhhmIv16yMZJqApc311RGOViHGfKWGkVJFgfdCg/7xZWPNBsTzC/taV7/td6iGuZvDcRD/Ua1VKlrr42NeLXuKDjcIPrk2Xi6PAw9hozSiM2HswgyhoxGbatpJOCrLelaKCAnyZW+jwWVReinf3kX//J36aWb1ng3SKx/GmjI54DWdxy1qR0De7B0B4Sw6XmbHIja+JSJK69WoH34Gg3qwXvdkQnLksFBCzkqRhRb7JGE15oBFMuR0wjuDb4Tw7YS2+oyhl9vRxsozVHGXwqLL0DHr0G/UFKHhBG2ZHvhVaWuFHhagvv+OHnyoXNgkREzfhVAa/EU2o2Q5QRRXbDpjRk8Lu5jJ3M7kPHQtBXXrkHr1nWP1aOxr5OdcpwBBnNzdJavFtnfTWk9519aNQi74xpcRyc+fBDbzEN2IvnVUm/gBvgkbcdIInizaPRHoTdPXncb8Y0k09F8aOULw/sEsSLHgk4mo9K562PlyursARTLH+bYiHloNaW15rYLVgBWI14T7fEmy+3sjG493AW76dTPj3XeMZvlW3MO6VEUvd/c28kKHN9N/y7fJnhwB6yj/8CoKxGpcH6wpwzRDHFzB4OO+ewwnVlcm4U8if8QAHn6u+zc4FiVGVuNDGMBRrMJDYmT0crpQb7IDhi+0NTptK8eeSSTGVmK4YaL7w4nb2hn2GJlvo7oPN7yP1tLFvfkOznVQ0zgn7KuAOxeO2xFMAW+p7DUJ6niSjR4DYShi0Oupa2EzhS7bKlg5pBauQfzbU/U2pHv7hvc+G9xr0fk75UOlpfHh+TRAn7KIIyPvv1euLN1PVZMNybYembTMiH8u6zDQDHu7+HFzqS0DzRXTOTOZc9Ezqet4XqUZUnya5ALRRIodxDXl5k2N6zT650UX/vweA7gw0/TO0sfx/EbNAUv/riy4X7J+OmR50AKzNrsTXEFmzLJHWWPpYlstjUffsVuKKvDI/+vHwL4TxoGh9zXGm+QfJxPwzHJre+n63sLa+4km6DbZqurBy9E0Q2cQ/yJd6Mi4aP8M2kR0/bMGgarUBdKZrw1QNaSjJzRXy21So1RtmJBDv4UPfjo0m+gmufCFAQjfDBri66G+XL2+Zud4kL1sL13HoLUk1fjdYI/irIEI+yIi2qX4ygShofxeaESBj4KTq1nmkZHIokXoeKeUKPnPjxMqxjGkJCtMMBiuNEjDsNoKz4ouvpb6qtdo77F1aXBApMNGOLNDqcnkYam9dAPtkc8rcvZEGwOCsjTL9kPNP4W/kqQJMGeKmQ4dQexVcPo6Qxxu+fdX053LJ76iftaXMmqS80PTOfmEmCSN3SLhnXO/P57kByigJp28VlM4AFvxE9HMcARDjJBKFHczoYdzfhWBRpYs1RQW4KcmoWpFsLSZIKr02QQDmiQrzQp3OyYJlB13gxCP17VC6lBQo0Wa/AOIgCXQshnortvGCEJT/qvKk1gU5jYxqUQjKKOjHEQOrA6dkAV6sQ7ZVjj0ly7bnUy6DjmJ/W0uxDbMPOHHNq/e/TNAWV5y4ndxA7AUpNFsZHush2GI3WR1a0mtPoMbmX/TsYHEDPzLKjUXSHXArEobD4MFStRTMWp6+jTfOw2lgSfGaAO6jueHArbQaVd8pPhGONi37oUutmfyMw9Qkpf8VhqRR/ra8Ee5Z0vJfjO95sUCgg7hqK/1mc1uhhYGA6usgrEAztRv7UlfiZCY7JtyV3n21nub2MO7i53ecxZiY89mMeh3rooIvzdUIhctUOEifZjkk18Q7tvRstqKs7lck5kAjcbH7aL58cwE5B/9H2LHfRQuyg88dZhdENN/jw9dPKUFJsnxO8uIwh4eyu0GmG5usvWEgQRmWBrHTP8EvLYLNYVT+XKOHO/SzEDCw2QXNeUadv9YjLwpzrZ9qdfZJKrroTDLLHn8e80o5w1TGjG+0gvxpIygHDMGsOHYhMfa9pwLWA5WiLJnK31Z9xjotTMg2MHE47jACzoNOugNjHLFkVEvcnfQl1WToyFdQBQaKJIajEkgOHwO60xDtHRiteCA46S7h5RZsvNeQwIizJXtht8757rU1QxUN87uH4oDbYAwq62V2JRj23c5hjHDR3yIcmzPLgXrUT7cXLkLUjH7xfv0in7aWy5YB+xsIAqjhtZLi1wzTCywdNAfrbpp2h9W7y6UU+M09YAVMG2rFzcyYODOHOOrX7LGArUcmgYHbSdDxEC03KEarBjJK00iJLWHBW6PdErzAh89KXZrdYV2AN8nf0LKlrNBmOBJGRcM2ZyAGK+xxC65gjo6ZLUfbzuehVlj3ENgjeED2z0lwRdD+btR3npROTdWWgVSsf5XX9mRI8IQgrBiqz9O3YAoTRRsU0kI9YH9CVVVjONsHjo96OkmiTQLnfybjPHzykV+trHWWUWdzr0djiCSo0lxpk0CwIhvLcfwuupzCuEq4AEpTtRi2XqVhh6TMZm6axTfxKO2BNUyva/U+j7/k6IgdVNDQAsm+hPuP0Yy073H9ZsCVG0fvtMDLlXF0qerWIzEHKYWbGVanzPyR3XV5D/OIOu+DX+ZbMRess+FYIvWUva0zs80u2STp1ygtekv5/JaxF5uhQZseZ/naWgd5g7jjj5Mgy9oh9SLPbROWUZjL0qvFqNurZO7k/NYxA374ayTvb8xvYgkbWX5Ell7bTl1JUni7aNh8FctltlG/JqSazRQthq0kuVGuTE2SdQPBk5Fvz0sTNTds20p2Bv4EHK6Z4aZm2Ji26eJMxkDiTVE/kGcbRXVT7O+ZlZ59WXudeGSX3MjvPwZU7pNvGxn5drQSobjQfEYsw1glNzNJdVpi00IM1usoIAcSfb/thx2qXsAMrxRTRVi2SmiJM1+Fo8jdBRSdgUsIvnil+c5woxYoMqtBiS1mjXDn4D9je//dZ+3Ol/+ms6QYuu0KSLCq8BwfiCJGuX8TCSSYbMA2HEobDHs3AZispOcIg1FrNs/zRAyZ8LjJpA8QkxbJdk6CWJYU24NDUqbDaD2lAvK9ab3gjP+oGbzoHevYl4FAf4leg3+9DPBYK3OOJgecHv3w5SRr9OwuYKaMNM/TKLFPxrX6I7A7CLWiEbAhhfGDgATEuxqRIrnk/JtBp490WOH7nnqXl1Xuw97RDnvyx6fR1XmKhLDciTmfW7XaqdZim7BCNgqXmM0iYdliMeycu8cDhXfw4iglK/cL7tzu1wTbAHzqGbTB8EFDJ5whN1WtI0l2D8q+Q96rROLjDv611mxAXCRU/aHNNS6Wp744QziATtdISl8MDcdoCkMq74OpBFGX+myx09etKvQ5/WtrcUJCpP1zWObUvhmn/HDbcQsMA5uQEpzdFgq8Nhi5koixiDP2/8cbL2bBjqirz0tQoVoVBLpAb9wjcWIXKWhPMQWzQoyhiza8S4dpCWQux2ULC0SgdqTcvYKVTDd4G73Y4yNfwPr8xxRTNoFEFCXeXTthkcc5OdyCiqQPMjazQdIxRFRf3a1fOmc18FvbzU9afVujgEU0srOVwjg5APgXFgkQNLjigXLmdZR7mmk3/5gnrNk/NlRJKTX7wx6cXVauGQLBNfGL0csdDt0ACacCc6fSueTDJo9XbsO+wYC61BYBnPyWr41o23Y3KNmiD1ap2rA9pYqKHDZ6v6PtXTabngN7Q7dLDGas57WLPxeOjnZsdGS12tWE1r2oiW3F7Z3SeBejOOIzBZVnc8C1PXUJDo4xaJqOO3aS4tOumqrB3xc2QRDJdtJS2PhK5vZuEDyWPtdNSN2AfNlY5BfNDcBsDh9JZQn6+MeSqAr76eEkE45aofGVhwpp+DtQ78kE/tLkEFBGp47yQ0nTaShNlnoziqD/4pQmp6vBfuhiAs2rfo7N0A1Zyi2ZuMOh+Ja8URxGTJj0adSRV/RHewJplOPFNdWBQ5xg6GWYX5rBrUa4NUW3NbOq/dS1La9L99XbBrnn5tZTvsBhvOXoIJuFJvFjBTl7u6wA6Vy/5/Kq+XhBRKXXL+mj5uTUA7EG7zo3BnFbtot22YNtnF9a8UTcE/FvRCLjvoWXYpBnCHprJj1oTGswL0HGjB7CmM+Br/MQFHQ3T+U5isspqury6O9WFYH4A3acSSBoVhom/pURD9HrpEMLuegWzUXvlp2Veolp5jJJEX1BLVABZTM28ylWSMG6fbyhlAzyFFeXLz+WPMh9E1iQjVZqWFBxxQIaOu2P+OMV+mwQVQlpUPKhY3TYH0QyJuvcjR/mmze8E83OfAD6rdXGrcAWShjcQ1/QO3igyFso6LhAkltZ+tH7LMiuN3XME75cDDEAJzdR7XA5aKOdI694UiHWTFd6SuuLXJ4H55iwbGX0G175G94IfHKzrMqJQ//WL2Ihr0ZJBAgeXYAJ7nK75IuxUhvzE9WWs5SSTr25nUE6GYhI8szosKpdlLWZ2CMgEZgb69jsfMZzHaT0Mgtl3bfzW3g5nGBgxiVyUzTK118voJdhSBxJ2tzNLTWFf1i0lfk7AKx13mjHaJPGwOP/DsKNobJyQyWHzHJ0fsUiSu8/mbiMpWexVnix0Udq9d4/sw4LorX11jKiye29yG2plO+CimrAJEXNfPEEVS45ldubyBd4+Ztgx8SeANaLhqBRAeexH6t0oxj7A4f/QgTlO68xhzQfryUV8HOyUXAvnbQLbNPf53V+tSbDD1lsaDe0UQ5CaSqWMfGlAF3D87GyotPWlTshH8I4qodFRG/Mtqa37doy93FUS9zEU0uHUysJhuPLzsVrD7HTBGq44/SOdzwSOPqnH809OadTU9oof3Re6RNNoK+m5BiEMgfzGkgzTcQZwaVUJxOzJWTUxMKHEZ+dSPFAUyCf8BIlXVY154AGPGBAGmdEEPvc3XYpVicYMLGR+VkzvhG36H1WyFtFug1fbpHYI/DPRkLF72mxb35ri1p4lGCUOrrobNsTD65ATcOeNq4T8ps2uL+6ENVD0X5RzeYTepHBLCzsNeTRM/RnxfzDyAlBoS8pNhIQc3xQ0IrnzFYTviUMK4Nv0iqcITVYypHcd9I5KoM2dXw3OfFD/oTh3lSzFWRwufiRZIdaTU/6kmYtwDcm/kB+E7j0r/glWgAklce/GTQpds+wvVxcw/TprWOjaaANhYIazVkjBAH5m2TDFX4xLOjmsV2twlBIEj3ZGf4WVIl8o/7Muxybi3naMIyPt1QUezfybfPhEj9RdmNGCmNhrW82Hi6ME448B8fKl+J60Fp3dUT6a0LfFiBeB83Mrn6Wzo8MmRXfq2Dlrhd/OnJ59bSrNYdW9f0L+TKO7NchB8kE5Ix1XD1lQexnyRA5sTuSWxtqEKgfCQVKir4aGE7Q7n1NxajatnYRMVJNwI2B3qNY9Q1Y5R2l5LQgWUuPmtgMVYBSJibEuEu1CRrVeD1VjMf2tfPVScQg2j0qnMZAdkfm4iJCfkq8wpOHfNFmM45gf+8GqKkVQlx2RT/k0pZEDzq9+gXxwOHN2/50QQ7Ti5KVDdhLmCcFzfUOZ6hfXkweOGqldOfmSZdOHE1+KYvBOFcsekJf91Wb3MqTiflCJjedqxvHtOJvf/od0p1S7F055bBwTQ+7M516cIS9uHZGTIX9QPJ2OTKttXRiQy/cuYW7MMId7rtsObUuUtvXQT40JIYufyVjeVU11rlhrbfqO06XaEELwVLekaLBM0Umynw4O3stMr/Zi5niPM6npkeDErymIl0uIoOUYllGf9nUnGGBPymBLRC4ve1aKJ+5K5M0ox1RRnnPfxtNgqStSTDDXBd1eHB/gBcI2ZHp6NPeoOXU3pErkaOKb1aNHWcD1D/XU0YhSJPHyLMHRqhUEZ8VwkDcCCjx+fQTdQSYOfC/dqJhtDC7pwTezKlFdi8XT9utzR442Z169Z0NKXtX5/RXdDCnRNVMVVvAqh8tSE3d4rv09qagxC9nBi2sSo75JiOEGeBjahiYxAvwMSn8sAveG3SBIf4hE8YpA4znXcsEIEcW/PeJoauBD+1Bu6d4VNAPWyxXvY0EVGo6P0zptfshhbW98E38lAjmYdYtfxuaImHBaUa1cINsVyEzOvGZXgKPCD3QSGJSND1bvn5TUdJPDQXnJ42Yy3Ipb1hfB9UZvETxpj8pMqYwsSF7A4qXHOWkQd9qzYMYnehAa8bPg1RD0eAdpovWlPV2CGPp+9AAtswHlMvpPhbp4KC0OErcbFhbSLo85azlQYWYwl0GdrG8hRhOugp/fEIXyipq5xAEvTYDvlZPbq5r4BUJ6eiB6KKa9YNDyQ2LdM0+p75ha70ql9RNSvUL2e5XP877DdR/OkEAofutuH/3kd5m6nXT23+lChTNtODtZALMg34hjnmglxpjb8dZsi7ZLm87eJCysMUFHezZ/oKkGCyipAgGGskQL5v69YVaSPxIWXTePO4ye63g4wT1eeUrIbstitszpabEs4DzQTLHmml4ZinIuq/eWfLrSToWOadeHr0ivVexyQCT261L9DMAPo99ZjJuz1uruAmixvKsg1Q+Er3FIlj9R4cnloI+MddX3aUE5bBESrE07p0maGKumxyZeD+E87MabLpmEFPwiOVqCVnia6PpASZTzCg7H+K//J6NSGIL85bRMEkegCNJfNyaWT6co7+1RYq+eh9IphkgbUlliKq7joPt+lRxO9HeLYpJ3Agw23lKLKX4LK/JFC9n/1ENy7UZ+VK4zj3iadZRWPzmk4Fi1t7LIfEdXF4s46hBEL6U9ymAinS7BGf3pN6wfWsglJ75sSOAb502loNqSU4oquYNligGbntgdyTxexoHBq8ilXCxknrp8WSyrFxb/GHqmjDOwLc7MvLmUW/pEKAMx8e6+BVfotjnrQr8WHPT9si52cQlvTOwXR8Vd4imID6OI0Gd0gJKcS3sKW3egrcYcV9PomZbG/5D3Dq7AZLKf0ZebVINZGOExYJV+jFX1kUj+viKH0jHB27+x9Z6dhm2HU3rTxSKnrfKsV+NEYVXsR9LkHm8v9AkV0/PW34wb67mTACmFfpCg6gnTmglyqDsMMMxgljIn/eaXIF2hckwNCL+v5pdPF7eDxxPRs8DkqX8lJ2pdZ6/O6xPaboO1GQ8xxLfD+CP+vfDqM7kIcYkBKWOqGTjxEp73x+hO17LTkGqTfUn905w6qx1/gyU3BqRKlTADVWMxfBNfDJ2FSi+2tqpvMfVJSXfN2hSQzvYgfkyVbmXIa4Wp30T7m1xSV35Vs0eoJ2FXY7dSd3H/i5actOeC+zVZoGG/p32miZY6DL2ykZko7vl+KJuglL+kwFZPRsDcjlIFOFXOFPRubFDRkw8C5yJzdeQ8W5C3ET3zxS9cuj3svOtgfeH1JpV1QMGN0W0PiAtj6Zujtcq4fRNCQDNvaKBWnJk679zNWYC6j7yZjxKXI+f5KZxH6NamzJ0FxkoRPfStAV5eX3fm7xPyVqoteP2egdBiFqPhdbmcpWWlt3Soue+ezbxCu80K35degNRWeKvn7Oqov1QRuv9y8/awoQy5RqxevdiiSBB+gBKXRVwOamlQO1fBgnB9JSHq+tMUtdNHGKPRtxgjfJxoiBTg1hOkMIAhpAXptPfn5W0ASJl2XfcCwKMYZUc5Cu5+NapASMOR7IUlSwmseGX5UKsbL3SPCK6hfYeq0FAS+Y4gdrnp9C8lT6FrMcQW+xypxgA+7zj2Uj5/ekDu49DXoVF7xIK7e6SE7+rDZxGhpZtsrpSQP3YBhquIJ1lBgvORyYsLI2M2L8vvFs94L1oL3zRkKI68RbxVLP44Rr+MMEQcyYHp2KEAEn7HWbWv8GFTraC2IcBWMHHsJImDZjdOXW0n4z6Nq8Za7vfglIoeeqreJi9uDIdVRDYtlpk29C5SV7rv6chw3OmWojxrUtAs5k13RcTxZc44Nqlyj3ChOnDpLT99oAgxAkmLk73OsMB1memcS27oCcQGs2JQvHAqFvd9jWn7Dn6O3uGMVHfiojVZO4jAI2qLrBfpw0zBPCvFgFTtwTJ+Xpy+ncLKO9r/7/sFA2nSujMs3HhVlwB6FCx7c4qVr4Isdt7eqQcEHxgvaHY8tqM5M4TyIAS8sjD1MbiYZ5gB33kh97xJrXMdhEiTuiYKPkOzKMGh+eFoWk/a3KGDKE/EThIrRZi+I5hvD+c354JUPvyOB6Dhaqjj3noQY56zliwvWYRpLbic1OmIzI8StcCtZSTBJWhpRgHfF0jj+7itGTIHtiAmP6eGAONsLQpNU+np4kDndqn0cTxKp0T8a2WI9qEHk5AolZGP+eNJ0kJtlJ1eejdanErFLNiL9hCcJtIEITZAsKHtl53ZRql8NVvJAizduzTCEKs0yIAIToldAM2p0JkxJs4I9of3WhLijIR28xCRlYrya/enBuTpS5ijrgbrngG0aj/2OKdxrOQn8hWGhkVZFyyItwJ2WMLUcNlex8od+hKAyUGiRMuzPnuvXqEDZzCYS8UMw/YhP+ybbplGTF0tc4Q/CuOTZaFV9c2m90K0eBI10NnAMHGkURuMyQpsNl9G0ztplQYgPSb5G/sh7zQyEocxhxMGSujb6TPdKNXjvjkn5OsIq5VwzXhfi7/FwiCZCtpRv74pzkTVUhD/eeSm/Dbtp8fQdheP9EJ5eq1qbUNBaqscqUJoGXFu6z7Lu1+kXLKkS8+B55O5ERZBy38u1mlRXNuf0LuvVVFF1qcEYB+lYnwmR1goI91Z3lx3/SYxuVoKBs9e9Qsdprwc/02xV3OZ/Brk13ViFY/n5fCV2H/AF/uj0Nz1mNvzMBGgfBXUST635bXoj/FDnrdxLeI14hMdrcx1536tqsb8MY1w1C2zzVfYn+O6M32NcB4b+/5kRFgVbcgTqFD1z+ptTh8TyOi+4CwZY0ydLCuG/JXwTjmwqtOnF3CnRjw5Bok6NMoI8RBlKQKkq3obq9Olv/fJrZWL7xUwMxbnLs23OnjJtpGtJEyNnux3hHlEMttStFpIRPlRChwtkgQFBfjTIogcG0o/utMpRIf9TWknagicO0WD2tB6cVIRfOSmXUeTe4g3UfQQYA2cHy5CvILw0SM89bowP10tBs3bP1eF5CIE6tGL/AGOnE1Ju4sppTVU87jR55i+yRugnEnI28vXpjcLBYKzUDhz41asRxztbhKe4EiDR241r/JEpvKAwifCiA5v6WN5TI+oxXOkwLdZTJdxLw4GjCpJjypw4WQYuE6OMgqbtPcE0tDIXwJ8yXA8zY3EA6y+yYVSwA+rAAf3ZYC+5grn56rzp3YJydgogxpcuMVMESaxAth9MRrcUS5TiigbCYkNWifWmrw8QemVsEeqeSfCw8s+/oK+K4sHry2HDPPx+QQwLH+peTsS3EKo6/WLoA102h0OhjBf0Z5IruNtOlNeu2IFuSW4ISGynZYe0baM+l0g+3VCfYfOdv5RtO7bmD2B24WT7bwTl4wGvKMJvolg4rs9srFQE8wOHHcUxYryWzqSAbA39RShI7m4LmkQ4R+NtX3jzBbdinNEfTX4HTKgOo6WqqWAieQt0DjSO2365HuuNLYYPncnIw+rbBj2YHvIr1y4t+xAZGJQfeKT9C3MrvP0djeDUbhQi88HFA6dcNqzOzAE2jLVGxhjUfJfxCw3FubU/wxvosm8UcTZmSU6VuwFFoPueOEbGVdCgunpzmL/hRkR35mp40OoAAN4emFUVRyHl1FVdo3ULriZa+RRSWyPW++ibBcq8FxHwwMlm1KRSFBTsSQVpb5ih4MdVyCrZ+ZyhylAnCqSLGha8wWDPNWLmhstivk2zssHWOiX8THB8eYZL+cvUEaXHeWc46n/rgX4eBUCo7GoxCiaXd5OFsC3BggO8qUJf1/2eWHFCFb/CYGfKvuPMOFSBhdF3DZNvRmqs7TcGPPjs2I79IQPFkjVnyf3SInoUxpTeGP5ApetVj49Y831CbE5pOtrMtbn3t7Kz9N03QqYyquiXhK1QPv6SfNiu0pgayOsZOLlZSOH4WQMYJoUJ/Q+yUo7DyhOUpIfEpRKh3nZ7xas441zQekKY5AjC9/1z6HgI1oUAvRzZxtC4omUye+AbsL5m4tWpQ9y9IUIquSz2Y3cf46pPVpvW9R2pf2reqvFCsHMNlWpReWmSVf1FLiGYl/VYpDUQtma0K5K6nI4iA8me4Y2fUWTLLS0RYw9VWafN+SK+PNCSDPflg/pO5IOJ625gEj9bmFjOuMe5SwDXycCukNyU41qZcEknMI8WjbM9+6scXdHh1oP9u+EAa9oFXegg3kJHUu+e1GOJa+LATlWsItFj1GjXkL8T3SVjU+etAiR/rQz89rxTeNiiqE4PsDbZlnGun26bq9xaSg+Fp4BWj5HOODpt6oWYNm7LbIVN0dSuLfZJ0JXF88bRCnlA5Fb8aZNj7eu1/OuAgC6e1oUH4SKI1AV5fqURCZJtZlTZ3dt8f2vcIoPtLxInRDFhYezfIRSMOC9RVZs48GyXZIBpjonHU5EczIaAhxcnmE3Yq9GwHXe+neWFHjqyyvZpcEfBXQbGE3+PeQcrSoFRrY5ClIw8dhfw8m4C8DF5olFQTBWq6exxmyXuFBu/MsGEsU6ENtfJyU7PMMPZSr+Otl7NTWqCsGnHs8Ha0sXfYl1yUSu7sndSZWFcrIjq0BORLW2o9AKiO6S1HFJc9ncPylzVGVPV3DgSHyys4VWgLpQRepL3wFuI8HXVjVSApf5RjCVSHFIATKnb8ypzUXK8njtW1y/wcuWd1TvzYXWbVROlXvRKhf81qxWw0T2ojLNagR+fPjYi8ZPQ7kkWUs1/+iy+sXCRzB79+pIzwpc5w8am0kB9k3VanIXmC1iPdVtMH+GeXXfEPNd6xaJT0aQwo5XBp4d1WXQxifGRplECq9p3gz/TkrWMsU5fZSiDDZYxbw75k1UWLqd4zesHTNnqwcQ+ucAqfhu5/fgnPIIp5O0j/RgqQEsK7CEO1sURzb0dOAXqXqvNGHTwSBI/bO4xQi/d2iOBnvucaKWCXNJszEtC5v0clwHat1Xwd5D3L4zbyF2ozN3tcOJ8uKWxZBkmo559Sg5URmSvVj9pm8BILdW3ctVhOZzlGw/H+H2yhD8w0dM1vlX4BfQnnygRoOk/RjEGuKg6JBZ6g9xBBQ26kYU4roCWGqgj/C3GmthKWDBgd3qiZYzvBLVqTqr6bO8PF2pU0MYHy0B7gPjTTSKm4aQAkRtexfMRe/TkiIPwz+t3TjMZ6y+udQepoGWg2m6zv1/WPPaqa6hirtkQ5CUwyksBQMpQZY9S4vQsqTAiirjj7prICkW4LRDE2b9j9EoBcnHEkcF9p3pds4uiaahqS7xN93vhNj9TF4rHN8cHJ5y1gA5aGV0RQiih1WIzEvcnQTEEmSE/lD6BhcIDIMzjqKPn1tSDeVjuTaL3szh8/C3L/1PWMTQ8h8CiC+X/TZeurkcMPsPRNfCllXjnBYX1aArOyycLs9Bt2K9L75VOH1P6ywZj0a58jr3LjjLJ9GdXd8zv7NDp6NMEUhPc6Z+hmnROOYI6SWCWYc8hDDrF3S1VAwvQfOcosshJ092LiToQPSLFEDkj2IJGU7MdtAi9HqeKe9VXZvcRqfG8tbu4u2lwc1QLZRIfAjGeK1RglvWjIhHv05ITCM9rFzU/g3otmEkIlC3I0RYYZ33jGH34OpjDTCa3Xp2Jhj4TaAfC3SXywdIPLoRZplVHIAztxE2qyP2Z4Tc599iPE4C8/h+5vgIAt2nDvaowGWiGzsV2fGtQxJpY26x3Kv/13TF2IrkU5/zA4VUz3ine9WjHrfU/tt6JBbBATKArgV4NKEBBgRiVjxvfQmKOj9jwMCXV7nbiluPKRLyMBALdB29AHXhcveI8GQ5w2ZNfFV/VYC3g74J7zDt3SDe2rDUtLZ/W5qFqyoMeTvXrqTc/JedWA17DGHaxLYhnwxC1VHJgLCDvRus6kH504Sv65lN86AQtxRbeCvWBGFs3CACb9+k5CecqfFWqSbFqZYSBP5geJVeYAOThryTh0A1mAy8GzkfAckcVqs+SwoM08uq6JyktKa/KRVWJCui2mpuTu9MTNOjg1wa0yYmvOxqy6v8kz6dTYgyra8/gcNOuLZLcxy9UefhZukHpLvDRD7Ho41hDdFJ5ar3GSPNOYT2MjuoXGWec+WYrFNNPzRcB5WFy6hNpXqZrlDBTxJ7ApCf9bfzZJxTliNGMafroq3glPXPcHtvEw7w18/qyIDKxelGKkKFec2TNN4zbDG6xg8n5FNGWDT8fmFWx0f6NARb4WXueUFGfIL7Hm8TrPVSBFStGCuxED0BMgzUYZ6ItUaTs/+wKVnOrZuzDUl8fudHt9EgYda8CSOO2gjPPZ+jqPmHzYgyvsy63oFwFRHxfkQzUcBCPfkRc/Xx3pQ69FyXkjWher4DOQ8ANeX0LMVdTbSCtSohNS733fAsEI1UMwhQRJGJW+rwTCBm1rqOdFYm+xAowGBgZQu4PboGsVrUpa9LS2tdERt0V0Zo3SZTxXS3oGOs1di4UUvM9ofyrPE7UVI7uyAJUq8RvsVr8gq9FoN1ehfJ/l9G1iOvs2ofeyCjmfp04F5Qw0MXTsIVq7VrDUmVF6ofaLeGH4sc8uS6nhp4SfSP1zRfTzYpHHvlo7YxzcuT0KYqLD3IIbxtbNpXt/06Y3k7Eu3xmOADyFan9dEKNuLKRWNFFlmm0MLDRIdAo587SAdNErEpzFeUFPpVw9ImTn35Vdaeu+eVdgY8ixG9xuMDAyeCH/koeo1t5R8Gw1LBfq1aaDbp2zES2QVVVcdAb1TvmFpbzhBnnJsE4ZJ5abM/zfM/+RWe4wbhlRhVJByLCe1Q1PwphDSNYSFKd3n9Ae6//KSpz1oAW3f7cYKz5ATqqS8HAMa34AdIEQXjSMrIB2wm0qX6+XeZlFzPTjhpoVtSYwweRjxjn1GP1qH7cj2Bf9HhQEhEH7aTnIqsLlYLfUraex3iJAg3uroFcZiYDHxV2gOjXkiKFXDMc3hG7XN9zkSw+AeFLPVlj5BzZbpQ80qaFA2mFeJdth5d2g64TMWzg1Ysvud6/Fepb5o0D8iycODryk8U88lz3G+yYT5EQCtiPNG6TzVh8xs+T9uGp94qTbuXAUu1vpd0r/saGu5td9nqO898irX8EQUFn8G/tUuXCaqJoWsCq5ICUtfwChBTkZrUuf4HiPEa+L8B9x4eIPsCz84eKGS9cgtTOlzfF1GiP9fJlt3ftVjIeQV1YxGzKry6PmWUftJFO+ZM9lVpQV8vvDZoK2J1tYFBVWF8kuSCkN6mxfeynCDhoWkYGPAYZtrBDshi5H2XWBJ2kGjRsfNlzw2NJV6vm4hERrHB7NgWD1Nvp4aVvtMQFSU7OyYVHVJqc4spz2DlGFZBQnaNkuo2tlnJ2DirbqSZSZIkZYfKgc1Swvwsz9FR/giQt2M6/TvGwJ0tYwp4chZ7SVGhnPcIBZsZNl4ytch7fS72WJ9e05CvrLlprVlWpp0H81/X0iyKM2O/GIZ/TjGqKjD5Yo8GiqhCDmcIrgW1RrGH/XdqvZVkUqLmHGVGKig5/Yhs18HWKNwmsPeC0NQ23ah7+R4wHrxkyFu+slQ1jGhoPKViZssVPdnOxbZ9Cbl2kX7is4+e/gcGLk6fllsAGfvYxxCF1Tjb7MGrXDZxLwq/z1UdjM2VEVEc0iV4ctiCuymAaa1mK0h1w+ULXQr8a/2RD/GTZWttTVKcgDyVPhQGgaO7uuHzj3vHwhrkXNOiJGD+jNtcod8vkA7Sth+Tow4zwcBHw2ksTZ6x9s7Qxchmo6dmH/ZycQaMB/9CUQ+AFtH6jq6ZpNigHJNLvCiEL5h4/sJp8C65rt7cTTODn6oXiHIvO1+QGmIjbB5YyzsNXQ9LezEsO7b4sZgw0GKtwKHrwGXZ4xtnA+vKZZA6KsWd7uuNbY/rMXByH+AVyPkTGYO+guguZnalKmhTZ/Xu9xbGQr0SNtmWvGLTndKtKNzc9T16HQhJgbg6adXXq4djVIHue9IvsIUDUjFQxWJSApHWKD2pdwxvIXgokDdDRU0LcPq2K4/B3oWKeIDTT3WJ/USrCsdEoV4GTSJusamwnIuEvWXJmd9fwdP5P3FLSSdnWsuBqD8RcVXPwUiEmTecS+8ELTi4X4/LeCYg/XhpFWbzJRPDAJXVLKqM9VhaOP7h0m+OWHprigBLcW9Y3eTO9qbknsN8dRXqe/kMy/HIqmSxiPxdhx4Z6t9q9mkwjbdcfDpvWP4mrAPrlAWfIJIuqJrs4uZwOPEg9eMk9aU+MXot4fWmMcVDohk8Q6bhleE6Groyx9z4r69TV0Uy5OiiMiWmsSX/BPS92TnGiDVzbahA02nm2y8iwCEKkg02sFQfQMtNsiAX5om2W5mlNBEgynd4WFD1KVm95nB55xTL1hCmemtKv8jhgmcZZD3Eti8BairaE0l42yQdcEQNkN1SerTzg08ed2mTWvrx17wAos0jxFnhxIZblCerfC45fQDCdZkrHhgdqe8uW3Y6wxn3GOvGRsgkEHVj0Nbb80c3ch1sp9h793GPtkHICogr4Jbq5++ODUuuEbHPCGiA7HhJ73yI5qULqsFxU7tQt84odZfDccYrlLR7owgOV0wc4d6L5NUQ56WqWoDnLB6bJiRK6eTp4vjqkKMDuf/6u+BqoXao7Wo7yYQtuTmE/7+wzvRHIxcCj1PRV4PwSKtGUfOsUuIt+klFsFS+p1chbFlWsd36LbCcpaBu3q3elFbguwYKj7sOW6GsUs8PpLfKlnVL1eRgtcZ6Di3arJCKS9T6z2BWuNwyF+qYL+l20lhnacqCXqwJothaCGQf4vv1ay0AocMSlv8aJ94oKyZZ2xNCUuJlcw4PSRfuvxVlFgxVw/KoROtZ/JL3SN1s1jxCLMgXZg8SCAO3A7YVyORYQRb2dj8B7n8hOpAuttZIb6HoL6MaXtUnaozbWUo793YOaZ8SyxeH1Th90zLDcgxY0Ocw/6u292y71oEl2MJ+KR4TkCxpQfl1m5gYTcDlsk9+32bpSCp+Vo09s/BDT1tRyAITugbN4zWnfdtH1GvZmuULhYoQivjA1Pp3J2w/mMyu3Cy8+WIKvZNjLKbzihDVYna845pPvubBqZCfaICDq7mAGHxo+v/jiSrotokKt5Ck1XXCYXNSEvcgbT2fxqN/dRGUz0HVF7cAGgo6nnNfgWEQtdpzyNL7SZD/bu9ZqLgw5mSs/zuXxDWNzujObvSpn0yK7DgNtyM0gIHALXEvPT8x8XPLb2PuTA7afH4fl7n7CO8ODBnfGwXjSvDkLmGODI64O0CcOOhk1eBHDACQmrIcAfjzR2mvSkO7DzFbYv76X65m3fet5fJsihqvaLwDItJTyQzugvq7WbV5MMQwG56dsZFzslrzMU0VnfsGpgwdTARns+/Nk/HCj5iKc9YncZWMrSe+iRO2FGCppgHfH78aRIeUF2BxIb8U9T6NmFGuOS4Fqi21OpIFDvndUW9cckMT/EKk55PuQE5lOcnpaMGsuULPLxAXawtbVekP3uWGOzkw12JigEP2qw0vVXgom6CCaDAbieQHLCSLyy+hCCw7L149WWVCxuTi9kjQlkMjv60u7oHBnCbisdsf6eewASKXVjpfftWigI7Dv/K/OIZMVS4IbXTh6mVf5aQ9Qr+o/MF5o+pg8vKm2O1HFWsxVh0ruEwSEssCNerY5rdXElc8O/IMcCWklpsmzVk1Uoob7cyhi5MKFouWNEHgS71Qkr4VagMoXev5CyqBdoTby+PpLWhWlTAGPdQlGuzwCIhdOFWgIU9yOF0rnHB9lTFabTTWNXbyBYZphVQjBQU2RDbkFl+uCbk9U9vSnxWGS8Y0nuSQTDliUcvvp2PxZw+aTFyD3FNXjh12q1XJUZXALotYbhFPVSA/dDUOKPQiEbEwZKWVXXSVHq3czpUaSMYNIt6XyKfOTZKvZnH6+D9ObhTpMsQLIm9liI6tdwmNcXIA5NC9cMgAG2SE3zUONZrYNOAFpMCiXm2agFE5OQy2cQhEkmm8CuEjYvZGC2bfOV7fLfAp3ENeoX2ILT2Zd59erDyRS9ApHJE05+24CkriPXacX+WjU6B6uJv0bei0gSPNmGH9IB1MFeCr/Pdi2J01kQx+LomnyQ85EIn+GJRgSW5M3eQMkCpf7pcc2QG6SSToos8ukEuBo2C09JbetdY4C1GoZ/lqe1fFiJMsEMzyOhCorR2bOLNLdj99GMu61CJ+W/j18DJRVwPjq1VPgnYH1uylRmagy0OoDSFgr9z3DpGgFlQ70K/DC/iZGYoxZSZl3/X5KhlGlP61N3ynI1BLcx0A7wD0rIK0UCJfw+5wgSA72Fi/mGZUMP2u4qIEhYrpDR6z6wC9F6q18ukItaEKyhNPC7xzdtleqj+yOz9WrntsQLaURM7uhQJCbYgXRJMdniuNVu+cED7mzRl0JJEB4fctVJ0cSEkWiwZutkkcFqcFGuv2ul7od13XdmZLp+hQPXDsp+zNKrWxtBb9q8HmZ3p8f8id/rS4Oq7gkvEEzG8YdMngS6ewTDU6ptlOkM6hTtjSg0cqXFzr0Fz1TdIY4gGRrOCaweYGtlW7yE8uUmNf3tBDeH3l38lFFKxcBz9CEMfJhrL/e6DmU5JmF0oWG6wWsJHI1D3oIYlLs3qsRJoyugnZ6kO2j+d0ujpcC2O7DHYWfYtY1+CVi6j060Ml21Creb0GXTy7eZJS+Zgo/pmpWgQ/qEUZlT0f+i0vPai9b9Rr/o5M5Ui3g8DrFmt5CnV42pKp7rcgSXQVmCYydppgs2zB4hHvsUimVqg3v6cp2SHIAaBpBRuOxnp4qiKxoRuA8S+ef20Hfwcb5GXLEv/MkbJ5uwGFr2Xje3IbhB1N3cdlgK/4eJlZtSVy7cWeC60vcqc9SkNwkmmA1R0T4hYuabMkbtoDb/cTB6ujnTpZA75+QEZh1XA0pGgNKwlLJb7nJnikvMFYM1w6VKiavyddHlkmUCI1FUaIktPdqg2gqwZelcK6sDKUv1kaROPom3hkKtjeOUTMoSA9Z+U8U7V8r9hJlcMSBraY159nn/+G2Fzh9/EWA9hegSR1uOHwb6joBSfQr2nhea0IR6RuEIJ+sEG8oqJGKTmKap3h6x13k+CPFEXWBcyxZVpxXmATMML5mt5UeGLURsiXY9AbxTXCthCHg14bkIPdtDEhbrhNFR+bp52GevCuyKC+6si7SEWlKhK0cHehC9iwE27tN9ZhxMvFGM7kv+Ipemq908BFtVLbqN3yz8mFa96pqOanlrauz1jhvzB5SYQl2bzGr6BihLWZHvT+Ai63PFTuOAv/Va7ZX7b7UVE2OoPK+Xy0TkUaR+2wIpe++j7G7ZmXy22E0+gy9DKu2Op+8OQxoYGl9in2akrqgc3GK5kfAjC9orKLHXnPNfSVb/llWjzAYs57LYeoAdj7Ym2f76KnD2K5RN6dxB35MDAl1LyDuxT3UHzDCKppD49MYKG4aZsqC9EomUyz4FvJ5IgxgcbNY4oIa7pl/XqOgrdACX9cvGOMKFxhQOWrO9ugjoTaOXWZ1DF9MYsx8wyJ9N9lkWVPFcoSJ+oQSIKMqTAKMjp2fzRF8pb8FTEAVcVOQ/fePfbGXS0jGg5aSU9MNzicE29m7MCUUmE+TFcWW6wBeAMbESJhG8iPDTM5EjKa0K1lt5ZXvvy0LZATyc03K3tUXCT9rI4J5bdyik56/ZMUsQdR9jfQCZ4VXBxkURIdpZ8ULzn0NzENcp+91qdrxG8Xsnphdns8bMem0ll7XpEnzyuYxYYwp5kio8ID46WKoAxtlA1T18fiUvlFu8rqaUWojPvD3qtzm1hLV9C8AVpxx1VYCPAYquJEvdsFK51LMODhy3jyfjE++aQs3Ii5JWpgH2gWU+m79UrLfoItmQJWScHg6HqOytUbjvTGTCBY3qC4SuHbFEWAFqKaz2u1AaLWQVn22aTSZYhlyVCmL8l8vV5OCQ7u22uyayuP0C/yTS7D4xx66A2Xs6QW7f1L8nB17YpFcc6cVOA13cw5P/rZkGAavAhYK3EWtHvzR/9DFOZxqobjrbjeHhZJc4MMoHLULkybr/QtFQqAAmh63jy2MGF5cSgzBL+Vwl1TZ/8xLk4VBipPt5xa0PyrNfFS7KLVXAeetBNwLHqv0+GVO3NQoVcO40JIZmMFJ0dvgyA9ysar9YRQDuam/a/An0PJbpjl+wV0/g4Mn5fT40BpxTh1weu51Q7f2VDmGG7iW1XL0FkW4awibZNwTn/R2ICpSBiTf+9OlyH5C9fLbvQrVCeIW7ZI3CpjHmC1CDsy/y8PDaxYW3ytF3to084uV1o0L+VeE68B0sQOPEOhWhNTBBJg0YRMyhgfIFhMrvcP+n8pR8jStqMNylyuVmBVU5MvWaxnSRWMB6M8sLJJzFLC/3rhibXEue2iB+EeIG0DHfSAR0BHHwbVcaCZcD27xxj+5YDjFYDf+khZycb/vZaWt37Gmm3qo33JYgf1dawPgcifvh84bZKOBi+LW7j6ewv7a0hEc9b58KY94TGkJcTsrZckfh0RelNso4MYjMr1ORtkpcigwIPu4CdO/gwA22/fJcyWsU2QXN61r+uPWH2LW2kfwpQvOcP/TIto3F6uWpF8fDPFdhee/RhYXrjyAtWd/A0mLmQwvWgT18UySdX1r5Y8BRlxxinq2CogMI/GsYqdhcFllc7fRO0p2f0ff5Y6guyJH61t3lTv7yq3NC5TCCbv+3apwYeOJWVTejdcfo+ligOaZohI4xMTGIjmIh6VUfsvgteXkulfaUQcxFuqWSITTOjm3CRZajbBn1JfPfwVZNaypIGCaNOLG/YSG5SwShyHmhal/Q++lt357I9iq7IvfkN3zAYe8yo1Yi+Iyzf5J5H8U2xQvxJ1dJPIhSqAZfNhxbBx1+FA8J+8KWteMvL4AB2w/Puuz1N2ix+xXtkf+CuNPqkbuXRT0OdxVnDkzY/NOdqXCGslGiU7tKul7Nl/JWzFDSAp74NPwc6aSUGmLmiBDfzHITzLUphGes3Zy7Z/SCjFu1aHuaOUnvEuBOMcuheTYVlWz6uiyebn2DX59UNPJsUUHZoLY8k8HPwJErsVvfxXpVoZiqWUpOSs1acwx16EjE5/+afIWDR2lgy2pgrLg/iEXu/rv+J7dQO79e4ebaWrV2Ri/H8xfnPUPOwgueRMdAOyI1psZ7ubIUDZeNmzK121jravbyPj2AKGGHPbqCAbx2Yww92E575RU5nTlkJEbNUmOjaa69Tq+Zg6vSPoL6RNPHZOVWwVGTNYnFKRulYEuVkSxHO+UWbM83I3ImpYaXDgJQ4ktd1E5c7s0rdZhkUdtvsDgW8QNNTuBu0HaRECFdGzQbcI8mKYPwISCjiyyyzjMYoO7VF2uSahpaQwsioEDAhx810KnczTJFRz+NVCAz3fHbzyL02QG56GZLaEkP4+Z4FlNftzJhN8pIL4A3dgYHboNGP5TpmP5MvMJ6S1uqllW+un+j2Ej7KAUR+zScm1YpVj+mHqBSY0m9hFk7dC2ENAwHWJMK92aK4wtN4RVnOro2YLw2x+FQEbeLizMthGelg5FA/tgt5obNcNQL6hhJ7pObaXreIk14KfCm86TaOn7cMOOyGZFDUCYE4mc4Fw6vi7Fpfs0U/8g1ItH0CnE2kQ3t8hLFYRnODPmN1UnoBAh+FiyywqWvB9yww3lw/59hx1w/JwgDamHAKZL6BJfZIS7HoHvRM2zA8Nvqmc/Ol/3FLMJXc2fixuU2I2fTiPcZ59WuWR1A2c46nsbplsBKJ1unXaAHleZn+uJVdFwtzZybvm0ahi6CUJSeEJWq8uc+V0V8YH5qhvvER7FV/2ip1Pc85AdVJ5piF0NxAZKD06Z3Uxty9zUBc+XlEa9ceFKMglwyf/v3kAlWGfvTqJDZ/as6S1G0BARMM7bzye4ODvj2wn5JJrsZwdyer3rrqizZYuGRgLVuDLbJAyodgmchndgsZNxu8LIKYRBu/cfm5fwC3QuUgjlcpCgrAby7gV2W90T1W+yye4MLlKKh9CZsEZT3zW1TQx33/kqm6/GbqYc/CzQ+HJ12IfE0m5rAH+ceMAA5TBKPOGZacfcvQr3raV2tf11DDd9fzZpVasH8W7lNIp5UX5znpUQSlt+YCURTVpzQUm3BghInpTFVeESwXpQagPs1qUbEWQF8uhNpOkrsmsTnCcRBe3WZajW+BwPLHGgzOvaUv9ZQltVXCtdplqTa3AdtDHnRrLR9MPpeeNnoXcN60nMA7QE+Vo7fnBy5g6oePhNM6m4sFoRqpwTaO6T/FGH2X2psEWhZUSO7FyQzg5JrdX19EhDs7aYkaOrVa5D31vmIAV39eWhJNczlWziQc7GqhkGe1UE43crAF6E89w+9Vx8KsJ35CFSVmgaiutkJkdEE2mR35q/E9R4PdWie7trR57crSZLOJfgKCh965RFwwJeCS1oormAl8GnrpHSRdo37YnzQPZlRskC5bMrmFzd4IA2NfIkoDFf6tMgvsm6wK0JahRtnHDWR52RjQUYVKz0rWBwIGnQo8inoDDIrSFULz71o5Y2/HtZ9YUTHLXCD6evEod3PxNXc1vbwDAbvgWjfwhQuB168ZDVvsDqv6ez8MZJp5wlybuQAfsga89tqK+/Wlm0Km56KS6Rk6bjwTWg43pqSPGyd0F8LK8mlb5HvcRhLGCDc05731gnET0/wO73V0C3CqxB5clROwqCZAD2oPZg9wYxv9WSeRpSU2HKtU6rLj8vKfP6Pdb0lQOQ58zAAlXgtjKYwIMalWRH8lS2BvFi+qGME/BwVDQiMr3oMguJfDyJpzQjUnpSrkg3NKnAnajOnxvL9SgtmeR4dukFscj2FV+yQjHWO0rECFvx8wd5f0gPH12Pzys4V7FhpS1jqD3C3hCXKVDWlTdIRKfypt5RthBqLUDtIOtkq2vPCcyfDBHG9tAuw/eb+u+Nrw5jVcOE1tGKobOk7uBVMPGH0WVbzTVUF63YGoqXC8Vob1ZL7T3QwHbOJpNRhOyMyLuptV2CsOcCc2mAmdznUMsOyrXM+C/cx8MvVOjpIETEkxmqulYp4pQqesCQQcrsVSGFEXEFQt1X5e6ICXaOdOiDCjTT1D492vwikUoXR4WsYM7ysTP7rZvSY1il/TKZVQ9O6NzVNw+BuRo+PMcq+Hwvwwpc47nkyeJy8CwllRnvZvcloUNOg8giQr75GG0wDrpCS11ICpIg8SKce/1VwHVhPJKQ/wOnCsxTZNzIzfHpcHWwcB5AM7KgV8cImPHD8fAn5R8EY+4GbgHK7EwlWYMXU7AxLHwZ26gWX3WnIkRf/Xu18JuxxINP5TcyuBXF0W+7MbqJ9CoY1G2L8NbGQl4e3KqjlNVmASNckgd0HzbQyicRqPrU2ftUdM5YFTYr0oaUEM+7jRfBkVBrm3bzIrFii0P7hxXViRjKJlIrm262+4bfMem/rOtqK9avu2CSfoe5WE7iDw4AQCpe+3MIl4Wn+mJk0FVqFzi8YFP7vYGpVOOc1AjHiMb+3SEgLoCGhmXnRH4PTB6SsDry9yiRzNNJhPnJ8m01QLo9V+p87jFaGFmbdDHUkTgaouQShR2onmNmzf7J7YO/heX4xz4+DUULIFx2Lwgzc0hilqUN/O2OvMFO8N9LiNsCmk5nWurTLgvQ1hsS3jqg0XFBKY/TJYvxdrv+QfD9YvuL7hshyAY8w3zX1bjl2Kr1A5/FtiBabog3WkNWmEFkm9G5THV8Ukt6e6W7al3OP8bBmSFTseY0tUeLhC8Wlv9GZuOVy6yTXiE74kWaiQKkwHQ4bNRn1TWET68JOhKRIfzy2Ow9QWU8ZYWTdeSyxEkv7VKf8h/mu7ClnLxGyuw2KkGP2bZgbmr2IbXpyr0ME5N8q//T+tRGii8wB1bWWJYbQy7dvgJYd/V3CfgHoluF4c+10WTG3EaiUmGIjnGG8I3bkfK37ZGxGgG8yGtn6z7jWLJC58HAdhmhP8ZToAdZX/9YHT/DCD0qGqtjOA86t5v/UeSy7mqQd/yoJRByey5x6D3VDKeqyQepPp4aJkNZ66JbpK2o6i0YzqG9Ot2+Gy1QfwIhqDrLTMpv417xss1oXWrOYNHegZgXaKXTRxrc9mb8LWoCNhWFXFHw19OfaTbLYF9K7s1pIi0kt5OaEqP200SbXNAPat+MXAi3GeOcWKMpmT7PqL3aQ4MWiQvgfgb32Q93tz0bowJ6r70eBXhNdAOjoJNCzB/0yel3M1ckg70CGmqZAB3BcJ/oqSsTL+wp5V1OVj/YN3URXPkKFcMBm5NZ/mJ35hfK1XqfdqMfXIvNO90ah53qIy6vlQtr5JKA7yOjE94NcfkuHPgzBTJy3bILXRQQceGz8RsWGPHMAgF9+vAoHxq5P8J09JU/vFQOLun/ovyEeWxwy8LpQXJWJfF3+mqqXHZqsg/Wr4s+6jFdZhNXXj97g+1y2xLmGOE4d59gcBUWxI3PZYAj71PNGI6nmcjQJ7cQZQvkKBkoMo3LrB0MxtKXtVipA49vy+kKd78KIkEIM6OeYMAAuTSTdegsGiLpux0MSToSBac0Rmh+600+eJETs/4HpCL28ibGFBZnvtOOhhkkKbeAv3nXEqF+80VyAsinLeF+XnVyqzP5uWzv6YHoFHzl30VARkcbHMpw0VnkBsmE2wV11UwjC1OolIsQ5tW4NRYfZEQkFzumGKjSnQ7fQcsGuQpStg4Ut/kai+pny3I7XiSbfcJbE7NWDk28d8AL+QVUn/YyUATjfWeY+vM5guPWBDmQ7342AuAs4Td5kZOuO/b3diCEzaraPvFEH+MN+5yaBCluTx5RSpBjKS+TO1C0GchA8tyb5v7Gc60J3VmJjwgm+JPxRkohDiPygdAf1/T+l3S3P5i2SkujLDt6bNhQJ8KtcwmFJ5BQmW2Vni3Z37XAF0pa/vv0bAXZUxB5RiA7whG/PHv3L8OcTG0drlQCeRv+QcRb0NMFvpWFS0kbucMsxnRhR6xoAv24UdePZLdrEHPKrSE/xEAOvdQh/4vXTRvHssZYTxPC8abFRw7jE96bmjsAz4kocmZc7GWh80R3skV2yvhTgg2J0lv/n0N7pvdBqMjpObhNdB4o21JaUhVOfyErQwExsF+pTGyEpmjbBB7cRZBxc2nB5r+9AQeZHcsMW7LJS6e9TcUHRRBN+fjJ3lXjfe+HJnAULd7r22Y4qZNNjpliWo7ky7nBNm1vkewJfHLafXYibpJHbKCrdd7PuXg9eRLWCgfRbzalVbUqm4gy6rILC9SFlPiNic2MRWsDsu8CTmagAaP5ws0uTRknFJyLMj4JScGwwbzTP1WJkT8F2v4zkvPBANapC5CYhkdTOEAcHIQvGmNoIFYUKtvsKRV6I3FSKoBWx9mnKpJ/HWMyFOIJ5+HDQuBmxL0Eh3Dex0w3nwegvY/5Rz/5U78Vz8WaKZ+v+iS0wxJSwobYuVfsJhjh+6eFktAfT/lTbLCH7TAWOhMku8Mo4ouWA9I4GJMNj5QZuPiR2AP+nHK4x7Kr7/tG/ulxEB7CRNEfpId3LR89Cx1JTBm2V3K+OLinDet4ZNkLCVYCT+ipQTVowC5mX58jfa3XuTj1iAy60wEYj8r+d3m+g4ZSMm+dvUg5tkXKU0a3Hc3QvBL+PRH06R1yHo48UaSDrj0IhtRvLjkzx3BvhUF50U2MLtR5LzQvQxgxUSMOJTE283tWtocRr74OUsC8ZYx2Z3I07LwkYa//THDUREz4euMsNvA8kU22FjNta4lVfRiStfryQYR8T8YPzI2IKeLCXfD8XfodsBOkq7rlVP0cG2VwmqnfIJU4c8CkjNtA2Mxaz3XjSEupGjlpZ/vhkJqEUNjqGU+4XHMcUqbQHerDfHvO+gQG9wTrwUniZJ5jhUcmbBZMsERDBQQLUljYYB2Glp3X2bAh0IUMnPjTDqlqcGj8A/qmVGaB2inphAiioV/wkC9MXrEWWdzQHe5bRxXGaAeUti9Ns3Vx+x6M2yxskutjwtEYYbZ64r14dVDKEEjMXVKAMkr5HSE/jkJ8gbt3YDf80v8U02lfPWqvPTE72iBTcdS7dabrNI9BotXxgFdBat0MnrPW6ldKIxt6HwT2mZuxy3YuaPUt2HNogcJ/3oenp0KdiHChiZ5ulbWKX34Nqrkz/DXMMJNzubTt/q5yTcjHOs0xJdSaKDyawJYoUJVXDgNfR7CDd8P2yFzAtSOx4VPmuc2P/nIqkiYR8hy3zEI9rwk5tjf/EVGOqrFXz8/I0XdlfsNh/3S2SEH6kbrKxFBRDVBFY5m5oCAKCS+mwp1mm/GYlFyS5kTflGT5KHYCiWFY3ah15WEiA5hiJ9EKVw1rQtNNKh+tES76fpe2YPadqnHhaELjoPOAE7eY1B0yXaS8Rj56eFOd+uaeHSsIwld/MfGvEgr0vAm3Xgz2fuMz1vIGa8BMcul02iBOy7WYBGg/HFxhsKpzBz5hDLnzNztLSnb3FCCkwwmZOdPtiOlUZdrPam+n/0TFB96wBaCAWlhN45ZTOYKph3372hROeVO4hsOPiA37/nkplg9GqSyBlI2Isy5w2p8z1JS56Zp4K+Pv0yYWxJ6XAK+bVoDgDqVdpNGhHqn1gFNU+Zh5u91Enfi2SfWDFVaf46iHpL8vaxJ7Gu/QqwCB7j14xSr5mK73bvMiP4NoxEnKZ+a7yrjZT5jWc4s6d7fNaK4dhLpR80eUuwVmihKSa1QxeJi3os+EUJ7Qp5zDtZzOu64vAHmSW1YSEkbmJiyxHMQQBdlJQ2GjxfLckln+vwT+aWRZHdoNwqxOPfzR2eZN5Rsji+X5ypNb/EJUk7zZzS9K16BG8tvg76EviKigotzidL8Svu2iQGZDvlW4z1N3fv59JEHioGbpoFoh2RZ6KBpd2YUlgxQvlzH/g+npOX3ffDkrfPtot17leEAO7ZEbsKXJh8wEdtYmZlJ0dmQVNxpSkb5eRyRbdQOut+Wjd6UHNDUZmd1CFz5VPYfIYCB5/ISBg6Lo4NQQ3K4xa1XqjMRua7mv/ci6m0ngKhCbiVixI5qXZCmZUnHsyQbjrrNiDPvU1wsCwPsINR9gmkP9TQhyj+jZNudJWpuNE/lqKdzT5gpCoF6mjCee5jKccodL3wXUl3OKI8sMjbwGvzAMpYS1wnGxRATB17qrh3Swu6HOmiwH/Bl6My7io5nCTvgurcoG/a3hLBSCcCEiDOAba4tmisY1/eo9Cwks1fGAZR6HHposvwxhJhmyBUCJu8oP+MbKpLfFZ4AqPKGmmuwgNbr25LEUOWPFLHv1v2W6hRD+pOrcvaWyRv51ap1EM7FnZKhWyAVpzeSTP8SFfgvWN3NmTR8/3FhTR55cAkIq6W6533OFi07CeY8Awd68ygDi6xikruWvlN1PFPlSmVwJhVbYcvifWeX95e/iEydkYIEdKEGde1EAKQoRJJtFFGWPz6pHex7mNqJG0UvT6FEJBl+4rk/7jr5PCumsKXxKC+N+oQXGNuPu6F1XtziWHnnF6ObTlI3SgSZeKOMnuDJ6K8aPds9KdyY0R/el1R2VQb3LJwcecD71QojoiYWldB3mwkTARIyJwqs2BYvxBI/0ZNEhnYh+Qb3cmnwVFvuRJhfx2mQOssRc3ePNYI6K/E10JsLiPIGWx6GCZnJsUgMgHGg2UUltNE24CN1zViWQTIKYDOQSdcBE3HkO+ahmjHt3lYdivSIJT57xf5hk65VinOgXj2c/GzkofJ5QJh04gPss4DBNiIA9nwAW2XQwz7vUaErt/BGwxkSENS6GQuxQKHt0QIM9bnn1slhwc6zWOjPvpS9B3PcdJncgoGIXv5guOd+to3T3+QivOsuw/qem9z9nXrYor8QeQ8cs57MT3loAuPEjEi2xqsbIgThZ2NZPKUdcllrVhQeYGH5dMANRG928FbVtNnJb09Ffs/t0yJgwNenoQQX4aBKlbVZdDEAqmwiewBF860/meGb24vaIR+CscG7ImSPcdlszhBwQEjtyoGHwlb6yt8inckfdbuDyzhRbR7owG/lgPtIC75YheGZHfOpO9Z9CVpJcHpnuxy4Fq/c0kr6hJSZ20R2zuRB+XSBdRkpAOlEJc3QBZ4nLHSOFcCLbtEq2znjVEgyPZ91x7bwLkN4SlKRmIX6PhXYNHPs0q10aLnNp08kERUOTGNET2bQuJBX9ajKz/rS5GuX3VeM/wW6KG0NM+xQT08TdwTwMCjMIJKzgOw6RhT5JY4TDoSqs9TrZjyczKstTXJawwLVoSR7yKay3vyAJid3VM6+K4VTJxJcPst+/RuvQrto2q/rMKKCrk2mvhtFWlT2G28nX/lW9TxkJmvmYbplNNN0B2VYc1aos9jylNKP7qMMPV1I6YR+tc+r5huBp+eIqHYLupethOYwl17GsxbODwYJNA71iQQGv8K0SAqiknr/cyZfMOn8lQlyUXlpdan2Ld0K3m1uRND4oDSQwTkyV3Vep1jFDBGWGkPRhMq1W98hHjNhzWWdny3SKOMZTG+OLPZvx+JAO9C8iQLdduJx52DVIEUUwLEaawGmgzCITYXF6++Rc+t+0I6a8NJ2FVmke1wDx7qP476e3iPCbV8Eq9PUtfoQig2pMBE5X42iivHKJNTD38Q04/ivc+LDQv94nXeQG9eebgTSfcyKPLAKElrS0xpYDSPWmIYiLw8B1j7XjI7h8TQt8JqOPV66WDVdAwM79TcSk0lre4smUdh+t6bdM4fIfXt+fCh+LC7bdV8t5C8MJR623BhJ5Q0szWiNbh+q2R+hk7kltutaa4ybWOe8KbVFysQ38hS9urIFzVg5CZCypLl6Hpt7Jl/DPB5f2MgQ65bMliKVjCYUFuQcj3DhZergNrMtOhpZjuqOUR/TMFwjTT+w4BO4ymaEeI273XcGFC0094kWlIJG2majKDp8xDTkb2eT+fIF+2QFXfcYbMX51oa0WLxaYNxdznRFVaRWJyZ/aXIAcAXwx08toynM4kaDlGAtcmwORGpqIpUOZUTw6A/lb0EKsT2w8e9bw3oqyS13QzkMGdrBEPGsJyuL8YyJPc8KvOkKJbhqwB5UFj+cpm/2PpPAgZtMnqE+56FOmO0ac3h/PK7uk+CdwGNP5GNoguEmW6i3+pLOgBKTGvygDffrKTclcR0ikGob52+9bl3xGO3Eazr3+iZp86j6SSOIrG8/ilm2Fr1reQ2kbVU0P5yViF8R/YMrQx6P5PlI7UfApkLx3EAIYMzf0w2+edTJcLCBaCDVbIfFECGH+1PpFiYEx6Jmj+rimvJqHLf0nm2yWOgLomThDDzG111BJpPH5JyGNS2hxp7WXjjgjzs7H60Za3Ns/vGpY2+36S21BkUUl15LStDzB2AdOJjh5GBPUMlkiEzNX3cjcz5qir02coNhrntHO+KM790Qn2wKGw8ZhZ4NV47C7QRxDn6kg9qKsc9BC7J6vK5fGUO7NIvaC8noLMIHoBANZSwHyv3lBV2AxHLTcsM3TiS98LwODHXsN0dZ204b9n5hhDhJ6yy31k41BgMrTM9VKg6wtV/02eC4Jrkgx1KWpdm/FzI9Jt4Y9AwdZUTEpp3KP0DE5riVsD1Efzi/tOg60A0fPaLOgEqWvhu1Dsz/vPtiTLZoVlrm+5G8nh23brysmQj3BgEL7nsYRN1H36J31rn5D4vD/yve6jhV1fdlZ8o0kBlUIFAjsm6gcQsr8SFLlPKCWqVgQVYzQUwTg/CvSMdL9FKYkWgQOdmr99KNptD3KWGyNpk5dRHMl2q5KUuq4/r+Do5f+VUgs67LuTRYHRMu1S0PAGxnJtrCq8LDIGzK2dv4SccubtrKLU0m11tzI4HW6ZTpMvymEhbWdqXmASUq9b7iu2W3dpPJKBidCLm17rEjPZmZc8gAvzZ2STRjaB9JYhUGU7XXHVvX4Jf+g5nUm0JAh0GShEsbb8JcNSuzUFhltNllCD1O+bvG92ITjeEsUalXxu7a0MoMx4Y2heMNHems+iQqEgnNa5Wvq/lQ3tEjIY6hRxMMz7r1adpGmDocfKg//MGDGhMjJcljqwZfG+9fxmDOp8RHQbsCK9O4I4GHRvsiB72kWPLJW3HDtl6GS6t8/HczwHNDXaOov8vAUjpwWm0XCHV0J6ruaCjXqY3uw4JVPd9Ul0lKxLvD9wVu2jQ2Ir8a4cWr3Jcro4w0BrrTN4ucyIuYY2Rhpe3lEsPAsi5njKL88jJVVO58FikSdIo5GXfboMqv4XZqllY3bBNquK6vaeA1+CNZ//uSKc97JbhjRTu1XLv27AlhEagPVQtr8UN+flNJCS44GZ13ALbIIdplycz3EQhORJpf1v9uTB1FUJQEHqvY2HqiKR+4C0jd/s8nKbhF8FOK/7dbTu2EMD9pOsR3plKEo3tzA7zQ9+Cd9JtBBZaZoMKqgeZNp2bJir4yosFmkKTZvhGvMPTjiANl5IKUi/+6DECTFV7cxeOhwgE7r9MCa+ivwybaW7PNzazwXZTEb1Jj/Ogr2dTuti0TLiFGENVTKvdM2ruH+eGhKAXT/v9e8hCqjJe0S1+QgAlgjqDBGQ8pR1rqAILxPw2Ge4Iu/1X1sPwSZm2W9qwV4Ad9YYDWraqADg/XVT8vj9HEy31Aea08doC1m0O4cEwZi79MD2+bUzVzPAR6YOZ18uiYb6PBptB6rdIr0nxcRfPqd1bsFi2W/62Mi9mY0QUWCNVFy3NFAoWX9ITfaAKMjwNk7KkwCZpjqgSRC7RbxERLZMUwfTxCsnsBWO2vxsqLvIi5Y8P0CPnxUA6lLmTlfNuqzMqN6pvnpetCpZcLDkGLsl36veAvtE4xlln8lhi5l3AlMKPZBb/8WYSKl8HZlxjI2xq4lv8YSWLvUhm/+P9yDjtJuoUnx+DSBwayp/nckpx21gRibhDV/vgjUhqOYuzDRwiIq5UzjJt8HiPdk1lKs+eX9hpnMC+Hv24wWzC873RRT07Gj3nFTsA1lb9PmUm5cEPDtB5VJiY1O/XPyIWiquhCYFpkRMqH49Z8k1REXn0OnqlFvEeLFT//jTTAKFYoCmso2ULHtLm82FJyb1WR2u546QRWPncvyJoafcWcJgU4i7COr/+KBM7TEhIiorXxzJu1QK/dO+B0brKbw7TU9QZZfbEeRkJ0yGi7Syu2sxoKw9HHGGHBy9Vz1OgnPyKzn7+ZsV1x6/qJrpP9rRuRGWUzBVb6cKVkymcPLb/SA9v334FSX6fIrVSnFncRppkCUMnFNAkfCR8UHJJ7Baxhl+P+k+8PxYvCBhHs2+j4QS9+Kh+TjXf91zuvHs03/XaKNBCcdKROCCj476YzvG8OaoWShFibHaNgLC8w+0c4t9unirnrvCus1gS1ywQ0PTGwJpsZntfrIYzbP0bfPBnPXkPN0TG5Benq39WhLXrd/UdEn/Z06+w2HuvjmH8DD2JbFGQlPsZ19pVM+IOHfrYrxRr04QBiYrYhd9NOuvwTjy4+OqZ0w7phTrCEM9/d6aYMagZ/TBfY9UCa2uanR55ulU1OqCm+4yH3WCF+xZZCykp5CYajqFSFCPN/wi7HYVMi4tgFnlbIR4VYsSMtkR4gMHzDk3+o5zZlW0JAHHea+4y/9Wo2tlo7v4FAxW/kkv3wk/MjIoPIEDPSb1cJMPCpMQxrY/IX9Y/qFdIeq6TnM7fUWqbGXUtHyM9hbY6h9IRQ0KuZqzzAJhI7Os7lHyXeauYePR6l/0+0yhvU5gf3CJds0tPLPtpNU9FkPYLjtsDynT/bmi+THV9Auut3AnIQuUCnFY1qgXbDz2kNSYEGvsyqL3FQeOezfNBu+1ITWe7nDeRzUvjeOLWE9ARroctAef2gJX1KAVNm/ornXdd2IvOlf/T5ySY4ZMWOqSMzv6G2JMW1XQUyvnSqb1xG0Una+mHRdWqR/yE5IXz4MamA0ZvPMGPzguMjLn/C3DMDTuqnmUASuN0qsZbDrzF0PGlSifiYCh7/N0zn8T4mn88wl4/uOumarwOHKqUUCYveh9u6Bfuy/vj7hHroOcjZk4P40KIgodNCJ3EixbSre7DjPDkjAUPH5iOeGJ3PNiY8yaVnvCo/57y9WzJROciq7rekzTN6+NxwqWlrSb2Yd//v+5gVj1ShEf+jrF5MYMG3FQTgsDl+nAAgFPE9aB4ErxCd5Ye3DIVxD/gS5Vu4ceJF7BDHplresFiFv8vN3nJOyc0ANonDn3u7sctp7M+d8ScaDHboWZSpTuxGcCVE6L2M4Bv0uLAFCQxku9OMHccW7nwKR9V1W8pH7FiGdHBUcDeeCm8ockPgmxRba2QmBBNL6I+sERQSLnIb6ubeVEdKxkIOLPcsPjTYZjeWrtcqQESPuD1Xy4YzkbtQJZNg+X47650PIuDoZpioJGi5TrBmZ3HMV8hFS8sxVzR0nJMNoQ7gFKbUhzF/iaYcChHo6UbP3zKRT5kp2C6c8EBEIkqrltMWIDsDCClTQQEyRfWHXNvyvjy3zDb6GFHSFhjhYj9JI7IMAiMiyzS8+t92kSRMbqT38M2LXTJXiP4hIQo7u1mJEBXIihy8O8hCCjfPxqpE9H+6/14lFmXW+uf7YVxz6ieQ/efKtV/254B0Tr6qM0PyBLj6gAuWOCjIsrVj6N43FQyXB7K8LPeOOUOQvfHn38ZWQ+gITzUO2lEw5n+cn0XxuoPlLjTL5K409A+GfFxFjGVwD3q0QnJuNCws+LlqunuIrc0G5YvoAHNOwtcLB2KpvwY8y68H6CJRLxKaY7tCwgqmrTHXfKrjqeKNkR7e2DMC1uIoWGahA51+uf9x/DQVg21rYGibg33DouICg0rUKY2Odi/Vi1isJYWOitG4ao/N+J+1LtgXPQX4Th+/bLvqzBetlCy07IoFrBxF0YO4yYH9s1FI8GmECDnXA8JXGjGkmk7o/pvs/CgQNWQj8XmPBWsvpATWu15FbANe7AL6aoX9ipUd02227xtC3c2JXss6ihpb6PzqPtpxchYX0eBNjRu/0SWhgr0sNDj5iaLQdLmcSZYSMrBKaxucrrYlH+hm+JgNU2dDl9zgkJ/NOcOP+GE9WCMOMbZZzHWWqkVsTtEJpVNXwN2Drt0Adqij+M4GJWACfEX9foWWtuvPovKzwEo8kunKqWn9cu11hemfJknHEeX3XdeqxovEoOsWa0SU5po25T/la+ZpjIGUe/NX9SRwjYc5WA8x5WWeYeNVlFawmfL7ZyTDT28H5BpJCnRjZ4gdEz875zodDYZzWKfB3XVtvLJ1Ws6FCPLlZ/QiFzJ2RHUagatx0J5vrGxKZAlycTxfJvQ1GWf8ENUjqXkbdlq25bFZyvJPHWc0rxWDgaZurvQQ5RgSjt5CX00NZdwOPZgZXbFsZfZE36N4w8NiLWZyWpsqgHqgpH0SQcFBIA68jJ4JYg0k1hQmQb9+xRNKziMsniBiL21RmIqKfIiixQy1MwRtz2k103/bmw7r5Ff0/LIMi7on6c8TzSJ4Frknmc5QJpNHDcdmetw+e66LkX9L1gu/Q/kfcskzSlvaRmCCPkL4yoeKhNNj6f8JJ6fIEUigZuAKJJKkHk88ge5mC9212lE4FRNV6Jw1PNak9y2mKEeF45ugTTlha/qkcWo3E8IV65CZwRt7wq5J3xJvY1chqWWYRMLayeP09dVbN2dxK1XgEHVVel/BfoFVdJFZUZ4sZqr5UPf68Oo47LrEnfeWjrkFZNiHHwXfhRyifRArbna6urAJmNFMhvou2Uqu/l7snXGX0hDDWApIXnxZAFM0cqYEJCf5CQxwQMno004xMD66f4TFD5ZRFMyh5hBlyT2k6p8iwlkWcskJLD+uEboYsglbfXxTPNZeDVmj7LT1sSFtQXfaRZjH72VfoeU8vnmuUH1/Tfw2nbbjg4LJEzSQxMc6RZwE051aYgoLHToYQwA4Z1oCIf1H2tbibQmEYyTxHpxL+oqQRCi7t0amkWTaDVuJWUmgHJlISUx5E54FR9H5VAQFSN67RjgdflJYrrtIF7cOQ9oTHskm8FI0+38xxcV8q9j/NI3yIBR5nix96FmL0EXsb7vzr+c6mUvit2mbdHuw3CgfoEFOw/yBbPCnnXVU1r6VYlVosjpKB+uVBiDU59LxgAwrHHu3UZWC1qK1mVqTZJyH+BAGFtyMS30sL1SnFP8/tbwI2JfG6piHrqyURiMm7TNA3Jj60y7ZOar4y5yb6Zk9bftx+7yBhSC+jncK1S5GyfzDO9MRnY9rSNNKCd27Z/nF3oGb1MAWaovJzVj3SrXtmEZydY5Kp/dkGLC5Hg+wxa2eDUQyxKRonNQEm+ifGYFRj81EKshp1vq1fjrTLwSd49JtgKmm+HtJ/NQ0+n73oA/CsdeVayo2uA9iydGUzCg2NsIAwKD2GPRwG/JnxKuI3cCtvyBJPKOPV7kaCKnjNoiT3Ni6yhg5QkKUiICI54zCO60j86bR2unnxDTEBuYqw/ZUa3mD+ljiqkeI9uMU5msu8fZnYalDKBuSAqIqkLhpPOVc8nYqXq20k8gPiLHoxg/lWOsKWAkTvOWDxkcEsf7fubYENAottmwZNZQVeFyg35Y+YfLq/hPXOHO0dDX4jV0ypL/bVGs9SPuP5S0C6X/vfePqmq4wAXnLfsrf8tKZ4rFRzjAUpI3IFPQmaAr0fPxHrqfqPNxMkqGyIXbHacnHsu5tTeDt8eL6f4Xkx+Ekry7Wt/PWi7azRiEgoCfdSFZtUXyZokSwPjQRavIE/r2F99kEuhbiXXYLq3lJiz/iw0yOC5oMDaAMMXGvZzDQfRGCoYwT0PPSnBUP3TcbxTKVgg1rjjmtpHfXefO8mpawQZHofC+KSencD4UjUAn4nvFEYNUHEXpYEK3bWRBeVkESSsgbJ1pGRurO6NZ83Bk8oPe43x7zazohJzfTCLeNwbV8Xw9wW54bshrK5KFlhqpBgaP2Q0lkrGIJM7Ywv+A91UFjiz7Xq87BASSIuOqcVVg5smxI4EErbRahc5a9vANc+Iv6d4hAbmXfblN2gBmjPmmubZHnYmgfX9hhbPHLwpJ6L3M6ZaCYNmuRxOwOwFqINij6DYsPvxwupg9KoYHliRMMLusjKQE+IPeSRIDWE917Ahl31VLZZxO5wyEMtobZTpudU3PYP4r+IeOkBfrbzyE06hXPdZ+em42LKJl9QbUhDSDStgw+t8BiIRTCZ/AC6PSqI0ovbVJbxvzL2M8FNlAum0MWN7ifQVgUGiVacIBycu3kF/6nISpdVYNcuqwHUtO/3jJga7hIObOU13rIhcgDLaLKfH78bJwxHhc0oPzwVZOda80OaCvD3M7EfhtVl103vcsVTFc/BxXSgQOt7rFYm9wOUNdgW6raHusjgAQm0f6MBf6XeKoQ1NkvX8fkVV+hlM93rYH3cUQgFux3FKENQnBGlRDamUXJz274O1CQd5E1jXLo+SOZsnDDzFaiGmEctqhV/COikXpwCeBOzokjKnq6TcUMemCf/EIyElxTl+XOg9IWgR28ISVdlfvNTOK3GzC1jK7mSdqZT/p/N2Z18+apgQ/I1MvmGou8vkzhD8GPSMCHgoZaraP+lbgVatX40PpruZflKDyT5jCs+ZlQUt3O1b7gcJ1w6+fMJcH/zUUm2RY4uSbrp20KRLedQePB4ePRlCFSwfIwccFAYQnlbDTBF9nGI9GMBH4tmwGuAbcAFlLogKGVtQvfMCJJ0zNAZtAqoXAWHnRN85qgrJVf0HRHls7hlMwvtj5HrqpbGnYXbqf6rbCafxBeZy4FkAo/P8AKWhXB8LjkBLhcWsFMG5mKloPLWyAOL5wB13xGHgBGvLOlm4BIxwzu02S9xnvZD+HxDnxS1W8FxTp6LlqzXZjYYjcPF7UW4EwAZXgD1VrWwk9NBqp3GHALMN3HBW5Z3xlTQnd9ADmYUksSNJjfncmmO8KO3O1GAfc3RB1385pXm/GpjvOyvzXONfpkkCdAgQJq1/OlyfSMqnt28FO3u7HEFO3Y/KBJYYhucrsL1fnWhz3Rk2R3uqqEYt9PpKX6ZE8+6tcnhZwk/4cAx/OjnmM7sgXv2K6b8J/JjVGjLt1GsJH35pGbY1zL2Cl8SoOQfkJEiyMX8Z87+4xFhlQOxiTTQDU3ZBF+eA8s1Tu9LAzmcvbUKDWYLTWPljK3dTN9y+4FLpxspg7BQiZU6q0j/d+Xwufevlzw8iDwvk5nQMAbtXft13keFmJqZt1yC29+UCRiuZ9LAxGUkuFd1Pb/oLbqbXqYbCMGXGC4vwrtZaL5Bye9uVV5EcOxpKm3TgY20HTmB133S6hiiWEGDWa9BO27dNrqSyijbCW1RPWt9x+V/PskRDxAAXX9j9AdRY1b3m1hxHbK2zIi16bSI2pQ4NKpDIW0IV1goK3vG8vqjNBA6N6jqFOcCRyQm3RQkir86hRbcwCeNtuKKt11qqpwgOT95bOMHbDrytueMmmuczik4bIQ1AWMzG2bv/1qE1jdEQwQZrFcL04ViaARVfystuCqL436yNh392N+cAgD3OmhbtWG4XNh0zW6u/0HxAbEH/tTMT8sLNmQBiKm8Wr43tkvIq/tanGd9rMwDtSxvVRy6O9hQWf6W8R5bd0cQSzWmq4EmiFQpNWEeonfabMiEyho1WKrx7QyRCon776EtrqDeTWYkIoIEMwio/cNCOnlvvp4UpPp1hPjYZOtS3gpGCghcqiXuBkYBd59hpaJ+OqRwph6NH6IxeKWUaJ3P0vcIbJPhD7nbMAL6kNe/HVeWE03kiPPdWzkv5ORYsUQqcZN/7IshM9Ae/K3IlwZDZeLkFnq7kUGB5xCj3Fcx56CJG7FGLl2boaGB1u3z/8MLMqBF+iPkUjOJA5C+Vz24bnu+ZN1fx5S30qCJMUVTBPYCsim0OqDq974mRgzWxdF+D1sK7/Yc7o3EP1iYKmyGOyHWUTd4qzOTAUcrG2cAyZD8CWbwqKa6cfVTJKRb6tnWk+06pGgiCAnftyc/cKsMEbHj1uiRkpjNh+SN88C/0ex20SpLLdFwlHIhOYCt9wi8t4A6kWBAI0XuW9qLV8bJj6cMUdKIaw16JjQntCVfneD20QAxgFJIzHEute9Rlt8kHvlO+Zi8cWpRQ0DgXueKo0NOodoVLLijB30n6gmSAJfshUtezV2kqWT/Wp/Q6hr6zGHgwOouzCWXZOWa8v+AKTz+e6GdEkekgFJACFnhFxF/W621XepkkVVUKRSGI9IgQahSjRbAcnk2ieUQjfW8sN877inKO5QDSDktVLXYQcUCX8oME5DFU0QKNfRTuNHQcCy/B0iFPweV9Gf6GorRIQ6NgRucHEBquL6chV4FdXDvUxnzIs9NamjWV0+WkODnFBKS+ATg+x0DVod1S8TanaDdS7GUfN6y+n7sQjbLTGPVHcEBpJv1P3bauAn7ofqSW0rOZ20CHBv8GS4KDTJn0Bz873L6mM3aIF4p0uUn8h74mCSDx/p/Dfheh5jbf9jGFuS4RBuZdr2zn/e6md8qUVw7MadHsz81pkgfIMVAIACb2dpoNmqabIPWI+i4ka3vcaO7X/VuCltujmBO4uTAaJHmJ7iDNlnJu75IPTO6GWxf/K666CrSz2EVMeXjbE+EIeWxyBVBESS9hjFu8Trtd6NhYw1dHYoeqHA7woXKOh1Qyx//9oqMj7pZJ1YENbCIKoXQGGR4buFHVByictPDsFYV1SiRxPTtZ/cMXAi1RjTuIl7FB4niZK2HT6IN5b8hUASwC/GD+f7iexvQq7wvYlIIb0dzRm7GZl9ZvgxMWCaxWpUh+IcXLnWrKqMjof7BgI5B10UnvzAvBh+ACMy7nrVCfQhtOO3P0zWSHbh47unzuet19nYq1LDdLZJQrPdbx8Das/yJcQg4mBlUc0NYte7K+nhEjMzvaLQqz27+IQ/Pu4uA04bWUFxj/GvxWbRuDaW3HVS1xoPfGPls7RGvnaStc9N8ta1FwEDO2XzHTN7kV+YYHdCDL4542nULRagHvcDuw5uIEUKF//o8Z59lHeGmeAmhp70U7yl8DwyTfyQ7KqSkcaVcnR8heeqWlsx4mdlSr7lC02YK07lnP/o16jndFhg7dCMIJa/2S6tWYBHo9ccdWUZwpsAp7Ssk3fuv10GCdyez58PsEHfcFBdONemH0BLOqQWXcvVJNMzx1GavKHcL4T1pz26sEo5MeWVQ5wDjng/g4c9uojagni2LJbm+BzyJxm8Zio6xk+dLhefYWrNXAaXcBSRSmUki/Jd1eyDZeB4DvOczRARshOYmEGzEpc1t7pMgR6+CivVskFFprl+yJUV52gPnoG4bURk3wvSKQbROFCYip3i70h82i5QnqQZ6wIG+EZomyTcslPNeT0mdZvI+NFUiMiGqvBlJ7dAtshn0ZpQfEDXXFAoutu6VG09asOOvGFB6/v6p2h79sUzWiQMubMpMHYypL7aq7lbQimZdY9rSeWQUnB8YP7PflP4dIlN61XO4yFMIu93nqlbSRtLs7J6H/KXOjUqTMlOAsYgte//rN7fA2whQ49DhXRRKLRrm3k7l4V940UMrlZVzeS4t7WfoUj577S4X+bA7ypSrI3mwlkus6Zj7gRcVbRo+80aDuEF3KhY3osf25fIHnhT7TftV2GBpRkrQq1RB6KSDEW4mfn/oCJyYTMs1f9Gfgih2gJeqquPk/JvpogHyXaZ0fzmS6l61KDInkWj2Uwg2t1eeLjUIuVOuDtK0EIzlSkG5oWDaC4d2k7+kzElThw8g+CM573pIlRTl+Q1+0NR0JZw2Hd2dK4/zlQphdOjHev9RAvSZ2CLKiDVRq5kDKUMIvqWk6uuDR6v5iTtaiXkJ18Us9dPFsJ88QIwENKVDTOxIQjhNMKZhXanhZSewi3IhgGPBqTCXrPzuncr/XQFmqqq8Wq8qwl/t3h0T4ADf/lxxF34mGmAMRMNankdLlEn5JukZxGl0luZLFFO0PAoOBEAwT66xQqqPfXDReRPcGjmSTHxl3NiBgErL/czvTWjsKHe9qKbKG4HY6ruZU1Lu1ymu1sbTIV3pmBh4nh4/AfO2aFIcQa0Z/x6BEngO9MTtypPVyEQg+dFhZausjZelS0CcZ9xz1Yrm7kyY/yHmco5eB3aNlBliB67IP30kg2ooNo9U57Ot3wpRxhezcLKcKzZ8/MEzR1bos3+wH7XoBjCFQidIyVzaM+AMCkn2NkABNe0AqPPMttw0YkkoRrGNCSmev4JrJ6BBgQEP7oT3J1A+/nJlnMAS6bCH8SVezbi0lrfZpD5zMKL3Mrtzb+0AcAWkHB8xpd6OD0q4LiinnDcE2aGxis6Z3VzdiIYSGRThy0ICvz7GptIroPscS8h30Nbou9YE7EkS7XTZ8eqv6fSU/t68tGJk3JhsxU4g7zX4kSbpWKEv4k/SPviZOtUVCiFH/035GrbkdfJmYXxYfkACYFgQmT6d+ZriM5x45+2u2xgtDTTURE+4n3r5VMVegjP6e1HB1ods1yD5NpYRyxjHamNym+Bhl8eTreifyb3GbyxI6dPvEQUGrEwJmWArBgpo8HvokR8vr+cCEe4+0HbcNstA8ASR0iv/oAU2rNHS5qwmYgRonN3lm43yZSFZqQ+uk/OaZaBjCuAF5K1eROyE0Ao93dLanYA4aGSW6W/iJTurrZDuwp34dqHF1cabgh5ycCzyccWQ91zUzeNuNaDpDmzd4RtINKPBNC2vGth5XY5BN2xVJE0eUBFBGqg5nwaVDo6HBlx5B+pT8nfjIyviPYBUr6+0CT2YHyfj5Se+WHGgR24eAYzefRqyiNOFqT9BWCvAa2xkZhdURrFRMBqd3RlXSSiSQV0YF4H/Q9Rw8/i/xQL5ukQmkK2U8Xpl6+ingqNEJSdirsyZ7KOYmQPBFRPMjDtZfVqiYFjZBydZbG52ZIjE9PjvL9zucFuo784VCb9zXyIjrTZjs5uxmB0b1HZUDIX8PEZ42RBtJZQ/MZCVP3UMlczrE5FhdOgvvHithQ2TvyYrrT6HBU5DWj9rZQkVV+FDbvGvhblmIKgn3Zlabaava9pSowMcevdo25ASpsnhmHTdXo5nAEUx6keNlhSR3KxtPDcobeJdjIdLL8/hZtqlIZr7yehZaJiiju1/VgVYjCFmVGn9ifFXYYCMkh+P7B4sEIF5FaXkLXLhVixEPimq4PU0F6ok88ccs3l6kzapdXNDPmeCZ2lumuZDED38677ADOFaQT2U8sG3WnDUjkrI4nnm+bl2edpc9wUdZ5OpCfxkspbWxP1aVXy5n+RdkhFGLfZVD4B2C+Wx3KsDvy8OF7mW8t/l5eMLBYQGjQZtpFYPJJvPNk7/UXX/Qnn9El3k82pCp+kyOXD6n6vTQig+jBf8ypGjd2yKVTXg4yBJpSB2BTnpXa/gOh+7lsy5fF00aj/LEaYeS+9b3AwU6gIQ1nGY7zKNp+n8R3rzaRLXp24vT8QA2xa0sTkE2BbHHdyvO71Htrsw2aCIZHqBqG5HgGt06gVjXvO0M55rseNFE5naMfEeT1IusJgOEmC/HgRfpNsuS5hZ1y14B2zoHG7MCURipGwbjyN0wgEfW2n6CQDRHTuXmE41pvDni4JSio9oWiY9Cg5HOSOP9PCj0MFUwZay8zeFqn6sZuZcsMDSu2ViTp7OhpPk77dolseHVpdIZHOQ190WZ4v+WrHEJr1d/khCZ3z9k416scJMLa0XwOnZvYpO66QNNfVd8ie+y+cKjPnZprOwNh2do7NPp+kj05DFCKm9ebgiSG8aiXWChz0R0qkjLO1BFssGZ7OKwB0K9MQOlT1Bmi7j8pGgfDIUST5M7wzrPoBAYWFWoxuTH+ICrJkhuhQbY06vnpZ2r5U0TqG+dPVRaHdwzcr/x3CiE63mbhk89ofh6t6o1QiWjVOGhtV21V8fQRDqMZ77m9s3q/QdyseZRGSC9pvW/GdSEBPbmbf493lzWv1l3V6mdZajLpFoOG3TBKoywunOyZjtu4yQ978NwTjKlWywZl90aUO9H9Hw0KY50KJpNcTseOhjgQ1p1WPHtVGIPxJAll4CH4DWWPGGar1v93ghGZF7Jyhm5M8czI3xFyyi14EYa6dQBBJQQf2dhOADmJudmiWJVgH3NX2KeOj56nijKT6jTVlMG95UaFnBUkwzDILFC5Q9IVmPEQYgsRJMdam7fvaE1Ok4/YPdQpxocgVARB+PNeUCV44lreBTPNxDJIgywMYMVc9vpEKJnq4razgwPUDBsG8W6L0RC3ucXJSdmaOJtvy40/mVX4KQxIOq989wf9rd/obGJQdsD9fhDv2Zb+13P91fy7MpeZ0XnSTCxouRX5GgGG7uoWFHPxcLHpaoEVyarBuK7EMgnx3Dz2TLJ9ffn5L8Z7Psj269gB3U7d41gk45hHuCrxXAy+BV7UIMYX/83L+k2enUjn34FnnUXTD/n10I+VeFSzaBDid8MgDUvc/80hBlb+AJGUlYKevmZxCsn8OSs0AtoNwjwexNsBFYbm4vrwFdY49NZHsrWO0ZKG1jL7kq6/83iPfZ7E5fJ9IqFjxxXE998b2RuF2NlFCi+DXId4JPCq7UzS4mVLjk3q8AWdtEDFWYvUIS8pPmfCuL67besv8XcKwOkp/Yz6F4C067W0UaArs3rmF5GEeNNs5+MhXKzveEvkZQGSlRT2siDHzOxkDV0mPyByRsk8pgH9OA5Il7jWzhahiTOS3abWq0P1taER4r7r5snoMkYlF4fuD+VqqHqMYWayRk6REq3cvEm/2EG3VnGVy3pSZ6iEj6F7O3ncv8/oteH0JsEjKM4lqUKJtdBNHtv5HwHnWHzg+Ad2kKd8zm8d29iVogWlZ6NHR6w5/W9aVBh85LoMBI3vyHOwTuyz8aUQ96Xm4PPvC0v+/s1I7zh8Y2Dbwn9qoO7/sbvfDTA5mOfPxEpYl/ifphOfsR/Bi9U4f2R5J6u2aGq1/rG6okSsIMnEnI83iY70PWrBgJ91oW0NK7mQ+zQvC9AWQXPFjDHrZYaMVZqC8z6uPacf2TNCZexFAWAp9FUXcf3iQ1Vk/sQS3ZAjx+BnTrD5NA9WPJaFxplPXgFsRjUldNuSRcZhh2ttPSHfWF0SILpQH2u0IiPSM52PFddXUOk0X/St4xssIQHIE+fYVx6PDYHI3qwWUkNz145XvLuWzgkn67xzP1EKlZVznoB/ZgyoB/+RYrZyHo+/2KFyAK++2vL1ov3IrhKfHaS6aCRuMuiD6uBpZq/IJ9gHm8z2IGsNkQB80Gpe26D7PItCl5UPhlEt93Yt6D7XkmnNiEorLA+9dldNdktxlXqhzmt4juD/soOtH62d9pLMdUT4R0UN/5h66/nQcO4ew4Zt9jf7BmPwiLgkCEeGT7x3iFCDCM4Jbx0a0K7dEN/yGp7i/RzjGeukUGwWuK/q3BSfJkthn0Zo4zQXvNU9lVYayjAQhxITuzREq5eeaiEWqqdDrkZeYONKFU0lke8z/yrKzDQ1FjH7CCJO4FmQ16Cxh/sB0qpWoem8vejeK8hACi92x6A1a4/NpD3nfsHxhZRkIQRW0NKU2qHNz0wtaMM19kKvogvQJ/Yki5KARdlMCG+26DZDMGA6bIxuhEIVhNxjjrvCvSIMGxQ+uZVb1+sJBWZ3K2NqoCuxDLmo+KJUw0bezDi3KVgh7E6HTLoJTBJK1HaUUu5ejGde5/qvhvzMWtgeurK24dLhi2AL21Nf7FoRIflBTF4mEUHtZIXMKNNDdFlZ7zjUeJRBsCszBF25KL8el3/UkLq5EdBl0N7lk2qZq9ul95hPtK8TSAJnfUC1H2satnvQocz9F+pL3AbdGeyt8DLP5PFcs2OqHDj+FV57XrgpqCCk+ERykYD3oHXgKMoebkAEo7hqQJYpTXSI5IVLnpXtMi5Txo/ChPcRFPDC6GEHnCScqF/dQUa0ybYWtk+nbpP5P/aahsLEKlfqjPQaIIBrBi/mY62RBzOtu7yCs8sl6XSSgW3om25u0mR1zhKjKlDfhE4zUpXt7egxrn3jTmg1leElxAxVSUcr4mDbNlf9M9BZm5gxwCGPZv4jWnaiwo4cIeWaYIe+mWcuFRQYucvr842CsHlwloHkdc33dYLSKtcistAmZQXALJ7DSRrK3wCjPEzoUkaOadJZrX+fS7tEM9S74pPNvWWhv4heRr/ndJlt3zkY7m7fqZ6DKko2DtPafEgXVTbpjQioH8KS6VFHn73d787vBwb5C2N/h9WjDC4R7xauRjuEoGvS9W5mAGpTXuoTYAqPbxDQ+hGko1OooD8IHF8I5bCmfvf7QTmCH5W2Ds3/8GWJranwO8fDMIxdlQeDsW8iC4YRol983Ga1slgkUd/OosifX2W1XY4T8dSsrYO0/N4IfH0VOF/kAHdMGFkNZOcDplhPR6kud5rH5ee6KzATIWPdlQW8jHVdZjXH4K6aghRdikOiTZXhOlC73QlQCOIZ29szfdsw0P2QPonkw4Tu2tEIXMANqHtJQLOcZWGF1pQuaeYLfIbU9Uy1WTKQTdhitSRKHfLm17HWierRdYPKlbbao7uIgYLVKAz9Hj/SX88xAWKkOSmatBttlanuPR3/TiM+KcwF6EEHTbTWUG8Ln4Mg+atuWElnw4Sw2/JuWzdXQjCeadmHlEeSVDE48hw1lVblUMQj/u5wwJYtvIkiC8MC6owNZp8fNgl8oMixjsQi+xt7L+dGnwg59gXKv6eXI+FR0rhElv8flWOH8Cy8i4yJmReogqieD3oXGe0YbOXFVtz+lh8Ht6QRSMraAVSVI+zFhHea/cCm4RgN09VTyn3kfpgAWPtBL/6MlPmoXNLnwQcJxRqWM5KYHcDhlGeawaeTz0KOJeLw4MIzUvu7h/V04eg34dDQZNsqODZogdAhRyaaJ5sD64i8bZlxVKrY34ZTIaj7kT9mo3SDNG8Zlyo0VSH2LaPXUPOAm/JA4dxvJ1wxVTpHX8Bq+KnXvsgTOTeZbJfpjoOYpawjLk+iNRQsG7lY/pWbAgjeDgImniBluAcDHKSFCUV4z+5FryVVM139EgrnwRAMHNsbo2Duana30d8yoD7ouOAjVFXe0I5o+CVTKnFLCTY1Eq6WD7PyqEOMmLsxO/zsbZEKoZvjyCz/A/py8LZEeHsVx9YJnlgqolrMBYTarJrkDuUs02CIIOVNETvON8aw+rXy4pzX0wEJ3p2S6XvDdD7/0Cq0+Xb5MPrmKjrwqNh2IF2B7yWX+5m7fXR7FM0KIl8j9U9OhfyhUn74O1eIq/zfH7edrfaUpzg7U/cMOzt2C6kXCAX2CU04KSrHn0HrNw94cNaP6cxrX1uPmoAM91ZBz5jw4D9znLD7R68DSFOMCuk3nsS394Il2u6pBquhnOnuMAHQq7GWTeqJPNn1xVlFefcnPhVpH+ekNW+ekqqytXWZr+y1tWeKqS2zIx9uV9ZhHqUbJF/Ouy9QlVQM3uQUeDsK3XKGXWDLt3b3/hRy4+VLWpwmfEB+oMBATtTg5ygh4zOUbcWU494hfxp6ZrxsSsbkXLVejGe8nbQZwWAQoGBm4piw6PmXqMPzvD1Mn6RIQV34hA/TSMvxHEtwi0qA0hJixmseAMBAnJ2IvUgZmrW6EWdrGSFLVcDzz2Dzt6UM6u5aby3uGEHs6QLCyIPrrnTF5SWimWCItgaJ1ZEgcvSp1WkyUJJAbisZgQqCbLij2GllGHXB13HSwcEsDd4PY7CVzSlbQBt3ui0wnEd6kTePHT40q9HwXrWGCdGoqhzoldBR8V3xHmAbxN5SAWQnvSrwbEpUVdVYb0SFOp3lJQKY6Dk81FgBEyYC4Qin/l1NAl2cIjCSsA5sDp3NyIu1XDQ540qMH0Dj81dpQ/fNTzvKPiTay6+JjG3OfTBCWAbOa9PtUTvwsr5qQO1SxRC/t3lxuPJJzp5GR5EfiqJ2Ut/taT0mmk8AnOuM1DTEHYE0apUuKGJJlcpQuCyzGZerWKthQ0zKYiQAjxlPhlvp/30bj/N8LONpi3DZXN//GTIjHAXPzmSOa9wBXV/Zjg1WyeRkUK0xfNPBhWmoh3zMwufzAbMxEiF2CqdSYTr20AzdNSFlS/IKsGA/39nQqZyCHIiOz351JsUBjJAHxiibo5hA4BauLv62CNZzTR94/Y5ILUjrW+hR/PFrjViSaS7vFieYEKIP9t55IOp/rV0eir4XMuRuu65si8gBgPOHGP0nQn0zbd1n8+IzwcNd1ksgEyresr0lk1RokRn2Ydt6d0PuliZEt3BW4vXQzHVR2p400uK7lnzYZeiRjSrEgrhQ1q6yEwrsarR2RnXWxaNF4cnCmt8FfWkt82hBoOyWPM60491tNapFR2LFmUhCBe7UF2xIwzpZwgRQrrMEtQ0LZKunILk3ItdAzszytr3RPeCt5a+EohFuX1IWSLdfWpOaCsvq1AE6gXZ5WCnF57VPbz0I4mp+pJ3a7uNkhbU6sTOYBDB+pVoEgmuNzzo1gMMeQcJWyb/zemw9cGZNdn4XJFqq+AsI3nZdNKIC3f1BUtqJgRO2IaWV69QMxAesZuvn4M1VslMVDaoXnjf9FvWD3twEoZ4xU7ZjIWJ3espGdkWtCb2hnUpUVyDQlJ0usQrsgjA3bqbI7Xei9JmmbW3IPu75f5vpObFeWjJi8RXedMgjx6J919Tu6ql8YHRPdZLfGXUrzrBGhYAA4BRU7XkfoKLWDtacAsda65VWMNL9OFgvMUOlKeapvx3JEOR3vfD/Ixs6XFWNe+FO+vQg6gDH04ALXzD1vGUbgOOHUaMpkGM5UYfd5Bu+Ogt86KUnXeSoAVdJKu4XML151LW/1oNVrnVEudM2Hk5cz6X9+pf/LzgLFBq6mYwhGZnn0o+D+wYgI30MuEYhmfAmu0XZeQx7PiGT/qA/Xf0KyqZWDQxMxK8N7f/qnHDEZwNCO1ib7r1bZgIQOgC76R9HSd+cuCYGuypbWMVYlK2mjwvy7hKb/L1XVjftHvigpEmAwSFYT7yTuLJgKhZQCHeThPoKY7LXJTL/6Pw/eNKdoZ1UPjIHFy8poPdGYf3cWXAe3yKD2mA1dDkgV9iAWgnaq3z8LcTgG1c3Iymxn1aNekbaTXkbv7VNAehoqIqzIg/Er7y2ouZCVQYGpaLl09z4yyE65jjcjIzrN1GIGr38d3RGaz2+xmBd0Nsn8pBLV2Lvom2DUMem9vTvu34e6ouEpLfl9RQAeTHokiIozPU/mtaFHSsP3qRBbhK1/j3Tx2k3tTOyUmw6ZqN81ZYQit3+OzJfmEmNLd1Hysi4QHcD5WfqGVl/K0cSOVrzYyTuf2/abWevOSg2WEaoj6soNyoKQRG6YcFQ03kKxJtgikyI+sGF4WwAM9mLn8l2/aHDQjVoQqHC0bqNILv0R4JUMRqMHoQzjLwxGeQmF3qjo6jPPfAlBOZe5LIRMOjtSBcBvktU3y/3Jzis0uKclyQ6pX75DqjXQvDhXUC57ltqBwVRVvGBqMQ9SLqdkPNChUWL9GQC4a8JLwxKSywfhtftW+sbxDNt/gGEEmvI50iFlJtAUrs138/fPG5zQuseRyTXD89LaCFuHRMJarYc8W0sPCN17gtIZt90Jn1sCaTNCr6PkIF2QjzhKChoOfPmntYvKqeqkzbN5CsuPy5FlonhyaiBMKlJgHkp3+uIEoy/qgN/CPv+mAUzAzFEYfzndGnUvx/gPzW2JXsHno16i7SmvOOcVEytGlCRapJTrWsdmeMXusrGjqLsxaMZJdh8oABsUjfzO44z/FJKL4PDxYDEDKSSKm6UQbIm0PjFzQp0A/b59vvsGtNgEGFClBamvf/vZnmZi8Q0LSOzjjr2nf7E5yHsw/9HZr+bJd0OPR1NE31YZOdOfwgprmiO4QziDnfEquX+FH3rURuxH6P4o/XoIYFzWJ7twhYzAL/74kqAU6rGAxHumGmo6js06X4yzF+2q9scEXQ39Gg8WubbBczfbM2jN5B8P/fpdmMyXVCPWyB32Y9F3nPEtTTuJbuzJz5AhoON4D9qZaFueYnp2bEImQrSs4ZgkvGdqUmRMQl1i51M5V1+GDrSASzPWmec8NnjlpdCuZ4b1ZgoUDHQOyX2fp9UwIoKBpsrH3urCjKHl/RYaaJkJ2kS3Nw1YapgFaFMfIspTBLWHVKsZ0FmWc7OVYu49VJOLQ9ItYxqKw7AUqfo7mn6oKoaQpnlK/8ZKgbeEaVNQ08jajFSSTIEErpr4aRsg09DZMejG7tandkuHKDpFraAGOS+iWI0a2YT/yZun32P1xCgqLAhvB4FLHI6IwXnN/N6qwPi4PG+VszjQxRm6/fXOCE88ekOl05/CvRE4dXaK8p5J4fdgcVGzlxaByviTqnmb8E15g9aUjiCJ43yyk0Eqxl0u6bSl/N+gNfQHvJD6xj+lbnF6FBBNUJ1p29pSH/zMcB5fTq3bkO6+rpZ4MkjtVJTplZvgcPTHP2Gw/LMpBSjV56gdNr5FFeDtJNweZaeUfZ+e0DSKAMp0UjWo+zE4GC83iJzuc3Q69vIk/vHwttdes9rAVr381kVQwoPddG0naXvmkBpFRcj5yXaKnOmYhHDxs5pu3biMGhpcCLYWWyhSKo/N6CYnOPyX3bPp0e9bBZ7FFMRuKo8064dWKgu2NLWaie0l6Wegg7x5b+k08QSn62y/bMLCo0EbnV2wnQF8i/frc98BQXqVax4TE4P/L9HF6IHLNp6EwlaPVL79DbH4K24vNZHSR61ED2UlE+8M4+Nxr/Mfsh1XynUav0WUgQT0CriMjxn4ZSgNCtLcZyGTAEkKoaiH3F48zPbfjQ63OlRf3x1L1J1lOnfLB730cWE2fJAEEqDHGuyN4HVQPrVPEI7XHY17u60Ll3ks7wv7ORd8zxxXblr1dXPcZdbhXeuxB5EsKPXps5y/CDsWuUGEukWAyTaRGGV9zDgnrwQyrcX9TMbdpFF6SKnMoTFBrpWRZsNE3C8m1lJVW9fARuITCuaMYupUB3D6ZuDjq/t/eg44KLZDdUyrFZ1vpe1ipcQ/UyDUeU2HHGzYvZKM8U+nb8HEIbNP/V0sgB68OjkcDz36JO7pO6r8zAm7osvU++TxXFh1ffnqXsgihZxPJN0Fp+fsl35PapCJqommrTEIrQSqLMFZA50acP3iJarLQTH17w/mV0wy1o08I6Y8Xywr+/ERD/ZWwyY15NkfdTW3W03BLNIMEtmO6blG6PCgQ15/tFeKExuFNtt9j6HPNdRLR0YgL4LWwoy0VP6l1FU33LxFxVfCku2wUsGEi32Q8qemydq5zEXSWDX6NC4ecHI6Aau+uDOgZYeQhP98SUFDkgXLl/lQy5MO3225xyLT44LxsXDRjFPqBVIpY4QLd7L0toULvM0T1Wzpkl4BNMbQVb9Q7+o4JafFbLIfpLOm3+/m8ZqYTOXW7hjUrsYfYEFmfAaLpgUDq9i9weThvFMB9wlYhcynvR0nSDgwmBUVFjZumozmsWAifbJOY/4H7oBuOsa10hT0LWy5GvVTZaqCA5DCnRM7kSjtpNDC0wQinpPoYr+LZIrcADhfkUaqTjwBi0mtRNbAupACNd55yU1sxJukP43Xbc6PCcCOVt+LkQ7B1dsR+SZB4enFYhzb7xMIOad2K/IAX5Q1SZrFQRkiHX+5Oin0ckI1EQUyJNPP/PhFbYCbWpdk55cdzJ6Hv8ZE1gQJ33o2qSagj/rR1viwLmdf2KnaambInyyxize41RpYM6hZSeVnNr75FAkss+0UjGYCXLzVuclRejrpvl3OtCTV2eItsfn9VXXUCD/Uvl9k5PPL57DnjsXpdxUAp2OMlKkUfKA7lsw2VgW//15TwvHn6NEUqRSLTNqCwHHWZADgG9DelKekqL5c3v4XQLwwXelFsPWRip40mkhZ1dWdu05fIvcCXkM64LNL3d8y3ivIFK4W5In024Zzwugx1L1fIToeB4PCkaXKj+eTg43ALsBF+UFMiCNzvnMTkpjhpQAszX0dqYoE6T07uUHOg4cjGzMktHvXbrJ/v8ChWgif4KrdSZUOhn5mpwD+Uiuv+ooTbtlU3TzoQQ9+lsKhOmIaBMMZ3oOb0qc48RalJbDc7XyaSAX2R7l79svBY83kQqmiv5fA+KmHdlpPti2kClMNENL8eLAXE7BxXIc9llMN7NiH8654pQ8ZfPRKjWwykiX17YofsJpa3CLvBSqxapyc9AZrS57V+rU2YQgdmsvlJoB9nD4Bliyr3WQtFcME17z4ji1HKmPmKOykVkUBfUgqiWyvGPiL9SH5teKJEDTBfGxl3YRdPkk7F5UwrVIcFl2HeHcFjzQBYgauRcVkfdLyJlLk5TTLPT70aItJIpR60tcX/omkxnLq2+aHC12nmjh7WKPz1QQfouCT+10AcT5tzRhbfOpu3ZN6f/IXRl78oX/7Kllti6MldnKb8zNMC7iUIM0i9AV7pNInJtBrTYq9NxKtMYTQJPnYffsqIapb//xC51ZG7VSGsQJIrzzG2h7U4h3s3P9p13QGHamsrKKM+r5Ps5t5Fj83n3llD+Zd5eFKcAfQWLFWU9WHnvxRl0m2HCGIK593xJLMQbRxzFA6tLYRwS2cmTrJxH4bzg9+DMF9fGHddvtoDXrNwCKtINZVjUE6sIoQgf/4M04lgKCbzuXCNi+CnVTSKaTwjARO0KdVKjYo3rHleTCkJGCrJ28rMA4u3gszj/xi7KglNIJwywXS1/y9We92rU/4RI5nkdTwO6wPxXrrs64jaXwQa8xggf+1bFEp3y7vkKifK8PiJiM12/IoWG0h/TYRfba3wwbbMQUj5XwMYsPsCzwY2Srtsjlnk+xsTWGkbXNGd6d/TsGtRhAQuflchjXTLje1gtggS/1lJN5TVOG9yyjBDYNoiINgZ7YUZ817sZaTpUWq1q8DziXbYtMC5Lcwy8KV/Swf5THPweUA+cIefTprIUdDOKP5Wn9UpXio+w18/3eybflKj4uMzkOllL8PvyVZo9KKxTHZvCV72F84ot75GdKaFRGBjQ7j1BOxZxtU0mMcGYUlATt591gRKMyJPdI1l6OvnWQ2zF9LvUrsK69D+++0Ru9O5JGDQNLiQ6TutVtD5gR4Cv4l+FcPfwIwb0jE7a5hdvhNlXptSXgV7rHUWD42/3t86m8REgn+gVnMwDMVMYgYkOiaVXNAl2Lmh7embc/chhgh+heiZQBklXmZmMpkaQocaZBXgeiPv1KTPnitS/0JjnDtVYtPN1Qd4e4Um+D3lOwzWwxjhVUQ6B61tuBLDZ+HyuMrzI9aijeV3zuLEW9xxYVMAv65hUq5kG+pH+oY+TOvPm2BwxdkHVfb4JWJ7r98xAym95OG2JZJr+1zh4OBsWtS5O1u9rnPE9vPrrxqx2lDdbCPhPaXsKFiTxjfK4+V4pMvRmERNg5G+dpj0VM6ZR7USbWNqIXl4CO/s7/JaU58LNZDl1ar99jqEhpiM8S106+L4+FH8lwkLjJMwiNJtj5gfQYhv3Tn+I9Yl9YwwuxtoNCRkHD5jOF4RFKvywLdNr4dcJDSau0in2C6xOoFqN8RBDYyBef5h/cyzOxgb49akSDplVYSiQ16x+5oCldNd0zf9s2WUgohH5vPtBIq4dQmMOYJP+Xb01ZQVjq65Fz5EKB0CnoPB7y+tornnYyGnl79ShsI601/jYc2ZucHNdEnbx3pjugfsHPGGK+ErrOfqWczuCDYQ4WHhO+5fSOW/RV5sYGrU5Y6jQdUdyCSPxfWiMit4JQol69O54B2Mq/AsPciG/P5UZjJ3TMu7yfvJFsegdGWUFo++yuuEtEbogL63BiWdUQjstps08IzKl0U147KNFa18UZvS0OU46Ok0uHTIbcX0Lh1iEl2xU9DUfLfbYUwPCoZU/LLsrEq4FR3qaNQNzpmjZXjgB0GVRKFiORcfIGX5qapNjXEq21NU+smmRY9u8+orv1vUYkkBRSc+gCaFlDal9vrbd/JcF8HE2A7h78qyWrPLkGKcTO04SngJLIlLYx351eZFJ++pJGrSSjIPT1swVT61KPlWjXu4uifQfmfhdJ06LS7MJK2sna5/u0o9lV/HU9DdPHTW/2ncIs7sKLDe1zQUMrUMA4ztVWrKLTFzbwRm6912t+7UfOfLEYrWliK9u1h3kIoQrczgGLO+895N15zsLEAyzwl3K9vp/beqBbk6UW0KGTMdlnqoid1jvuAhh+Tia4VsqLZPwmZ/DGvRwS05btohMlRpz3esxREMldzjyq5zPjJKmYFg37AcXVoU8va2zYncTgygNJjm02LXV1WjHcJCXwQyoy6nHWJydskAV+BYn91J+0kxfiDh2Wqab0mRU97uHS97lA9FJyFdPFpmhlYfpsqPjCLOkngP28eKbhU0W3ClopAr4o0CKCbTEYdFJXWzXNbgnarHs34bEuHLTi4arSGcc8942P+2jaFLvHQto9LSphobpRg2zAWKKl12nsbT5fK8DhViQVixfI3ILTU6g5Vt2TbDhLC2ziXjcM589rLNTvRb907awKltcQKjFLZTExMU8ZuRWoDQXi9X46bArfrD5KIUfBqVyG+DJat+6soJbtK3WPDDtV5Ha/UEILyDvXZMFZlEGBfhPkkbT6KxXCTwPCtWtjaFZyUx3jaHjIFcvGPy6TS3eharB4gLR4Bivlj4RUWEH4TPGggZins2pL2+w0QoEwidEJ9NlBjaGE7SmzBieRVE+BQd9Gc2vSKFRalld5J0hh3EUcHVWRyYt7bywGwWFAIUjBxw+9pgqnAg8NF3Ov4Vo1HuUoEa8Ayi3+Mo5xlBy43uQK3FdXZpqw0YhykioPcm0GdLSdZasxTvWTB+By+xuO7N90Np12hoTv5sVWSTOZ/npa3//2BBbn0YMm/tQLfPtfLz8EbC26g6rL5FPeMr3YDoNqsjY3kboK0IwYU+yhP+G9/jY2dsnFgrEejxmK+iWd09ztrH6X+yF64D7wtmK+1wtGh12wtKhvMVF2JMFs+AYpKyRD/yYLuaR50oekdvfbt+ZYGny3ugpfh6BRKjLt5zNcEU/XIqQB/jG2XnC8VVRjKZANBujSbJmTreG5ymeCI7+IBqZ6h8mgHorrjrn1lUDwBtxkJhTGhHphj5Yb90p5aPEW1Ua+HvyWdeidIxNbfIDxrKGhCXLddEGGa7s9PnlWZCk/8pN4LURB8RVFcETIWPz2tfNKQxUxasLX//yg6Qbfee0KEJYGeEgNQlr6Ou92AK5hLfdf0oCd8/tFjWn2wGwx1WLW8urRnAoXyHNZVH6l5TX3crLkEOvrnS6cJRg+BtvEDEF1C0wXoKN0CHs3LqXsZZ64rOCNOUlcDcdpMfd7JNtmzlCej7FipVuNgOihQAnMowv41t3rrYUIZcJWJTkdZi+hrEDHoLf6xKDtjgAB4InbPKWE5QhvUJK95LByV6V9xZL8rC9UZOkVu6iOl+kRWTQdSQVwVoPyhuHal9LImZuEZZyIaWpJpt3BDehH+d18cOe2oykpcbOtKzDl3/yuuvB3Z66DaZYKGnG0x0jSFfaPLMcZwZJY0wU74hQjn8DBTRdT/D2r34bRnQrgDRBKR8LfefAbv8ksV/oMZBvf55FYIJ3czmEbjS2dXrCtNltdHWf7yjk6utmrjvjLz4oCKsr6M+XPuxZDSqKL3DQvGBJG1n95k00vq/YZv6bAwsYGy655pbTtd/pEylIn3QKyU47zxxPK2C4hnwgJQvqPtRgJ84L46OHPOKQMnL4TNEj96GyiqpN190OEc5jjQwGiqvvAYt1Zv7eJBpjOPmxOdwJxM5Ze+hXVk9CX89JV/NDDZpNdWcpnc9QwqVj4EpvuLMU8TR61Im5vJZjteLs8SOblDll/TX496Acuv0NGVdpW4r461vyxkLPfS7bDWbprbcmBnxlusORvhcakEL3cnkakmCmdOiQtQeFEpiM5+9a794uZinegFnzwGDN00f2abp86mz917W9jrYYDxVxs1ujbq+zvD4LX4FO9x752unbvFycFNmBL9Ox4AzeNFEMZFor1gWS89RNkM/tomo9uPoHSjJlqcheAMOjJt6i07XfyCd/gHPMdgTjkME4KnrmEwWTzOt3v1yS0ADn/HvaTT6YSqLvXWouv+KAaXxc8TtinOcpuhgNrZJGfjLU10LZ5mIjk3lCx9oBAyZ5kYe1/IgHx1KIUX95h5/CgBFSnJy20H8iUbLJPsTqmSxVQVeavF7RuL/9eaGYiQZ9tLiBtMKADs9YrQib+3BJU/qS1y3QzYSm3VRFUuFm9wKQN/98FRfdMYuJmq8lY38kebmOLyzYG71mTn6cvcTAMmZKB/K88xoy2NEaC7hiJiThNqMUMhVg6Dzf55vtB+SCP5FXJMVXm+HUk3yp7ha8pRgks3iyyA6aSdr9i1U9MaLfN2LJSs5nmdTMxvNtqrOAE8YJByefl4vwNQu0GbMip5OSrBfC/LKXSQNUX6wFqluLdboXeYyOpzmtVUeeWfM6f+b2M/9twtb8rwpdeWqgmmOeQeDbBTo37Zi4djvf/N5x8B3TfYzw+PDWco5GPiAAMxZ+x24IG/+NyYLwmCVUBAj+9vil9mDOH46HWJ7Pp0vRleV+yKXuEG7sQ2Y9J34ZkFCR0foFEAWtFe+uHQnQFQ39Sgfb8fnKbH/LzBIWvURgHMYZRDh1hAX+c/UKWof9rHv+R6+geegLnP7cWglAl32VTIunpW3roGalYgyOpMyM88qKH8/ARPveQZgxxuapiD7a55Tbvfe5MgnT9hesAVbo88VdqqdEuBc9AGsbQ9dKwB4zh6rqDumBEs/HOhuOboN/PQ15LxMuR+CE+RyBc1PVZSdg4CAvdrEevcfSFlhkNp/yR+zhvDxoFvL8DtouL4oJJkPpsWt4Mb4uQNFvLKqkVVO7hkXeVSumwAIes2zT4fqbrZG8+aRBTFjXToRq+u3SFPtcqocMaN7FmirBrwC7eNHm6vfyqfh4Vnfqpd/nz2ksr3WRmkUj2qVBhBzBvcoQKvc11LNk5o7ZLwIsoMQHt5MJudMUUDPpdXlG97f5aQSoivbFe5LSXzCNs+tvI53dUoAtEgSoqgWv5Z+Wsb74GvAse6JpDQooxkFxGZtpxhnHJJAL9qusLs0BD0mEKMfL3/T7lhxanBag4LCCk/lNC4lil+9GxT+i/GGd+Knl859TupvXVPJFBrptub69o8b2TkCTzx0dcqiuJFo5vaf+CUDNNyWL3yH6o6xgSGCHgCF71uh9T6gG8AQqwEwq838M0HKwIIwSVr7AhpiTdAnSZzpQMIBODo+DzyaGGjl02e2e7i5BjUGUjpwQXEFMMaLIOp4FtFjCMhgkmJho3VepHU0GlrOW8TSU3E7c4G09Wvoxr47NUWkk9tTG2IvsqB8XEd63SdcNklu4pfwpriq4jEB6+pLRFl8rNQizMmrOKZBqVzv4uLHabkTLbRMjh6D0AB1959L+AGRzloDPmHTdjD6WfBACaw+sw4YqmJkkJkJHnZOIgpDCTVTWqV+QUjzWeHjc50l9UOkhs6osVnRrhSA3tZqmOfTWhA4ic4hmuev/Jx7yD8dc3Ki0jkk0KFW6BiZ2HKVRncKC1UBGCOV6k+K5Uwxmy53p8k0le0EeF2liCzG9TcT22axG1p/WnjNZsh+RrUbT+TooFhMi9hES9TRzG/GPp1Qk8/kpvdonnxyxlj2U8Eot1UfSBWFHxmFz9S+2zKaDAOCnw1G51H74sgY9F3xEW2NBhBTvu5Wn12MSofLsckY1zLQbaYxLpUI4qgHhWdEUwDTAZqb7pQdlrJew3fbxxrcK+rrmctDqLzYRfkDvStytB4IgMeWZZAlF/EBd+BieGC2n4I1gf/t0YvxldR22F2KIknOAI47XUg8WqSyvuLY+mTPHt5WoP7Q0S04nnpQp1nY5qF1x3QYPB2Y6tKiw2icn5//VNBNPJ8zCqNibgsVWSwpBBwQOmFp01M0WCGCStApSictcCdHl4VeSyHUDNIFbhBBEVpde+MnVRXxJ1HRZDi52o/sWxAgVP5o3FMLd/Tk3Zjx6Yiw25AN+1+DD7pv0FekZlsiuhVLg72UknOj/ycUMKO4mFRDKT1SQRrIN1jTz5bvJumBz4fdEyd3tXT17XZz8WSlvfcd58hUN2GnoFhGYrbhba35CfK6KhJzTPnfaHqNlS1e2y2D7njfdU81PKg8qK4MapZzbr7PzaoAM6NLaJaQ4j/+K3pO82c5yKdCcXawvDvbRkguhd18c6h4V5aVW999sQ8Z07CyAuQhkJgT3ZOmRpFh/SPRijmhEAxbR02bbvScMr2PfGh5HIPUwiX1R3HWzFERtL4YDRb2f7MEijOEVqxdT2Lot5seLgNJ8wp40TheqhpmJIn/F9Qm5+Uv+arhMG/BgAHwrn8okLlO7Bc0ZR6ib8zeWaBgSlIFpfAyMf/KhNFn99VC0dH33OLg5pTnu7j08cIc/Zsf6YdTlRoji89gH3tMERqPw+6o1SHfZkOWjUPiN8k679ydnFIhQAPAXmyG8j9eZOo8EubOk3I2js1LQt5vJ1t4nbndC6eceIeEf38I4H9rPiSmKLChgQ1i80bf56Ufm0b0qpCSba2QBn54A96jx3iefcl3K9cpH9fscLG9rudl2tbcFM4zA6cFvsdlpQ6HW5dpW+PCHvVLmU0JtM7Krzdmg9BDE6MSVpK52QgTNxm3oCkKhv7JPFtdT3ysaBLQv0uUVxPd5CgUjyRS/VSexElXZbxEWmp6USQ95cNOZmWKLf3PT3sJCpdJeiN5ueMzoKC77jgWa9jIXfPr2fMzDOp68bYFc1sb2NjYnmcvF3HAZaI+qsOIAJSc52Jzp0fnyenl4hB8Gg3OyHgwJV7g9u3qMSWLnQIZKrbRFTy2bCfn+hrMENB8Z1aMdoVaFiuR9xbR/PGRdbPPC2OHiy0y8RIm294H1AW6IAOKycTLvUGtEjaVzYJfL/r/NdAKNiLblGNbJsJSw47eQnFpkjlSSiB/H8YnMuzduQIBI3K4PfqxGX9BPMg5b1f71VR0VGcOV6sJJ4QJN8mzndCV4xv00nDpNTnZe8xEUwvD8kDBb4FmMA0lYTtsvSCxIMn3rNZEKsFCvdB1pid4TKb+eAlVqLlaQXq2SJcWnd0iTRyobIJGzAf5o0WgmatJTlqc0kRSrL+RYLAwS7Wkc4g/z210VAUmDpHZ9sVBP5B9bS3hx37GilOHFzAeKlnrqj/agxyRv8BP4r3TOma5Jy04x4xEU+O7yKBIH9VFzsZkBWZLVms4wMokc6IQrw5OSTMFnkt2UuNiTuQj2xtCVeW4F5q3NJO5kKyfvORs462BmaIApIQZvbUJdL1rHwZrFkRvVbMHqw+DcR+/OXD4YbZM87ZAtZ4G/SirnUAAQBt1p+9ED+HwF+V+oxEcP5iLpZTPAjEwHZoOG/CGT+CRJl+jKjz6zH+3KnqsglQ5kZKgUK2VX24UNSCpC4m93/1/1F0pGWQctN60h1/GLN5DpN9RBVQ1PZ+F3B7yH4BKtCQ5pa7E11uKUFAB8NrSGbrSf6qlaB3hsSlJxaAIyjqFz1a0N75uiuvAYe63ZDLynsEjStFxZ0da3VQzx89lPshKSCdpplseBp/43kg6ij49du+FAv2uxH+SxwDERORVv+wcMEQu6fbvw29gUwhSNtD959mn/zoOng763ow+rwhAnTz4BfldKSRHxobtzKUExyejDcE8ZtCPtdFcchcT16YhBzZiUK5h/R53lqHJY5fWsZhvjnICW2zEiHMlfEIf4pntEjpAaEWfJV1UazZ8CTeHUEny4UAEJPdZN0L8BMv8hzbCng7/jpRGhy3C+lrraYjYM7JnLQl8WUWhEJNx8mDn0xUKuvnDVfPyFkp0Wlr6AV0dpxyJVNUzB1U0yqg1IdiOE6TXzjRJbDSxi9D1jA+eqvrpmN2ODHkmjCVKPL9sM2jb50O7ulTU11zBaSq2Q0xcsxaWQd+auJTtiW81V7vwDF7EsrwGzcPH+cjAS1MObuPl5Xyp1a9FUvWKmow1SpuiUeavUqFI6LixFOMkEqt98vsDiaAOCDMQKmp02WkpXjLAFm0j0XeR9me92m9kmFY16vL8BInUkyl3sFels4whknl41KKGEDcRFiJr8cFyebo5N2RTNLUnY46cCBXO5QgbnL9Mheul5raUDKDrLd0k0oO77iy8YSsQFO3weKyxHIWn+Ak0rItGFKQ37FzlTJLjVeFf3ZAsnZmvSp5CpDmZAkgUaZTwgZCsnRr4Uwdbzy8FaURmsGEJy+G7xx/KT556Mm/nBU3V/u/6K0z2gBq5qdTuFYpGMVFGzvR2g6A/UBhBzLSU8FOueymnLE2ReiNyoCiuml1+O416W8UOC2jteMaLDCyaHeTuWLVk7mYGGJUTVhiVNW5LpbINC0aFwL9tb7yfhB9vdVWuUmdZjNTiLDpPOvjmqByj7j8KZexIg/V0YZoaewFg6BlsN06jsebyMMjmFq4/OCGo3EeFU2pIK7+FcKEROrWa33A8aEQc0hRLEn3ugQfDftsgZwyfSmN3ozjVCOFjGdFOFnnvJXYfgqPPKRdaPuqqKZtZB0kcoUisLGZuLQcV5lIZq2/X4CvdS8fiih6dDwDuLPUzAsuJGjI8AEeO5CtFc2yMYLIv9aXkgPVcvxOE0R+EOA7LOnJ9JnSArfPT0/4kEOdf0ytKvr1tJ5ikuYNCPhBre8F7glgcbGsJHNf4/tXjFoZ+Q36q51Z6lO2GtgFM6VmqEfEBLnfHqH4bZspSshLEenE7LzF3qpW1hkfFsFqiCiyjG+z6M2HNNmhEfRCuPfWLhx4MRWqOZNBmxsXeGyN4HHoEyBzRN3GqBjq3+1krQbhxo3l9vhrwTSgeycZrGP18HwKaxYdDJU3OtMQKIt8S9OqV0duGl1adalv0SJng/POu2PKhzudkeB8A0Xi+7vJHGPBb8FifdDa+iEHdcD0khJl9pV6fDhyPVuKvRqnluCF/VAlwBKSyW/10VPCCDf8T/knVwatfhbUxfij83uHQ6RnVm2JgA3ayO6bRcIbwcodyrT+ewP/q5JgFwm1otB/SFC/fG6/gp3BigckgDZ1sjJjtsHC+G5stVX+WXtdEVLyR4vi+DWeUEWMqFyoc0wpQwYaiW1ImUu4lRLGN36hnXKIFobfZcSsYSDnTbRhKbuvEoqaRQcpb5DPbmwyqXNzRkgdG6r/NQcj5Ynmh23BrHYXUoy69aUWr4EpVMqtsimWDK7S4i/Xy/JkvfBvGe/acDw42i4SGYY+U5Zpt5DaepsgcjpXDVuuKbUy41z3oqcu1TW3/46ktWApUTbvC7HEZbISW7vckIer9rHO154guGaRPPdWqJjocxal5dsvfYcyTJam6rLF5zjeycH7Yder2prexZnHhQKUq42cyTyyvz4DrBsbhckwzQTHz4D0Vp5o5UoRRMQkQ3euMj+ZhczEaLBOHwJwOXmcBHEZy5OUnzff7nhkV5pWFoVTJ1G1RJu/gtinamB2udh6M28Jj6OfCBeKihQZbXwCkyZ0h29yWQMMXrAmEEBE0aPEtFUW0mBKtQq6Q0YmkGN5+8/OXY4qrVwg1zrxGTC713ScjaAZn+bXoip+RpOSor7ZSsmcqAuT8FCTyb7HhX8r3nirr/5BdnvoGbqm46u36hKoduyQW9kPgOfWkEhQYEXW7sczm8xaws8mmHwjYJtspKdZkm/XLcNPRrX+RBEASvwl86pEtfvIOrL+cIvDI+9bTcJXVfnuvbLi/CLVasJFcJ2CV8NOX7bbNj/i0KTQM3lt/8luDop4vidJ5C2gHUoC9uXh0u7rvBbYxdOx/prQ5vFw7moLaDaFJsvDk2laYRpty8ftVjBIHmLeOKFJDhPgpgVOMxwkQlMQmviPacItr7Ej0a9B5CsRCtRXqKnuenizjNavDqyCczO9fKFsLYQnFYSj0KXNa54hvJgKacVc1Xgxzc9eYhqDCS9TdBhfqKFOr4wp6/E3HQGi3UmAntuFk7p2vI0vcJB4ePDpYGcLlzh3VGxRmyUevO48K5Lx/ebaQw2wxFc7+Qb0QgxK3zxtC16MQqfuXPBmMjDBpV1ABMTbpoAkd+XNsDbobIlidZ1z4j0I5NLC/WoTyvMg6NdXSABtmjspHv4gZDRAOfJXmNyaY7VhocxPTz5N60lEXzU0Z6nJZ1BkymsjnbupudQzM5NZCmVHZkSpiWA2nxsPsZbCSQKCHfQqwe403Bk4hqZklWxDTEJbmeOI6nDl6FGKg0oL9jrso7TmUqvRUlT9/mpyVbuzj14Pnf9QKbaBtXE91wUz2luqq/8yWhkSMNaB/pERzLgPrLjaV6Rlm/FC3uav8J2qhiK4FAonQMy5NqdK+cUAZeZRDGO+t0U/7HYxOE2giDd/5Dsdx+isWklSnMnD/RE9at3cDORO1oP28uZtrrTbGTkQ8pJzCm0XYbuyUNANAbiUvZBMf6R6wYRiooimVY0f5X9gkR3a3H6KGal6JRtfNKdHIf2XByS0fe7c9JLdYxsha15MdI0dxfAgJj9fgFWLADzrKdMwmPXeln5mJ+oXanchttI3muyJBevL/J6LcQopStI5wFMnXu4lIxgihDcHTCrJ5Sd7GiK6MREO57SYME6XwJNZnQDtkvEb9bjrVn5s4CdrbQ36d7K1nADhBHmf6zARgqYpmf5QqHRGaoblxHZLqYKDpw92WFJNcAL9sCNcxkJy9XcoBP/06dnhZVgGjMzqnqiZkZ4tfJUUofMnnL6Y4c4reF7fiHvnWaYdoEu0z8vM3+sO6WhBGja/rgpG2pqfTjUIPBi3PZ+G6lGZHxqo5XQ28nHvLSxrCfiA+/urRK2S5v6FydbNhfJQNKjq5INafde583tc5SO4umD+RSSkegtY9OeSolusfxpXGVxmBTzAHRQiuBjYilpE4zdOM0nZXvVKkvq475zQDLhTAVpPJ4ddwZ70O1XTfT+lfICIcgFm0QyDFNvNkyXGi6mBHg0IXG7sjsE+fgMQMLh19MLBxkVopd12nYnvOtQUkE0BEnurm+CA3fxSDtT42hO6V6g2AaW6PwNq4ZNCF/mGkufF0veuoenso530pHEilfpKE4nDRX3hR6tBDNCjj1M/oCjMDcgmNx7dvoAPyKVK58AocS33QTgbldAO+7i368fzQG0reK5bXZ/HrOTDV9G5aONpxyJHV6aXR3Nkv76qG/1fd04YtA2A0TzIiL32Qv4KLaxnxCHCfyNk+cNgf1GZMQdKBz5BywxWCs4W2hg2aV7mhy+729FsfD53ldBWDRflLhjgeboybdG3TF4OVomaz+tpHbc02TxSQkP15w3lJS9vQaiEMPDq+v0Z9Dsps7btFq6nUitt5EmOXQj4SvvxkM2/9J+00lOtsSwJWtSzA1Lo+E8AyGGKER7ul6fi7wuubIjafB0WmtHM6vNv+ffsobTdHYn2tm1uGBznL64p+AdVqI6xlwCPhoJHgEFYjUPC9fSadsLRbqqWvYKRtm5wFjaSVnvUvSAQSd8SCuCke4jOTea4V370r03t7xpoUfT+plWvGg65xQMKx4h2Y8pxxqUVbfFp9sSAf0HpA5dQoh/jFtEivWPDBwczvFR5608kDjXZ+nou2DYfBnIxKDQtLk705HybLXtrYmtFJTgzDWMm41lGWhKRFvKXdqXN1ZnpWoJFUGH2Z3OSqRBN90rnRqEIWnl4m5EPRziw9heCBmex0S6idLplaPF3vICcrHsmYTIE1JSmjI3xLo51Yh2OtEkGEY/yKtUXXQ4ztK8GZ08oG1WX3VFDkLdiJmsH3YvaGuTiMpEmzq6+rdZCRpvDgP7VLY7IVf4ivdy4b/fsYDmb2Yz/0+Hsqcadm9ukPEwuclGofWdMe7Umi+RHyCvO9M1kIfieaRwHY9m2xXE+0pNbsCId/+io7U+P39Yhx768Umbd7irGFeO1pliCwcexqkySKmvvK8CPQJkzlH3cegpFBz8a2fB6uC6zzvw0VwNoQFKX1SsroruENwb9GAG9JC/0dXnnpkncMw3F1keJNQikUtXWyfYdZjQD0l3tYdYxvCShh0QMB2dq3u4osnY80GCUK9JatoHwOypbDoCdh7Bgk/BDqUfsBdRe1qyZrvA8UY+20E+/Oio95U1FlnFMf8/6XD1/LtuDNJw8G4Tsx87v+KO6KUdnutA8lhoZ+kO1MgteQgUl7EFXMoC9U45gyglH9ABxHw5iIMO/UlJvfzROgrlU+o+yLNpJ/EvBG3XZmdpN+ZzDoNuvKAI1JmEpXkhIuxiJmyaXooBi0X5GQca3AjtXfElXvBBTn4qqTjXfAHbR/AOmgZkSiLegOg8aBOTHUYfsrd/FLBF+udDqASp+ThKRLI1CaIXJbsCgxza5PsgnWLdKbCWaD4fqIswpF6FPfaXanLyuKFIGgdM+ndcpgpIgaulTOLbe0LADlucC0Zhwg6bSvToo304sdcGQeD9NIiXMlS037eB805LX27sYPYGov+6nPpx+TQMFHysx1P54O1PjowO/9tIrVvAWHl50gcxS4CxcW27+hEPYFOdc4jccYoI6KbzSBioGBUsI7/EeoskHBDKDKhh9n9D30UEEhkbvfZ9srOjt7nDmkscoEz3j7dE+cU01+GRAFimYj0vB0IkhCOseAHc3FI6XO0GWOrm4Q/CUGImxnIGZlcXb14/3O5/v8hd48TdAwW0RK9kLMgo4Ea2t5cYYd5GQVMWQO0NV/4kRWcTdvAHk9e9r92muEr9l/6jg9xWDniXLgjCcbl33kCpvsSFRhsn1Yn2pXEBEj0ahvitWCt4qK9DgOeKl+WTbbBoaVorHnnlu+Nl2blIAixMPn9XMNM7qPrWNPdffcO0DLX/Goe1Rs5AatkQLUINitL5CYBvtVJBC6anK6sfjhbwbQGTCR+xwiExBW+4NdkgfuQOqq8tSVOF6RqM5yNSDzZ4KovDqpIW1+gELU0zT5Cd57TUK7CwOx04zi/1X1ocvOTjqc1dBrwD74Xq6RogptclXzwNrS9UsknCku2zlqdcKfsxw/XVslhmyyuAs0a3yweXZPyfBsdZ2h7njxwgwRFwOMYkmopV4u6b5HMDu+fmt+nx5XfNQzfp5pMw3n3ZH+bqivNv1N70lF40Vr5Al5kyU/mJHzD0Fe956T3kh3s/v/qhe15v2S4H3ji4jSGIOZL4imhrbdOIdvJBYX5hrrZ+yCz6YWiC51F2B6uEnJQaryeq47uZE9/MYoAlBO/MYSV4XBg9L+VhCPZEsprqLN+O59QVeVL8T52sAi6L46V4nZL8kvhfQpRGA49JZF/DaORbbXVeyuR9mfWlrcra67gymYvMdQ25VQmsnCWlXvHa0G74Rex3lAZLzjn5LXvsSukal7G4YLaGxeclm6J6K8iBSOAktwK1NJ6m8jXozyyuWXD+KIHJGEDaMKzW9ZHgrrPqiGK66bGmHgfYxg0/OpIagFkaFU00HX7MOTP3A5BsjYHGgL0gwYC2gyGmkZTQ6VwI/j0vnJyj+x+mDsPBwgqbE4uY5V5zHdu4cvncgimIaX3JIPlxQWyjpz49htLGTUctiqTS+4zK6YIu2MtfMZHRvmEqxNQdq8nRYCarw28iNaY5O3aCdHDp2289TwMl+dtoBS7ZghH4FDNj6yxtQARrtM64YzxdsO8EJhxmSpRTxSgjQf8PIOiT7rFKIcMFQDUuMEp5PP0QMZ8EtXT+Ghs5mTbnhrm7KmKcehqlTIshmhKw5DGHIKdiqOU4XmmAF4X7dRc1j88igz3LUx3js+VEgwxdnNsSpuBSuGFOL5BNkDjH+xtIFP+n0yrZLIWkOBGLtQ0mr1+J2AniocDAaJhXKFLqnnlzh0kFu+0WLKkL457pRWNELO9ylm/oyODJ1by4yDweWE+yiU95a3zLVV7Fcx29EIcBZY8KaIbuaPE9/ZdLQjVkRV7MEfRfOqSmieqQJZBfKxOQSWMmQnEjyjYtN4r9x/Ssbw+mxoP6KWdDSksw6hvp4+FRNdUYc8tS6BMxv7gbQLsGNB4t54uVM4nrCj3qzC/8pp52ldJjP08vv9KU45c6+cbky/xNS/uCx/8whXP6M4IBJAwTrxuhWVOExdhOHoY6AamEncv22/Ufm80tdTMBF63UWaed10XOLlH39YwzgINYNzIXZA6uN33V+5u6behNVig1xYZ94rz8+kk1MelSJnbDGHzjCAyFT9iWTEjq4eEQgTzQg7+q5CTqigv/YOzZR7NmxHVZdWufkV8oZGC3d0o30W69217D/1aB1h5uZA6Er/JmnBdPEYIXJrP7xA47E7r2seuwW4h1bQAWf25XQvPOQ4B39jswwSr6LmtSVmCPAflHUrvJQujBZSo3i5rFW28v1JdrcMoK6xxZdfriy4jccRxqLVy0wu+08+GBrBNWSVVdM37atRiZ9hUz8sHV7LEpd3Tl6ZF5DsAQ//1WR26uYjZYx7G8exwZKGAMkqTyWuU4vL8q1LQX3aC0DwpGn96ryPwWJ/wG7r843C0uvLjCzcIGhJJW6k4QdSJAqZMN2CGz4lfESyYwebSeQG3oJe+WtWj1aSCo3Do1rO+btVajq15nBZ5O8TOYjreIBukaj5R1y1n03d+/eZnfhuS5vBgG9vDw5CK5STcPFvHWo/PR4w2JNs8/svBIXrpx1vc1DVmAApEUaLJXRuKGJElYp28EpPuYwIVjZSi6T+0+dSp3uGZ2yZ29cQqvL3AJ17zqqgAcjjYQfERttRzvhCgwow4rdDxvXYTidSKSok8LCkRHVx4HMD5OWZMk/YxsfQMwl/k0T5jjuX8164SsUFllaxZseYp2vvpNNwS6Nc19jv1lZB53cwjV4d6wDy8u0OSeI2Qe3OwxLvdLt/ZxmJC1cnEaLk1RRZh5YtdyG9330gPRDujhy6upqzGx0nZWrnuww/zqYGb8GMrDCUXFE9ZHSG5R9mhy3kuYIFKGJHOJIu/msfVm6HEg3nclALlMSFYXl9PxoH4xpY5Q7GPyLX/L9yc4Q7nWU9ofx1yk3cKEnbyfK94uewWbnMFY0//uKqkDJlLww/raG4HNrUJZtBHeLW8ebZuqbR/1qxkWIBvn082ChkDMymyxLtyMe2mHHmqzi0BecjdnxQo87EfiLM3IO49rfADBpLloxAkoX83C00pC4wzLupK5nonDmMU8xom8wYumsu+TLUc2FzpfIhonrHTthIpLjIsEvIByj/ZgKDv3/vGDO559D7JlvCFBSvvkWfF4gdVsKZT3OXeqKaks44nWYzvT/JBkxWs9yGxdAA9IKSJMobpWXvDPDDYCPkTe31Wf9h8+5wyRwwWpOXcoNG/AMBjGDR2m0s7/xIBUxlBgMdg/tdGwDl6RJUH68X5fXSIiI4aiPTxY7yuNL9XeTHT+G5c6a6rr9ZTInsF7wnTtYvF3PPUwlURPI092oghueqYsVj/NXMk2o+LRBecmNyyhxUf6Ugec6OXb7/qYQnr6xsJxqg3Fa9Pb3Ku72rw+/jS0+EO4LwDSDW1ij7AN/3fCMcxaioJO+9jK1lNQ2c5cLZQ5zkALsP/0KH+h5pvXPHBsmgICqytrCuRHARU2MC1AU6scAFyXVIP+IttDs+lPgaW9XlgJH922rW0E5XDoaiYBdo7Sy/r4DoWW9xSpd/xEeg5EPSGc5/mFP7bqZopGxTrsZecPz+3qv6jeUchuysJjXOCFwMdKL/eXOYEKRAHKS5UhVx8PHHMralu7Oh6NenEywHqfcfmVlPU8kmmlA3zUlCtXe27BKtWAVNPB5Cnvi31TNY8gxDHaEVxcVmJvprFpGZpdbM4nZpzanJKJam5ChJ/oPD66OKOsUnB9qEDeemM2Tw8DgjgPXUIYgbqyyQfybcy7gtnywvuswYU6XjTwTQRRaWAb2a4dc5/9THQPWbQFbuEuihlyN/wapjJ3zIA7Gfpyk1Gat29pqoP2z1xUGacyWv/0F+qNZndO3leDUI7ABVjzxbdGbudBwytK3ETlx9Alc+vBLMfAucG8yuy/JdSlk6J/fhvRlWraKbyt28uXJweckGL4HqnOt/UAMAg1u00sNaxP7yHEq3m55+XrHOp8GCSyERdfMGc/NaRPZTqE5HmwmKTgGnbyOl3MozamaIALAZ1SG5lbXBHJ4dXg04/q27w8LgVN1GV9BqHsHUFQbSwRyoCuPExmIsXkIOSntNZy04GqEFzW4Lq48Q79wnxgTGVtF4EU5vaniFRHv5F1/DaWwCpoT2/KfawoQZ33POZYVdt/wThZAEC7FhyXhlDLjfDL3DXwAE/VHqpoTdvtNc7H6mwYROB6BLaDvbvLnJssKljju6YtQtFSGdZtcLEIShSjYnQMKCtRw+MdhOA22wYYDfCcTaJlgtkmXXhQteUsG0n7ceBw8L+ENNeHrtwbWoa3frjeYN1UKT6lmBnm5ktsv5oindOMBlV7szKMQAFsq/LgBEkQpwj7wRuwtOJti7x8G2OYrF6tnwIFMoJDk2AU51IVzXKMHtyiyXber1VsZ98MbkmmmmY0jBZBWJgWgewUOJ3CtunBYZhFVn6VyR0GYzNA3VbY7Sr6CmangsQ1CKvRMnriaf/qcEJLz0fpAGEz4E7DKggbq3PA91BsEvizqYBZeXR/FUeKkUu7+DAlAZ1zJG9vwEeNPae+9LWOMG2arsM8QVOi4EJvUkbdjkwSlZeK6PTlZtjt9GSForV+o0EzL+P4erZdKNnNgpMYENKjFFptwJ0YGQ92GNRWWxyYiiUjN+753saH554Gm0zkNMIw0g+7xJLuLFTjOOkJOA4qIZ9VDCSnYF0qQKwr7SsrK9GYMuNJ2Gb32iqLvl6uLyqQYDIiY0Z7RH7qXajdZqovqNwI2BWHL5kr+9i1QYpBCldFMo5m2Z2gJ/i3r1YJ5EDCh89+8djSJy5l6bLemZ+wSLv6AlEQsqk8RPEXoAqi+T3C9vYiMmbXHF6okTxx7e1dg+6d1Xx7+RJ5F49tAXdQaejF7PriYsXzsh+svjzphASAGMkOTjcesbWmckpMQfjoFDK4qVvy2n+d9FsYmGgzp6IBlGSkwL85H+6fBGK5xlph8Fc7zBKcGD8zoiz2DpULHQUnIHbnR8BIfUCQ05faJ5Q/vbu0/mFbs5lwNuvB/NOCni/axMUabXvJQhaaPpZABfNEoVTzkZEkRVQ3V8gXVA0ZqoHe2ddi8lrtTnQL8FOwRFKZKEgOOpOSoPbBIp5OH3AkuaqHn+v5aYgw/jcZZlFY3wFL+V+ssyfsdVFQsTTZ7oou6/6VXU5FJM2PXEV/ujPsLGJfVnQF6AaQBhBKlGQ764bfOvhnQyH5ZSNZwAB4KKU536W2D2bJf87oSMirAdGv/aH7POEx1Ll3TRTciNLTEUneFfCyCq8uuTvzNTg64uLQl3QegSgsGckv99XCzIi25lCT7EJUAwE4sBst22EvE3NX76ez/n8qR1C/2iDHNBFBypoL6/bHSCWMvJUfPxkSbJSqQOYFn6diMOua157YnpY12ehu+RAwNHbx2qHYfKRwyxcdaycleJLv+V8eNAE6f7TkYfEODwDKwj44LCEj0R+C7tcl1QJIhbiCc5fKRteajQipTPARUBM/fsLEQr55XlXq5VWmD95iq+6VpBbARn5koTKVqvUcGHZJj54ihUTn8P00Gyq4OP5EojRwPKv3/J401ZA9Pjn5gsvKK8xTuADb2eFFoAqPdihPLu+jmNn5DI4xv7wYYc/6E1yuMscivApnnWIUAkXkS1fvSVNeO6xWCmvo+W2gxyQDKPrSTUm2/CbUVwDEk+QCHYfGjibSJyPEti4o4hHx2QiZ754r5/ZN2kAEjRKLGiem+812+aHhuWT0lX8lzLwsqApVfhIrfDvpoZeG+AvAccH2oP4p4yFRG2xmY5qFkTGJsyjm+asteyJuKDZUMDHLW5LA0PgxdlkDN2qE2YFlcF9HSIAKtuVYlHmPQFvFP/NbVIpphX+2f6h1voggcHTI8vfQwlD+WF0MkHlAZyi7NnAfWqk8yAu53J/nhWenT7sW/kR0zkcOJJEMHT11YyjbR9NTY2qOV5JpoaTbgbNHbcOZEAjFjSvrzlKNhjSJ0qwa60nOnW8Ize6mKDG/XI3nEQdyA5CsJCYU3rzH9N46+aqUN6K/go3bKaW15IsxIo2IIb2/AF0wX+J4TzoDhkyivNexz9/JNqVgtR8ywWAx/qoG3OfOGIAUNsLDwue9jj9jNHF+I5IEWeO4HeoV2ymg1ZvgQWwQZ/fg6uA/jQdEhVwhhHnEB8m4KrUvIQtLp5PcLKLsHUxq3z2pqc1dOYvxCyEd+giZL/s2kMqLZ5+1DjSUhPcRpXSs6rgzYS9Ecknoc9ueHVp4yeMbxigMmM8vWDcKfmTxb9w10QYOLKb8kaTXA4gbEBy4Nx1H0pVttqnQQPtjwSuhKo/X8QY4zPwCUnPfNec3E0SiuoTU0IdeNxpAL1y8JpPcUZKfYO5KUjwhfGRz1VuCr0U+1NIS04yRkcJ+wEHAu6oAAo2OvO4ECRvnvdP/7OxzfwuIBdsGZZNnsddzClj1uXiez1JmW0It2+WSVUVg1JFmmoC5mt1IEbcKDTmCpUtdX60dVgWB9JKwwSyhuHhZ8f80HCu8qZFWEkE7JDIh34mGQfIn/e1jp9K6opt/UOlX8YkAtqb3aRTkW4+5yGSJfV1tBmOKzXE0S3MmMWMdsZ/s1Z0NLIfXlyzBktglH6YwOtSENpR25VGjryTYk6jL7fOGc5/gt/mDHz04zWasCiKK6gO2NUEjHxw3QQ7mAKcrKAntH6FfdtfFWJ7DMX/kWK3296SGCeC1qHWBAqNJrrx+dEUSsX+aQ5KvT+Npf11XQcHHtdjWvIh3I0aBJf20vKE7/aGhZFrKB1ouFaK/7nxhEHeyzGaIuDlLXPtqxQ8g4wgXItRVLVqq2TvMNhEfjracmYvReWO7X8BeSTwWNYYjbpvadg554WFINz7/RyjjgRGq0NTleKfpPYwYnnKsNz+pp8aGgLP691AWg447ZcyLnO/BFk6G46G7LuJwUJZWqwDrMKtuwHDayqjpzKLxy+7YOCnNut6bPEWsIj5l4x8A0z7yjXj21aB9L6smuLeiQibSmJtbNOAVMxGrQFGXdEO6V6Z2seFgbiNGgTnyKFihLehf3UTDxho/F3zOzKnXrV3ODB9oGE1YaqVV098fup5jpN1duG659mbkJbvRc5i7HcyAgXlQ6AahlWDUWWoAC0bVDEdCKyojmrmGTAsOODooPy4iKGbEfZ5MzIUSlSCfULjHBoMHpCXzyzBsAan0uwd7W2YBBUMCmbZyD2W+3xSUT03VW/bY10HePQrEt3oo6xBZXHN9UhiU8fS2h3eZ1Gk+Jt5hCB+HdRaHrWGj67sLO4W0oXnaV2xJZKmg9f5IZit9OsO0ibXp2YYlgKXl36ZNZykgRw1kmzsbmAhp0S5brmnhhEsjBxx0E1hGtkeJA6EsARwP7eor9PFvUauinME3d9rhTY909aVSmm4YUSORhmZojHY8CaJxPZhA4S5t5ccc5XEvU8en/GnR6DYfsU0hk0e7qx26VhY/gFPfGCKt26rzV6aEY3anghOKtoctqXS0OnYSuWAkyzeV6D3X2c0/GCt7iMvKgC7dj3U2lBWXFnY4pATQBxCnhMvkjkmoRG+O7VIm4rdbOohuSwyDdOAGOwl6Y4ckmIL7bNGIPFQC2U0xRQw+Aweg3/3ovWxthbgqbZo9o9RDmDj71CNgDbc6XcVprPz9ZSf/SNrexkQVONCir9ftdHPCDa0Dz2My/ZvENjEcJWJMiDKLt2UZU2qbbvLMqWYpPRnJRWtFWpixVO9chbHB9lDp7aYbXWl/j9WovoDCRq7IwA1IYm5esR6tgXYjt7p2NIoGGwX2UDerUs1rrPnyswiZus+K+EtyYLhssFiT5Q6sW6+sRKsCD9qZIY/9UhpPNqz/jGfNi/UAPbLvzoApXb+Dj0PyOdm8o23DzZ78rAN5yJUGiDErC4gSkTuSenodbRwX2vIOGPrK5emOrxS+xx9CM9SN7JL+LziQx6JNVRya9Wf0HTFZ1TVI6ZP3kybaXDUm0RHiVCwyu2ax6xwe5j81QUYvINrwelrrVahiZgjRTpAi/qRL7XjnHu7bTA/g63T+Sif51peD7o8DJ2lHBQfqgmGbikqq/u+QQYUKnjxTHCqbtSWj+w71nLDNICTNfkrfPrlDbDpNk1IJ06lAGh/lS6lYZetrFdDqcvf1GFTuW7nOJw1wGzw7YgYB5GDUBmvwPMHVt+WuzdUQP8HiXJtvdi/bRKDcxcCB4A/RwvwBJZgzqo6+sWUsNJRzOEBfFa1uYffx7Ztd8X3TTfALGAGLan6WS6gB0e3LDbq+O8jYtbSCK78MmqJ84O4RfLQhXjq91nhd8dR4bpCxznBSgHBJFSYlu94GOUHkg/1RAdQxWG1acEdILq3t/HZQ7jSdhhNpoeWdkWVHkshESxbeD9J4p17xLuh78mH76SrZqIpcgHibJQbu1rp/qMAO4f7FnoLDO6tYp0g4k/qPfja1s7UIsAbirXxOPwDcrHO1qhRdxvgSGmA+tacGNRNeYPp1Gu+0CORkWPC7n25m+EHgz0DHZOlNCEKvleVJtPyPt/nG+FKr4H0eG4Xm4dSVXq6EWgZzS5lL+E91z356ZzLmMjLrfHXRYmTPSbIxe1LNRViPFK6q/Kiofmrlya5vb03CLuZB+j+6FhvGoXJvpRYd/1VVlUi5hlV8SFPuobjQXpUG5jXJ/+UmLGxpgFLwwY1vCIFXN/8cXgVN+8UT68uWfDn9GesghUNBZD8o8//MBuSobBYKWwPVXhXW5GnNJvqvo1cY0pmgIqCigwPEEACIiT3e/8NOIL26xdQ2eeR29Ry944L2yeCCNIzQUeG6Vwr71n4Mxa2qKSdsNuQdGcKIy/r4yePmniI51NLYfKcmqfs3f9Rzn0pwYm/jqd8+KLbNVQnD8OjNwTymzlB+YiKpLeTvWmcJNl1Fi8xExRPlLbip6OJflf4FDHbqG0YbQOanzDHBaHX6ujEenfhm5FezfI5aWRIDSiCYCABbwF4qZ6jm0mRMbQxl7qJYEvkIAI2Bwn97ibEMekSR7A5D9bmQYbLTaJ4FV/RhYulm7Sz7NaMq5rv/SzEhBw/jmj21Vf90klPm3LPHkpdpKtNFDnT8GmQYTLCze9+PIEY+ifTMnH1qbgVY15xiUAJbID09kIYRnrnuK6qlmWA48CR54/X2oAYS/2vZueqEhOwYhYEhFuJ7fG7ACNENenRT2ZVFgcGGvqObJWgVfUyYXtFhalrI3v6B+d59m4Ty8WHI0BmdGsR+0W2iXeKU2XpW6iMjEUUiUDLF8SVDXEr0gcQEPOwGO8ckTBERLN56Xe6cVme1GpNJwh8p3OD5gekRQrs/v2SZGEjr76+vsQ8s66D9R8avSTPxUNmrtGMtVMO4Hc3Hd9BFyCuPHg2a45tjsuZx7lYnJAGcM2xwDRgJzOL1e2UISP1E0iUBmc4cveMVBtCX7+uU7+j30k1nr0Oy/p8fzcMZ/7zDjZ5KW4gRN/b28ryYbhsFkWJqpoTbf+87g0uJqUhpy4m5DKfQaXAS38btOoi0ZDFL/PT1Vn5wzbiaQ3WRRE+epAg00HObhXuViIKWtou9pO8gmTUq1vOY22aV9eZhFH9TqKWnaLm85AczPyAFuMu6a3wBO1RVgGKpc2wqjl8VkI7JBf87x1aIOr39/4BZ7UN4UOapepafbxAtK6X6SGXacKjJNmjW3hgsgShTYJTU4BJjhDKQEqAzXDbhcKNhprHe1eUlyELRjLFun40jWzQJVZQpbAnhaCc3BizyetbBG7SMkeigNIokosuiOETtfA2EvmoNE+N0l6zbbjXkck9uIW+dR0Hmhae/hx6bdFmuDvHXuySAonUMVhGyX2Qw1NQxXU/ygrSSneE2wgOXF2I/SvloWORY5Fepn8EcO6Be9SnvsOX0+0Zd8ZOk6FmdVIyc0vVKdFnDUv43Dws7OXz9XhPDoh9a/WUvmCwFwbImWL4HbimT5UaLCIb+BB7h2OU3eMYht4QuwnslsxTu1MTEx0NHMLAqfVGQ7uRP9KjlvLQPhUmofHgcaOkRHo6WLaTu+Ssg1FUHOELBSEhPCqvbIK4fUKAUoKDf7edkgfY/IiXD3spJrhCWzUvbUQbsdU67zEHUqX9Nnpi6KngVtmIHBXeiL46QptU95O/QNEvLnrmZj0IWZcyP+2s1a2rL4EImrsxG9mfOEXybuNd08GQ1ZQAl0xDbosnmvT2dSKZy0Kre2zGN1mCUqGRvh/vKBIc2iy974dBVuSPM/Oj1GTSmZLkCHRycZCbp9dUuhhUmknql1pf1CdGebfyEE4dsQYZFWHSx1YEawEt/c2KIoy79nRYs63mp8kVL3J29n8AaGOH7S6QFmWINeJwrS9H3yl0Xe5M8O2Im+KOTGmE710rFugHLRfozIe9fV+/ggBDNiduqKWb8LupWHl/yUq8MfNwn74+1ZQ2OvhuCUat0gG7q6/FBvI054z6fjxtOzqKxNMGxtSZv9o93GCSW1CAYA5Of/k5ahRl6iPDCCRRULJxFsg8+Sw3K9s47ZOZQcul4ak2/uazYcxYodxkZVC5Q9V8aCv1D6SDBO/VdbFdSno77XZoSy4N6U9havjW/dpfKRIJO53/UG5WQsx7tRoG3jOY+PPEqYZebDmFVam7CKPb9qfHs2ABr6voFkQtDlPxkCcZo9NhnfIIOYyjiFSlVMlKylWSEQ4xOHscWeeWEb89qbt9GBx9xBnWeNAhK5r3v60vr6oI716wEW8dQ1LyiOfeL0C335b5Rwb0Y+4gGbFpDGAiyrBUiwAIUG+chUE8HwaGsfPdjYZ1hCwtNb7Qg1ztZflKUnJD8euSoTWeq9yKN9Novy0vIkdrGU9Sy3+Mj40tlrV/VHbNLeU34qC6qsBV1RDF9lTAjjmar82t43esVZUv/7BBdyVWJFUwrwnywj6mOgYSz7SQkVan419RKImbfCdmMxsibxZBLCgE8mAez8WrpTkHIhQ8BiMmhAvfLBStYcPhzmk0zdjocXomwj4LpWwWnDjCoZV94bYdU9d7B+zoe8sLScHnAjtMYDTada4hbbBD8BvRvP5FTydOMb2WBLeeCBsiMPxtJWtUwMc1OlFpbE8gcRjnisFrA7fwKtC4NesRiG/OqgxmYcsLEOIuAgFNDVO8n8c/JWH8W6oUHayJ0ndOkcizOw5JZmdHJfyZFMVb22YNnVA/YLzpJb3F0T+AIY5z3e3mvuDINIIlfjagsFnYcBww9QnJEkhrwKwDJJ945HjcilJUjlzF9VtXh5JiCxQKXhAiwvCwOITFimHBFViaBs5MN9M1CDZC2AiMvGKUarYq8X4Eel+bQotLKpcAXYIZsb396SnQzgvoiAnA+b5AF7gxkQi+5VL2OrMNoTB1Xpfgk+AlKhvIWe52ezeOPf/4YZegVLh2AB1fwBjjgpjTj9D0oaFJwjYQJOq9NDOFkDYVI364akK0kXSKGHLtDocxBZmHINfKAN05v1n8z3zxAi3MH3iL1dQnkRpDMIt/MQayVVNdWitdBtNR0CUT8vteRxNvCYrE3rmiBFct8XK6SsQa7hwCTFXX90aOSUFHJMI2QX03CyU6uxTD42CHXRban32svsNSMy8I1kC41ohtlMXt8ohNWLKP/PRqN+t8DdkZKqCkbpfatbUmwJIg0lLO7JjlTMYqqbUKLlyLYc1AJ3mD3Rx0DSyHVnNcISPp2Jj8LCyoIsGc2tHaNBY0waovXRbhOQoQtmk/U0wk0eSfVkEDZDiibIDsAO+9iI7tbfjn02pGeMambGfV2L6C26rTpA5+iVMWIZ6Aa1O3rhBxKn8vNQVQ4ESs9+ubdoJ6T37peAEowGHRlRHPsGKFFtTQG2kua1xLm2XCbtusrIrVucB9p2o6QogZZdpMB5Vo+uD/K0uTJgVdC+x7lI8c/I/gAFuONLAb7KfeUv83OtA/N1AsTZh2qJazb2p+VVQ2TRAJgC4IbsPuCNxPv9K/niaKMl2VSFpQMmJEVVXjfkDLIlRMGZgBzD1OI8fT4jLfMQTrQ34N75ObJptF/Frkrc/8nx1B33gJh0W6Mp+HwdBU/RL+Xhk7DI1xtQIF1WKR2D9ZmdAW+ff7SaqMsSPyDggA1F17IOzpsZAlpMebH86M3vCYND6t+LWyL8iJK7R+Duu7KBALJ3GABPwzV9dqQMycu40WuA3y5jI9Bcb6sRA3e+QCFsuUQQ5HPMdU6VQjlCCv+bpEZ/h1bW80YE6Rv+bo/HD/INJq7Z3PJXsyZuMLLPdfNqgnILdkXEiXhAu56PknJqWzZdQpBOVo18n7BrqY0I06YMSuzqQ7JOK0tTeK99k4BVRLVzMhV72DCyI0/x6dG2UPn1vP1hPpkpOUfDOCvJxUM4IPv3D8vPkrBN5s4mHYszlUdEDUx2K2MDhjDG24UsqT5Xpbp4uEhEguoX6Jwx1N1zoATDgjg3fOGMMYxmTyX8g3YPhyY5gZFalAaK5oZLpaHu0x0q8+j38qv69w/GxxXvqm1XF+QOp/mid0bpa5jZ5rndc91kH1He9OeDeflA9gzYVsFr5M5LCE9UKojfpVZ0Gip0XXto5o3lUikTWzp1CCOUVmF2jDXkTRlCHXXMI0+DGqwEX8/1/4FZKQj/aXmn6/Gp9f1Cz6d5nGf/ZpbvEcOJOT8MXgIk2kHuFJn+FBDzF3+nHafIz0JZ3sXdmQrs3UAo/vsYWsROyoAyWXdFGErOgOpl/GPCruPdmIAhY7SiIUehVZEzOuPNFvFA71IEMcMY7ratUSWxXZ8RuYHrtFBliBMrbdpT21VMGhBRhUpGLhD01NOF4qfYfPjabeXIvZYcSM/IXjJjrRIIaIJTQOOUKviH72742+AtRRlKarLhekfveB0qhK/Dc9EhJ6GKsvmBubd/tp2y1Hdoirv6seuBXbosYvEMq0A9arlP1zebyb3XTm9Efwx0iGRKcRPwRcKb4Bw70qMeDFgfkhKzhXzvKV67QTfJcR+dK9xKE26xnUSQrpLhLNd3o+x6SKX+5s2+BHjJt6XIfreaHAdv2TS3ws0KNe4Aw/hKWEThYXEutcT/qis5luAISIvVQ/cyytI0X3mthxPBONzGGWEsZBrYsD37x2xK/6y0jVjE5PQ0QR31uot8ftquroa9TpHpfVz2vKmB/bgAyVTHv+kK0VBKAhOtW23/+muIFNlIbj0WH4V6wvQD/dinj6UfBEohXGiFqVFQL/wDc1Sxx4O3jYh3CGra9NkiM/Q/SLKU+aorvT4B8nwGasPl+K9cx83zURkfDPArfc7wWdKsmqE4Pq8x7EPdwf7PlxU08xW1zUP+omCZ2hKn/QEmk6WphCJRT6O5Y/jSU3yawzheTs95P3waf60MYLt5fptPZiCvUlFOMJ/Ajpc2lpMeo9rQHbT+dsql/L5ClbEoYdKuTL8rSwDASf3iOiWGBIihwCO9K/Oj8n0lMjmyWvWPRZoMO1WMR2Pj0KEfFtcKbRjCOhPJeHdwIMwBMVB07kyGf/azWAdhy+sb8kIqiN7WuLBRqStKxOVBeujoWfLenXOzfvI7phqEKeMIdo58SzIMu0lko3VQ4/yjrVRPf5rDZMQGDhvKpasTNNt6dvjioz8WJMb8uyjT/MXSmetMECYYp3Z/UsrEzq0mSzw3dZwXbKCO4JpuuRb+vrIV3yz9yKLdl8zvCz2v8wiqZYiLq0r2o9/19i6ob9i3iKljdzEZZWdMzGVBG4vI76rqJJVr9JujuoqC6dFSkGKKVrEX/C/iAupfamkEgeICkSdHOMlvjW73ykYkvnsr7K4sw3c63IFak0E+gBl45D59c4N1xO4Wxk2wdaJCsoIhMAE5Df0zr05fKUozwK7VT11z2Bjy5oiiwXpYn0+SAItoxxWoqx596fGHQuJuE1Svl2Cw51EYApgzvUd6XDSdqSY9LN2QPQwCW8W0lL8OGVv8kxSsTtwc7D/s651dRgDLIDXkF04YWtGvC3fc7le5Rw62dq7DwXVNM2kX2eFDDEmTPglfW4t2R3fCsQ7WJMmAkksYEtqYA+s9cS/RVJviVDJr1XoduYUgLip8Tghv4Wl4h0xIXU1Th5Iz6RwNuJJ6krDC/k83VV8/6P2+PDaZWxspiLN/FetoSHMV9GSIkH1FmoNi84/a/+W6MPvXMZNLc6ZW378ZbYckZlixfDXZluH095PKDH4o1Za5EO1oanLAyKSG+xbrAKxlQ5jToGlobML+pgVuy6WbTw5FYYiUr1gQhAStUihQ4OHng4wvpWA4Kwnj0gqaL537DWHzkgIqjOC3dupuiOhDBQYCSpFschljMgdi8i9brUICYIhy4mQKSh1/QZqj1VOGOIaD9NL6tTd9Vxz+BfaZWtbL0owLc9Q2hwQ+vHw0HaBsvIJR6OAJG6XcHLkCVXWIC9RMbkxYehCYFuovpDfyHGYoqzGuTNGPL1LaxhSYAxyGzqCiC/uX3htHKb5DsKue51+8/aVFgDXwE6BQgCdbTXQlA/2a2Rbs/RqAfSF0KnHPXCQdDduh2CDDJI5LK0OCBKlZPuyTuFZMgnyiRn5HkcvI/rvQV+w9sZS0KNwXiW/N3xN8D1UQLl7HEX1prnKn5mLMqGV2KrKh7p+g6kPiuFSvRg7nOXqH/QybbOS4d5wr9N/k5eeZV/g1IL8grrtmgDGdZyiR1i6l8CIj+UUbpmEPKi8eF+N3lYsbdnH5dJRw5L+MknV3whiC/bKiDO20hk4zTUp3C3f3UvJclPWoeDBLQ1OJyhiG1HEgYfZf8/Kg6rTNjcgG2LoyH35NDbYiJMWrlS0WrU5ljesFzicpgYfnpOD0gK5PHELEUPFY2k/MclWt936KbNii8E9d898qs3IV/wkRROyrxBvTSeIoTogq+60/RvG2VAzpHF/kRbPyOI+QUWGnzZZTnPR1p4iFsgjzUJHBbRA78DCrIZCkQTDlw+E/sTQjidqJsFSXdjOTVPDzCgZewba01veXDctOqo7VC7Q7HIZHIz1SGsmC0NQRpq4jVR6QUmLMqWN/fzVuJ3fpPXs1Z+QsuYSe/iahbiMqYhoE87bEKDk9LwT9Ob7UMefx4O02p+gcM80PK0bv3+HasX813Nd3rYFYkwOJA8QoHe9DdYY7BHAlQbvTS6rPagvU1n9vGZow66jLyo5bMSm8guYY2CW0/esmfwr33i+3JGneGpbUxXFIK2klrA5i8p2Dr9KCKFUMKQuxD5DLOR1RbvTPW54/0owpq2G5aPTWP2+4qT2x2Vfqy1fMED+brOF+Um+KtUKgBCwqjrCUTTA8EgtofklyV8nzRI071ew5N3Kj2rE/kdlz+584VAA6PPAIM5OEyUIT8k5gX7gWTWWcoEcEG2H7FIBN/uH7wQM2UMztm5gRSzZej6Ik38qKQvgl/TY4yC6Sjvt0ihVkiiBT/6pIFK6OjyiYgYDeeT7w9aloH3o2AM6eWlEqJDqYF85nYFbGkA749EPcIYjD1cuRPgCBGkwjKXRT43JfU6zAVg7QXbX6iLYIOKw7bY6kDp/hHta7WusB0/HuT7NF8m4QN1RD9xBqt9NnPFHE12lVTdG4ugrd0IdcAWYdWJrBFkTrcu5Z/jCskIGrHuR2QJcp2NIsbbdj0bc6vJnDMcKlPXtvLVaqAPyBOQyKjRTii4kR2z8iX8pvWQ7YqtZVeWkNveZLPnmcW6iVAIzGwaYWWIbeUsxfnUBKl+yiWQD0c59K+bB4Lh3/d5LbyAbP/dc8vksT216sGgIsB7o8f7G+SluQHN1oJCbt4kEWr9cigxhe71iZmD/gJ0CJ7/2BpHQ4Con3ikzQulI5Qjgg6toXmU5cvJZvEsJtkjYTZbXBE5fz4jNxeX7EzXNH9M0KUYQ833hX+Et6FqxjyR0Lo3OWho/7Rxoouh738kE6iLhNoR22Jeuuvao5tqpmjsmmERlTt8Nx02cUFUQF0P4UG4+MuZKqbgLCQ6FAG6WUlbPp0ThpFYgM8To81RCwpVN6uGAg0LZktjIEN7tZg2UOOILvz0p0oeVqhG0ZZlRTEqCJEwE12efPHa5+Gqf+YyMGDHceurWV2cX6K3Z7+X6oIvPEtihfvnkzg8rfOm1s/sqPNAZH9qmTVDuNqBQGkBsl7jZ5+XwR48tqd6iBCINx5DJH1+5yeF5lAHq8Ox34kDbqK+WvlIX/5/++GKWCohRL2RqZ2VJAwHHE0dQr/H0bxpTANRpT8sN6/0OhhR88lHI5dgfr60/DqZf6RJ/BHWuW8hA8lVwv7Qw9/e33ipr3ymRRWhNQ544rJXo8DbTIn8p8JKQ9vurYCfKHHDzrMdHsn/uxVB5VRtEekXRJQ+a2KhYdG62JxnPTmWXNPwxExfKTBWIt/V3i+cZuc1aTUOyhJnth/n/qSVd2oQDuxn+V1ZOlC8P+R9edHxwcUsxoeAcQ02e8W+iIiUWUsBDnwPIwqxPOXG1lJQ58KV2s0h8ws8i2Xqj40s1glB/lOjMouzJFyP0vxyh04Dn+MwopDHUBkW+KulQxVNl4WcoYaYd+6JOnR2a4mZUQJ2QMyUsDDRGrTXiWmd2CL6b4uRPm7PIS6V/gjEwqXLO0265FmdXBieJAtqsjqqzb7TaJC0rC8e44gDjBi5djiYEsgvlzRiOunuNHTaYPKSRMEoX2oIouXgjIHK/JUtHvpLk+46laXC0I0NyZ2Ua01eP9E6GUHjU2ur8v8oyfLanZLDoIM/ZJGgjwmHsitt/d0pv0eYaQnWnVnIg6pGHpeuqxj/S9u6e2B9ykzWfFyY/WVN2xYGgfoTl7qis19zgLEfeTM96aOqypHPfbcctXyoNeFnyI5W/50fAUhnWBDEnlkpIfeELfLgTA2H2v5vWOyQ9N7YgCHeuT6oe58L/JSk0JQGYbeb/AMlsAFVgdQU8NvSeoTnyEutfl+CTy1j6y0ybrI5ZKwUt7cqTh/bn9s9vDWsU2GDlCvToyTE7nGFJcLc+7UoA/dI+bi3qGFlnnblNcutAZ1S7ZJIRIldZ0lzOhLO28nAz65neL64qocYa/oqgJF7idgPM5DCOIY1o5A5n/zVz4Kx3jmbJ3u/trxYQ92TPTrrhBWRKk3D2h3HpE5/5p0Bz94BXtnFZwEj8jVL5xix4gDBOEx0ZBiFiL/AcY2KHCeGiCuQbXNVcvHD9VVC2UxWkC2bJrJnK3tQtVG7v239R7bQstcNb0FkxmJwITosp96ljAY5wn1Qfdh17KPKAa1FkoYJPAiZGaNENUHSLyBGB1p3RelRGyPQ7yJtFpqTNC59LHHlrseVMyxlOuHqFlXORRi8RwRJVVlU0jO7HaNsPuET0U/uvgX31G8nF2yjt5IAYkgfd+hgBr4mO9ygk9mIJpfc9clFx3TbFqVjkBbx9TqsLqM/nM0BtjQHkU7Ield0k3FzbEjzEKT7f4Tr4H7Vw551WHay6vjb86CFXW9uO8dBOAzrAMxq00po4F4pfG69uX+prVawi89/tCCzeZMG4oCAdnSfVSDtsyB29oGRjf0SRnNndwuTtITxbK9pTTCufkEVvn9Hyk2eVCEjDcGhKzcif9c2uFfbxM0O5vv1Rc5xcoScYBSe9JoQbx3TLwX6DZNoGpvyrVHJc2tJjL5DIMD/6ANNHcEKalH7gPro5vsPX6OmROd0bNCrkoyY5l4gqWTY9h8EYu40crxG2tK1jYvk4tOXpFt9ksqZnqu+BX7fk9+iUGhqiWLZQUkOiifna7dkBctX0j0gY4S8yBLYOSRpr9wEeZWhp5Xp2FY3bsI8H1H/XlRFucZBJjT6Iv0JoReS7xIRvZYyCjqUjNPR3T0kN8KFRMPbYmhm3zm19KTOhktwRXrdENKtkI7Pmb403FIgbaRb5eEkJ0PP/A/KHt2FPtbjm3vVpGWjkWOaAuWsq2Ka7GT/rTZnBxKnWpcnleyBVp1CkEf37ECZ7Uh0YJpr2xweWcwkr9CJwVHai3eYwvI3nwPFxdb6HJpGNFfnKpqhkmsUPmdDCSiuuU7CffunBFzoSaxjYQMtVQLJpkVlYQI5Ud4Q87YKTYAx6Vs1lbNH+4TVbv5LJLsRBDnU3O+tuBeIjTZqwTAA6WQGplc0WJzOcxcgTo0srNQ6u6K8XBKJGovhn2hV3Cdig9NKbo2zb14KQREEqQL/UO3fkCVc+pOYXYbIyvZHjY6B0b04of8wL3BNf41wix0w4ruLO/u0xKiaSvM73q7i7vd6G2I8DUtxSVwT4Yf/PY7XPC6vGI/JE4V+Cj1XcpPQaS8ynljrdWcfRQTH2/RiNEbAckRWN7HbLyJ1beVMYeywqy2DlvjAh1d70oIJbb36jTtr9qUFb58e8W+8Iq6XQvUXZAIy7CQpByUH3uEx/SLppu0UrWtdhk90c9dpJFsYbTtsfqcwu30E643e16hr8hXYn57eiJHhqVBV8qeI/OsTr3SQqGcOeL/UMNjm4/IlXI3KCHguj2IojJEHcWeYZQsSb9yxo4a1T6bt63n/TFNSrjYGbi7ljVS/Wr1m1wEf5ZTMg96AvmWzr73yRN9rqBJHFhzrh/JfqejDowbwaFesPP7wTl1zFtazgmM/iizB+9x7ZwOMifXLwMtVjdHYaCKoV2BeNVyRyj7gtZk35ptQhy29AC1Pbovg+ed2eKeBaoTgGBVJy5L6f+BYKHQhPg9dGEM5mQqPl5dckLUv5Y7CVj53tEHf5/DbTe4acl9ZZV/7VzX7ADFQKYri0vF5Fd4RdjPyZjGjsucsimHfUtB3MJHVfebA76Gm9ya3kigyvmlsDe5cpABidrG48rFZo3DDo8BYacB0H7mNEp9HKue0PxbiAM7/XGU/nm+OFZKPFu1IrULqKBOVLKYPZl2isI8rMur+jX0/srL7aEyQ1Y8zAw7WNbv6zOngBgNduGXHJidObqeLPMMpyaXXToJIiysOxiCFu2V2npZaQr7Q6NyJIMmsoORqPYVCew3OWsHXWc2Ts/Qpzjwrjr6cqTh/KNhyro8y/EPDS8n3NAwp4bbmH/16y/T7yXGU7gKx6ks6u9SNPuX7WLn7AX6MTS8xb6QyNTA2Kmko8sZ1gu9JYj2fMVEoaGY9qJE5s3EfdsVWEvy33y5uLE19GL2BJdFSSwD5yINlrQ27AMZx75hB6FU+Nl0nIbUrkK71UDD8A/iDwLFOiSqlKl88eiBfVl1ZlwANcgkiYlqXcHeRi3dE5ZVhHZec5n1tRcaWNsBsmxeunGx9IzKUOIdemzYsgTG0+UcylCADLG9URGd9e8YVoj8Bp2GXbaleRP6VohIwlg+oClG2NzRn4g+GMX7iH/HfB25mIVF72xJOc0VOzB3yDSVRCsGDSJAKIy5iLu+barrVQ/57dvYpW+5CkNXMUlzJkWVqweQoC4LWfJ3/n7Z9MGSvA6fqsy5tsqf1MN17oYSEUPNexlA/gH9SXPC8CcH/iUhKGnFA4+0ZjerETQ6qib7Tt4xqQ92qvApG4Puor0eRlNdFYmNms99ZWmcgSAuHge4l40UqbSiezfvRffXzCSG/5I5QpyDzCv6BOEXRLZ8fyGvDBl7J1PFHhNdg4hGcSrgfOXIPKFzLI5wWot/YRoGW9VV41IxfPrBh/dyULi6vQV2+9wcD/RiwTrzSS/2KBc5IezQ54tRVq2/H26CknVY/aG5jZkXk3cQvNVIMqU6JKmI5DiquVzhXGISMfnpCols0wrB6P0yvuozP1YuObickbPKTUW+NaXapY1+J8llbrgMCoHuh6+Y25zuKZCCmtwLcgGleRhFL+u9fuXiTUP1YQaHFIielTEdM/Vlgz68c4yrP7+2xgolxSk0Lqh4Th4L7zfBWornilk4cyP4fCfygmSjOKHZ7MeCI5NSl+kQkL6jlxlgkOpREeNl84/jyExFIY6YJmmpeBE4p3odD2gvxUxy38LIlnzQ0dQXPSo/6TjV2/wdubCoy85Q1Br7x0A6z41v37Vu8/2o6y0hOQK7eD3OAatQiBdEm8uvnb08UbMnsnqM/Qoq54viWuayILVHmWveTk99hCpE1CV9DeYWkaFadAgFxUniV6IATE51V7uDzEHO1aXVpxjFCbgr1LwX6jWIL2gy3MD1LVz77NdkFGg8rjsX97QrQ2o2apjxzsgMTypoAjJzXqSWgRaTI5Kh59kHAj4Vkih+tY1ukrwogGFaJyhqMzHpPbP8U8Fh/pxz31j2uIU04vWCZIG8hxYsNDA1BhvDpO7ow/Nd11QWkmBrnCTA8SsQb1UtK19hzZLqWk4iCEBsjAPQgwYfcfy/5202okQNLnvzcmJvtu2/J5/pAH0M5fojvNpH1xTvm0jbV1+DfGB7A53qJ9tcA+GIotcSfc3sJQOEfg97g9i8/BENjQipEX9kuEHOQE6apkU18y6l3fgqp9Mfd1+70GFZyGsw3sShqwSZFSP4NLENdzXj9WRa0d6lwb7TGbnM7fzUP6PypAbR1Dj8RtxaZ2FY30kc89jWIkoFNTHT10bzMmQmTIfXz+DJRuTIhEAcPTVvyaA23TSfxs6Bj6Jx+QIIZrZCROfcirJibTcpabRAvVmVL+ywD4zLhkDOvjXD7zoOgnjd7WxsGUp/dEGKwe9cNG8DkWT/nUhT4UqJxFgtIIe9dLwnQ4VqsvaholYULZmOfo/5j/YY3n4j586vKFxDP5w1RwRNOGs/tY1Ymf5H2rnuLwp2i57e8mywaUR44QkFnnkrCgkVP8claqEkzx6Twro5IJgfDZ6zWSAstga9PbeezI6YF3BMJ62mATylrnh6PiD7asQ41B+imjNGiuuEeEhSe+GDxY1r3qSxCMOHGy324G/7nXL4JGooZj+qxS/JgOkwEK4PbBDVtzj9HLFGFTsTgsjujzF16nTcFNBO91zUfbrQUmeSIRDzSr/6yqg98e0+V0/XHXexf5tDSj1F1ku5w/rgrbSxDnyVxHUg/MSb7x7UtwJlE3x3wCXYF1aZz+YiVS1cGH6CdxIiBmzFXu2/NtgpVc2bRBxGK8UIvGdS1W0+0lMP11qtz7G3Fnayjsl8Kzd4nxVSBft94E+qtgtGL1UGbibadQ8PU0/7YCT2dMkkDap8TpdQ+rBBkbhTf2tSjKhL9e66YPpcxNM/H5ZW2OuLMHiCtRNtpw1oOmzCeOhxf68+04u6zA0kOy5duK2XBXgaEWJVUBRJFiQu/g475r/sMDo0a2raMH7y5MON9NX9s/jhrWsUwfBrAX6ouHBQUaWWhDwuayZB0BPqdo9T1n+cH9kKgvpLgPvbgAvwKfdwt/XW5V8Geec7rbxRc+tbkdon7dnRdiwyUPyVSJ1tUfKDWnH5G3kSdSFqaMy3xoQV3xEzDGvVdvSsnUbuRATQpNo0wYHo11bNhkRyAGd7vjfuso+8RBlXErpWspMJifjymCAUetsW/x7bHzm8qEji5yD2nJTrfR0pVr/sZ9PhZU7troWXJWdZv5RgPunrj0U643WtN2SfZTPLKuYjTfAfVi4eHg3VNNq2m4dun9bUm6oGE8/pURE5HEAnDx+0GjvrGOz8PlEzqg78Rs8drQ/H9kPQJoz8gnq63KHElfr6FD4mFegFOalM1412zFM0g7KU9ppTrwhm2ILGhiyb0fkMSNfPYyCOpDjUTKOrILu1LjcJTo5zE97bnPTXi5+r+JjC9c+3jcsiz/KVGETkPtKRHdIMyeYeIzF6FWdXZ08Bb16Oeo/3wqHjP50L+CyPy9fsJrvB4f8Hy6tVJ29rooQJ0jAT1ICYjNkSclSc79bNUzuI1MiUDqIdtN1BNA1P1rgsF78u3pLZ2b19KtUE6g2SkbF/vchtrG5SrupX1ZrSS6Efpap8fP0Da7XbLrWKGeIul8jUgEqSBpD7dC+fjQyyPqdVcC1xiblBRdBAiN9dWcXNdLhn+MoytEQNnGDiqelgH4bHsDaspK+tmtcQQI4Q0EHvJ6IUtLsvF/DVfvT9/RdYzQdZRI0Irc7RxkXXH/0QQbSpiwBLzyaoM/xAD172cNwtDLEy9iDN56qThqvg/8HuwtNKmo3QnyF3toIos9dHMex2MwsnIAR+mccSdsJwEdAps9uKSWjr9IfO8kCUA+47opY0ZHp80JwQ2sUpfaPDLcsFjRzXDsHqUsyuC9PuiT9Z0jlTUGRnIBOJYpB0EMP1aNi3XCPSSae5OnT0E61NN68wtNlEKcjd3HTcp/KuaPEDWJmcjQ2pP9fcvpGIHE6C5/KyptYdG3ukbxkVfBC29UAF1MlWoqSS8cw5z7nBVl1BO/hUWKCh19+v1tKCBiV4vVVwNFUMigqB0mx/0pewi20M02JIpTIplahircr4wFm4uT+VMNAT4onvfV+zAdd0xapQadC9+7R28wolVutHYuiThkVyDS5YwhHaJL8Y11fBKtSj3QZfrnYO1sFCt/D0IfXs9knY1HvK1bOO4XyLe6UH0KJMcdqpQv1lrIJZ6rrAlcRn66q5GOgZka4bvbsXWS++Lssm82Zq9ReMajEgxJhOscfa8CoLQEWiC/XlaAdErt1KSJGYOySmOcQ1mJSbjYjYJs479xhk7OwqQknFqxQOhL1o7RG+bjCsFhBslg7hUGk0CWL0+PtlKX/kv3pGO72KiQ3ZcrIuul74viPZ6TwsU7r46JmrP68Wq5G+AU6myUeegi1HX7F7eD6f9tpYrUUrYOo1yVj7xTSbT1kP0+hlyucBu/SJ03K/yMLHb+hYFfO8j57ksD96r5Nz2q03e3W2WP9yYHjb6e5HXuIfP6VMkwBvEc16D307qj1MYtHh1F5TYDeJ8ATDPnoMrIc3ki1hy02aCNY+FSpTd8pncz2gqOXgzaqcxJFUR5nOm7cl0kY22xP74vEaUaFnoW71V1Tl10nU3vsdZySNB46gJy+Y2D93Qqeru1vb+RAjuzEjhfHl53kQ4aOnCRKYlKJGyflLKoX+BMuRvJRVfE2AjGrnxy1SR0E2Tzk5nynmO/HEciYqr7CQYQWjjgNvIpIztn9CSD2tO14e5zqSzwrkpwDLNCo2i6gwBd8+If8gGqdq2hBR3aaVRzKZB31W3xtmsq0dqtfECG1NnuCCFgSd7cvDJBruHn6hlMAnI0GRfnKGtzvH9s4JOqp378/UGd6o/7zPqicGVtiQWtgncFdqcXSxl43kGjp6BW7AYOe5x2O0Yt4z1M/a+hkHNpc/zNO+HGU6KoUGemKQeT82VL2Wy0pO8NowFEg6aPEHJRLrTR6oM4cRd1/WJJh91DHroqGjN+VPFA1PNwL9R6vVvrNP/bcX0DVtUFLAquT/fyyJdHPVFigEcTVW+4HHrmOyo/y7DnPUmuqtkaqVcHKrZ1LSZcUE7rgQ/BAX1wbnbDuTK76p4I+ienwLPl3g5B6tS2U24QKKil4V0EBS968w0SoRQov/VaPvCiQVxZgBwvfOcX71mFD6UhBPEcL4XlQTRk1T6G+5VTAVnaYvizESRXbh8Em6huvtDMIlt3um+CcPKal9u9R0HqV7OZ3HcoD69msSlkOuY+pivWKpxophzqXYKj63bj9Xy28AYmPGkPatFIptzXWN3uFKKIu6+QNNICSLv4cgr+ebmfXHkJDr0GpuNdGdEAOiFU/t53tpQrO0uolj7azFdcdjcpJ8w9++zvAgSRiUmpYIYyWDYSdtQOp6NpAiwtxT4IJwuuqTcvINFFGdF1/hxpacOqi0I/rnvUylE3OpMRnYI92l/I4pj+uUW9LwZXHBUx6xrJn2qXgKKQrDZ1PkB28arxLjsAY0hcdS5gSD4IgoUBYI534MyWo8PXDU49eY1FSsE0XzEwqKWhynEueHkZqPryuQ9N5BqUIwbLB5v34SojDJ/MMFFlCDWCSDEANkPxN2JWdtOIc6HNG+QGvTZgZdz+ndbANhnAvI2rUExVT7Q+b4CenwF2k+YCkHQnGyap/t1m8M8bCtZxW94fieXiz6uYquHvTiV3INwX0TtlBJzqe0PS1CPUpka2oBBdzgHwIGmA+IpFjf0ukiQ3HITeIdRFu95walRG2GF3TR5UgvQSoOqn+UmgiP6XkDmRMwAlr2Qa7+rog5Z4Ussl+MGJ92DiSLBpERFes3+t+w3EuYdhuD0OTQeynTEG/yQYHPX2YNYZo71Qk9rQ2y6zxkzPtBxmLPkNmxlYf8Wx9d3rp/dystN/zwE0TYm0fRIU+E9+mSyeFUHK4oRqjLX1CW5xP4Pvq2KwXOkRm28DDQKYo/vq2Qv/Pf4DzHslbi4kyOXZndJ9/iJ1iqNwBXgGaKDU1JaEk6Zs/42UmhN2WrcDxl4asLEli4Ro+qk4B5xvDCUWtXFv0HDR520pjGttdr4wCMjp+/feKuy5I7nDg53E3p0h703bltVuYYXebwnjNTpNQhtM+P8KiBRWwcb5ZU7EU4fQkZLvymqzanp38Jpz0Qf7G9FUTpcmsKDA1sJ4bGz0hQmV62fyaEIxqEV+kekE7FWG/E23y4paOuLH7CBOVy+l+41qBRdKAPsObI9qDsU8eFBsecSyqgO6LCPcAFdNKXkE8oJfBG6rRqMPgBFmRrqsn3mEnPnQiHbfKH0Cz3ZOBZVcNRqoj/eLKQZB+E+UuW7YcBq7KmJmrBQGYXlZwJhlKTWc49Hgfpe8gJcHGWfsT3A3D0D8auaBf6ZSV68oNRJVrLjHmmfevkKHy8i084g5X+5LBBTsWpJtYWYVDyTs8DbwQdzcMmWc8aIcPouIh+7n+fvc1n49JyPIJelal7T9MrvZt7oqMybpYI6uZtX2IzBDjcWZIHy6Ow2C3CAY406hbzZFK2Xfw1iOtDhgLm7LLsQhnP3ylwmX/CK40LvPXc5FOpYw5WoicCQ4zQe3L3joFjVDhE1l97IeNyAmZsCWuf5I8x3WANwDVA/FpQFqYUHx5Ef/uG5qV3TiBGnxLE9UtQ2SpHm7HI64aM1SpeElLc4lfS0bTYK2VmpLB5tesPC31zCWt9K/8kR51XleezO4h1X15U1ZLVPC2Y4sULWk/kO+KmishHEqPMEdUweI9G/T/4a7qeEF93mLhDpxbc3AMuPk4V2ok7U+LCOmh45vjdzDqqY2pinCImRlR0mAWg7KeZmO5/mTu1udZE/MzA9FgbgOZe4EdSta7z8QOfUiy1X7xcLqLv19puyqOyTf2I498QGiePV+b9/LZ0f/nmnAxfsiWTtPq48lu+wTWkoRAEdYReXirodWA/IZOB0AOKmoQsyjw9X1cEr68sSISZgyCXK61n7wE0zacrioATec7BJLChP/H2nypbCwuEnpf0Soh1kraz22KERubkoiexY4vkxcBF/h9AJQI2+H/xHkowepI0WVpZEGhaR0Yl2z+rjstdndRZiuI3VfVVfDbCkZN+N8Drz8TBkMOA0EppxLQIrYT37AjzT4rKICv8xg94jb2zl3x00ylXXQ8EXq0UH9YRH+r3JfF+r9Fi3bOZaZpscFGFklYg/GtxTyWncEsQDLeQUuMF+Pro5PYqjY576x0wCldb4gprbsmszeEKCamAhu8etd1xmOHKme8KW8ob7W1CVlRanglz8iZHirjwV+dG2zhr+9YQ6mV1UAhpttn5AsXNTTKvI9IlagTvVxo+kmKP8yrdQCQ2nzDvLPETMdApiFyVY9YzRVv94BgUEbbMroEGS20VlENXc0g8LoCQ0hbLoldrD7IXrWvQRFEzWWn0C+36mfPNEmv3rXwZBBnUy6Fh3n1jAbeCIp8fc+OGXN6utPjKbH9pYuo8oI7iqlKM7VF9KQADnNn1Vi91MYdtH7Sl23k4SYaJ/rVfEEZN71WWjWefgZWz2sf3TutfydW3xHAHqDml2JFpiALzyWzCBnivEJRP8iMcw6P4mpoB/bQvdUaF840ngc3H0MgZJYLZ44Lcj39cF9tHFVS7MKvaUWvfK4a71/g9aUJ1xaVREArqVz5hcPoGYg6gd+ydA627U0GsBcE7jEppFAgvfdtiKXzTWTpGpmIMKMYjIGlDuYOrlx3ycf6mJO3k+1uR/2/7nNmL0gOyXA8nKDaJcYm1wKlt0YcB2sS3OhCbO/6gnv/Vi1LTR7o4XGcaZhbUy0umlh5RIL8YM0Qa5AMvyU5di8Mx4DnAuJEdwqKhInfDQxcaWRsAdwdnqVLC6n2Udn8Fz5d35SvjA1v22Ms1PKl5bxxk8B1Voe/AZqNgmcCRk6o4KKdnnIzlsi9EOWVy6SaUiq3hTfZsOv+SvYFbBAyxM1YK7Q5hTZk4ZfEstEQuRJ6GOZtd0zGshVoyRGiALhXoN3tEUgxVURN0QXWs608iJ52qYBO/8S+3NH2ouWhJhbzUpIRMYTl6a5xGNCVyQxmPqu1jQXwm7q4EBAVHPWwdQJdrLsXP0sdpXdUTA/X1EjS8ROsdpqt/NO8j2amdVJDCKe0B/f0wUVhXdBNCedoBmeotFh9/14amfokFoeKEUqqQrnEnOWzzSKsWoysxpgvOyTWESRH63ygrI2+30pFWdQBXstGRlE8bDr/hSKxZ0XSxvSZOAzbSUJVv7+zKUYbHC7HsEN9Zq6HOcj/ubz6MdQak+cvHsD+NgCKj0tTjDxu/tb0diOp23SDVv7NNlddrm0pdlxGXpbDcK94S+tZNEQR5KlXx5So5XQ098Xfw91XvRh01n5W+eHw2mOccqbCNV5zplbegmT0yOlj3WuXLAMoPjqU7mcxVXkEMXsiJe69eUpmZigahpKr8GaCVJ7MdYAjRsBQ2KJPMUV7igpXKCXkwSGodrmfW8BV0U6zLeJOz0F8pURjOH80W5voMmtzt/0ruohCNOg8XJ5he8BHSoG3mW2Zs6ltG3E1BUmUmqy2PLzL6ynMNcIEY2vMrupO7p/5wRKbYO3uGq4zeyIYxklUGZ/grJPAYaAiwImKve2qsOtUuT2+kGoPXNbY9J+3uCWWlWvQWwQr17AOZ01ZF6UsEagkb86FeEtpIsaDQbxYorqDJRqOTBC7bZmE295hgxBuP11bOSuxVmgAgw1xYowwC3FQHkPVaK8NBXgBjIq2PsbPFQtUD4Xy3IyAQ3odh90C0jfNW1KdyzwMeZpZzO9Oo1hPdz3msvttMn7TJnatF3Yhj9T8iCuSlZT8c9Y/ziQGnvRZ+kcugV4+gbNIDGelhPgYkm1Jj4uiG0IUPME6103iXiYXN/RjHm1G5c4IQZIrPY4z1O/IeFoqCM0fvfgl9bdm0LuAlfdu8liRGxigdS0KMivvRI5STF1VSED+NCg/dXHfHutWve5KToyfew2UkizXHd3ReEx2slAwwz1ZdqcTLDBId4C/99jBKiPQZB2T+RI9/crTRxbDXx737fbC4szC7iY7u7eeIqjtXMaiHmShtFa6PP8Hn9nLbthUen+Z9qmDfG8yHULqIAyU0j5pCNYI3k1iRgjykPGVb353wLLWEYIp3xi/9SRiAkTBgcvKe47rzPb+0h3Xo51rZNNBAhgZfrxXH4z1P7PaYvIjVRxPDUvpkPyZujk/iYrSzpHbMxFZxUE0Io7TMgk3kKmjFZuKTe1t6XjL+eocm6pVmXVAuAXLKKx8ol9UFdsKbetzYXE2P0mUBUM9SmRengfgc0o8H0CCBWdPpOfgy8pXEwAdLmPsPzc7Tj9Ddyy67Kf50nBZ5r0LkM7g9nDofWAvTxkPnR+Cup4rOzFZLXr5uBtumwNjAjaN8tip5dE/l38c7GCb04noxdWlFYBTvBgfgKZK57gb7bwcJHuoYIXRTI1FRdT/PIsF487o4SsnCNYHpZlL6H4GV5C2KgKxAXXgjFqmCj9uHWSbvR6EoDJmbcq4FBCWDHKfvwYZrQuaUNz8Uqi67MhLUCiLVbBMiKP++RTYibpo95NECseuXaxGb2YkzCE39NjWcvNJHYhqanH+OAUt2O0TTGkCnHG3wU0BHOhYL2DxU27TBmX9e3rwPLs7qRAkDve8pw+7wPdPTj7VHtOGSVDoPUqz27rUXFlDWSvhupVmb37KfJU7SoZvwfpEz+HOj/8NPLrZIi11eljE2Gfrilfyl+sHs+GWsrpVTqjD+qPY6WtXcLmG+fI9VfCvwRF/R1Ng3eEd1UQoEBdXaF8G/0Ag7tJFyt0wjtLkJNN4uhtOlGp6Yx50nwcDRHysFkKLsf2pkvXw8Fw6A/rCt0W2TQunl/nGdxeD9G39BikLb7a11dnDJC4zuyencZGp+Uh2VdOliwX5Ii9l/+MWAJzAPJnLtQzz+u95JWeJXj7oVTweO3S5huIgR4QO3Ix8rAMjBKCpCJpafq+GyLiPn/GJRPI/YpFD6gQcxRcKiv59HfDL0LN4cq/JqkQXHux8UNZCHEX6alsFr9TL69bnccNwVldmqcVcjiB0AfyVoQ0zbGZo/50PVv3Y9s2todMrJrnl0s3cEXWr0vQ5a81HChPWQawU1DMGkjUzqXCwYYxKNbc5oV0SQ2LrZoYeHDtF3u1ar3NnFtn/5ihIpaFZKWAyj5jhz2mrQRjrOZDjNT6650soWv7Djbwd8qOMygnQ4wNiRlZLdHX4OTUSbjmAl54OpyWRHEWCpk8Ty+cKAoA0Fc3MVzutnd8p3A5CkEVE8LbRdziUVlnbSUr7LgA2JLTAq5vLAHEDMDeVTEyjylhsoYiyXIAy1/Ow9FzCObxcLSP2fyvxQXiani1KcSnrUfaMjnUlMrBjbpCnNv0e75HaPHnsOr1m5NFd2A+5y/5xm0/9IQav1RFKzVTv6aTVWTtMdWf4Sa4Nova8haV23C/8WF8ueVcD9KLDEaVLWveUCNwKwCZZAPYn23pT6+x0ExR1bafu1k1oCoG8D+c6nWxFhrlt8qW2onOBLeWSZwxpi+lsyBR0Pd+bmvpyYtlCG9dpr/aZuYozaXfcfrnBCFF8vVT60WGL92dS9hVyq4toNhD6r0o8r3TxpyRYdlupEomnxXvz90fNYJFiHIPkFVlzY/JQJRiRVvCLo8j5L62IFZMi3BLoM46f9pujVy8eBLfpQ5YV8CZcZTLQpByiMNcFvxEseFM1ub8NRwu/rliqpuV1KBuspr7+p/mSqW0AAwEVSyzJ3lYkw/nn9bUR5mSx3Yy0HiSSwRtv0M3i0ienPhoVgljoh0R7Y4MqKc7hp5GAf1v4wwFnCEH8lkreZneraekjwSvGl9j9Zig9wFeVoZdCtDQCU/A1h18Frro3QGtPNlySPdNJbVq5AAfBRpPFCpaA04Vtev/Wt2Ajo4UoAd33g+ERtz9DTS5zTBax5g2vkhNHnpldzqTPMJNGIFDKLaDBYi5zxLdv6rgyaiEnvPQovHqKUl+/OvZF9xQOve1oMa3Rm+Ng60OBxFGjKXXKXCUouyTpL7Tpp4zHNL8j4BWweBSYYoNeclKRrCyJ/zC/c1WHRkJKS4nUmtpfBg/EI93FI2DSuANPm4BRlOUwz1ehxuy6DnrZF6lsA+299m6z1Vk136nuq2LcInlMwfrkHIlR3jmtWWjMDRAXl2zi6er49ewH99BzATISlEkZrXHIxGbCdmIVWffkHJ8yWg67ZOzTXv2NqJNpOTs7wDEoWR39xDoIDK0pyFO+97fcTDjZ/8Er58U8WsoJGHAAI+pXD8yuhbzuRGi9TT5tmRSf2IrJebMnRevxj1J4Gt4mSVE0rk2Cf6AZNfcPgcML4GnJuTdynJ5vqPvdU48k+uFuJkeA6HauXVPDetHtrTCh0H2CI6TGBEy/EEPiZmRl3GbwbwJvMUmbcUX3C4mxtoXWX+iiZXOCHROHTwjjGJV6ohvul3J+6DnMk68vQxVK3n448SCnztEhQfxvM3u57nT5700eNWPV7dXFwqrnbPVX/UxOP/xcHtaLaOLCGt2j/agi2LQpX4uWTpirHfMcei+iBsaKr18F/zJtYE2B1ecRcIElTTCetK34PmV3SWmIHnzrP+QEdkoo5x+jvHAu0QvOACO8fmN5sZqQm9ECnfD32QLFikbgkE4y94fZKdIWlAujpuSo2x+PCr/GbKIUIaM3PbXullmPgoWaWvXY8XlaHPEzVZWgL8GupsS+YVeGNdWUTiczgbLkoR8dfOtZQTTPPNNJYGL1ej0lG7jlBV6xMHoOZYjljSbkE13MnEpagrtOQaBjiWnCDfZZfivPbqac6E79b1yi67XDWSld5UpldCVwnmVd0aeRz9Gaf5G8xqsBiaQlffz7jooAldHlSFlQwmtUo2f30ZWS7c8XwpcPpKzzG/Q0tq7L6tT1CuB1duosg2l6XZEZodeOyoIb+7zKFKxSdUzCKdbAJ4kuzSgI9z6Hq5Jy4Nfze417Oz6iujS8lAWClbyHTYeFuN/i5xRYDM2iuF3ttuyTQ/WowZQGUp3QucalwajYmsJTskBIQ8mOwUP/tQ9SvNTfhHqbktJbtooRufIAmLN2NiDshquOPDeo9HaLpfEB80S0lA7L323HNRzHA1MlKmg9Rpgcj3PlbwDTLg8BF7s1nTohq4TSx7zfYVY339HwT+uz7K+WgXezTSk6eaByI+3T128bosryciSSudGMDU806/XR3MbJx5gFB6LDljpEd2b3wQIYZCgEdn8cfBC9NyNVPKgtIwmQHA6Wjuv9FVl1NoQPSPjFluN2tfr5Lv//zXhSnog7hLp/GWTQpLAACJiPeAYBgb6Xw7FA3rsLsKdiCtvA8cN8UKSrt7XLXSioq/h4FwGtUP/ucQUcBu2q6lJRJ1GzJw9yf4gzOPvkFXY0ZZjsOtqnc998JWia0+lRkYdzmA1Q6TTbJS/ky1vpPR1dH/xz/yOoOwzKEJX3B1XZcG/pcTogK7OkA+3FHSp4nxWzs+8FaIBOeOm2nOsbdtHSxeweRK+h3lFZ4+T+7Ze6DaJqDhi34AHM7pQqVDFIx1/82u9i9upQr/gJGegr3w032Bq6ju6leAugDUW3f/4irHJePmaCltJ5OpLI1oYd1uoky3SAfBytSuB4IEtyQcSxj1Redv8YuBddq6T3geoU7Lw4D8VSCoCFXWXuyxeO2gloFEsOXvHsYZ5GrnjNl8htO/3pwu22z4fG6GaUV4cty9y2szuOAQCOCMfMETUDev7VtKvyD3SR63kDy3AKPhGg0SYwKF5IFqlGMHjcIse+h8uYsN5nXAnwQjiM4OoUbHFi2/hl8q2ArDF2GMAPe2PhzB0RfNAdnLtje5utYg3mUPdeEPz/H7P6rPGrG1uy6mncUnV6rBkxrN99Vc7tRx4EILvqL1ckzjSx+yiEgDdwGuk+aH0qZ0sOQ24UsdN2savxnMA5Eaz3iDryGXeeHkNW/8tpvqFgzSqKO0tWlOF+qmzU87A8jSNmp2p5yKwNG8t40cBbkBeR0cpticpM9Z8mdP6BAip/3J4eB+hA/LhgevZyeaGboZ/VwKuU3F17dPOKaamnvIbMBm/PP+1VaQk/75cDE3mBHhHUE9Bw21A9ONFD3KOt4TUWG/n8vXbWhqsoZweTRMdrDrUeyOQ6hSu+jWcmAXDRcPsQQHJe9CemyFRBfn4adguvF2fYbbPLUgG7HrKThopQeTGTjBpcwFwSUqWgr/M7k9Ixi5X8gb4hP2+8XMU2ZbTLVfBOJi0ghRvRke1OwwfCCOUG8+oWU0OR4BwBXsKujsiVARlJFr3QBBg9eyaBDyl98x7HdKHDe6RvnXHtcrh1ppRaWNbuWaXxDswPokljGaARW82q+crzI1oWyFjt4Jra53tH9T1CcP+nrCgvImwpgxWb61aOrNtzj8NdrERBi7/q4/0BjTeNgWMfmDCTp8UUHh8mCgBkygQnepyuJ00wyh2KMJrqvCQypBsTrKiFopIDshJli7MmU8o/xeHSfE+clcV3T4aqQbTpvm9nH5H85m0w92mnNafNfOabWSzTaGAwa4F0PVuxy6Kr2a49BXV4s0T0bGDaz3aOfUG0mGYf60Zl9q6/qeCwvAuYXeLZGutZCOoWdy+Xy8v/XO8dl67XmSu+T7TkcDKq1E8ZcHVxN5r3Mxf6MvqS22a/M/jcFDyBmfR+8F5UbpmUonSzmkocjSIIyj5YUpG9q0OpYMw1fOTMqZTO8Ff42FqMevBOyaDqgJy38BtKlkRiaesI50YESTerRSjBg2z5z9eDUIKNdge8F5zA7LPhlSVRDdduRrJrM7QxTaHxNdDVbVLOcTQaMXJkXaQgTjANyHOf5XL2AW7gyKDpuouCrpcahWuKuHt6RESt9d0idoFlhnQHiaOMehl9UeDfifVVmGRcXijOhObj4Zig2KPJjJYNGt9jmlJ5MUazPNk9nWD9S7F6hB671sjYxAU34vW1U2UGC8ldPTHO5e9vXfmkA5BeA0QWOeUta88g7rIBV3//KCaRIVWF26jxam4E7A5DJqPH0NVJqrArSNr7JV25ATATorvkE9m4MHmnCJ25kcf2o0RejxoAlPubxp4KTkeR+qX3jR3XGVrAmP1PqUqdpMUYf3wxzRluJpn8AQCNYMFHgVzncsYC4L6bN83hkwnDpTZAzjNGHswUULcQGKPxel9e9kv18n5KvH3y0p9ZZfEaH+aWc16CWCSPp7wTksLn5rDjk6s2mhV3EfHgTfjqV7UUg3NqrN2WaWKl3urXXTPzf2/xHiPCQTe10VlNNCXT5ksERwE959vvp8z/1VkBKO4WNYbX38YKMGLaWA5X4/JGnJGds0wS5s+GjBWAIrpIYnYHppRcep66ZiwmN/ym8fal3sr6iUttsY0LtZMlPIERrb3zQuAvpEmcHpfffQsgyX6u49vu6zD14EMyH7vjNJz1bPBNDDrmM9u+LK50jBG/tU8nTf+t9T6fDLJBnXkJP5bf4Zj7Xm/YjFYYDbHNgJSJ3rQ1e65BVpNGBkO8aDmiUSATi5dlK3cKoOm7vuTawotyqQhjf6y8h2RXmtl23imVPaw251blUARhmQ4sgITfdeNqImoUQzkJYSQHXLc96zhNi+ewD0rd0jXMEo7rqL40PBePDPfWHYYZZm3vBRJzozT/oY+tshJqzPuwMjtVtIkCkJkMvwEh3gHreougrgEhTuxufOeMUQ0I1uEP8EXGQU1KkT1R6y4jkRmEjruJqkMOvuiB9oQxfzHr2rd4mJP+nt8FCGHn8YTVsmAG/j91HouLN35O8f6xBeui/p5c04drSktJCJHQDBZ8a0sIMbIKNzMMbweoH84ESzBFKsnI/RfS0sKtcxKAX78if2FtvnH6JYk/tgp59p3YgAlyH+0qCs2hQGBI/1UKnK/RN0Y9h16ptyDgxoGMkN5BszxOGq88rVssmD/gPZxUW+giSGIjRwesa82V4+SvdVBL6lrCcxkb6nJxxcXOtP5l2Cv7oGoXpfQapaoUX+QPixsuLoF5YePD+kK6Yx+tXjttBej+b3EB+DzoP8RRfMSXcjJZQRg9xrouBvp3HLG7nYggOMTO3yOxw/GovD3dxSZDFbE8n6NJuPlAbKAjsmLd2zoDc3SGDaCCfyg96lmD3Zy7oUmeJyKHgG3sH7ar9M/CRwdoPzj2iV8sgEzRt5pmOQpIhySMkyDkt6Ssa4COAI8G/km42UEW9x1b+VBoxV8VvrWraJ55f5jbObfzX/GCd6VQOQDjJLvQSYyY3PXYtIFS9N7NkPFhiG620CCljmseHzVTeXcKFNk9moSeUVsEh8137rGuFAZ2M89X7XB/qz0qBf4DlKp7tf89K0ubQ5++iwyLvM7W8qELfm5anCZLd3C8+c437DYRThbrN75l5oNoWpPhnQsMkJmRtAX+v6sGE6K6QOOr1aPh4YuHuhjByYiygj0I6nv8dkdZrMm4vYfSJErQ4RsEQU6ghqtal/UjL00p2x2uW9i+4RXSnrXltwlFKlYPZPlW3rteDra9kwAhkbo4WdqKEkHsp3Ctbo/TEBEOhvUZnmRiU7pmF5hW9zPVFp19yyBo0vh7cN176FhwUD+EsqwLj6v7yNmTVgToYEYJcvqTE8ppUt1DtAYla9+0HQCpAfQZLKe8nmD49vqwFQ6034Ui8gEfto8vCnfrHgi9tpf3sQk0ntj9LwfgSx4ORPEnMeuqYZHK7W1iBA5QLpfhNbGmmVxp25rR7Wiq42JWcuaYgFEkLeD4bL3vBGAcU6zAvkOqtOIb9mi9+HkpYTgh53jmyNepdmcZAEqW+HtSloTtx5+zfIuFNfq+NBCs5c6qehZ0J4xYlbAbzU8CiZWN442XCRt4NE1mTwyZnqKZG7JwN1fNp0Liu/syUnx7Tzm61cZjq3z7kvTv3j5LighwJ0vcqlNhKTVUDAJJRyBcHGV6ar6VaQwbITEqOGYd4xDVBEaoE8IUtuEJ743yPFOfRNXeTvvr5P51HdfcLDOgf+vfznSRC/Nd6CkLgGRqj7adCsMQX00xLMRj3ekUl4QXRB87/5ItL0porRTw2mXKyhuapDbc5AhvEIAey8UGOWXVQer4H4kbbIgqLVtABJqB1ix3qgNYAvJHXQA8/sSfujgr1wWrtzRBEoypv7Olkz09haC5PQaidXoYVwlx8ONSjJBkfGlDu8ZZxGI+eiEXm4pdEWqwN64f3BlJ5dCDcavoqPopOh6eHh2VM76rO1phKC2jLHE/58eCU3Ed59Odnmg8OqMDrVOSLhkZbRHLEk/2Yrv5YH1k5Z2zFwNXZ5aQX0NGY58qU5H5Dz+1H2YBpMFFWV0VwixgH2kQvpkiJ2M5OhFhHa5IaMJi3hDbWsKjtIHviWWYZ2MnoOyKGp+TDBjUFJ4hfROfuBeaYSVJrCuz/rlbshfDPwua53aMvxOmx1pdJETwN7e+Hzu/GXHmR5D/XG0xRt7E7zXMdBHUVVkI9kxhx1gh4/d/BVH7Cc6jxxHh3P9L4DRHiSatjNEogmrPwr2SYarYzkhCYkjE4T1veXZ+VjnejUygZud/0DsSVI1sHUd86S34jkKpG9Pv8UHvaM/hr4TcN8YyNSyzAUXceF3r0QgCL4Kb4TNOykYdradRTLYlLcZco+j0wcdAcU1POlYt6uWN3tK+aU9VGkZLiWLKyiI9AKCvkwYioi7/pM7iB9Omlft1PMalVfGMo8u7raELrLKvLE0ZMW8ySIuhDIcmBDjhsLA1uzg6eHmL54taZHspGUcq68n6stUr3y4Acj9HWVgqtmHJDzsMWcUua2c5yhd0R2XFGpAU+svWwXqrgifQCWPrSDoAH+vC9PPey1Iw5MTpHl6aptZzxyIJmSgX312ecVsizNJdlTFncEnNAMCV9vtX6rCgI2CY1DbHN/xSyu3UaMtep9p3H5lj1PR7oG/NgKeN/+maqrujlprJ1IcZPHaHq4sKVu16in4AVm+pdDZfuzYu6kIcSf3OczQfq3XXSQwvnrHtkS1LkJ3+BBP/1rMvAtcjtxhGDcAJPMVxDeu41mF7jTZKVcbGsvw8mr8DQMc5sQvXKh4Y0YU20L5gU+Gu3SG/ZODXFyqE02Ni33v5Db9XQVWqZ0kvmwLiWNiOtBvRUKVb7TG4CZu3mNxC6SKYjda6+JrsVBkxIq4qVdFF5K+Qe8unfr/JKZshQ+jiaiH5JIGtQozf4YZIw6o8zhdr+aFeHYkTVTIrqnn14SwkHI5aQcRAzHT0Xq+YREy5HzeDIbXFp6eWWUikQbXzfAgQQxBiJaIHBkYMDxaqKXzAEFPon6ssb/Z4O+iAR+REm4gKxEw1Cw5MjQNlSVY0exsi1MOfv5aAKFbgUOtyjIWSLB79L8YtKleGa483nrtKy5s/qemWI0eFWUDoL+Uy+S3dNqNwTavjjbNMsuPIN4PfaXYStm1HlxdnduNvUztLw6DhbD5wkOSdXwHFxPUGc/I6FLgpntA09vi7WQlh0OqX8U4oSBMNzHh1XBFHqjCDZg4LgdBeGHyMfKoZdBz2vBedHeG3Vj76ERq9Da7IiYXccEHsAC9ItOOVxCBO4qOZ/R819GO1w1xQ5+hBQ4kUXX9GuMcIiQTwFtlZvm8vmW6TqnNGTR56bpqUNKUZM1kl6Pl9yhGmtzmqJkSEYlNu3Z/8gGjXZ2M+6ZSWhwLBPNf5B+d2lhVsZ8hJK103x0W58uvmebeSxdBj9CBGBmySLKllGkDHq8uo+lFZKnhyncHW4n0B1Hz9+nrF3oBLQgQ+S58JqfPn3pDQdepdus9JjcyV4bRxqFxoX76EkHhpBrIgt9WxmLJ3ZARxRCZtVUo1UVSRk0WkaECYzfRYm4+j8LJdA1bWD04jj3gOJcTJfLMM5HLjbUOOlkqivtP/qIiW4iUimLcd5RepixSwspMSBirp3e/eJLSlP0H9U073vyAf+gR6zT3NEcaS0uIu1ChtwUFuKi5mTadIxNKsopL/y8T4mQl3nZUDBNk71HYdOuN5RdcLbFzK+oBT4UKsfsy14z68c2GMoiBha6GpIMUlY2TrRFgyxqmEI7kIXbM653XNgMBn4DgTAa037IPOsmgRZJ/DTTDLRhK2sx/rLBRBv1/M9a8Y3m34nAUPSOx8gbip1GJ5ghJQ4PtK3Z3OxxFCsyf9Ewn6tYuMJ133arSfusRUAieh8A8c5SG5s+/QYGnmUI8mAnwpkeQTkMF3l87+h3TAtWz8fFYL7Qbrk01UJZPJchzPVWGOM0pvPIhE/AWrKliCZ33AIQrvmR6G0RmEED+oob26bVxlGfn2U7Yg2KHUTUFSCwv3NlP/BXGnW9d9WHtLt0B1+6/cae19qqYRf9gJa1VmZJHz161blxm8KDJos9i0V3mijKI1o0PVPBcU21e+Z2gLqx20Iov2EP3TAo502Cn9KbDTvl5pp8FeY4dtnxXxfbzOKL5/Y/VnRU9qZuPgzumvbWR1+isPF1bVMapJC12ElUhnUREkTgBWUHOO+q0mUYhJc2SS9blu2XEXsvjsrvA77RfQwmbGKeLt73X/FG+ahKqhGj9rHnvlkB+c8PyscNHgHcqdojCnQ1cWMuYT1icfz19t5+f2l/0sVsv9Z8+eVuiQPcq7cWJaa1YiONRmOjccVJocUas2FLsxg2ZeSeC71th99BDDeGQ2QJQsfXkztkjKQLra0jPOxUIR9Fs6dPkyVw5W0wPgZdsCxbgoYHzmPHm9lyLwDluBfCksyIZhAldyI2I5y2yAm8dwmuvBQWP0IG5vjn/bg6VCJvFDG/9xG/ld7tARbvub6Lvk+lCnN8nsTUdj7DwvAJDQlW52l9+Hy1WY0UonPb0Y+1bvF1vC0Wp/qCK3iLnoENR+uYN1d1xprmTuQ41rsFmKHdcD6F/QHIPwum+w/XT+X5qvACTA2ItuQVnrYPGz8wvzkBZ7GNzzua6EX1C3EDvrk1gtSZHB59oDOUBY0QXEf5a+vp/kPUuhRjSqrBsgAX3Einbm9wz0RTb4N2MzEZImMU5XPPAH9T6u1MqwGfC80VJrvaeA8hbVy8zb2DY3HxS82AUilUEhKz6gfM1B4UbhghPljS8OhnkeopwjP2nHsMOcgKStseetlUj9ibkLTQj8xblSdfT7HnIKQkz4WFKfRx+0C4ACHZgRgYYcTc3MG4PpBRtvJPHBFEZB8Tjx+aAHT9gqhBm/omb12SYqHOuefe8h9qNrH2eALOYrV5hndxG3RAMpAdgH+0gIkcBKE2Wz3aXvCk0W8ZJSMPU77K3ljzHlGgalj4DOKg9hUQRXd4MZbOiRtK64YamRgk/JRdEhmbJZ35VOH0BxOvPfDAgqeHuheHk9AqtpB75ToYosxj03rUU1xq5WTwLH+iZKM3Qr6j/f73g02gUHerxXZBPDMEVnNrBiLK1nIHBB7bltL6feBJhzcrP2xIh51wUHOdG9SOsOw1SeSUxUjNMCpXb/80O+sQgr8/ZReLzT6ylOiFofmTzfvgiMSQGCZdFu7L8MNjrtxVanQh+ScK6qQ3NPcGJ/HhIXf1WC5mpCQLo4zKlPRCMRln3fZELsS50tG6VYlS+D4dgUR/TVe0SVoBd53msnRqp/Yi21cF4A0R2ddxfIpd0/24L3vx3UIdKpYATFvgjz3+RoX/rbj/XJmz8h/QBWj2yM9auU085hW6fDWA25+mcRTXVpSLvkG2hMw1BKV8D+B9U+S3yQf3mGOzvVw3Xx70+myV7+8F+tdsbaU2RV6VPYdI9Lotz7aqJiu7tCaU5R4eS4aQkAyLlBeXdu4BqVwUo2v6b1bUea4boYxzIG5PxIGwFzQN+Nm4ZxdcUCT7xiJg+arCrdxol9DjB+cc9gK33sdZzqwcjDsaEM9FwpsAmodP/f/zi30U+FOaTDOO9LF7IDRCgEaxpk2etn3Ei5jACbwGMjb0dkHR80t5hrlm7LES4DM8UDeCek79CGQ6qO7Nv88jP+x6bewcnQPtfeGaI9dSIBapf/zUjaYJGpDXiV6vsZ3KchhIVFUnXzdcerScHaL1VTXUv+dRgbS1yQfXQBprbYAkbQOCOiBQHDYX/BlgPv9vxxg0ujIMBplStM0M42ygjXRmZUB6MwN2y4wnQlZ7sw2cWQ3XucQz3IYThrgYHeoKO8NK5GaouKhEhwAEm/E0XepqXW4B/tn6ngfKZ5i9X8XwX38H0iWiauQ6aHA3qanrSH7Wdr24+/TCa/jX61fblojL+M5ZfNGnGyVe6CheU8Nv/JgzqXPWmlAfut0T1h4nRyOFg5/eFqVSw8C3A8CAJDbC0+WFQJAinfgMykPgs8kbOONjcC7T8EvSRuAsmHvBQr5OzxAFGtRT+EerVQn7G7wYcFTGH4RcPqq/da+JeQFCt5YOWdkJ6obsWie4WQUpH+lcPvxgHJHoqGO97lvc4dYrkShWMea0lVOdCa0Mhc7Csc3Hx1WtrIKG5Ff4OHGm4+twtlux6S2DyaSvfqVTluv72JG60IOUnLFo9T/1fQrOqjnEpS3wX1461CtgQjUBB7f4mHkWO86A8T5lu+YGdNFi9sjvbT3z0PQIyMFdAszPwgqvMyyTLBbuqotdrtnVw14YE6gED+/QXDavRXzI2XWS2aIQtKxoIBTjxS41+ffUhc1J4LhRBcRys39u78xBIRzzNFvpm1j1yVYKNAyF58EmAr6ZjN344E/jIgVm2HAr4NgT3KUvI7ZL9B5/Jo4d/dKObwcNsVt6K8XMzd2GjXDTbmA4xAEzLrPvQrC9ghj2MqCbI0MS4+wv2ePyc5h7OEhGBTg6e3G+yRew01wCyJfYKiI8kcKfO3/xYyIJcQHqj8DWKwPtMyW7jnHHRD5rJSFkC1z1RuZefmlQa8U+LbCZaVs1id3pm2KP3fcmgm/fsgp5tnh09H0DV0uP9EU7OdKKNX001x6xjYob6WZC99EP/QERPc6IdHrkCMATLOijyLJ0AwCDRf44rUNj62UJFu1he3cwwxMDMfgNmFzg71yVQim8YjjmCmzIEXm8DT8RecmxI/kfdKUrlSJlC+xcPN9iZV2M21S9ii62a5mGCKK7DvhlRv87aqLaeG/zhWLd1cU9P2xrz+BVVRk7kgKXdvVzwnqkvJ/awro0aoksz2QCoMpFR/X7L9Nfs81xbIn7hdOWvn5GxLnvM7GaduL1rDj2KycZjHgKbDtepqOIW6ghLg98b4F4Wr3La359H03ZNVUGK6WPh/1i900T8tIUkj3opMypmRVm4owEGY8C5OhTgO8ud5+aa7XYvGfHAP+m+NbhXJjcdGgM0L4r1JIOH8tlc6PqK/+nqJxeSi9Nf5IUT2e1KEiHExjw5XYxCHPjO/Y5zHp9OkgWusz/K7VREuYEM+d3pUx1WBEgiiy8ZkjRAY0VK03lJrEqumPqeec+Afqi8O3uQWEW7e+Bw0iQKQVY4UDb+lqnNWuuhq8HM4F9Uf1b7QNG21WWJU85P0VZPSL3Gh1sDYp3Mn35QwsVbzh/vkTNycgOl3DvxyvY+y67t0gQ77hfvmsCGE1kNBGJ5LVIKouZ/2/Rj5QtAtn7u7Tct/jQGVLrp/KxKEONk+0tGfISw1MtpbfBySg2OEmxX4HWKsPxT/CbEuNTobQLNLRl7yiG+awpLdacz3F6Z2mt1q5YsUi8nCtMUHWzDzvd8PpJ48eQy1JE3ErQU/tXgIO5KiXfuWx9q5Vy5v6jlkm6rSnRfdXIsOCLuuxp91IVQOiEkg4wGGI+FwGURJ6CdjHH2xx8fnUks2FAH70tubnftObysDOOu0GELfPw994E+W357Uoam0fQH93bSENP+3iAaLDVcjnFL6M82EcvJZrCAWb1f89eMPTbF2Ls0ZWYpONWXh728/l30Moh2nnNcO/OR3v9G+jd4H41CndGduDlBxBqn+BKyHkcBYTenN2sFT+m/QTrD9IuM8l2qqzOL22iUhOKf3ClvsYf3yZk6tnH4nw3/+cZ75nhglcSCenXD4WHUdXnwy3Hjhx7QlE2YcVj5mnhVDcb6lwcxJ2xp6mwSnmX02L6F1Jkmr90G2pasbz2KDG/u8w1t9diTzJLCc5IgaIiuEBQPctS48L8oNbPbnjsmu1YqbOeKLBJ2JcpAdqltEkLxlnn82qegCrjk3/BQvAU0acrG1dnAbmv1DFU4513KZVylDbCBrfgXYvKp2pB1AS9EuO6jSKZdWaD6LnVFU9ctfvCK2D4WyBFeqmPRtBtiqJn/Q7tn5WRTbutSIz3iYd4VZZ2Y01yq+0g84zoPPCAPBaHJ+WZNho8Ol+KtSt2lXm0QSuz+H4OChnf84HGrDlRcE2kIjZzUcKXCtqC6y/wvyPxhf/CJ3NdX6mCZlCQJ/ZLS5pkV5LdT83R4/tlJ0eJ0p4ROY2oP7D/Hy0COV/Pv/fBvHkZZ1tZXf0oDurA182rlERhfx1hWU9XoazdwlrLdcPQXt32IeVNnIbNiSFhoCT5kViMp0S08CtrTi0d+PrmcS39X71hyJ2rZgxeDEZw8CuPL7syUKq9JztkEGuvffZdlFoPu6+ubAieEONyJOjAku+DefqKMEzBEkIbj8GFRMKOv9YpkdjlyX4TJU820tEwy4HlSPJoCfjo24X8Xxe541DrkwfrHcQ67jAQFkABVPLn1WCn4g2WFZ2/R+AiOAsMpx5ruWvm9IC4Op5zholzwgEl6MByx44Uv09Q/tBmIi3OU+5VLXGACRHMkaPe4qY3E6LTVsFK/b96qGT0SLDCP+A+UslOrakoWTrLdaK7wv5VIyKiirx80urdWj4F/9pXD3kxTA+QwpATf5Y5ws3iwmDy/CsP4N9tHQsRiCCLyWC+dHNLDBXzi0DMYkTR60jbmlUTkzqej4WlzqBXhlqFpERjf6+0KLrERgGwcCOz2D7QqtKB62xdJy77+aOy//WxdproXfNMSO4LHfPZJyNrKepIxaJ9s/28GaH+6RMwpWtTPwn4eoJJr2bLOlmSXOjF2ccZzsXNwIshNxrlRbEQD6lVSe9WAQzIfwe+a2csFCq5tVsjGZlF13MgJRR/dnjbvsposjAs1ZvH5B7Rs13/HMkY2Hcgj5iC/xgns1YXCP7BswzGDA+b7WuDdWb8v1FmVX3hZSKpAVZMIT9UuZDU057jSs+5d8D+HWRVtsuvUpRMXCnoC11etcgnW/zUXXyRdOQlLp9ub/BYGNkOWTLrgannbnPxbAtvF9cISG2cBb+OqeOlBqzKsieCpsRzneRDlc1LK7w9OuJLy9uYzDH9zPvxk9pm0t4bIZHZNk/ex4ZjTQUEhrMWw8I/Y3AlM6i5fd4GtH4h9uxqGH7svjwcbmBd4AgN6xPulLZgHC/Z5mKWt8KOWqZe1+QAoAQb3lvJJe3a3LV2CIgCyPw+1bAp5pCB/j81hv/s0D3XqUA1TorUNfeB5+NDnbBjJEI/6EM43oyRZd2Ehz/9GCdyS4w/XnSm9V7kWR/51RXNkKwDXpVSkffnwQn2M6OWQ3A0CtW9Po89tmTK5cFDrdLcDqQoB6gNsIjsNeLajsBOPl2tkK6L1zA4Riafp+j5ExEMjJiM0B0jFTACXlGGgU4RsYxzofXr+lGqMjAyxWt8sBMZ6k2psiot7S6tb7GUlIvlV7q1XePpwoCbzp02gXmLvH0I4tkcJMdSFD1PuthryZpkl7rKsKfdzXW6S05Kcy8/ZO0CRWsVsNvk1rbujAQyeI9YYC5zB+L62k7AUgsJbOKAUA5If4bALINEs7sG8ldEGYavN/ykA9OXSuFA5qPR/RdzzuHDTSlOx4tCSOPDWzUbkPi5wEKJ49Y6iFkGtnRyiUNxFskb8NNQYf23WNlGtRy/zzxFkMmtFLAVjnsRl5sdyKv6tosaly3wnP/v/oYbnLfH9UsWksxBxrXE3ZcqHARUdG+tkcPlVSqf/QDBMDhF4hO6qw7OWcjwgU80xGg8G1CZHgcdOxyxx1j8zS+BZAIRH5egCSZ2NqVG1zWpiwkebdacNcKjkc3oAs2xp0Ku2KPW50+m434rFYByoNkS3EQlCLdW0D/QGfU/LaTT3RrZ68LUv0WMruKz2nFvBO9vUq6l7rWn7PUF+jadJ0/75hxHHOF8cZVxVdFJc9pm1WXdo1136Xeo0TWHf1GGimt+cW2fwvRv5/1kBpueucdzynIP3N/OkGEII/HKlZysXP0Hz11Cp4MnEuFvnQDrufKFu0IOsKPxHKGGo1RoIQR/VryrHsnOfKRRPaUC1owRFSvF9NTH06YzjebadCzjbvTGCQ2QQVixLqKAvoxADEby0+7UjhEetytADdygcYrdh8r9ByjqoVl6lGyCzlkWEeSmS9q2CIABMibB9p04yo+sa3XzWZG3AtjJcy0cZ3Pmln52K3ZPtrPiPbxnj6V4h3GUY+NHpumdeSCSdoQQYPYKdU3TyrB7myhtUiJlkRnJ5FKqYuhd7HF0prP6yxGl7QRKq5Xg6JiVpYoDV06RV6AyN59WeMZC249w2Jy2mcl9qqW/IMeHlUjGWjPP00ogGmi0cljNb448xntcskKZhHAZ5R21a3qJakd+Ztp32Q3SvksDIAlpzYA3JjF/2RqklFFUUhvR8KLfXSqNQtJuxfFVwLlWKBievwe4ZI2rD+evCGtWeBGMQyJRoC4GsJHDqLQXYH1KXDAiIGMJoBN8JhAOaVh7Oq0QCz+VW7aBYaLyuKDjh1AntndTtIlrfDpkyVhewjp2WJ06spMm/5LMJLLVCiu6DQNAOoigasakXqxfvDkROuHUdw0a6Ep3Y8IgyQw+0Nm23IFlx9sRcKvsYWs3ofdzkXR7FsxyTIeA7/OrGagrsG2QkgjgENh7Dy48Q0DdrEwaR9ud8NvWsDUFFMQ+i7NldqFXPHH9awOjX4AcTkTBqqAKWmmDVqkAfra7b8PFXttAPu8oRJtspKNLePfJRwxSC9lfgOz6rm60sM57xZlvy8jn6lX2QfND7MYCz9RvLxR2gvfR5z3AKRd3WrqPCS6VaSFJxolNeZPWUVOassyyKXWbvJjnmMOsclw0gUQot6dQ+4qw+y+QNh9EwBH5y37wyfaAwhtUV0uaHyUL14bdfdICklvNxCnPtR1AMqMTecGVkGQ5MunuS7U7bc6ca+x0gIWfoaIvUWp7j5lQe4ufrdOwYjhbtE3az7MTVCh1NMwOf4aVK4JrX47Ws9cLMYhVKGtR13vXrgUBj3E0K/j9cBQyQBq0+O2pI+4ao8jpAZ/1mX78PFl34Bph80qtzowXUGEL1SF+D8T9hKCehlTwIjWrkkR8xUFVgakoRqM6shn30bFJoxbbDjlRzUaaJmppBDK8D4Z4iujgyJPu4KvQKPr5CC8Fd+HKRid9chdbJCNE6BAUTBfpBuIsZOAW4Om/9IXUuUdVj2z9Zu5+Zwp20Tqs2rWC2sLsLytbu6NmVexLaVYMmlgJoTBhtUlflumn4RtbtJq1byslNwNReYMxtfnVZOZ+f+bhgWNt3QYwnLv26jZeBZ2DtcZGREZrsxGvBbRlXXFlyrbo7xpro4qFxnArcCNhCNa2dkcLIFkruzeUvQK49Z2fpNX52D36vbnWHtgNy1WXQ+F5PxdCvdonwhtwpKrIYqjCO2gZ5hPJy7ZLdIDeYqSAmDyMpEPpyAR2saK3yPvAeUQNoIFEBIHRESYgJbXZZ1PZZPSUXbt2KBXzpaGXxOITXyElv0w8pnvaFV58cQTLY5RdhuBEjzXRGgym3QZyTLWdY5MSCgQ/c1AABS0qL0XJ32rzJcw4SCD4YQJsB9tfGsl3z7zzkkR3cqxQL0AvV9i6P/aKEuQ772GR6x9BTU9DO+spuK2AcsE7gvVYjdi1RdAwZwu5kzoqoiq7gOWB5FhVjkGSZ5VGLRLbp3PKrs1gCXCwRmcPaxY422J3v9G4DIMSMryStBUkYLQSkoApUIKbH8N9L/RsRm4pJkqa9QIOL8oVUBWFsCVA2aYdLIvKRJCHBRIqCztW/xcGE4bkYCchyFWGmFd8GJw49g0d+LnyfVEDjoYi/GXZ5pzW24J4/EqJK4ZOZjHhw5joGu7E5vG6nbXxWK1iaDG6NqdCr7YoX02mcsr8LmNin/AzRVgm/OSX3VDf7hMHjgwOyfHohhu00YZzy9TWSz3LpupkocKemWuxqVaCMyWNU3/LB1MGAvVxLws2h1HKzpse6k8u/sd4SIqnRJishet10lBQfBg9ZIrrahtEFRmpN+Thn/f7Yi5M6dfORxcUIAzU5bs5tCXiYJVOc2lvhQlvYrsW9xM/+b9DKprRA2pbnDzKV9lFvfmwO+F70LpV9tqkXmKgXDtMAoiOJaFO9KVmpYZMrR3mRxbdbrZQvNQ1/VlQPAlMiemZXmrPKd87AESUO5uCOJqpVcgtTw/SCjQ73eU12PAiym6+jypOV5GKAJG2aFPp0nZCZ1TQNTcfX7yxopvPUFDSU65+ygg64dVPPloZm4GbKM6dvb9aXok5RsxtCAEH7NdC55F7zpIEbbcIjAD/T1DebcDazP+iTgIaAms4ovlWy288INzNyU5/NqpFcZh/+310+yqChcdQo7612laumoeroqxCnNMr/8uiz68mpA2pYuFdkhk/3VJHUXKQSGMSjhjU9HeU95tuEwC4SOXJuinyJSAbSmpBd43v5txVX69B8UnLRW//XmZOdiyV1JPQgVfPlyuaq2kfQfiM5ziTyWt64tNry4FjFqGNArCdYKokmNC9lIgog2r4sNJqO5rrGIv+/IUQdyi/dv1Zv1z4rJVHOOoLfp9Kxg37geHpCp9aKwrio3jGlwf0jU+4+bvVEp0gRBxDVolj4MRvqCBka9MD6RiLltUGTVFs981St32qpvGwzLlbi20VsEsdxRCfpS4Q3baMwkVLW2m/ARsslFY8BRniCwA3mFQ5uzA6EBfmgDtY9Fv+A0RiyRxii8QCjt17qDbXHb1OaVUaxVcnO6Al2DLpah8MTh+O1vYX9gVHfBuKrSBIW0Hjaq9Cu/hBGKCv3ZfNnTkmsaJa/r0CohDit++F4t73U4U/TqTL88zJDApQ7ul2b1Z1QuI68dj6X8o8W+tqCsaxdN8dNBwlmCoXjGHfroelDA/Lu2rgEtkHRmun8R9w3PalGd5/Niu7xqKhuHjSF6tgwgRRKSlIk+OCV6LPmt5pRjzDBxfpK1MaMaiwngslwdhqccFde3JNf1Klqk5JKxjuxegevCCvPMAaK4/8Z5vrokP6yFcOlTpy1WDxJwr3rh0/V7AaIcVzd9t5u/Cl8F2qQ/4qEEEkS56+zTpwkxMyaJ3P+Tq3rUWXJ2Zgmy0FufYR6kCLUcuZ+XAuGwM2eDgu81oGv6oIMv14IZQAAcyAFSSbN8l139RufBfhM7suV/5wIjDDIUP2mRcxUrwyecPJFUKmZjF3JEQAP3XWRDO9rs7OaAAygA07uZccafeoe5WuuYKou5zMx4T3+uBkBRySxDSI16C7HRiayS6p2GslbslVLwsGY4FNX21vzbckmZZnGg2SVmUMH6XW6mwmF6YbWZ5Ozq5bj51GPctgtS6Aok/NFlxOlKmkPX2oZh17QDZtwbLztg2f2/4WMFDO6U1eewRWGVbC49PC6NWePXvfhi8CtKdXbS9pibjkVdHUR8nQNYiU5F8LQZ+bwiI19R44JR3CPbyzkmCCDky20fNmVJSKDFo4d7lrSN/S8JM15QfdVeMgUC9/ET+gIc/ELrpd7+nM7wuMsr97zk9tKKYuz7+6zbWKCvxEM4rxCZhS6ed5IScfB/ox5AUelAILikV2jjQvs78BLZhHXqvYjh5Ha8PwzkSM/0ql1puT0QAWiku3vJ7auSLBgFLJ78K0Tf4H+WCIrWqgEGFhEa58m/lGukP97SCmB/BRNJZu3WfhibDT5csNuLIWnOrb6nId5KQHr6FLJ/NYrBYyQ6sA2s2HJfdGfw2pEwBjBIGIchg2SQPMI3hLSb9OsGMRZlE2MW9EzJReBx+DaZ0nzPWUnyTYFEmfgG18OMvCMH8fQdNFLfL7UqEMI+aDiKud5UsSaJR0w2NgBbaKxpHBoaTRKLn7pVr6NjMe6223Cv5Oo8G60GYMDzdpdEdq8K4vH18ZFxTkOAYcybRBb9/lL+feTgbgf2mTx1DAj9Xb5DTYBOI9CE3+D/ZNRBP/WVOc0Of5Ss82AZlAnUd2GBvlobQAFSvJNiMKbwG6NWcpD5madCL9/xbVnTxAGmC/pciP4Wx081+YZqfGHQi3xc7yQNh4J6RL/9J0Or5RBTwTC/a/dKIqu0Yr/+XjviNEn+rhAetM0uff0P3+c7g/RHhhw1de7ZFibcaJav+9g0NxAeOkmLu/0dPDCgekly2XSzs9hjawH8940OVFTPVVcx2OO+4DZErw/aIgx04H/UyfEpyMLyTMRwP0TkKjvl3slndM01sJz6S6Ph/SBN92gPm0yxfoyWCLGUKlOf3wxerei4+LcAjhItG94BixLlZ4IPiUUThzcM8LTCX8axnDpeosU+DZpoF0rpJrTOQ6fgcgDZQA2GK4ENZTpYOxprEDajF1ihXPImxxiVIYgYJIM5nbCiMiTpEvXpsrM7L1TvYWRKeYfWaG1H7ad5olx7qnxramwlAi/XVrw1yBbl/pVgy5lRJkAaQsBqZ7FicPnCOAtUUqj+wUFBgZSI3qUIx2pHRh0wz0826sh33CGf+guumwlBdBnBxVXofDkuJGQQnAKVySnXs7IZtzT4wi5gEgoIdetzxT5U6g4rq77L2LyWx3MkRrlMFV0874UvI/67Ifua4vOqx3eRBHK47FwTq0cBmsB+47pqygUNU4HDmRPQ5LjNAOQpQP1nWDV9xpy9Hdfhbr7EfxW4du7O+5CLnp7A9FCBQYJWNZHjLZQ2YuG183NrQb4vNyR9ll1eufxC7QMrm2kcIpS71lxt21ba7zlw4XYz0xlb0bextWZOLek1np2HgprFKGpE8b8fxmQK8nFop8cwD/16v9YKD/wAVwZUpfHzSutRnj2j+y2aesnsnzZ0TmVFeII+jiGPQYMTJtT9CrgzYuN8pCmMbmWPX5F/opz0fYcPJsxXkOfAINNNPr4C0+qPGTYhWSXtHfJ5Mu5rGV7ZdwIfLxxv53FC6izPzJrsHKG5UTAYwMKVdvRpWjVnRkcnZPPEuBZwG8mFS2qPe9FrcfCfxmzZdd71hMdB9DMe+u8/G7+YCuZEwK7F4NBmuhQU2gxwtJE9s8jeRP6KVwZXq60DbENlY6thnxKEpS0lLpqvmUTj3Kp8nbOivAijZ0jR/ZyPBDk7fjMEixWV3M4LKqV1ZIXS3XmVUTJ0Wor3ssgRyWdg23hkgBjYzEtPk8BAe7Ocavnn4TagcnHoZSJ8s4QFiIntmBewYGlhn0Cr0nMTD5Lb0f10v3Q/R1yiMMe3+GlOy5GWeR0gE/dd+N362v9JgG/pAo99ZE/as72yE0GBuUaKbWqSb0QdK2TLfu3b5LN9yqRMsa4CONO+gfQSvujVhM41N2PPcPkVZ2ujBj7uc4iG7XnUYNeUbzQoH0HGRekPSTszVXX7EFIbrAIDvpjUBWLWnXj+XA5v6wg9qcAWh6Y6YzpIRF/ytZd+lSLQdHmTyt5UhyLHMGolqEwBLK3JE2NyMEljxnRWbuo4kEzc0FPE8unhM5qXQaVOEHs0YUD+/ugCeNAQGuosf7r3fUqzw35ey9ezV3Nd0f5ZdGhhCVJ2or6ypjC+hsryspLKHiVcR1fBa3OnJTK0TjmkTyaWUHw1aH9CyqyPFfgAvUmPjtN0me8xNukn/u+OHEEikEK+kolYPXt5xNoaB6GlplipEbIEpW2W2xP/y2l/6ZU3tTY6XkpTxyfo2X5nGmh2MXXG9gPtahLLrZI8s5x3N/3w5oM3o1BAAJOsoJOiIzD2sz1exMdGFE9cSRqUNHG3C/DEpBokl6DXuirg8k2/baOMX9IKK6AGi2h3mMK6Nm1vwS1qWJBYJwDPzkf0nzvXgH2zL2uJRzovnjurkro3RW9FanR3Jgn5hZC6Utx/dds2geUar3oXdHqIfIV+GXjdxIkQ7lNqi+wvXxdWKYj65spwio6HmFPj5u+XDCyFQeSrmAuEtlER1Z7OHaTmFLY7KS/n63BD/c52dbKcKvdgGTnQZH9v7NonaSekS23RHEhKADwlMtDf9xIWpfnPBCn6/N6VqUutS9zsbwk+ir3a9hAf+SRnxilE7q51XRig2fuqQ39sr+a1YPeGOpS132TcHKkPn3t8cmaA0kqE9An0aIHFuj88kko9lwFj7KUMfvVpx653JeYKCMRq8uM7TiRNlBBSdAMuuPfMCUezU/GKkJRFlZOiFqzjKGUzg7B2TSMKbLlXojHbZRjnPUjiDq63RGz85jwqmez7fl+ktWdWVcLpYYISbqoB0lSmmglzcSzhq14mRnVXLTUnr1EKb13cEKtyvJ/emrSU6rKX7FEFOLtclb3zpQ1zmH//G2gB8PX6E060lg/m0Xm3YoLqmIY5ZYWjTNpO7LylJDc04MNWl3twr+DIXfxjXKBeDPpgWsMrnjAOfZponblAgPi/HDQcXOugT/q7ulgBuy3maftgsA8Okwui+LFDWzOGSHJVjU9xMnJEqFjiy8spOe08EtIgXwaODTqscfH46aPhpIJjg/YT9ho7il2RQ3gLQ399d7z4NGI5MUo5CCcvv5hZ6yUf9WAWeXdlpZxNpDDGArt0A8qAUsm1qF8v5CscRM6cAN/1C8PA/wQau+rwRbP5yaVSul/pLQGIdrMYOC8gxCMCPw21ypd5Q9pZC6SAcSAxvppC/oDNhxErpmKl+tTHoDsndhNW3SN1+/1wiV+jTvvQxmQJ/zuboDAvzmHwOPq+zIxURdO6wETrRxSY3f9UTr7onm/LQDNmj6H0VXnxynHxslA4zAgJUGYs2JS/sdca3idf+GKbpbP+doIyb4s7HJqi2vJgHpc/bGfyPlfc6ynv/yKPTzKuMVD8mDCcypV6OjqxFHfECAe/IbzJpUwRymbrxLwdqo3oIVO8n6hqm728qgOz3HONgqrdlaaFCPeGhgQ5pF3ZqCk+W6lVsj8JRFd/g6ynFM4hjZI/o5nOn9l8gzKrgOp3fGszCdu+Koq2mloDcM/85C3gIBBnURl4f8uanGyUikspg2U8aN9Y3stX/VWGRmc4a8RCFRRfsleoX/xTxNaUiJnZ6taS8jlkjhWdbzFzE2qpKO37CEOXb7FRMGuXbWexoPXT64QG4KSkWYkN0Km7oS2UFdy/NdXhuG4656w362RkGo7uX2DaW5EBR0+mIJgWYm0pDhZYN74S8wyVuSJJGoainK/ECoy2oop+tJsEnxq49XD/yK0hkp9AfR6aMD88ECiDqRykvzBTgPxbbf3xKlu86VGd0sptcsyJUXhg0EQbN3s7u6YlmDw4PkuW1ZjsOEH7sOF6KO1IrtR5W1KZZ489UfZp5Jpv0andSMQBu3JRlFbmRsV+u6aL4JUy3YCYIhv2de10DfAms+w4VCk/7l+Y8YOekyNUl8/m9LK1V8lbMRVklwu4v+nX7yeHaMnH/lATJGqOlimY4k+gbB9joXVCP9buhstUHJEj33ehoTllLYCBra3qaNiUX81ZLVtWQCE0sLJQYmhcBAPP6NS2zqaI4KnRmTu3K3E01DmC+58Z+Czok4mOL9VhGwpYI0BKxfJyIgBtWCzr4j+DfNK6vVE4AM9PylOCKqnnwLgKDycpQkdMjJeyyi70FhhVbT/PikgBtRjRMJD+fiSnKjUCnGHuLSM0OoBX0AsmsP9dbbnmehSSZviWViNILEsnSfrRDwK4wwPrC7kuRiw0tzNxhRv5R1T8zNLuL9+8qAqd+KNltyVBrZWP7EmH2B+YozNNhir0d4xJ5gcVBfrcUPkwOin48WV9U/1Qq2pAhe3Ae9MLwAqf5fACp99ECxCNPHxWmyQkGKzhyZC/Nptc4rZ7Puz5eYNlMwN3OADegJAZ1Bi1A+SisyiAYxTsy9zWSLXtd8ta/fllXcTRLXINi2m3n/+J8RaeUn3B8FVupLzZ4QbgPBKfgTFrcuphNip4RuTsd+/NJB1c1YNQCvIY77iOCFqumN1GNXmsthLKVek5N0xTRGFuTLQnlYcjvKCKNLjjGUAcm/0kzviYvVwOySaWLEy5rLZE2jldZq+NQQ0PwEUqBlLtxe/dzauYxRF2lZLKnu2vX56UK3EPDWFbUE7C+sEBsOlWK6e3mhlmsn+NST/4VPvsFNpoXxlBCulY84tRc4aCLDqRNttqp4jFk8UM40/IGs6XyQBkgaGSyKgyy+n5VSX/llmRU2uRrpblryGmBhV/f7c4OkuoHs0O8OjQKpovWSuCy3rC7oVN7bvIH9272PhdPoDUg5T+GjNbamyWI39r5sa9t75ewOxF1LfC814tqHyVOvKlIaSRpB9BTO/c94Ee7EdUtKFSoSv8Nrx81MNXiNiqYxvdCjEFcG72/1FILmbRdNUEt4pg0imMPGM+J8RmDnEz30TR+c2peXO2/hEear8PE8w24AfiX+cvi9yxceZUBnagzN2oiauLc/xEJhzEBkqLXgj7Cw8lxdUiF1Sd1XIWohDRx1EAB6pMWyeopX3JcLdGu64Z7P+/uQ8xzVerA0QvfXaCfc3LRHGVB6OWEVXxlNMmuOMuhbaxiBUl71EevAqDNa8XHqXiTjtqvYA6PHkMXGG7qk8ruXwfHYqM4EvNrbWwwaBSVdRw1UTD8oR1aB2TIDs/PHfBEie6UeAtvM6jWo8rViB+o8Nef3UzihMdTbz5sBdL3rqsMqEn7PSMEkJwKO2SsRJh53wmeL3M4NL6d2v2YQehqC2oj7nTl0+2TBL2XSjAYz9VwfCvQNAs9+Q0IYcymD8YPImyWrrDjaXY60wpn2l1NEg5F34ZDpk5LfRlukd3pH14Zcif9tiT93WiIdQTmktQz1nTw6cVyD0jiK/GkCtqtw0+Bl3vk4JHHoqDHIg3oCfGkINC0Lb2zbTqGQKroPQQyPnrne+1TabFbVxkvZNzxzxzJ0oL7kkulsKqUH5LNftNr5pwT9XrLsEZQudXSwQTcrXgU+yZdI4Lim1wojOCCKGtquQki4RaC+GyGm++3RQBAMvTCYJ4IMaPoYQcuBsiZV7cftHtDhSXIiMmZXq73kt+/IwXTpLRlkN0LfAnR0JUI27MOydbylBLBHhZmyhoXEfJN6y03hJU8D88lJvduaKkk2IKaDoS4i5UB+/Fk2B1/3uN8O6C27SCZakzqGJ2T8s0gWZASGPS+Ph6njCNggiMuLeJp/WkmAAhm3WE2zo5j1duxoWKq4igYwUbyG9mKaUxKYwcOS18bK64WSlcNGZrrJBmf4XDIBq7s7qcy7kgbWFs2tWmgyc22lNqZGxyxmObtIOyF2ytghdtJdahdVqKigny5JLLZjDVOI8zSRNmLOpXv0oxe71tANXIPAmvlU1udaZD+ObB6MYxYOdAkV40F2pS2QtbDaojLbDpBATKEDCAbObEMJgTj64+wpCq69f2KC6aellC8hO8+ze4gsRBLZ66WNrLEknr52H9Va25jvaFWsPD4EA/p/SJIhPRjvzAiKloQMzWCxPVUwvNkF9BxNwns+pbrk62ZtiJhJ09GyjylI+DtgkLVwYDgIq7eoFvTeD++8/XXf6tNN9QyNBINq1WZpkxpNigH/ZT5cRHvzqr7737CaGsaF01hqpRBE4I3fR9U9JzuOMBVQzyR61vQQmWHdPXvLoMhkll6j42Cr15D9XeSZnXgokb0GggSTboD8TgpL2MmEguafjb/vgFHpulUrpQi55vSHGIxYUXwTxiwpKju+Hj7xLnTdGEa4h+LqeT4mXtEMP2XvXbaABw+YN33sQip6RiS4crOCzax1KBqs1zYpJbxaZSb0rbaisS867N/Ka1Mf4hCV6RiXkwaGZoLm/Zk5Dj5Yxlmp5uEarjp/9/ejxvWVafRtaZEdore+Tqv0K/2WztbZ84fXFVIR63DRkkuoYCRtf8N+EX3O8JCQ2zif3aKI6CJJZbgtkdbZvfmB9GH5a7NPzSKWuQEhtpzUeD6dDpSK9GBg/+tXzWtLjfJ2en4qNi3aUIHwT12XSMiyAsaz0wkCcHbV5LGYCvsTV78VLKLo2wrihc63uigHQ1/e9vvbjhxS2HQupb+2hRpUCoGk4fDhIx5gRDVB979eB9fF1e10H86cailaUWGKJ73PGwJuNTHmf5jChygw9Y3p2x5+uSvh/XMt9MXGaf18IFyL9jKAyOyU7DDR7N1UDrHPX073oyu0RNHObvGorjMGnFi7nbgoh0kwm1gCkXLLQ1u952Ub2mA/yPR+Cn9swLMkWcn581n4LKSCBke0Qk6K8swzg0IQloi6kyF71sn3zRvtuHU0Hyiqe87ss7FdcERwd1m0m9uANkRlJIXLsNTSvxeg5vSCcMoYt+yWVey4prN6FPUKDLVutXlvdjkZYbMbPQn75CjbqdVtcvvNaJrrXMLIbwfeo45G+aNEDPWd1fwHgUXC2iIcfOltpAI8sGLIn5aW3x14/enA33jvRpuikbU1ryt5XfrCyjRFE5JDzUSp4hUi8n5pekY2Wk3FYIt55aAsmvty58AFyprhK6L5Qta5KV4SyOr1wXWh1+ot2kFwX/u/b+SUQ/b5CdAqToGbuGoj/DHVkhrwaacLY3jBzpjtX1Whmqcxcvrv17T7Got/cbTSCp8Z7FJEwZxyTGcVkkIB5evQwQtKVvNLVzivCcRfUPxAkOk5Ffj21vrN2M1OvjfW9mHqY8XQ5xLkYTTFGFR9yLvsBEwazlk8GCGXMP6teWMaeAkSEL8PuqpRIeiKXJWR/F/bESH+cIVN4hbqjZ5eWzFioPK9bLs/5hkWj1mNHMqGKurwKFEhPFRymmI6LkVSgoHNVxfa0l0EpKP01akZeEeA+2ZQDAJeqWMJsH99Ln8SDauko8oi9yzz1P9B1dJPIdoQmQ5OotUGmh6a+cX0M19Ayczed4RF/iikpdbi0YYuijf3NOLBJmCUa+lBnuEaCbADoGots5idEVTzOAwz1kFrtoZJV6i5S6QgPH3L14NWiQoSDoN6UdECE+Sje/T9aIyIEaoN4j9QB8RX47HfZW31BE425+piE3jD+mSwASzTgW0221WpymMH3Ujlsj8CczLjBn4X05VdEloUx+UtFpfYg/dNwGlITy0EVVDyfCcoX4+xm4VKMqZrn91uyfOR6ky+KtKX+FZ9xAy5STDyHEj7CTNjZQE5nfR79BiBQLQBW8YVyyAGGyiOXi941YCB6pV5tso9KmRSCGBAyf6+4/TcLivPTzKHvy7Zua1Lvc4lJF4G7i0RKh21QNaae+709WfEhgaHvMvzCYIDygRvfzl46y/RwVTILRlr5AtPDMXAtpEXPRV1nJgRuEKcyrS3/eqX6KbqLEaKW5T5HuqP3CqzwggQNAo17/IIwy3dxbnTiGvsYzWKFEKv+bqBWM/u11G+2W5QvGcTmGnhKRHZR6IYM/FM0504TjJfbZb3S37MJ7Xxyb/vzPT4jS3HS3ZPWom6StjmR3S8mHDjJSdfhOViMHDozgxzz5R0yXwe38hV0fhvJU3gfvX5WcxXzw0rLF1GQV260MmDkf2cHa263648RByRwPeDrwoiTilZ0r2vgPYN4OJ/sE5XJ1rqzta1e3iKlN3ypRUMHJuNcBbCpv3qPIEXxT0cFSzsQ77zKfkZ6n0QahGfihI8AoFgwmDqp5mW9jZjlEIlfgIOj6YS7BHEXCs5gKkgmwa1ytcEmteD8vLvrBjD2Jth6Y+864AxOl8ZfsjK6p7fPawQeAt2GYR7fEThGVb/pUr13lC0jKCBzUMMvQXUN4C6EJxj0Qgiwnn+GDzCknhQT4JQSZEnyiHaR4ESqsBACOKEPYEqLKPGmRUYqOG0KTxsin23u8voNP8rjWtgyrPJs9Ya2vKhyvWoNl9T4UEsAy0Hw53aChmS3s8+JVnr5wNDAqnIYkHA0DB/V/P9Vj8O2ew73nzNoRENg9LXXL5bSrRktL1dK8kuzvvhQ5IJYjtenx0Nou6E9wm3hfcnK/gyVW1EVddzoI0qZ8cySTndI59vcKViIPSaMiGeygCGHRlm6cQyawKEKPZzecTAyhLn8kG1tPVoNAa5Sd7wEqMFagC0TCc5E6BBmwNA8xdDdbaBHVUgGlKtEZ7K1l2u+/ONsMYFyBH/gi4axuwiYtXbrl0x+5m5Rb4Bq8CGJxp6qUZMY3mYW3UoDkGVFEcNIOFUHSx7SHhj9cGWn+hKzYsS2J49ukwYzKw02svqKleY0BZQVVdAvDYfmqbiqJ/h7t3kWzipp6mpqzs7ZzI6Tv+6JRRUbpihRQwm0UohNCY63UynqNkbTWmywQhjLKkCttzbuVwTJc7jEqcFUtlskjuZ+PF0WLytT2fDc3hJxCMYpjgwxc3CzWJcWJMfDvJ7FlkEDcXHXNhxEQvQjxLA0m4NCXvGDZ5L7gAG8Bn45iw1bbzJJ3vaUGFNixg4aM68Ods8yNNj6bITnEWBWbEAdpOgbzmsE4Lt4J41vDPnoqUHUvpQGcJc7IVM84J+omUJRpNzVZQabOJjAxEuiz3MKa9U/2WL80cZNjCHCAOtdRwt5lEiyJCVzokcyCbl9KjrnoxvaBlpwnVQlSWQPAtVZEhXnUMnn8gLgkk8iXztJ31tyQ6B+P8ezOqMwrk5GaFYYL8XIXYVC4eGP9faUvaqkbEZJ4vdFXU+WFk/+o3N+Yrg/YOcuizrfnD46S2wR9ulE5HYudmGzLWRGeZ9wNegocWXesrDsK9biNCeOKE+z0J4prj0zPeRMqfJfUng+0uD9pkbL0zbIihZangVUHnee7OeWYUykrFXzA+GnDrIiqJIyvcIIFmnqatXlZV2UXL0G40zHcQ9LwW8KNfcvd8WU2UlPoAnsB/MRH7gHbW/PbmXJ6Kxa+9uEDrqu+Kuy7AjbVnPbmj36ykXP7dRJbRiGqC6L0M3ehpb20W3fa4mLPewXE1yNY3oXnGbfuanIdhjKmcrD8BCNji9wP1CVVhXW+04GiWoYOm3bgOtXJp3e6Ff/E42ngbuFEiQrxhgK1KiZyp6J+OIbHebbLDdlYtw3Tcw6UqadUV+gecKLs3jN20zbmMd6gS3E/fuDrZAEx3Uf02i9UpleBLiwO71+My6Xpr2qOVBHbHlTmq4nxwUwDZwpVPWTI2iV8VYxRNR5TjpD7QB5TdxBuFBEUdi9n81BOeC5PRQx+Q8whq9mcDMWAR7oQpSTs8Ep2t3WDTI1d+yHsLcIdsktzzZq8R2VLqdLX6uo6p8JvuxBUSUOYTP8CNrZgWeJ6CBkMc9E/2K40IyfsPuYt/gqc4+tCt91naNCa3fRf1gFqa8WlGjm+kBVQoIdGcuUKv073760rJN05Z5uJxCu+vY8cghDwMRKC9fjs0X/eEMnWFGiHnwfH/As3LoQLqoUcP2RK//OxThzex5cGsMwdY2MMOqAMHR7eusd0zHvGfZN8CkoUM83thaDt31Omy/Fje23h9jDbX6lr8mNXia3RoB93xzPDS49Gg4juPazVImKkS1fzyoVfXU2x8+r71LYPo8LWj0+eF0WfD2xlC/dhgaLWV3o+EIH2E+uiJyGgra2Wv1inQq2eSIfoS4C8Y5nbxpzXuCAr6eIMtnOokuqfTKzRY0FUTlTWmoe/kThFov6svwBDb9WhN+u0CfO9ZyLDUXVJyGKlcWkLxHAZFnTkyv8qDuZIjBohaRH00Qy38JxPxfd6/1OeuiJsqDKPK5kOK1SYky1HvmoYm787qSDQifDNYki45kM3TLTtHe6j5+r16Bty5q4sWeEmwxzTuiqZI7Sd5EFfHhs700II2vE7yL3xemnC/blaqjc+md+9IG2rF3khd7XRKDUwR+v69qEP1ank1XRu22xipNvD4wPAbe2/M490ma6+dKDLrDUdFIkcTKaPuZXrgcMQau8ihzxfarHN/wtU6RNu8fNZVtJn0H9QKVYnxP5LO/0/wKTf4lZ+CXsMvE/8a/1h+3KgFk8EoA9GGy7jITg2hdIROYZkSoa1GiW++/ZJLr+k1m5qaMYEj7Rr41U4/vIb1e6K4pQQh1NfKjX31hu2sIdZJSc519P/VLEMOSTkXR+0ZECKQcu7BQ/tQyLFsCG1dXBIffbWgc0QvvjnIRzF/GPNHwIghTZEWm8uHn75/dCJB4jPcVYsj51TQ3AyVRdwbGAmsUg5+I7qLcLJSIteh0ZhC630CYCNEyaZXNXmRRdGSXDVZ3TXVurjZJhgz9sy1VSj8vEeTVSobfqNh7viDLbBE/DKb0TJQi3S237L96kfcV7I+WlYJjREgp3czjRuzkmJiBRhvz1JLm/Cr/Q7INaSxT9R8GrKwaq2GZcBfGmm+e7mpqxxUJYB4nyO39MSDqNrWk+MRwP0YNzC42t0B8H11kEur/3Q0Kf5zdkAZklwt2OmXdboIp0at/3JiNmyf/4QzuIYAyxGA3S/O7+UlquvkPurQSXOxdYyE4sg8n6BUEDkKlfWFyPYYF6WTiWQn6AprCaYVPDyEQpnZKBDYe/ywFdAc6FKdpElg1cjhnAe/flvZ5wJBKyWW31jvenBlKSOmDmF5eQdMjdus/8/ZCGQ1ilVx/8VP+p7JG3/cYPVSZWDgfzn+p1bNeF8yhvHlhGKRAT69h7cmJegR8ueynZHr6e2d1uKYtvCTZJi5lfGnlVsjZJSlMtsLNCr+Td7T/OPrHSOCcyhXLSiLm5GPmAMZ01xfHbFAVxJ+x3e2WbprQ+mT5Eo/f1PboLdGyUaiSF36VCWxt/7YhK/k/5PO4ArXu7Lbo6lR9zOogb+HSEeqkzL7qii5o4FING5ZzbET8kLA1JHYGAh1kT6MhsGTZ02vHg+SuIf7BLuhujacHXWtt0UudUCySlwYGZ64Kqlv0u17T5GOEFvSsS5xOS1eQx094BDAIXFQ3gpkde5IVREnKpHvdO0Ym5hjupNb86qjqQ5wn6pPaLwMe6vCMiLgWhWnN9XKhWxXdJ5kCHU7xuyS/jiBr4RUc7/B6/ovLCTVsyzpABqPpnoQSaA+rab28PTfXPqjfqS+8Qpbx1di9bzRazosgsIeokNs0NF2FsqtI5uLQUPMWKHmwNgOFoWGo4Y9oYRDbS5D+MBTjQPxAAvx7HWjdpUY/lA+EPKPwAEegtM6f0LnGUw+7DKRqLLUEXI0eC2d21XBrmh33UbD+Lw7mdGr1x0zCqnPgiz1ta2fMDSdVHiJ5U9L8LDQ9o6VmVO3HtqqrPdMCwDLj97madokGdUPIaMXq5AMj5VzJ2VZrI+Cp9x6LrXrsXH2PSR6GbmOSD/CR403fnyajrBcrmvEGte4jeG92wLliOcqkyHCRT0z8do/R6/by4AkFDdgOy8VRGOUKGGZidbKnAUCFknQq+uRMpMC1nzuUFtABZdCjb1deyIvn2P8dmGIaWL5mGZu9l6r5pTeZjbRhvgk56GOG38XutmbCiyhl/34tgZMx9EOPR7af2T9Q4YhyV6fCoteDftwjeyIB/tH149id7hqjI+ZeZxj+o7zzzVgifqnUyaXD1q9yFhfUEHwTwYxcmvkV8I75By91dcWUDVxNvRGux+Dl6S+/HrqFCxqb7i96+bGDx/Dw3bkTncLG5hdVSOakj/2HaWIcVdoPshaoQnmVwe5giph7MFAe2Ipz0ecOucaYkpDQ7yF/vmH9Eo680HkgHZOFJITtPnx4KWbkCYV8yr5cegVniTosO4k5Lc3g77fZ7ctaQ+dXAExSv1m5f3esY+yN6YdCF3sgyP9QrAaDg46Ei94SvR/ToUZPqjJzltWLtI3mDNI5y7kkwkB/67ZqyC+YxxSdY/TMevjgP/CwEJOKU+vJWtNabwNcv5QbIiEY00Fu6eE+dOdciT5/dEImo2gurPbSVj/eHUqcl84K4QPlzUx4If7xyfNrrXjUtwoFNx96XRBZtlMI6l6CoU3+VJslg64Tj5OGBIt/2RTYAXBX48giIdgzOhxpe6qlO1ThytJpULfH9RWVItO0ov2bKIu8D/KhqLyS5lvs4GVt70CLe+xX4JJJ4EIlb9KTRbiJaWl19B8BgsjzxfLf8NlgC0IlUc6/X3Ln7X55vQfeD1yXWoLUc8gULNvSh9hVkZ5iCh+oaSCWHcqO+pDjofkwLY0bXIQlfVQnY48Bq6Gg5bATAiGhyVp5n85tE9QW1y0CA/gn7RL3GKSxmUfHy58phJrKmFs+t/nMt7yP2vjW4lH14VGHU1BI3FOu7x6z11MPeQUMxe+Ktz1UbVDz5mFpNP9LwhKnTNkC3T1fD/spA0R2VgtP087Ik4VBrqjYRQI5Scwk7ud9D0cst32vjfa3+r1AfjcRwTTHtOxPlLly53nXa2T4dj7kPEq1XEJGif/ljgJ601282WN1sExblpgwnBwTcR1xJNWY/3Do/e1h3WhlhodAQO620uZrnpFRAWBh4KKHIpJ4DDRP0PB5vtJcoCLxvFjd/7z2hz2Rfw0B3rxZo8V1gNWorCHxGoaVXyRHnA5WIjtc86PvORovdB250Pt5j/wGb8+0QOVVaHigiiPPPOsRTMS1JmBfnl/L1F3T78qD5A1Zw8qasVveWw5/AbfcmXmvGXzd+Saukq382Ta2Zy8XngJvo8UamsjOS9uWSiBjIF3R6ol5kxMTKM0DIQUL7BTniyHXHSELN4KvkyUk0u2NWdySug/aNISEUq8oE1QVEtL72CJiofVnXTy50DOFkqHQs9cvW4YxtyF88o9mfGsoQc5BuiDKKI/t59fwFIKTR+h8SLb/GhSPa43kgsXSBVdHIDnnGeX+UsVdOBp1GT42UgT/+UGpcL79m9SLYReXKpb1/6BZvx7iIJ4hq8gRJ40Fb2VKQC+3+QDmZTA5ujTjEVPAYErfybNLc2+G790lEhjPxUTyCHIyrQ28wtxKvkfBObztGgBqZY1M+VSUOBGIlEgCuM7IOMp4nY7GSSHTZ2aKbm1Z8vqB7/ehtwQVMoRXTvoVBzt7mgBXR6IFbqt8oEeOGUfrmwgxGY86UvDb4RQxGrBE1z45bZYFGJUKbvRgHPWD6mZuxVNs1yn+0ZwEwO43qTzzr6d5Z8wYb2XQDR3Aur6e1t36WulRhNygJImYTkDG/IHAFZjMAD+O2CQ0MmjUzH6Tg73Woq/tpcqATRFbeFhH7IlJOlDgPp5VQZOim4rU4vhbgBvWSLvoLjbhxL4A0ugMBQOws2p+DTvpvckRurEWZvfdAa1/Oit/fIpCP3+TGxb5C8RnxkhFImoAOxhPA2tj4ZlIyKIs9RGw8bZznXrRRf+z+s6vSDkZxIhsSkYkyRGSyBnSXsHoiMAGJetkvpjoM4KyHTaZ4mo0vjOptP9/8VgiAIJckyW0bedFyaBqGIbAVhLDdGFNrZ11S1lnL/MEhByT5b39FwJ7H3lT5l9tr/Utz+bvQtjUgbmiUIM5s9R4aH9wClXKfyM11iXNr2UYnOyTk1BntfUd74GRzCI/qVRGCWktn9dNvvloHebdgIL3G47Ytko9HaLSmPefUGrbTHcaAiz2etLWd8Tdxh1SYBvVJ3W/zKbhQmmBCR7rqJ54IRqmFJjJpsLSY1R0aDI7GmKieehqT4aJgR3YL0hJEZ3szo62CFTBur297LzVuayOqc3wA04rKvxAXXsfjNtuIqct3rmuljcyUPui34CkYx/CQA96JmLlTa2TQ+wi9Wyrl4AzZa5xRy8Fo2lDg3UMvM6G6STIicsyGFBje8bxWPN/TVM+3FyyxgFUjjzfZJxzVmMrbVQn6nIfzQOeayBsfHCEjdgoMsm7HJNnc38HjqvROZ0YIK79k+JhfdgGwxW+pzhwO/iaU9rVY0nvAeWcukIOyFB+alAEjDMmoLCJ2oA4Blsu+UB3FEplxJMmqxZNndmZOJfh+NBG704iHJ7kGNKMqo1atSgM/VXs1oMinqPniLY0kygRT7RT8ct07DvLZklt2hVLRZrxaBZTevNv+++iOT/uqFOBl5Lowq8Z5eIG3We8pd87Od9df4qpGTb1da3xiCXq8EsuKXUh9P3/pABDaLsKT0zlmB55AlN7ZsS/AmnjRCHkD/T3z3gbEkqNfPWQLu9tNg79gV3WYiGxLxOJBOUsOfO5LNWpUD6vJhQMtIKFJxhS2KVw3m7ev9Z1Bvuv6kNFzVJElN/+PzEe7HlIyBK2dyCQEnghz4ZWv3vjbmvkJoUWCtHI0CtoXmla0Qxj8CgO1eqbleBZtNPKz594Euwa46bwdRFy+ggP+6H/VTAesMk6jv4D8xZlhP4KrL3y4No6V0HVV/rl8oGsZwL2yFoUj13e40AgyTrRfrGpjck0jwKkrn8j3RbDyOgBuBFG6h9kuu4bYZ5ZOwIkMSF4D0Wi7y+x+c+Mq8M/gSuUsJyowsgDK0x/5XfblQLI0Cfo8BxRFrRDlw928abGSVMdIfUfCvpaBuY8am7nqcLV7Tap6Ih4YARzlCD9VAx5FDX5rdEmXnWn54j0KYhBsKfCVR8vK3T82hoQdwPRyTjJjafaoNDKZkUTIT51WCh5PaPDq1+Lo2nZpWtItXRkdGXfZKfzxyB5RIVwxXRqocvSnt1ztzicPY1Z96FyX1NPWqiSsx6TXl2PYW60XSCyRxxBnEoSSXHUgJ/ZJPnlJ5/ijK5p7skW24A1jS3OOtNEGmTGxT5AOKG4mpRsK75bXj8j3rEUU2BAL3/JDCmTLGNGptzqVTXPDxg5uJJq4qMYT9UhLVIQ3jkbRzSE43hDi5lfNFZ58TqjF/NU+V7+iV9RLj19/j/EQ71GN4vVDxGUV1h8QE0uPL1FQODjrBhSGaKnU0QtsaFaRY829ZFk6uGhsbP0SoTPKO6wQF8SH66HXHJLPzLPWS83iw04EZLbSaajeUAo0YJL4B1+iP20ncJIPfYaAIxmjLt/tSOJOq7sHCVkPjzBPmBxN5/cFzU+f98R/vQXec+Hj1BpWSdv8+JEWGrErENCTFl4wNcqdR4Zc2dj2ANHNW/GB0Mu523kH038npQEMbw/cVNJbyIZPlJVo7HI+fN8AWrq3FTbBoUaCguWQDYGrYwkoDO/8MwrbrIafvQrRhWXNXJ6Hm0jZIJlMpugO4Q5Z1/TkhcFdbj8E1DD3dK7w9f4QE3mtjh7apb0o7Z0BArpcCAldY8FV1pFRo5ji9wA5nGCzYoNPgPHilc/2TPpCvEHGJ9l8xEzlzmJRS2EwxBP/Ooo2tKzuM7mg5NxsuT15ENGlRr27E2YitJt6qdJ0UejPioCLjePQ0hMPUfF+nOjBWcyBRxUGgn56q1ikW4fe8+UB0vnntVzOL29ZdC+pGYqqFQobIoquWJpHZEU9B0Tgfe9yvgZHDYOeaIM+5K87LeGlT0zog1kai6SIUTlH6adFi71qZ5nEToukL2Goz+vsaYkOuPytoNC0tnIYH3hP3x1F78kpV6QT6giNCfVEV+haM/LTy8RkAMLOcwQhkmc755btxmwP3F0x6pi2KPUrDWGDSIH6sSkEYBmMm/9TyLaOB3IMU0RmBfArB5bIeIC5XpmygJAl6nZD5hly75qL/YJ+2PHewpQ9xA8HbSL4gY1S5MZ5TaOr6P3E+HLjs2V37HAUiKMO/2OnWkIjtBbBU5VMwaNC486UvcjLG1k1pGf0RFFzejHd5UwwcSwkBLSWVQlxyjIdlF/8pwj3JMMoo6c+8ygswFJWhZsQIQfQa1+1ZIrA0qpyNggVm6JR0LkTshQ5bR19zqmZuGQfB12a4/B/9que5Pxp1AhPkmCQBygKzRzR891dUwSIoXvu6MDM03zCUHiQTT0/d6PSvC7zjz9eAGxNHcuwl8G0CaHJRaolMMgqv7HLEMGimBin/VGAqBk8eI5/qThyH5rnEndaHyM24/aQurtS0/aOvZ0BD7u2HXfGjEyi7FiTZ4Ms/bOZokLoeJEsJqQILXx9+vc/uoMj9UouMnwXdcwapH3d3H/dFeuIumRJoFFgVEwhj6qhS3vdUbaYejbetq4BGalhu7P9U8mXVlCN4b48Uzheb1cRQ59z2AR1fHeX0ugZjinaQgQEyrI0q1X+1Aay8VrVxYcBbfghiaIxrYqfymzNJMMd+c4xSRaH7hlYVVmw1pchRgPVZNaNCCp2KOgrhrzgnbqkbJhO7RDr/No+eGczI9hEDQqrHpzSHAxa24K1i4xBAepNq6pE1pfL/hjM95YCGWInHQmj5+nIv84kls4RU8qN5TzR7TlBLzth6NsQF+bPdVd4LSC9xUHljwjKY8fqF+qSJh1WlqG8WaHI4D9IwPzApUPGIRo5t1N3OQ3BiUzE1IiqG2no8ZD9AxMr4JVRw7foM9FPTTgnd3Pgz6443n+sNaNMRLBwdSgB/Tk/2RBFOsyyb9FZ6V6f14u9tXh1AHfDqarXCYCuHqDY7PWeN7LprYpvfEcKqP4arajDH3B7N40DjbhUWKyiEI9CcVu++rId8nn5qgdmJuDpw5hsgfix+tZ+h8Nsnfrx2twKHE4FCw/7EVEhGIq0d4EcWRavAJjjubzbfa9CYdNo+CJQRfyrSMfVB4IEKYf0cxXllOzyR2ab1FOV5JM87WJwbQMXN9LA9YINEeEd4F/k3mKtiXkrcXPd7OJHHuddQJuYmMg+zQs8pTXjwB31gBoMqs5WYConXX90HiamABbFMacCwQvyH9cEXVtmdRePJzgIO+3Jn9Fx+afMLv0xsNbrNhkxuGvYqv+4YIjNU/vBCABvpG3QV4+a72NPWg9RVXfgSAcBoj7n451t714lZrMdIyPG5ty+MOf1iq6X/2ahGlmHpndDcPzQqHZn1Q6znT167n8y9pOwPBCARBJqb5qRAWBi3mkjmckiNT4OYfE74Sv0Sq8T0SzJ9W2Qkl3c3ydqOnFIx4T/dBuHaXpe8fANQc9SwjiXTppSOITOQbjDI/XI0IrfNVI2z8jOami2wC/TbaDkB2omysSzPuSWcuafLVFKQ0mOaY7aKoydKp6Z6Jg7/o4HXvHfQr95SJUAWDYH+1fXbEOOIpLaTzCDRrZMer4UmRfOSjhUq4EwjugRJ/pbcHUquM30j49fK/NQH5OY79c7dGzF7MQJZQKjd16GiKCZboFo1KKeUj0YrfCEne6G9bxAkHNcKxIpLuiI9ZjL1rzG3B/4tzcBj2qdNNvd7fJvvElMjgWNHEhibV75+F/3Vd6BNbcjrkglr3giVD6lwdFIKDc1b3c4fbM1rtXCq+Cmzzm2BR6Ehnj2Z0bgOE8AQqXYYiYM2S0bNVAmW4rZQh02hYno9PomNt+bWvNEvgyeUHh+P9xCvgckuqV6RFUM+RPj0Xd90fBfAs0gPTuTj5qjiK0XidlGZWSsY6Bc3kZYub2FMmLZOCrWB0aBqRX3frGhWYFDmfeCx9mUbP0/qQHOgVzXs7SOV0cw+T1M9zrUkyrCt+V4zzZE8gdjomPh4tClNiwVNTLxYm0JOhTXM5y+se0dRZ/UyybLdGMaLkIP0ESzzEACuMacF2C9kenrn6Uh0+bI74dSXXhtJ7ligD17jVaNu3RHXRq0FvOl5PAuhT8MC77iJkY1IpDqnWQwjwpXpMy2PQKw/xPNgKfn2kuPbyibKasJbzILwQfYZn/euXh2aKWuVK78E9TZZsHc6eUKggt9fQWOmjdU/3xRVV99dh8eZus/1ytcpvFXFVhIwOaYCvBQblNWtTqiAexP/laRAQi4xLJGzHevmJnqKa6Cb2YF1LnlRHIp4YXYxqZJ0EWRYw6DB2RafJ2Mzqw+cPfkVvOwmjBv1hYF7B0jXPHW2wiPfHk76XTOPA00xIREPDESPM38Q06l6uGOGZ4nvkSPGRo+Bs/7byKWKVViC+VGMYtRjtofZaOO+5YCvaGE/ZDD3oA6I53tHD++y4/nNPw6Fix4ktDAY+iRQqom+q5eq3uFeWJAQDbdqivHtaVWjPsJkQyf9IZAe/mecOBqCLPnecfnVwfAucvWnDYfwfzE4EfOlP5f3cK5xoB+fBK+2MMdFDdE63TMXUo0d6Kngkx6fZMo1pcSbONyOCX8L51IwPHcAImDEb9/uO7ObXaSmt6Z5Kt1qxtkQKii3r7NuLJW8NHygYXHrapRbwaC4mWiEu7w+lwVQWLnEkTPnsGU+rBEV7F0D5w3G+VPts5cqW2jr/vjrX2iOEFYStM5eqtNKz6jo//KslkpyGsLixSUGn5LQ4VmUWeFBhD5hL6TCNRBXB67jYsJIOtGkLIQNubde+t5znYrC+qJ4Gb/RQsuonx8hYvPoZshVxC5Sbi3Gp2dMtd59I7NbjvXn1z6+6PZvztnNdzTRytTmYkj2kOWySBzMrmkPkxBofV03GJEBHdLJBuvJHps+PtxArM4lEOXKNfrNqxNKdKKHkvU83P0WL7n/J42KYEzfolo4KvryS9rIkNDQyba2aJHd6T/phmXRY3KcpbJQVAu4rnBIZKw2MJKu4M0is6dHAXzqDvf6fpDvbBebLxGP98PRSqSgyn6DfmZJe4R/kAQiaTeZym61Y4WAdJhoVdPCZeoYNFBtp2G93hoIBgMVLvcWSY+Zg0tJptrsjGuiAs5TIM2GPNIjIxKTWsMxtCS6wP3HRGtBH6r+rEQME0IO3rNZyIRnclGIPfxkaVESCX2y1jo84wT9ZWMYfwDNMF1Jc0jQ8Skm+tPfoTOkvEkI5mAi2gRSrgKIGhmx5G6PyXOiyeKdQzipdEBobY/vnL7FazJJEXMKhlTquV8PW/PXKEF/dqOxCfj+HWmZLEhvqxc1suSZcHpfHDj00yugCxOkBMbEnJ76XyE2QAsXl+Uq+PzxbIQQppSHSTuPjd9xZRPad12yzMjVxLMJy7t0k5ISkMz4RPz6UkN4yMfoekPwr5HWaz/+GiMndfwNpQcKc1s5jvXnLpPQivHRQZ5Ez3v4sDA95b1spXOc4b/cXvk0AD62HXD+cLvH6Y8dFj2Ssu8ZykVd1lmHMQQLeY0MgXafg7QuPRuioQumJgiclbvcEB1PVtNniPuUn/RllbcCKqCOFRMlgwWkJSIOLZF5NSzW1wjPNAeYGH6Z9XJQXIgI+/r/AtytjDdr/IOF+zzoOAzF5vsBA2ux4lbaUx7bRQTM2Vdt4xeqA0eh3Cd3fA+OveImF7+zWYauptsJmvyvAMDaNSoK2brxMu+UKsIzmG+NdM1iza9Uw+YV6VZFwbEKmOKm9boPy5lzjyVard2di929ZoERUJ8Mv82GcIWyhwzV09jGYLJR2ZJOoMg07HeDmjcPdGu4Ah7nwLc5zh6ljRGzKEfYjE2lNwNJfRib+kR0RCQkaacQ2NujykJKmznTy58ELUUPXqXXshBUppXOmXtW5xmk4IRu17cZY6kb2gQy/kcWvmhJWTccDKA3u51LEN24mAChAZHm06v0aXaCc9bHZUGdIOEFvCIUj6f7oz3kOolM9KAp8XoObmKymYVEzOu4MeiaHOzaBRPwdlsHoE2Z09lmcwwpB8A9oQHzQn/sTBceWVoM30AZsU6iC6KVocVzy0QeYH8/LWYDXstzmJH98lthO9ApjInUOBaq1IlbFGAhBYNjOiMmpUC+TWxVzR2rYggaTuJ3fuSkvub4g/VUugSlTorFAjk5m63gz7V4VTcAzFGsDv8bY2orjZXhRpd15FB1cd+9K9CWfxcfJSuHqQz/FQf+1dWVL3Gv5nVQ7iKKft1lt5zqF+OodzZdGnMt7H9VXhU15WvkwdaCXzrThZnmV+HZS0bF9UIhFrA2grXa+mOwtfVAELoASHhviV6CSsamo0SpuAVeftxeupdiUagiEjj2M4sFeM+wrjozW0h0TSVssibkKR6ErFn/jRYnpk6dnNCQ2iht2Fm03sNEcNrVKlESdJ6YRVE4no1mAw2SPHMkEMR1WjEAH94TlwJaEekrVu7FVujPh9NbRbCubr8MHx3+EUm20+1miE1JK15mMllPOySE2C4vbzmmHbnTOsrilijNKDQaA25t7ux32GxEsRSZ0n3cKOL6D84j22SI7lwIMdUtRW9SfoN+dgJjuIqFvRKFQbc97BcwHp9XhMy9B1Mg0E3nUIgkZ+EQo/hHZV2wb938BzxgITklxMlA3N+fPkeZSxl9tzl6PsYO+TFf1VuZdI7ov0AdiWipnQz9sOcwj/Y6KNU5CmlRN6PA7doFonAQtCbO5G39aU/9Qsa6AvRdz/jKUGTSCGv0wvtg1U2xKZBhG0ZKI+I5SUPN4GYV4LOtzrSx4ifpOwLdODGg0n6Jwv2NF1U8a8y20OmAuv0+fAADxI6R0rR/8r0g5i7ZmlKXU4gJTZVOFnqwy9ySxy0SqQX9xLuD2mFiq2OsKPuLkCiXhnsEvbxjMlhK6zxLU2uCpsQZ+V38bLJFbFnSnS/Im3u52KnV1I0v08RZmtTyGrezzzHD1Dn3gD+7nWDpXzMcWo1koQlbtamA7Pf40UJKereAim2TvSxenGFbnQicOtzrxO8pSbe5majXuNsvksonGuvaKXNnA5ZiTjd/e61XxfZlGrsie4snJ7Dy5cRexnJ8OoU+rcmu/P8YAJjqCMed+0RyVZpR6ImMqlqEw7/HoWGp6J2KH5rNoyDRpjXj63BEfaDlhUYIPuewIrx0DJsCns0iT2eiGx675FZoShJgfALkla/HHy86xA0iYK8eBsUOP8oNGNU9hFQDsOZgV+EWsuro+mvb9ViVeDjZDCUwf5Q1PNwKZ1qluZ4Qw8uvovf2mh8D+8uWAoVaGlZSSvMii4KaF1pG0ZQElX3fbVAAX+xnDCx0roCwmBKJsDwc+iQsdee46nF9UBBch4sGlTCP+m1CnybgR0sLpW82ySuudwcYrGEuDRHYfkz+NapSyhmj921r4bZNNT39LNEx6Y+Ko2jEFNPuJ7iE055Rw2bt9Qsw5jWCnTJ40mgR1KNIqli3rzJiRBdRtMFp2OMUiF4X6/GDxfkOsPhFDtICYlwJZ6PvtQLSYJeBL5vYtQIWgbV22MztrjJ5pvT2bqGjY18rL3cTA0AjZYJEOqqiSyCE7S5bXzD7iln6GijhKTRO0gYt4tvpCrwFl3W4iiSzvk6hM6lO0f224U1qpCWKaMj7S0IFVr0XnrxunzzTSt7Lpp///luI8mIRJ2PKtXa0u6z7NIDQvqovfglC1Va0xBJSk6cwuUlsZOozqHEeNEq/K9ZqoihbVUceSZKLtc3TZxR1etYQEHmGfEUxbI0oRivTbJz+q0mlyACN7ZOf9RnU9QX50mVZRdY4GdL4lxinHp1rlb3IY0YhFV6cRbiQssr6nmMjzUXmT2V4KKZLWEn9zLU/KlQvX1ZyLcNAp8lLEWEyyye5mpkTpQBEswg5X+nRkN1gwBMreVhFH18Cu/KGBXDyyEK4Js7APrZfzA8wBKDrVjNQtl2fMHfh6FJzEU22iqi4xSPJOLfwk23J0ZWTViNRwolZYaR4qKDJmP8anVx/Jx5RvWmYwjVupS0rLS1Bc4Q9ufziSILWs+fMGdmO2T4DrFKmVarXSwedHeJ2XikAzfvXKvki2TfiUvV5JaxVMnwI1CQnb/AfMXxeWw0Nu2u+3tXmqanAlLz7HGCLphUoHbqTGnwYkktqX93ywGzXDCDabcU4VqMs2xEoV0HP4d5p54+PFVSI+fQTUBTeeG0/c+Ce3cHma+1HENFklMBGIiIlNxtcRGKcFJ3y1jvCEbVf9szAesPqvzd6N3sUmM4Sy5LQLf7of68+rKseIsAl7DhEqj1OhbU6zUlqadrBiBw3lpc4UtkIvedu7eYVqld09ZTKCnPjlowbkz8NBkokJsAgZCYymSJKesunSGRz0gprwLUUfy1m18C8nqsduzo8h7tVJUPihA3kD3m6iii3E5zdeJ/rKK0M43P0DPNeamBbBPzHmRzZqIKeiiY7Bv395XKpFWnX6IaEBs+yokl4tJGQmq68n7RPBzFhePxFMGF4OLbZqHt/cXNJDlfoTVxuEESYMyR2T3Dxthv0pa/bhVU2/AVeoFDyNLxtJFv2VocvTd+vKUO7CFSZqwU6NKjJO1AwkKDkpY56bUQKrXDkQy+vIH837qRG8ozh3wj6ILQ3ZAbDXRXjG2B7fSCV9HKNgDRVp+UAe9a6DSyBCAvSQrJLnxlohNvnunPteST39IOjv+eHwdyhrpUo+bZCC0DY69dJ3l17S46WmDw52N4IkJrM6sXqXMPoK++NUiP0Jtc4Ytkz/ki9vdaeAEO7dIlfp9CFuZsYhffVFIc6EEx1XY1k4LizdoniHK1ZAi8M9oUdYsqmJn+yZs5nofcdSOlgocKkO6SbvkcsXeb3icBDe5RA+1d/sUKFfkJ9wKpjKcIYf7tqONgNhn77HNpy94WVqDMu3yiZZEjoXpV/LIxoshbezwkmixeWaKC4a+SWg5h/bJ0cSAwitpTL7yLuiW2Js9uQAoblk0Jmvw2dP8FumhCDWjPN4kc+mkg3jt/TbAYnJ81JIItDInzUFm39b+LQMKQcRnYHyhYekk2xWxte7o72mfICBTAe9zF/Wrw87IiO7GQiVJN4JQQdoxSaJDAAS4UDrdi8il4j032iLAsgpzsf5et61SbgalqQ3Clt/KXE1REVD3Adf+APlbYlt7Ib4UGJulBhy8OQc+2eiNQJZTwTd6ZVFXSh/ugHj95x4PJiLcDVTaa1iFftOrg1ab65Gf3D5g14c7aQc9uQEVDHES0ANl0ygxpSBpoCfDJ9SggRIY0hf28DwbmMjwvC79EYkS2PEOHxnT0NMwJX+YfnvvLXHWpDdH9DJEQIf8hdveJnwO10HYhyruimMfIYOfxKMJHfrNadetupOtQpP5H7IhYDm4HsIa64WkU6jdIpXNE6caBLJ9qy2kbpoie5RbTbj9mMjzDlRHTOzynKTAk7NcBZpeB5k1Pq0RK2Isbbnaxmq+mov4tt3EMXSQvSG1ytaqfr2Ga2XSSgXuaGlckl5AkjZoAkzPm6DgA9aqq9yn+ZCE8DgpvW2W/fZaCQIe7o1wNe+RlbIyan6FpXdlv76NNjXZIukJmjnvOURVzRuCpwqUUNnvUOVAMIPzTLSzPsBNe5OZSaaF2BZaiXjPp9Xyh+q25BIDdRn++imwSnQzMg3VlZpABnZ3J6KRkxq+Z37YTAKVIvwGuD23YMyat5ZJxcycctXO8UtAlm5PD0+Jn997l4vuT4oWNCbPx4z+XZ1vwe5kQXqCcaaROu8h5rj6Boc/LYTZJb0vihZTWnLOm5zE7RpR2u5pFNkEYTR9piAN3kz/hvCcB5E9lkoYeL/dccO7Rw3sno/HE+1ohXT2ztav666qIbQinWB7IOH2NGyuh1XqQ1TWdLuo5CSPQSytHpyL3esv4ayUPq2P8HCrVoTqFYZW5S1spq792YZuEdyFKemSa5DLcmBleHgqUQVuu6uHPkD90Uu20fMMKpgNjIb8inPa2vhVMcfl9tZvS4miqCDjmgm37aMqPmptaNjfkyUP69LIPRbujid1/aMF24osNKM6wy2Mg70G5c18hpameNv/oTp8ObKj/3z0C4zLGbxhCNz3BZaupA42HwGq4l+w0FyntJv3bcMNPrIAcGSlxSAGTPFX2scNJ6QrPrPEhmJ8PWNBaRbgcp1N2lzNKQFXcysGQ98AN84Edq9myYFREh2kJ/qbWialJxvjUkjcLMWIBsol+PpT2rW0Ny77tLlUnhRrnipceyq7q0lV3OFcJi96F4iKEviwOlZjPUOQKz0JUYy+sxGuc7sgICdfp7RXipPhesgzYWeNivdBVkp+30rWBCJqkqPpCEPvfsm2HRXWSrZd4vEFC9bPOusAMv1esH/eIyQTeWUpgEPv3jHhjQAnYQLWTWFtB+YN1dpsdE/R2P4Z7+ujh9y0+ziXCpoPnrwtK02E8I2GpX7N/AdQ3dfrkFFl9Sv8sNl9El+3nE0CQoEekItOuN9rkC53jXkmxq499lAwct18tq21r0oWXvdODWadvmXviO4o96nAuMCuo0y+a21gyoZTb04y7lKgCqSl80UfcXzU9vBYaajjVEmj5vw+yfBvGZgmTnrzH0+lvTpDv12hOxwGiNsra4/yNoafAiVvyvE0niyTr409AGLdhuWzv0T5zYuLup7fMsX7Bu1vA7y8E2uyywCuEoJzpxqav/8ZNdGhqIg2srdFeA/IcjdPXmDehb5KyztwAB9czhqPV5knASW6Ofy/VBplvps/F2++0e0FhGp1PlXg29SckxcxWnfgKxwBrnApPCauBJfa5KZ0TwqjVtthvyODHrJT6qb1l+gwa+POHZ4qjBYkwIwBejJB/YUpUOCV4GjKPE2P7+3vGCfBCI7Vdxyak3MHTaZtzBOgSsJy5KdR9wDwRZjxDSdVv1HZIf7bXBa0j3iV3rUtXJuQfsLqTw4bbBA8ZqQ7dtyMWYdJ6pnBCJIxyRrGtQ4DSc1fjkC7GKC6bX0ghhpbJXM8BU8VKDis6cRyYGQtqOzjZyszXgX7BUPAUa6SsZ4flJv7kprVs7/IuRDIkyDqa17bOeXqiaAdj4GJWZrpiAzecUhPB1Fu4ok3zv1J5jmlNNwvSRQLergLY09QCX0xWiK/RqmJYx9yP09z13J9fG5sJFVmKdOpXQ3WTY0wqVHStS/hAz4XIks6PgeCIvoasEDqrXRte98mklDkubwhAfUsvBgkXbJyFywiby8zNf5wJ8P0vDRyL5X5NCC46G+7+KHusIOzENY2rt3xN1NiJM585jqTYoMSZ7bbWfvjjAzfApzLonVsawD/oo9bfH7sIrk2KGRl872zkljF26wLGs29eBp9gtLEoQ+hxRp/ZQ1V/bNLOoo83ErPy4mrqAxq5oSxBtSNoJPcDwrr2Kqm+AXZhSN77mqogvFQQlcr//flowuC7o4cbP4+P8789ZxNqmfYATScFIwDiL/ZNxrlyhkbeSPc3TXGemxhd5dLG+zmPA5mZvsp0T+D+48L1FhKEKIv4ZW5WrrovsMKRrFJ6K9z1mjPdF55/7/X17lfXD1+St/VzvwGVqJUWI/5RYJm38UKw4CSOhA6mheXXcVF/EYc69GoLYAjeb8zjmU4LAdDb5F6bs/+B6A3xvbC6AzSbd2G/QGBVjOBO6/3m7ZV1trYo5v1Ybna+M/iBcl2vKkPK8NowBuYcaZymvrptjlhj47y5UfddSg/0DS1VV96HJl39OocR4pN+3vOTFCSpi+BvXWCbhY+mCTxaTmVk6eghaLSYdN7yIgwnhf0Lg509J/F+MTumj9/osu63BfxxRR1/mTRGrVT/XDcvgeYHQk3rYT/NYpTXQ1Vxch7G4I/nbZnqQ5XNrWWlfZ1hsfK+pTp7tFOrh0VsrQ2Trp2iU3U0U5LiaCt0Esmdyv41z1ZEmMcvme5wzme+FT+CfdFjxxX525PqHRODs8XqogbtswMapqVtNCxFmey3TvE/YzltgU65SOIv5STKjvmK83mF+NiEAVrF5D/WNmayvW8ac/T77rbQ/h3SI6Em6xoD4Ooulv4d1aWMczqjAjJhUTr87UxL7DdLvd4Onj6w9clWgo5LE5i/n4I/C44h8CsqsPP+4Wuspm2SeG75DcNM4HbAgVCQpEqC+IDorkaBNoHHYCJo6r1igR9nraOmvDV0xsB4komhDHc8yYwV/NO3Co4Cn+KVEQ/xegazyqq6nyz9omjURbtizxc0KtxRZZhky667tzCKe3RFbYPDlMpMDyaGLOgH7lMM6i3uybvrp1cHNdLwj9d0D69j28xn+wuUk+2MoXdih4ncUs9SYOeO01Z+1b8pw0qgkFOpEisioqtEI0XLdsnVvJTasqIbp8l2r7hX4N4VwSVVP9obt9GG+bJftD39ROgBx/PjmLAgACkFvmko4Ew05f71EtNZ4QirFBh7Z6yCBaU+MVROgirfTanxxxlb0nzMBXLUBadIM1jhTF5t2USg8GHibzfOFMiuCW7fYEhGXhQWeH1VD0c3RuKWIYnYpbFu16uGyQaH+rU9kP2KVNQvnczg/KUYCHbo3aSBYumZUvpXFEoGdU05UE22sHnYwcBP1yxdlRsftx1Ox4UU+Ln59B8lmrMexKsDaK1nHCuGZWcoPTGTxHc/yuwQb64B5Clv6VRqmMfAUjIO9TsU2NYig0k+cp7ERCaHZeBaHro9GVQzCfirn7iD/mdv6xibj4mVyeRK4Od8bobr+IMRpNvmG/gMlefL8bckG7hrk+T+CegG+bB3Maq10QxkEqiYBj1ad7rrlIas/iY5DYdeMFL/yb3PKrp3KUYbJXQBRB4nChVrjaVGHK2Qjaa0BYUoPDY/pxRTqyc8rq0YVMAk+1VJQC/wFtciu0ZLREBYzpXr6e41PNqV9aM5xeHp/EooEV8wcHgKaf3ltc8kKv+Op9hmngfRRHtai/4KWa8aGG1JmXDer8Uwn+w+YWJ1kqXPrKRyPahhy6TPU79CvKxAKOe/MUCBI9UaaFulprrzaxzm9/RyKVjycnMAxutQvuMmB+PUjRludPub7M2Uxcot9/oSmgcrcSD7oJ6gskcAXnNaA9Q6bVE77AbE0P9nS+6yI4Q1MNPK9ZNFgD0j0lcUW0Ec/kyWRF+DjGdEDx8dlIj7ElmTTcoCfrWitt4P4t3g0GuEotrBM/ZtmG9Tybimsy/npzFJU5BwTAoyQfHZ5IODXqGT1CgbT6MWgqGtVoyDok/1zvKPOi1tyyUqKCWKIsCoxri+qu8gFjjnrUQ5QHTiQzZrckwUZrBKJRjP+wfjZ0rTYlXQv7TNlYYP0V/IcId+Tol/erOYY2fwERh915YQjdEgQ7CRH2tCzLXA574gIjG1bSNHa2ny5kgAMGXkbXrysCD9cyFCEU7SJJapSilawWhclXe9eJFGTfnnM/uH+mGFncaFAadFUnkch8OZ/n+ON9tVUi4UhdRUQho5+6BAu7Gx9MZ90bdIT1MhqN76BBRur4HBCz7ur0kUYL6C4XE9I50KDQYsmnR5YDlL4k/ePmgupTqSa6MsfCFF3Q3XX9h9t3kSmLAZe7aCCsYs1Z4CZmM7OHM8jerKwGwdcimpYpHtYEgxAu4Y6B7LHu9cigM9GlRL8w7fBlKNqas6CMXTrrREz/9r4rnTgkL117u0V4JrKEYjPZTLyIfqqpL7FgoTAydcYxpZNadSHPjgEPNpacU4/SofnxBDjGpKly453vDTuSdk50MTU1rKOa5O55M4v5nKTEn6fJrO1k/e764G9ScAPIkcMkY611E8UGEcpYt2wlygDFyT02ngQ1/RMGevd/WHy7Z0dmaBHmvavT4P1tdsGGS6aJ2OoM/9K5XWsxxUyaLry+bGjg+pEh5uDPT7L5Kq+qXH2pVdTyAjCEGc+FlyiDur8ygp9b9rKtbD6TpQY1eALmFXyKEb+kJOwa424uuzS87EkOd1jHtyqMCGnELdYsh43UHc4V1/xT8pPG+rnsc4Kmlv6boy/VzTRo8oSrP2Dz/eBj9nh7fjmb4uz0l/xnXKxAIQQsP0SaKHLiRhaR2U2eEvViUX0gBDFkwh1bcdW6p1E88nvgnQwW78R5gmYlY9MEY6qQ+Z8PpNbrFBuVLOi4LTDC5RKTRBCGhdfprlA8dswLvLKyFiDaViG+VtDC4oExaKdHjC6iDOxwo1R67ygDwJv309wnCsfdE4djbz0ADfBVNcctvk11JbLS74ChoxekORmrTjeTRDNblkG2EtgNtChpfDt++iTGzhzNtCg7nnVQ9QFpt0kTk9BPQa1TB8xdfpOH75kbP9tScdzemfwyHfrRjmgV0IiL6CEHjnbNNG31FWw53JmSJHyAsEGNloP9ATHzlPbV82bkiLAt+FtHXBapEc7QDQw1Tu+pUvX6jjdWu8s57Jzw9S7DF9FxKhVdloHmMbn6DYDtRiTi7NAPl5RHiT+k6SFAdCDTGRh3lFYLY9PflOkSnyS9+P0C0xZWtbxp+lcGiDkhKSUulSUyM+yykPPBJVtaS6e+sexWU5H2IucUFfrIgVklo2UsDs8Q1tUrpEE4YkWVuLterhywo/O1KAQCiWN0e2Wa+dM3fiuV50HxQvBTa2tyf2nqJxlr10ZW3ohxWCPvdKzjC0TNnAys1Ah2uQRkFA5TC+jsjBwzCICs2KJguas/4oQvRomS9Js4vGN/1p62irRwWGUzV8hTxkMkfTMancZQrUr6+2ZubSvQfMdBQukC4ftspU3JsXvYJdQoSILYCb4+oESrV3Y3OIqiwM12WB2+aMl7btu9OUewBou8IXiUCa/nxBmpMmjahhxYb1ITJroExUNJWg2K/ov6y0xoqkcEEuYKKmASPH1/9D1ZrgXBaic/U5mwLKHkLERoUaYAb9rZ3NNihJzFMNjOHHVhc6jBnuzit5YxuMvSjTuCYZhW4Q/kbcmtBfeKc63ABCVTjBMKsiyjx2DKi5xitA4klhyHlX4w5iFoq1Zu6XygUlQs2RtGIeq6MgJN8ovd4dhdbb2CEecoRc37GHQY7rn6cPOSWneXUtUC4gLbLg33H4O5kb5pZ0u+C0SnA72d6imwuR7+XAL6NinbIFMH/WuvVlyu9jSuQRVK+4KXWzlbphRiH8Bjeo3NPbacbKdyAD9owPKtGVRDCaGbrDeNXZ07ORuDt9rwA78TRsW5Ddn7iRKZGHtp4wa1LEtMhXBCY35nwDt08lThN4MOR500Gh6BRx9+ZrjsNsABhMYUgz8LCu98It1WHdPagSgWpPKcUsDEwkX4z19MA8agam44dS/93LDDq7+I8PGloyQaGvaP2KBDVtGqzAMw0WoCPGF56H3b2RUfy2t9nj9dxeNG5vV+hLXIdnn1Ejy0Mj/yfUjwaC8061ZSgdeSnv4ok7W06g8PrV/6LUAn4rA7VSyKKI2TWV5qfU5KZ1ENZtBe4Tjhl2HXJ4u78ViGr9g7FJGgOQqZTdxp+Rss2SxzGxwb6IjWUJta+5ltiIwocp/xFaOcXSnI/PessU0BkdigfvvYOsg3aU+Qjdb7ExhBxss9L1nMFMmw7/+l4lNhgXQKdTmTGoSDinmGqn6Ftqbqcp3quA0YE4N2bSd8O0fwnToq+uPGCx2/fahz+DrK1AKkFN3TL20KBxo/31Qrj+MkOgHBzsX7/w3Wa6wAq2pYggfIyy9B5QB+cf36ijRfgkXd8BS39bsrpW5HglFP7Ro/p+hPsy21CG7yRUnAK6C1kX1seOH7sB1PiWyqnWiymw2sFVKMAS+UA3qknG7ozoCysEQ4BSIGfep94nNINda7JxNGiU1xxhvPp4BUwrVD1qcN/iPcmJ8cv2LZvEA0LD7WDFTJnx6jglGwdhl4OrydqJbdO8PlOgx1vjOFfllGDocQeGkIKn7cpCNujI8APWcPBWQMTVVZfRYu7NnkqPfsRv1B1mtRbkdS6+ioXodDmJ1OYVIzOkGGUhnDhJ9f7+VXclbMalencVDjUPLwhh2IYA8mP1vhlN/K9/xYKWH3wFX+GdbgBH7J6hOIF5Bv43v23xm/uR0YGNyFCCsQ8vieyeYdloogNf1WvHgHnaUTnE03ee367LKqbiLtEnZergUUA6AizwXqM/ZrbIOoC7BQiHzG5DdZxstZ29Y+wVPwN219feVGVXMxARbd2/WMKXE8RrZu9/P1d11K+mxbQU8jXRqpmZ9rdSxff3Azb330Rsv6z/o6uUOsomit3sZJ7NtJ1ZC0tLJ3rMm9xKzo9Y5XDn9Y5qGKrx0qEnRBrUDIr32o4ZlB1ODKlg0PqyCEgqQlqxhnp7pj7lSYhdu/u0Y9lUFXX4qLOKgamQTovwVCtEMIkpSL2nQEVV5liXlufg8fzIDDr7oxqSuDFxxwkqTmEIQ9SoMh40pkyUe3QLfegbEK2fWJYARpoOBzKUGyi/dsVBMtjB6Ds9eW9SUiHfPgWtiQwn9vOkJock4R2IKawBVfLTLGyEV4nnqPIGPmdHtuSwU+no3xN+Fv/o7soM2GWyRoHOS/8/SOF3dPFG3AlaeqaB1r+Q3AKjh3Voh/N7+NC2wN6u0PQy2LAT3DPzupA9Tx3l7wSgHLOCMIL2VCufT+P/xe0Nd3oWGJx5zSWongcVdNWDdTeginCGy4oFZ70KDmFeei6+63KT+WyK+HciN6ZXAApzYizrOPKiYzPcvtbraQ2WVjEpZNfpiWVlmSd8PwXDdlSyHgt3sWIAU+memv8jnjryKaTIPO4j8kqz4+BstUhJ/JBwNFF1nKe4xc9z76c+rIOAonikWB9wTNDGDGaASbHd3MUYZ4swyMT7qUTwtPX/R1+h/2Bt5216HtymCR/n4RKtSYh2Oa204D/VAL2ueAQI7MqmIKGZAWES+u+CvNL2/DHnEN5J9AKwbrTWOGeNrxMONg/Zvh2XFWwaDZbPI18h1CCHFfBJ4ZQ/DhNPzz3vIGY1hN7I5ep04fQz9U22PsRr1wu2o6y+aLoUuIm9fzpoM9VZ9+2VLq1HK7Pe79ctAeFWEKUaRjs/pQPcn5OAi0oWpQpyj9vOcOQUiFuOdzFzSVIdl3ieotcWk+1Ma4EH52QVL3U7ZN7VkpRU/iFGbXj/PpQMwba74IhCvGXBUQHvBAtQLQ4Wx+wf8siy1S5Aigvd99tdtCAoG7m/dEpkGw1bJe9ChfhjKPmZlCwc5z6mK9zG1X+eu6fWqQszQGe/oC4e1YG6LnrpW4jo3Q98thng6PwysVWpWfUrMJyGjAmpfR8tvUhbbVBzAdatOw/fU6FvMhk3lU9XM12cb02zORArLyoKDj+8PDqbNOfqM9vsXf4neX1NFfmiRnEinHbulX7sWkUOkqjm1CRwftmTBjxTa2Cn1H6/sjo2R9CzmEyiBgxUQfV5m59wJ8HFdZAO9c8vwPIXHGMkn0AxIAa15YKeQ6hte8rRGxUzJe59xy7P5VKdR3xk1+bE0DJRLdOj9E/shEOJBqIgwvuRtIQqmBsZAvRelYCziKb92Yw+pKISheWEuLnsvfVR4fu6yc6PErCWdCQ4Vibjg7O2iT7wqw2c+rdmGsIzxprf3QzyRzxMaIcIixA9IweTW9MmaS8WTLWopk11MqhrkVUK3MITkH0sLV0h9+XTKOnQO2/VTFfEN1jd1WeZEfjXkwyazePqQFO2+rMrDwBYUwWLDIJ9tfvFwF4iLRM1M2f/hPTTDTYYoHGI7Fjc+2efAvITCB8x5UaTYW3B0Yg01+7fEVH0hphDSwMxQdI3/LhK9YK5pG5HsqwyL4H6KE7UfOHfMdGFpDCFr/y5BQzS5Dr9KeQz7gHFHIn1eeWiI5k9/fJxEseHUQKdy5yLastE9Oc5wpF+hOMnPoNofCdi8PJMqGhuXjOpL0q4ZWTRCAIsPtr25pWtXI1F0dzb/a7QIDoZGrDhLqu6o5leib07G4oI+GzpRt7tK+79xwRaANsmKq5cxyw0zIws1+ZKtMSsrMnEDJqG25llJOXjsuUqqN28py9W5hdyjYuBKpfFKj5xPyMLBj0SQotg40gaBoXRStHMI8TxAXjc6wn4RCz2L/SWP3nb/GnoC/v4TRWxHnktSzF8aq7xt6e6c9gSJqA5A1PJVk0/uTq593tOfTL20021J6MKALxfv9i7w5BChcQVKYk7ttBb9yW26EYDUPWrUKoFAiiOFUfUui1pyc3xTIFF+qcV5M0n+EOPmeMaUQN5/Edb3AOY5BkofMWAShCQL3Z52cbThq3P5cyVlsyi0nSwDsFA4xIVcAxGrwlf4b5/uI0XoLAT9IO+phCdOnZyp3sFmJTnNZt/sOs1AdNHtVRW29DYdooO3bAWPY2nyR5Wdnhwq7DPf+viC2fjqvJDJOOIuMTRDayGHZiXaXak3e9uYQ57taZEI0jSWRmizfnI6zEe3B8NPlb/DQUjQc76PX1gw+zj4ZhfuRzcEyhmcwkxG3KbhuE2ugPBGskHc97/bLL4U7QA36qnaxFo1d4v+dVPRv6IULmFScx+huMvcDod0PAyq6JrFRlDRY7AnHs2HwSNIyAurrIRVA7mXi/mb3AqP9ORYacdHLzeg8skOimHiuXrwPT4KkNy4XvrzgDPUn1IK2YwBj/QgO8oJmor4YQ5oDnTcIC2tINHcZtZVNzLZqBVlCLik6ogzT9IeW+slXVoA4BSy839XgllWbU48F3JHT4Dj1mOKIEBbkey6iQhkXfKO++NeGJBv37XkqoN1zWlgTnc2ZQi9k0/yS0o5l8GmTcN2cPEgAPrlnKnAILfUg6fmSiLA0ScFhyhVQXNzx1+tQVouvjJi3g0o1KGwNCvopB16FPq1mbKKGaIywmpR/zl6U8UnCxqmxBavkJvhyQhiwTBffKi4L3RCDJdMOQ4JrdhdqviPcwf1OOMMDlsLegm+XqBpsmv7eZYqvkwbl0r5fIFZ3jfcEXMbzlgqY0TE1JmKAPvaQ32bA7yGcQj3nirpN4rMmnAPpcGNYTveE/FBf20niLlfmMmjlxuiZUAp+KnjPiGABdmTshU8C532XWLphTPVBnC+0DAFYltXjnqZkWp5oX+GZQKls8d2joeUNQ/VsaHQf3WlVTcisNabJzvRDQuYIdkQX0nTpOkKHnJoRiT3ure51As+xwAUdz75UtGfFKWJfE0LHDtV3t6E7dH8z/NgkRaPnXcyeOnOSfgFFRjCDkpVA/l9utanI+6KRKZUeQDEUUEEg3oqTQyrwGcgEWqZMnXwGKWI073c7ipHvCUBVT4PHNQYzxVxnnJSbV5dvaUHbcupWvXAH0PLLmhzoYltAiQ6iQ6lDESjPOfNmanlXQcEeK3jsd3kUKyK8FBbnQp4uue4QKyMiFwlSv4FNC7DbXx2NChF9ucJ5T8uQiDNCrFYqTsAvSdB2qZ5BD/Z1zaqKzRBcb2WIl5Imc1rLFnnYEp2O31kVSpshIozIpHZsEEXmZ2DLmRBC+fkKGMNJK4dFPR+fLTLXCQ9LCMFIdO8ConhBo7kQegvzcsr3LNvV+L/eHWu4WrQ1keKbxFM7fVFR2OnevVnoHgwjjwzatzEoe1Q1D0pMq3lQpDIlySDV/USDRXBtZMu0ekhpeilDcYfdSlilE0+KEyN4TosQ0EN7gyjd0Vo5O/G/Qs6LTZn+PiRBDXO9ozWf+LQ82jhNoohX1RKYfRFtrc6hQ6xBv6FC6YjRQWwRZnphxo9fOD1OfJghuaaJgQSh7CODDwjZ9CfpKZVh5WYNnnibxoG1WqXrswP81dOVUEN+4js2Swk/EOArttB8Q5ZBjggdXzqfe6r2gozdVLA0TqKdmP6HN80lplucvvHi8k880HAxiRmJlnfC35F04AOCobDei3ng2H/xAlNNR4y/OGZkAEw4tbCneZzXdVcO+gErziIP0ShHlGl7FYBmiFT8OaE9yVFmJyEpRFR/PsHvJiIqcqi9d7CcE97UUV3KWhIEQcUaRn59A1DWlDu8LRJ6FkDI1HPH9y1jIkwsyrh0s5uCDzby3GsJ65nS60tEo8YqhHHwTfS4h76O4WnUNDrvcjKtsF/09/xLX7w/9tN5L4XeibKyrgLhRVTN4UtReahDagR8t9kVPXtCKT40p2Uu3/SXssgZW243/VWvnuicJ4BETnB8DQjb+mk1gbsjWWQf8+Mhr1SHALICNLTZjuLVtWLOcv2yXJ+fjDwJoGERBTgpT5SVbS6SIH5zxfBeyXNusSW0sgbrnsGqUPzJYkJ8IHNTZzZwYfxwNeIkQsoCwx3C0SCCkIDSCzNGDhK3oYZcTWTRtSbVbUJdW6Q8jDGRVWWgb6cUhIgQiGQ8qbC5QWlESUaoc6LYGoU+8+JQn1qeVD0RG03J63Tmzmk+HYn9iVtIgRMuNo9/Mti4tRoCvz23J4Wna0XaE+FBE9Wl2KFPjpY5VuIA24ZvBA0QQgkUn16XfW6fgnMJpY2zS1cWqevxAWkzmMy2uTgQkSvuCaotqiS8fUzvILVtj+mId0Dbgi0QHBJMhLhknMW7hU4aQZfwHUlhbOHvU8aun+1cnZvcg8WaKh3bwfPshwdkfs8rESziMkhHfJtqnUnNZHyyrSIAUBiTTn1/Lk1YA5X/OuVxwY0yPZ3BOl24y4iLXnfDI8MTHt9lEasv3vLhs8O28FZpk5SMijszgWR19KjqxBS0eonCdiV7FQwbLSwQosCmcsaXgeNzePoKfsbb3E4WBG/iXXhEyztq1Usr+rAO47v7w8aFbIPU9/nWN4505c/STKy34L6fXJN/bofVyONsEJiMcTF+69s1VAIHcE2CPTPRlV7/Qaevj47j+mcU/ogRkn9n4vsVF/+rGu+pkdQHY52V8FAdRpXLp6LSn/GcNSLdmg3xjI4YMsHjlU2aW0oJPL10Qfin4y/bnTx8O0pBweU9p3Kz3YcVhEXv0pg+hvl9fqwWU5cQcEW6sXtfsGBJLG05J+ub3COY8GzbuXXyB5/1vwgQzkbb1bT4bjTK8U3+liXm3cGGDcaQPV2g8fhDN3lnjFyF00xQHYeoFAatrXR9b7gJKQQ1X2qGAbHuudoOtRcvgaVjIIfl3FvKYLmj5EmjPfWSun5cVoxpRxw3JOZ4/8u9uFPWEUcfUaVceaj96tniHiYmHIaKnNYTxJfrkUeBzNYktwbiO+k7rjZ0ubUbGHfPdbrNo1M93wCU+TuT1UAuWERtJBRq15JJmw1STUICh2tpRTrnh8kKTPXT+T/qf2jGcqn3NnZ0EW5ARi79Nuv704Llrc2ul5ZZRIKFdUUzsvadzyiBbqsI2BzKvj8ZLnGmNonU1n/87y0lmkZr65EMSXfO/wep01ob6rFXUkYWHZYwpJXEdqHS5ofYK5hIP4H27QizUv4uOqOgZmNIuLP/NUueOG0vEne0VMT5xIULGRw3NmQyZuyK+3hmdiFJ1QyTFrOvoyghm6ROHtRci/mlsJDQpvDf3XyS6F+UP5Y+6lmtDiPkoZ2CV4TUrcGA1wp9E+2ow6JqnBanjkCFkWGoroi+XCkqpSPyoqckdc12kcQor5paSaYV9BXA9OJhNTquWSniOKpPIBitQR1KJhS7eCJhSSMSzUVuexPnr5TcIxcihjQ7chTxTls/kFt9XK+KSLxxzo9VtBzwYbnqRW4v9PV4+K3OGUJBMajXPoJLZSa/iAqW8fWJDR0fIPPGl73EEJZPhOp5YGfdoHPugYmbBdQDJ+ueLuV8Ew3lVYTSSEvC9B+1AfRVUGwixcK5pJZmTIrfqgaPBKP14rNXHiXCsMaEAOlO934hNVvPs9cttKI4KWOUAN1lEiuUFPca5YtC1+WO8y6gyJ/AwRXtKE+1Xb+481kkfvgOMAAvMyj35PSnJ+4DWphRmzCdcRJzQcwFLKl9MXiPYBdJSEZlYMiY26WCvlEK9N6eNYemFvEjMHGNmV5MSZwEAqLpxjxXxWBDbd/zejPx7S1uxrNilqFtasVSnRCrWV2pYKavzQo+Rgi5FvEAAH4XPNWfsqCGQZEsHfke8Q2VdmpJqv1xi/tYQ6eYBDVQkDpL3j/E5fbAlmd2RYNvOQAaN/oXIOPXa2iafuJoB/xlZWuN+fu7WZLJqw6EMYLePr97yIjgKi00SDuxFBCHv/YfMq49PPfvnfe0sZHTgXXKzLhNJd2Jcc7cU+wfQHpkj5HmIn6KHT04h0i37Ypf7Q+Dt5R/iLs/OHQ0WKEJRX+mYZWlmwSODteJTzfrybSjFy5dvdgsyl1XhCA7hZfUqqe3GLsERmdqXZMAclQM14NihXydyOHev0m4gXsYp6ZRcaV5FP/tEDXFTubvdiOsLmJQf0rja8k9VLtWMV29yVM/JrbFi1eVQbW2xoiMyW7Bwoi0Fb+mWMETeK0ipM6+Ceu/WHe2Lx0MeCVp56AIaqAyal0xKgPw/H3nq+PMzN2vfbr17tF/mZPlXlwcwu4ExR6FsyYi3kKJb0ExXv+gPXUFkzmtkFIXCAUH9LnN1kS4B5iVog8q1KCXzdLzqseJHacrSGw1f5G7WCZ8OWUSU2rHtNDH9o7Sv8O1Og0jL0JHXNu8WfWzYWbGTBTbnT7tn6z1MBg5WTn9fj8B3a27Ofx4KgdHdwFdugaWeFbHNm4N9Uu3E8nlJow0/AXjYaJqEhhFhlmmVliA8U8BXjLEeikmCTE7Lyx6O020fS+4L+hkRwnUhHFmjOVwbwOQ3XtXzXGOF1TQRMG3CO3nYDzBDIOM4NGsiFh+Cv5FYt+QsJ/uudz9BYtePRelXgkrknJOXkXdz4wcKJml96/VNwEjAHhi1sY2HNhR2jfhZhdhylh+xnBY4AY/wt49I9HtuEPNdpNDLhSoN5uK3ZlNY1ztRAcQGbO6M8D3a8aTL4kyQ7B6312J9/zA0VwPnNKHewd+4buTBmzwun4VbbFpGnhrvngs81Rj0i2M0sRqew1nd5pKGMt2YSmr7qfIW46nmLzTgpsa3MnNgILzQbt+6ZMMjRV9inYbv/D5CgS3jdLOUM3gURXKTk72ksk1OMADlyzXHx/QLJTFhlmbOV/qdBq4/XTHHjZf92xxwan9Rc74BUQxKTRYkXpBpwrTW/JovHmNiW4/zDsfVTo75+TGoLCne2RwVhaXP3MWxzCzM51tl/Zkst/so42V+KlcnTWnis0kPSiF3zc0xepiHPW3nqNUOnalcxi1LcJwAGQB9ZorrynkfWJVg9I1ZvY5JXahMexVU/TKeJ6GliDzZArl4OEi0cJs1l5hqJIcJ1elyKNQbbxXLrFTq7+SdZpTYLA5YgHvAMMn2pBVRX1KwUIsbAGNVNIXoM4s9F/EH0OQq7REVTfJxjar4ZwFgCoynwRCmSS1+5XGVqkIZK6aDXqHfQRn8GlmbhGUhn12RrzL69gEdlMbBg+eZk8Hl9IZpkBo9pb2w1U+bBnP2VNGrdDvwTL7M2EdE+/cFyKTGhcf4fbW1FejvnEIRla3rNSm4W5pfa9F71N6gwHlXaJXZCX1N+kgUZZUGUJUDN/pCwyLPZqvTvJQJEEqTKj2HxxvObEemAq/GD7DQibwAULU/dD47dd2i35WUHMabiXwEEYqS82Rm4Tynn3r0aJBfg8cCXcdX2XHP7aFFULbW9Gtmpca1rTQJi0DhayCxKIpwjiXffMvCSAQ3eFVdxpcGLE3uwZddcLUnxZZiNDu6zfqWTWkFbmeU6cISpsG8SbrpcKTchkqFFE4LAJGEngP6yNdzGL9znOS8WCvQeDVAIJZB5Im+d02/t7BQauAdL4FmJFnj3JF7F/2bFJI3lE/l3HKaB2MtAE5WFGz7lzJOyFGECBbbGMspLK6/3y8oV3zHjgZTlAAwE4LqcW/3Bnfe3AEjJs/p6UM0fYmXlzgt2s886DebH/bSE5nskqgxkshkL9mUfUfAvSV2T2IoLn53qICcXIx8okmlyPnYN4fd9nqv9vw/1P+tlD54EKyWnUfY1H6hnow46LApTU/EB9LX21t56ACYasYgjTjW+qDHTn16J4gmolcHVwOsG/5LAzAxRfrx1YyHYazPoRae7HoDFCV8khNAh1tRsfIg2I01JL9pbIWVX86grpJpLJ8aibKAYxskwdNOb5izL6/Rn7IcaNsmceVoZtF5+RVd13CVlryEItdnlJHh8oU4VoQwvywGL/5klqA19pRymjgteZ5afM8drNAbNzGURwqQQFXlN2UmfOQzi082pyyEoYOpZA1cJKCtSOFrz1/e16Y6vPssBJ0LbK0pRaDNjCH8Zk73WdrgdZOOGJmTVARHEkoi9aHjFEupSQzaSJBrtqxmoBRyVVs+aAeV+bOX6lKNEQm0JxS1Ir/5I4kxAXlyirJzC3F8KnHpWouAdH83A9QVZ1xVWxZlQN4F3ainhnz0mnbmd5lz3S7JFyAcPbNOrnBrix2uqMFG9DxAjpxrC1hJgtYRjHtE77w5K0QFTBUSf3TcB1dCagiKur97SMd/sCNvXxKQzw3JX74Am9ZhzS22heJevyq6K8NQLS1Fc2zeRqO1JMSJVT2qq4Jy0A9wbZkIsVbiI3gEjTgMWar/uX8t9XuCoPRcaYaX/vW76uaVArB6NaQD4BX/TmAqsflLgFA1gmaOZx7geBYrP2xnl/EnNbFYEwDN/15dTpT/Ki7ALr/K+eG6B2Q+HdUg6T3DhJmYFVlG6eqlDx8Ri8N4w5fHLgE9IhtDddhdhEpr9CSRoDB27GW4HYTHzmHZ12ehQ0dbUfLaJqqLHgyOsRBQHp36Q0rVYtbkQd0vK7Rvr2mGGOm9hwYmw+0ORwcSs6BvzZ1fWhBIl9E5sKvlDBtD9XEXIQ2QIBUHmWt23B18AYxOLkoOITdaPVoDt1utBEMVdDxcHaN9lv/UBzfdQpNtKt6GJA2NC+YFM4vRiY+WMSz2uBUl5DDXVyUHZGD9xCcZyr+M7IRiCodn+Z95H78PdmFmlxiNEewtf0zF3EZg3xthgkUGVi7h4X/LDZb/3b1evAQGlFWGcRKh9r2c1h+sWr5JkrVzxGSqCCiqoqpdqabpXuPko003shy3UFO1FasgDH+Acu8BfUQQ/YBh+FFPy7Dxqj6thNXseipU0l5v40a+tX7DxYsvts3ODtBNISrIjS/kXf1cZHz7M//y1LHYY3Hs22DMo4LUwL/RfrtMYYpeWE6iVEyM/fGD+WzPY/3qiDmDzD0WVYkdyx+A0e+Wju6rxatLv0LV9JKyzjyPUoLMZiUQb6A0aqC8pYkt4f6YRqImJuOwEV8/TZUUrTlFQoZBoZkafdSsE0wdeWxU6W8COiMryfleWN34OD75uNJjsheEHn8qMRotWHqwtZPoYsnCMU7n33/THIYobDQl51vpxyv/WlMb1ijds+dLvYNaXHIx9kOdJbW5vTkiB2q6tZoN4I7CQ/Vc11mOdQer89ejJwUYwgG2343VNxI3dYvmw7d43VhC9Giii0w3KXPEZuIk7vka0nxiqvfbVgu0Od2FGXs4YIDm048rbBQIzgOpvD/Sab5FA8/msOb9+4OxIAR0SGmwKCouTeUmRTE2mHDp4ONjVfWC83+KtSYX+MYp7jc4iicNmihdgr73BPThNWVcnAMAGy/Zbeqq68WupzWTirN4kl7pToxIQx10xsgmeqASNkuCTz6rw7QGfOgF3UgIF0yYL3xmNilrqIL80UERcmcH0FtJDO8HpX+wKpyWxre7m8cgSEIJsQCisgv2GEE7E/XQXfL7xUQU/PMOIaJX+z78Xj0s4TaflAEumLy5Ukg3ebTcBzEgGuF4GGqtNojzf2t0Hq7UaFwasjDQKJdJRZFpwdj14eqYYzTPBJ45zpt9MDIkFGTUKOy//szWv0pHwGuzXsMYBCxTG06XCxXEKG/XopUhKaC0r3dC90kx759s+FWMCGqnF6Q/8bWFQZti1+0u1QFS/xtDW8k2q09yg78AUTOmK50R0/+AlJv2PLy9RCATuah21T0W8M16rNpG2FedunEeJEpabSmwTOCVqKQHjAE0Cc6R8JCFX8TG/X6JeFqLUZM2AGgA2ROgUzGxMBUiiSLIR17PS4qU+InKxmzbaMY2fWtjLZ72B542VReDLmaL9caGHjTXkDhqDUr/SizI+0cRq9Vo1XW0ewrvmYAAbxWD3A4rQKDUrwIThehX94WDn1C/F2grv+i7jMHdLp3a0cKVSWT3hghuNRF4u4mgqlK4z4MC9tdgrZCADVWFIcsrbhTDY2xBaSqFQ75lfCiFSGjBw+uRCD+7eOcfU+fCBchGv479WpEctdRKisY8p9wiyOI97PEsiSHEk60srAgvYKXTFwE7sJs03diVM9v+c2HotOQ1tjSLwu3c/SqeVvsdZVFhzAZqBoO9+3ec6sX4PzAacEoPa/RypMPBTuiWs8blJzUOZttglzzlNyskYaFYZTBOYyQ/AUCdrpDic/wpAaFwHH7bM2OiAG7+tNExB4jZi2h6D82kMrZFHoDNIM/bWvVw+ociyOwQO5qROrkJwbfxY80cwg9vfD+zLlFYfhdOm106+BOkBDUOd4byzcVGteeGovWN7WlqgAkp1wps1gDbDR5FVh3VR/LjxGEN48zpUFFVhHShpQUVsAP/W3jm3D9mfFQRi4+86iUwhsAIaq+Rls9P0S0pD8QC8LE2EhUNNTq11uRVIkLxrJV1q4IYCwnbt7GwdaZTVOaqQJ5JLy8L/jaAW2h2nkul6goqwaY7TMh20wZCNY2Onk57QY9FWQiGLmlOzSUyIfRjlzvXq9pDl0pOzpXuqoKX9cZRhba9ySwOH/w7zmwzpGcdvwQ0KMTa8WUvevdl1n14u/DZRgP/WWHB1N9GxqrRn5Q1vbi/aBZiMsRQ9VOIQSuNNg6Ief2Wk5QkFT3vAEFOJz71X2pu2Yy9Ppn0jtBm16GAvH2WSGLbyuyT87pBwTR4Sdg+I67SS4io8AmJUslBlH+1YvbEcKL56++RznrsliRxZ73E/HKyshqbTMGdP4VjNYfYPT3Bt1imypmoY8PZ9jN7HrDJtm5UVynLaSbhv5sT5kUG+pDrNybg7XaRWN6YThdklYWYXtzn52xzbHbp0hd82qNXAftmr3OYREfhXT4GwK+0z9rZzleUr/WeNYB2H08pR5HI1jG80D3cIQ03mkCqhx03IDWKjSPMzVvZcxgVYy2R3GVRjTteink5rj4yMCsdYs9njDj4MBoQtyyLst6ArMaK3+D+1CNrXFc8hTiV2KAKpyRp4zDTGhUDvvjyTzJ61okY3lPn6+FrNobEkp9cx5n1O+qMlL+5h9u0ui7sHd7pttYYU2mSffZpsMy/+AinBG0x/IHSgVBx4f7Pxj17ljW+QIZeYVvh6NtnrPY6IhtTxgjFZbcXQHT1Pn3fGYFL4QnKfpT4EaJ23VzwJNcx32p6vQzajwlaCsVGvtBxIjRh8BNnH5wmHlRq56uzz2m8YKfH6lTAFEqq8/5aZNxoV/wNaqXc70pZs+8ZpcNB8qOuggHOGVKsblLoGvU0cmy8G3dvMzEroXQB6+7Yb4sXAvxtMQt+PCNIY7eKhFgmIMrESEY3RyBocCr1YH1gZsEs4AAfsJYV+CVp7kSk6t+YvMbbHXW03ArZPL4W0FSN0J9FyaeVFHfYwd8y9+HlWbhh0mthdY4DAzTXfTE20OEi20ZYc1t42w07w+TV+vhmBk+G/MoiLcPfjtvuy0ITs7LiHL30fUZ7HmmCOWwcTbk5jpR6DwvgM/6X6nhTF15etA49x/ojmXPm9hUBsVHdZPSo+y75jgu1l2aSmgHyL0zXf+07LgRUPylphavtA5JteQwuwcTPZ0fX6xzI0akiokCnYnZ8e3eXuDOTjuLP+E/AYWv7I7f1obk/RuHAYBU70hOVubYwlCch+VmY+vVOHGBt/OrZrf3fizv4H4YmlxWGkJXWNCTiymUikGcik0Hefzl/+i8n8csd/YW2SBLr9yFR9VgTIbjHMbF7g121mlCBqK9UY2RoN7O3I3IrkAW2fgPa8VzRNvpEfB0w91+rmEQdNrwwpvY80WOgnpzeKSb6KDatL9gbbz4OW5ERMWN7FVmPg8z+M/cWhNfMRrhL6IODALIYyaDy6bgx/DkUwm99gy57izo3zjZslWF7bR2mi/NmfnEqqJbWVoL+OoUuxI+3m0rvbi0seeCmIwgCh+BNdpAmy+LSfLRR4XtKV8vck/D1A2YK2yo9tXkmLGM8B07wsHt0hWW3S78/qCpoUZGXCb17jm9O+VLIvqUgKHKzQTPBfAD1y0oxaYRJXAhPoUM7XYvaJgV/T9xE9hG43k5iqZc8qWHNAUwtnBCmUgXb23iwIRTcP+N3wsPK7o7135M3FIK1Wb72us0dAL3FBmZUdL6WxBLp67kJjP2ye288gRaxHXX+lLyz2W/nWAcF+ObtBl1JvM4H7JqackHLZeSN+/CcVHo2IWRLGRpwTiVJrld4LNs7C/S3AzyLTAQ+niQWK9kSFblblAXyqXWeMQaRaGtYcV7iLmeAEd54CZGFHOAcO+VguJN1hE9rzyyVq3/pOde5RW2rx2en8vR9Fkj02tOEECo3akzcbMLgEsBKSwZ/thr4AKjyHeb+Dx8Ssl5jNEx053A02FJe1paXUg1wVrYAsvXifc79vo7ITgBvaKv7qRaleTx4RutAAsiSYerfWASwWuNiwuYgaR/gdnNU+IXDOwUtWRHMktvIcqgKmjOhdhMbdlN7Fr7GnvK7bMbwORHbFUpUyYbNPv7Xsq+PuuB8lsSv5wfXF224+zFBRPeAP0PB4iAzV6h6tA+KAT42DqAfF9IAlIpqysZoqjkoaMRJ8VxGivDuwRDfNWeiHOtHSGzMEvZSxkL2WS06NpxZ/B2zZME4YflUfCgSuBDal0Z/z2d+z3IXLwfBEBmz7a8DMeZAhuOKaCVB/1CzqpxBopBvMyE+xZR7MxiuwmPPsYfNGq1W5uQZ6LFvu9dwjz/cmWVq3c3zboJ1bh/rWLdfPbWj9Y3hHVb8lJOVaNRU9gT0FttxfifOMQyEwqkMxzGlG8CwJtDDRojQLdKj1UG1qq7/RbV5tzlgkLX7hdaleP6E8MwD0mSQ8vOhYKV90qqIhshqmn6iNslV9HtF1kEWyFqwVmmbp9cHskMWaketpKz+6OcZHvOkmM3LLe0jlBZrKzGn0IWddo8xy61+ZSZ7PrfjvJPBTO9bHAZzt3JVk5lHMlReHKdlpVyrpmpQQBUwWCPgl5jT6nch4TQbYDeIMPUW3tRRy1HRGH3fzqB33kd7cM8bMmNe0WZvNTjbSEfK/oHt9sB2kEMvKJ9XrpFNexypUVyvDG9r14ahLuxAUkoJ9tgGoRlTP7tp4h+JaX71TPk84Yu7McjI8WEX5xFq8o9GT6ykI7SPrrb9CKOkezuOzsCNOxLWihzZ7anMaTYksx/bsR3eb1nBVCzrCyVcoRwwhxmVLxsPTryqroPgfa0L4mIueyRt8At4wozYdHlZYBcxmU8FcP80ATE5KUwdkOXlookB1aa0qzVBJLbR0rRxfyuNpRwawdO9GJ4HjKOEFN323856UR7mPEP+C1atSMYWQcF+/rSZZgsCtfs90n2Sm11fQlJkiY7zrvCP/Bo2qqgWhyNrNEU1WbQyYAfkcP0DymzU6CsFmbZGuBKu2XzIxPGxwCbYZBtKOc9kHGRT7F9IDy4m7GConkMMxSmbj2+z79bH6W7aTzv9QWnl2Weox5CxonIQ3u9KU4iDtNWcQLMXYSvAgGFOcoSbl3O88uF7zJyfUueihAFvMG9hRySbdPJuJazgoxQun7cfUR1DILHgTUpj6Qf1pTweP+zO7IOzIt1K1mz3g10Rj8in/T0UWpx2UcXWZ48WsRsoT0s2tJA/SqJpripH5YVkOG/rh9CnpLjqUuZnHndr4iQ8ovHw2vrlB2AizdpkDyuaXLeDoRrp5ZnNaGXnFDSB3BiomRvu+2UhvoIGbj1CuEzVwZ5KllPl/vFinYHtAauDUnF4wNUblUNq0ZNvSBmsxHuICo1Y4nrjtsspQzuqJ8vOc/CBl6iZi8w58qpS/jOuzbtM8JUzwTGm98sRH8Yw8MhphDtslH4FcqzE2yPm8Kr3NwU3P3ilmUkaI4F3fxrnb5opo8YX0HZ7NKW3FaYAgHbap7GMz9U2dps8YsaRbfYhQecfCTwNomCR6olP7nkzf3/3gyy0We9ZwbaCX+jJwbC/NH2/wjiHlE0rxfyej0JeiJUKk+gkIloDto+nIpQa38AZCxQpisn2pHAAUS2q9Ydtvf53RTl80iJk5w7uy4LSX2EPtSscM5vneYjc4mojhSUnwYLWO9fTYhTrkoRsz8nvw22BePkPE+DbBRIu0mMOQwT6aV8cgmXC2hzE6noNT5lK2j+ohQ4zCIXBe0iWBlEq4wU550IXbIYqciDn3xS0z4w5RxIK261bYH37FfowHkGw0XS6kmQU5hDH4kyjEFJCzWHfMXQWRLoT7HCLeoZaR/PB5QEr3DzajpfI9b9CJ36cglr9gOrQMJihQpA8bBnvOnVRsv5kzIqBvB3ISDeN38p+25TvmOQ8gzp+pWoHsB01aUcMeT+lHffwGEVBzXphgot/6GRhnO8gV8SNd9q96c7OM4TUQr38vQLwSDXqpaVVOI4MP8OZKs+qH9syAWh/o96OO1WAYjWQjqjtFeTAY67KQP+lZRy72facPl+Lmee4pPtFgPASSjL+MMXlsWx2uuPjvpxa64nb8RtJtAXkPaoep8QwyURX3r/qe7TPRxaCe/6ZdQQMC9UD7JVQyH46BdosE36sG+n0/5lHalNglnkxDriJW1YW+J5oumdm5QTpW5yww201gvvQGcFdxEiFF6oCcGVkIPFlg94FU8aN92tLscNG+Uz0mb71+V+aJ7T7+ZqMiJkuIFjdrp4t5KAhkGa7YlO90YZMCs5u7p+QrRR619IKYcVG20NOir11yX7Vc8WxWsvjLY42kJt8pD2Dy3roJW6L+thBHVsthsp+I9jWC9VYUtrYlOOBET0o4iJz/sZI+tWloRoFTlHBSp2F5fbg5FfT1SEipsT7JNoZqCzlp9QQoeCq4ixEpB15nJ7YJe+pWVZJxuF60WGKeIxg+wB/b/HUcPxXUle2inMw+k79BwpBWZn1HQZPh6k8c2zBxcCVpuBjrCnLCYOAEkTMJJwG4HDQemKuCe7ol5nEcDpUNg8sqOkqDqR3ejAypKy2VbVqQ2bIiF+Lgnd902weyDMLC6W7iFyCFFyptoByS06F5HIT39CD4qi+m/rTtv4RrbjnD9WKG5BbxmZvbi1XSTGuQsn57j78FcY/HxTOR6vzLdUEO6cwCFYI3i0l8hjk/W8wJgKdsEmM3MjVxYWL+zwUeHic1pVLLMqMQql0vOQ6HkBswOPb16Z8e5qAtaKjb8U71Enh/mS4PziDuf2+kIkKWzt2aAtiqZ67FgHFzdHPtl+2PqmQd/2lxzREcp7ZoM0R6OJZVS6t+6m6+Ta7EgU7x3xCOixidWN3TNazVKqwlzB45+GZWmzsDcbaw4FoaDgE7vBFCdBFFEf+AP2kXRSPfN+mPjPrLi2hQ0q30ndu0bGLZ/1TJlo7bGxxbPI7C1wo4+G0F4bdDVfHxd8FSnIkeMXC1+eG8bJNPq2Ef1kSzWxkGESXKpmvwhY30sGgjEyZn2bkytsVyu8Jmxu/47PAzBPlycWv2cs2oT7yJ1EMzmVwnSqjMoXsXgy0XUN2iZIeRevHUt+Nbgb+6Dv/HGth7dQ6IV5vsfRvLEaw+fU7Z+da5wrkG3v/aZIbRSmIzpFASBDUmxZKRC/434+vzXFXZZn7ABvjm3dNts3g0y/4nLZ5b2EYkBLc0i7K9U08Wim+5UfBTPXLkfdm489b3n/ikmtQKIHDlDUINTKGiglk6l9b95NvFmxe8Bq71/PWA8le9vHDj509AkwblVPfpd3vaBcU7WS6RTG5HDlcRGN/6r78l87LXnyMbun5E+86pMt0KvMmJhPB8Ni1jVu5KN+p8du13MIu275OwzPSFR7VpeH9TIFclnhxwYUr1pN4dcNpBz0j0Tdb/ICibpr/EawGFWUQ+uQaJpV7W6dEQwQ1CTzKYFJu9ZYKB/P60I95Ns4hKjQxxO6SzHadwTgM5ULfwsnZ6hagktxCExf/yePAega7Zy7SdJNht6hr/1cMGRRLA5xmz8jZw9qf8au8scTEdWJ9OoSBTs16Y3riCkr9unyuuFkDhZjR/uhqJn7k/T4rStcAQJrYnJOhjYHwBetKbyrTsqZ6iQNq0bqU6XrxLcireQi2tM9OMa374FJNL9mrui576dr4DxS7WruBr92JR+NxS7TkbgW+BVsm8ulHvsek0U+BAq1bcvw6SzPpH6u6ojgNfuAcGEKJd7darO3bmx6toZZQuMho+UO1PH0lT+Aulbo33t1KZJAY0Zmi5uZ4kijfXegB0TpFf5ueNWwIwb1+KnWqbtNSchRoxve2FNCkwfu4bQYu+OcMC6JtG8Ozv+nTZT2Yc+FovGT0DJ6gYOMvQxuTXbx49sylZr765y1Xk98gRsT2zFh7mt+OPc1ZF+ZspcXckj5TRanZEZknxOCHZxCy9NmV3B+GsKPrHCXi35gb2bDY94alPxGvWVeTplfM+d3qsY9ZB7O09HsWIhN43MqulmbS1WNttdr7LWEJ05CUMazXUfygERCUU9/8WG8uzR8NPOXxNq527C2vjuDyxa8HF7d3QBh1FobegvSxLWr0rxxNmKHhmCcUjuQUAD0mGu713TyPdv4y3LxKjmimZXDalms8Tgp+tzMMwuBL3fZVxWvdExXSIwREQzrRj9lwVGfH/bc3Nnrm1/OIS0dP+81lKQSrsxMkqeV4fzKLWUYILAZdiCOkYzEEIsqZp0lJ22Q+45hSabaH39bd+2gF/57BP8UfXtg2pivnq+L7YtX8opayd93K5GPWVd7KqS/Z+4Amk6etV2MWiGwuZpYeK2tMZnC73VsC3lY83hLY9Cqun6svPH0NqR6/EItDdLp21u1T3mlxoFnnUuwzmsrxAWbWOnCS3X92EgMSPUywcTUTgOZrZmRQnRHCYvAgi77tcxVq6KI+4xGFHY4jmPf90Jsjl3bdzrdHwDeQ77N+LkIzAxzIitarQBkv7gxCoIFpmv+7hiovGD1wq3LlNGHtOdRR15VNvj/aVudCmZyurfs9+zE00sm673zAjb1u9Q4L32L7WBtXOmFw64Eu/gOcyUjkv+ABluq0WoCmjcJ4g9XhMKPsD9Cmts6ce6EuSM59Otf3m0yaAThb0DHrSmYuKRJi0pz0+KR4CdgIcT/Djnj+sumKpFnQ29Ru6FCXecCOfcO9XOORzKsHZkxE7DQ5J6VQlTa8UiSphI9zbQgn3R20+R1voDvRGkEswkTKpNn23BcuGUKkxe8YBH1AVRrWXKsVTyzmCdY4A3pG5+CbpqD1RmTwUmMSVdukh0r4cj511yg6N5PXWzQWc+PxB18sqaDUq7/pMdKcwQP/TNfj1lS9XXtmCYW+meec3zH+dGdYPETJJ3L5dxm/UR+CuEje3Ggthyo+kHGuLhSw27S/65VZfNISKIMHlYJKozrkKvX31m+s5udmIA/2yB4nkmm+kCRLWo658Qgoq248IjK08AldDcZO/UuO5znoo+yVxZzbkVUco/vPMZnNIjLCY8XybQH4wbcN4MuLCJ3ORQ68lB28RHqd2UiE+eek6ugwW8EHH9jSbGA/VVCD38yk0WCYAwl3GGqX2tTAsAqClNIt4FugxTe409Iveho+er+A3zalIjVzL/6n2Irbp0izRTYWsXe5xhOyjWSkdmIYTu151KDqeJrr0x/ee+DQqx7aKx9iI67C3R8bNU8q/BsZQL8KMXWTA3WI14CisUynvW+mIgjAb/Rze0opTVBvI2G+5kWoOhIVuUKzIrbDWovPvl2I6IfkIsvAJtsD17YmohMAq4f+oWbpD56lgCcLOp44KISWbA+FyUn0MCR3qJkdlZldpBJb1kXyzOiHmvBpIjqB0GZe7e8gR9ei3DrdLpOqyBQUxHlDwlexCUgANVk7Zl605dHYIOLg5GNeo8t3fiBp+p5xy2BSpOalkPF4vRt3aew7f+krgOn9ErTbVxCV+RhoH88XOlF1MzpxLXDi+i1++GcClEQH5i5ZQRAyZMqHFzp4pOFcAVmDaeOH0ZE4di6DANiyVHi5P1FZ/9qCQOZhyot2lxFBQh0QoM2aBf/U2o1mox0q2n7/gtYFgJEDQyx6sfrgSYpTBvdgQ6et46uhYsVij5oZGEDReljZcdtRUx7fYpAYaccx2RL9/3uPeFHVmiWzO2bgFfI7j+28WS7loTR+6VwFcUM1CU6yotc5OqEa6VZjsf1/Bp6Luo0mV2DExe888vECVMU/S9Lo8CKv1NguKeM7PriBJhTjgtOrt7qObnmVqxtk3W2ZMIaXNs6yXCk+5hBPUzb0JKGhWmsmrYgmdHgh1275iv71JW0cB7iWRpULv5mHnpJlq9Up29g0da6IlAzZL+uLhvMbT/sbG76ywl3JevkoA5G1uObFBEFoQ6PukWJrasCLjm0MbU8GjkS2JsKldz0WLkXklW/FrzQmlzTe1Ob4lYBblKoOG4lZ/2yFT0ea9L3kvdTJFXiLoGz7+zukvuqK3sPGq6xvx/oM23nUyabQs6MCpx242dqUUgabUYkMqFmCyCMQKVJbbPMmyeR9VRP8z3717XkXamznsY64HswtVuA85zYt6RYYc7VEPV4xbKJwV7GNT7ZnxxwxclzNmvMMUAnIPS3uW/Gv4cwSfCBoC1sGs+DFxnkos1JPhBX/34IyzhzP1vJWWKcya5qiCHDcYZyOu5EAUGz6A9hbFZtYxFP74qEGErLOJYJRLg1iPQCbTJ/F042WzfiJOjx8lMspKqU4JY9UL7OHPG0T/Z42hSnbwAirt7msF10h+ttj3lWHS6AWuIxpR0Mpsgw37IUS1caD94CyzDkPJcWiKOG41odxITY/1w7ySm0HKN9AQbyEHgQjZLQ6LzdbO9R0iUcisM59VwDF+q7xRhaxGqN00J8utBjIEY5kWk6+uYSv5OPBC6pBdO0n/MCTrTTOx7Dkam5FPGT2dp6o4CpT6H8BmI+fROPNwnwcjbjz8Dv0E9I0XqUZAjZAuVNROENKSZDIlBR3W+KPo5Gn/yuEgFRmlhZ5gHYFqNBLBxv5bkQ2fEYwWBd1Q3mFc7bsBLXSw7VXHOdEJMXL24TZz7VhFxqUX7+F8KCllKj/EFywnh5NrWxQpZ4nahrUFGcrKJrpDn4/x5k2YidXFart8nMQbZ7lQyp9toLa6ReqZrCvkm6HhCGrOBaUJ54iBlfr0wgaCjcnKpjtbLGFYLw5pkP7UbnUiXxD8IYK7pnR53xD79ASHFJdHe2EusGLImUa++asdtuCXgCx2aCdHtcRNZlMmtFh1Sc5CDxBwbDCGTCFj5/JjZwxCvY4vpHSb0XWr3+0zxmVLcm194Wr4jKc5pCiiI4e/ibShCnh1JwtIDrfPpp+SD2YCJ9MwIkL52hjZZQPRs9hvmcb7nT+9PWqSMm/+i2j3lk3hP4+uMZRSgeCjO25ipPM8BizUHrNpMml7ux5Q/7N9RkZIYcwaRUH/p0PsOby4sHfxyXphTbSG7mUgnpu9aBo9RBSCBp2NtreQkVIxaG/MNZh8kIks51y3r/scqP/yuprmrTdM0XCCr2s7Q66Y/JEZoX/PQNpmOLBwDLXM+wliTNwipus/CAjDbDPqQ78VTo0TzzEcfIV8hFq1EmvChRYBWxP07T6NAIKo404WAIRfKYYzA8JaznDYGGvelHAdSvjrjzNqhyiLUcCflHbM7WhBalGCLBHS4uYxGYXE4Mj/4e3Qgwz9GhJVuX+V1eUCRLaYkaQnvylgHXVtCa1j1uVSN5ijZqJdxYCzgmV5jLjTP3lSUCAFVoo6i2xCWiq7Hx0Hs9E034Vat8QhTMKkuEbtcMZCEhfIKoMxmoYZ5k5o7naeQAFhrH8WUSgGVE8vr6sRPbsaJiEuQkEsjDM7S9bn26Yw4AifqoxJ7k35SQIbAM5ZBae7k0egcZgZdc/DEbNe6KOpVL9dimGLimP5e5BZl8gkUsT1NERieJBZSrOZyzHNlsxXVDSe/e+ZSGAJyLtsOP9j+8nbeFu0UW+ntNSFOoMFu9vVEoAE9gJG33QdXhX2PiwMycrvWDLBa+u01J0qu+nw9F/9Uh/s6hfxiPWgdEhvp5pw8O2HICRcUvgPOVYu6sU+sKFjDF/StTntTZ7xlP5Gm9wBiqrYbjzZZVvCRdbUMjfnc8tvHRyd0GA3I7RnyxPXofItSaQ6shKW7C7o4k4xO462CNsWwm7dsbnXUNQaVmuIfScwPx+p/6pMffIhdQSOm27Ynoh2RMhF3xzgWuNXr4heT3jyxJkhvEV5FuUkC07R48q7P5S0JNX1cBcrVUWOHzZ23HGInKR36bcT5U3jdYSyS+eTjG0WcswOO5jrTHGFlYQfiHjO77Tc7/mmV+0x4pW5iORwOe+9QQ2QQqigXLOOmwVEMgKkY7cV0IVk5xdgKGi2REvX1dNKpAz6DOrwonlvw3OCDp0ibuPSse3nATLgtCXUos0vYEb/4CAgTC6lSXShvwHudetzxU5qLaYiGgWSXtXb4xxb53mLihC4psmCaacwLIFZUoJlZbDrtxZSJrJ8ZlI1CDxmdF1G/viK3a5qEHLKmMSsu8boO3cqwRLGMuu5PUaonTuk32j3IJT0MgEOPvbt/OPB38Fw/aYB84/syNN/PMXtbVzMfcjhAfC8z0HvMXUUp8u9En+2e3nf0+sjX+TB1smiswB7IOi9nHaMTnP+dtehounzktpCqbtFVFEbiLq+utBw1kdpDedIN7hW32AsHBPhav2CG5OCsuhW9HY4KwDUR0iI23s3jTnphKrU4lhWrSG1LcXA/1sYjO3hnLefpRwV8pJtlUabHwmOS30pNiCybBv8JsBNeASvT6Zop9znIGS7bClPaY0KFeNK3mIYkbyb3gIXjmk4oQkjc+hsp0B/5bkrbbtytjJXlWl4KEijo/ZqrGC0QcFWyGKSmzN3zgSHbQyiFnBK7iLAyPWOx+Vkn3gYVZaZ+3jbbYvtZ8x3pHLVDPcoPa6TiNxj0Em1qnJ/h9mSLGCE36gsHJygGxEulMWkPLkYZqkDbLG2L2RmpVvneg0wZMctpxDG3Q3n0/scEpkDBHm59ZvbijbA8pt8ONTSOiLfRg6Lf0pDH/0J9/rksTl7fr0Igns/iXtBNovldGI0E6e9ufOszwYkQmquFOqTVEqOoRHRNuqSdnjm4QDDh+4ji1ZYwUJW6oPZ4MjHpeQeBEopNrznEMBIc2XpJIeANqa61LOf0WqO/z+3PRyFq3QREJjqluNazsQoDJiiKwimq/D0YAKBx+kXZWTPDNhR4AshF+IFDUAp9oQYrlJNJSSMGvOpOF5L0agdtLYvfHQgMaQvKAm4QwwXb4KrO3r45nlyl1B8O7M69oIgQ6bxYTmcV/WmbybDK7U4aujXTSV22gg+5QVuXDESQAxr8aheRLXlCOwX4p6YYCgJ4cvEYU3iNQiAo94OnezGvqFD3kE3ehIQ8L44mMSgI31CGZKeWELCjuMFkdgstUF81j3FKME7SAsdXCIZgE/w54TSzNsiUqd9kXaVwcP4dPhWSWsF7YGX6P4dFYHeKFTsMiuBn5kh/SbJcYozICvhgL5qEsFQJ9RWklOwWtjlFEpdwCUIJDYcDEmgvCuoClj/Ytsrm88pFWABLc1T57VWdV8uQMotn+WPjl+GHUKST4jIlFpz+K7aLIQvQ6EY9O6aG1smaKLl6MxOdT+qrB0q1r7XEpv5nRYdUhoficThVWsajJ9aDyIRUM3luI1UPrD19i2nEhYQzyWVpCiPXnOJkzG7I8OsUUG9p3JpM28RdLA4prYQSKOQeUU1YrQSRg4Y0q8dSRxq9X9FYEOtZNlJanGU0+O4IWEdIBVJYfdLmikgKoSki4cKEIvbhfByuxzkeQeI+UbbBUJlrIJDv8EG3rnNWly0ctTNVI8gvEzqrPmj9FnykN6LUofsS4JNxQS31FC/SRs2Gn65MoVKKRviwoKp7NCedIqELTp8dNJHhq5hHYJ/xo3x2cmvUviCaqBiXkNu+exAuBbx3P3t4lDLRtuFznGvOelk4paj1yUKfQ4gBp6vviTOVDazgOpwmvsomc20CUFwGLQtN4bFanlZblu1WcpAgxsNnb5/bovMUPGTHI0ukxlsmfHq+nZQUXBP1rPmU6VrQ6g1hznEjXL1ag4TT1pR3MWtQ7HKyKP9twfQgPjkIAP2zAXxjIzNB9VYvQr+0dxgNKbqcq+xvuUXTZ6tcPjYDaYdGm9JaORZwOaD5Z2u5XjyfOtytU/KmWi+NX+C7W2PPCr4vg0fmVO0Y/ynEzcOzPrGSMg3s3jBdWmlTN+ponQh75IGQnILcIFQeraBObkQLe+0H+7DTobWgGgy6cXsN0qne8j2r5bEaC/Lry//HR/lPs4jevtzxJeZRsFGTEMLTtIeAKdyIDvbxAFiYH7FW3P3NDruJg5XiQa6bgg4rqT95Wd8FsCbkePhY3AvKGg5k4HPNpXCedrOtfR9AjIdAfx28CB6Ls3XH1NDd0ydlxhQn6zcBnhnISDUz1NMbtxodb2aBBVAcnPI+bFQDt8Evr+GE+K0Pv5kXs9VHbIkFnq5o4BnOwQTgexU5pQL0Ud8SYV9x1iOETTnve035mwF3iDS2LA06l/jFsA4s/jYjDdQBjOBTNrtVXcC8nBt21KXLRbaeMWWSlj5VtF1A33Vv29ct6oy9dk4C5qF2SQkwoZE8DF9DQ7f0rKpFxymiqCnAGGyqLKgjVyvlwJuIJEQDm4wXgQUP0iOEO8ssvdfomJ9s4bFmwCkYt3OmilbGb70a31P1rzToSdhO98N3B8Uu4w6AhG6UJgVrNDuNb1IUkHsS8BrNoJ/283F1ZdFyf93gFDcRCfw+fZj7s8L+Km0LQ4LpKRzKeQ1CYBZuM7XVV1gt1tX17IHTNPyjpMPm1L7Mdl3r/5NfMXkOKkIFR7b70Y3XZFbxY29xejRwwtump/W2F4S14rgHQztbfdFLxvo1gY9TAxjiPqNTS+F0hFWUv0Mj0FOfCiIi3OK5+QpjIzYwdqwKzxP3XMyHXtF2GmTjpY6GfhdldgIM4UTxVKRI7NA6mKgPaQNjZIen03tivZ8r0ma+YOg7HCPov71bHSccKsmUZG9uhYCzd4mFPeUn74fYVQR9uaKLvfzPNYvmB7WbRbzQcJN72oDJAGbPXD3qi+c25t5yUKXq+cxlEKCxlOFDicXPlKieJoxXFBZtKI2wZgKHeJuWGvIYT0NfT1vh8/MfqW0EFOyCYO3LwSn2Uh4BL4B0l1Mac1P4AU0FNgJ/AFstSaC+U0q9BouCyzisMRdGthdZ+WZZ2ewC+O3Xt4Gj8mnUmm3XN1KzMoosRZ6LqU4l0rGjGFc2bCY6jMo5jEkkdsI+zPYm2mpWXYntVUvlAbxYC6fYv1mhkAUPGY9+8P91+w6U5gbiqHJlMKihdMWc5AfFej9AeljxXhaYlfCYekn5fKXOkfkBYe8PCJp8nj+QAOm4oZ5DB9XAdCBYRRrCFpGHLxnjsFZYIjF/KybrjJw9apT49XN8wPtk8lcgeqJmYdGj7j1nr5BQAQ6XRPEebC59hK6kUeA2ozmhIzRzpACXe/oKwZV3E0DMyfOcRrC50Q9Ns7tss79bPSruyNAuIwOJ+GTozGwLIXdiRYJA7VPK0ZYmUhP88rxGEH05GUw0jP9CrtKzglFd0FfXG3IAB8m3avz3N26yINHsG3rfCUzgoL9tavG3HRapu0eOoEuoZaY5g3LBdzcVr3k8JasyO8j8hTpsTUTNgU/EGk/W0rtybY8sjt/+5u7C6h28ff9DCKDDaHb+ZeUFevybbp95zuKJt7KZRCv5EbYSRafpQ3DwqY70PIwN1NibbF/z0rKf19SmUkSj5gB7XL4qH+s+a0RBiKfSWoGKicpQfY7+S4GeT7bQ479eThaBZCE/ZpW2zgi3v6QJeMq7w7OtsGmaWCGJiTTC1j+qtU7P23ZrVzb58f4osvGhOKGosBplzA/mnKnheERV8tnCFR2hxJBCehDKcFEZ7b7UD6bSQKdLTJ1idrvQ7Qc4PJRBpZJBtgVed0GQSOqYM14w1hMwMZdDuDf1MNHI5j9ZIV0S3YCEMApaNFF1H6zf6U+5TGf2oRUV3oZvuzXufhHUAcOJYS4bUo/i0XBswgokTZG6sR9ESaVbP2o/V0lPwJhruyHm/Fpe8N7qDtg3L2BqMDx9exKqc7cDoXo2xE97oJJzqT4tz+GsC3gwY7kS6HBiE80MC4/jkhKulMEyvoLqwTyx6vhP6YQO8LUsXHJxyx36vzfxI4k+rGPzcNnYn4cjAHxJK46K8L8YZ7Xdx5tSUhF7AFGynItdYA+4/7yVT7KHGeaXnjLz05C7Pu/Wx7adI3U5ZoFam1fvZu+3VXAxTP/UVS1pTUnSm6esEL7/XNrk7WRIJAqr3871CrTot9SBDoysiwa/5jdbnvqmDKVxVPhfD03u1xpsaT+pTRgUi5f/tjqwAxHutegZpbOeB4dWNOGp3331FXkhcRllDZ6R6aQX25omODHX7YVt6p0gbBM26CLC8jSb8nuZ4eRNCngQEiU3xK5Ew79cilbOnNNVJBI7RGouVdbHBr6CL4AOmkdlXPObEPR2n36yAkzMH7o88aFoZEgQR1vrMEl1x8cXw5Sg1xL264zRYan56st4aVRF8nwUhrG0MDXCPdDgDFxZaLQjANsjDqeZYDEzEEobeOiAlRLfyRnc5SBja1RoQJk/a06vyMCP2wREbaUnckfgCtEDHGIn3P3dsbkEbPSf+vfFp5LF4t4anCgDsi7GKPfQKE4gpnv0e/cP7NkhZKEuxtefV/+8h41sWiR9ZGV12mAv88VBoF5U+lQ0GX//k55CNwjQX+VD9oEk/Dr0zl33H4W1I74Xin//ax0S7d3Chwf4v5HQsmLtL7tzIv1F5wGePrYV/SykIo/sqzDONHu+meM+2GlX846ASJIZznMnkVA6KZrYfj1AJs93P6rKxZAliO6+uz8J/ko+KH9k4paTbJlu0hKWKy8/m6+67AfDxVzHbutnPR4a3wlbiSKpRdrYl0GN/dRPOM7nVcIkl878Jg+REBLjbpUkh0I8FpLkrDzCc5eAIIXu2g9YbUnDAs8hCxBC8I3M5CzKpQySBz5mrAaACKFOj0ZeqQZShpq41bwnUK9WlTs441ZyxmMHhG39EUCsQvszcW2D+grU/2NFdD4CO7frVLy4VBwNfKgml+XcmB7J7maMUBQ34oFA/oCpqW9xAHs2URT3ZWdzJ9o7aZhOIJk/E12+XDQ83WT7o1hXCklbTfNyyoEtCmtntRKNAM1JfAKEJSsVe3jTDw+GZ7+fvpKbyDiicr2MG8aPdJvNHA1MMW8XUS+n9oqKwMfp0zLgn0n2XxbXVDNko9qh+CejQ5m1hx/smzl24I00etbiV1uHx866JlLqCb2vG1W1eGvUbHZ3gr84gIWruzssZLzS/G5bLAkncXkLfh0PHrJysY0qmRvj5/4ng92rzCvfOlOyX7sUYMpMHeXb5PFAETvuTInSTPR+KdS8BVByGIZC8XWE7ICKttrgW210AItsAXZcgKoTaeeTkU8puNwJFpdTKkm+o39aqOiWG1JUObPaEdLE7f9oLqUPIxAnhMKcXPo1l9BlS9tVpc0w7FfnCSka/TXIcHa7V4CKu0rLW30RpeQSbI7Ydlz1i/OJ9cL2323Id0SBwcsP8uNPE28V++K0R6mtFKkRjatDeBZtME/3wyXnqtKLUARejlWVwN/f32yLT4h+cb5xGfTPlGRxZg6zXdG1jcwPMa336qldtZ3uie1sOizHbPs2ToETv0UbcfT7dSNX+Qop9XbizVUEDuYdaUh+B+7ywSZIaCUvKTDX852/WpwASNQXG5/w4vE3oTHBVjZAXzTuIAVrWtjFGxjTaPobfdu39pon3ddUYTgcVrrKRQioQJUOkJsRGE3T7D6BYO7Euq3H3bs6QhbImr4GT5Qqqpeb9Nlm093YisT/9dll6FluO84ZjNUWfTuhz1h/kMGFY6j6R0jAEGShS2Ma0I84FZAlpcBSyIxhl5myCcoyT0rbr5L/n+8zCGm5++gUDG5652RqbiXI6E/CSbAF73gSEG1u2i4EibIXW5m1l9HWlWn0T0aA8NTbUr/WhnKUX+5X1QbgNKJjyYyQ4Faz9444V6Lm6z3iVbf65Ct6fDGUy4cHqOW956t1d9yInPTW236ZxPTTRGk6ThkF84362tYEyKQHRtgClMWA0j2iBSSeOGlivdwOfCqClvyTodXTgT9JwFzHjvKMr+GLSksptuRd+AJ/qzyFUY2v3G5vP6L57R+rJHgsQkIdIThiQoW3zBS0WspCNtNkYuE8KkSRmEjJCYDqAbAuMjoeJoIKtvnw4r+OZTS++eDfRatUtH06WSslgdcP0Lt368hYVmpYJmkMwRwCK90f4qRBG1N2BBaU8yAp+kUTSyVgJ9ZCKMFPwvHX+DSFBBo8ejZbvZSEmvi8cVUTWZA6of/NalYObdSRDvYoPR7oMS8qfj07AbRLCRgOo6K6b66qYtC1KqZqupCXCJBExjzPXLe6w7LO1w1gmC7NBC+gsGsdk+Ly89BsjmxMK32oGv4hXYYOyJPW4wJmd6bM5tJTl7VTmtJUu8EdqhoFyuFcr/NJghpS0UfBYXVHd8s3fWLZocLf3F7UJAGCJwY1N76ptZ3zc6WQNGAKdMhvfz6HvaDMVR2a6Ir85lCOsVtx79Q++dzAxljaUFROryDSiMwQXRAz6/xUGo+iFFR3d3pzl0yawxzCj4GBInb+70+9PFKkw93V0ExjcYdxsAT4zV7BcEb0M5xdKwuzLfScpR04mfHTAUZSq4N6nrW6bJqT4fUfUyOqvxw6R7yCPICvbtye9EPBYF6+/aYRoh1NlR7+q6GAUCj5BDSVRe7/1sJ1aXksSLtLWS0LvGK9jst4q+FEl8p8Ms0pvl3EHCW8GWbpUQ08iwmbUxRO568QuZQpcYj0W+FzsO0haNmJn32DoL/dMy1ii9QwDwsRxL20oHoQzKkKUbqoHmBtl/ADvnn249sfmVNfsuxrUCGT/4PCwj/JJTi+AX68/SnGqSAY2Cnj7eICNLlwqEX+e7Kfurh4Qjge7TPAIXbo+Jce8VEOm8LxW4CU+w84UIQCxoiR0JIrEwXVBiXAJ+wmr2QgXnqg+wt/EKpQQLyDiwqsrU7wi8TZmieYsejmxJU5eJf8o55/hOcNp/Ra9aZaKhb0XG04MZOH74j2SEFvV2qvT5cHvKPJzkAUHE5HDogGTwwdgmgc1NPe+jG8GRp6vX69HbJE0iIPI+9GNkw9ImOysatDUAyhLUwkDHjKm3gOKyQdDm8BmMEP2FJUWkgFD6yCtoicSTigBj1+rTPSWEGoHUpbifhPDf/v7voyfmGt6NtPr0lRYW/aGEYAURRb/q7/piJkIWkCkO1VCqfE6OZk5fFPxB+FtKzffKo6cZqwnc5v2+kPWy23G4CwVMBwGfSWzaSMw/OPyxaPpmBsEmWI7zPjHmDgbm7X5xvjQr/9TSvZEQvQEtObuHqqeR8NpXACnTqBZQUuxsUVhIcXiYt+eIKqWjKNBwfE6EmA7w7Z2LLynWdInp/V6Kw0QfQb5hj6GioVhVF25xxGxqFhDQ3REhsjVLQMnETgDS3fzSeEmTm4i946XlXLEICZNj3hfCensOSZANNl7Iy9n4M9rviqr0QQSjGILunYNznnD6krR8GvwqWzGuze6elCBWNO1VHBv0PlqCD7iHuPhet1dGvedzxbAl4IzVOgO+zRKiJmOruLMV9kbAFMPhJwu2CYgKorUO8zI3rDrjYutIvhkJKBSPjh8V4k4X6bkohCKz8e3MOX2ZINIe0chTDzh9zfVFdJWeIzkmwkoKtZVgbCNc4ALPnF7WJQ07O7nH2ITKC0dQWn4bzUFdKoEi9tnuqDlqb6WKjsKXlnlIFLrAiHsIqapVTejruHjuz2d0AYoM5ByQV74TDgIGwzTm1iaixMu+RBTQNsTmOZ7J1/G/l2H5jClFWCOrcyJJpupwFXSvU+ddfSRZEoEVor4wwYiH0cJ9IBMxdXcfGIj6539OfWSOteNBYqPlKly4Bcrjix0iuwTcnbojqh5Z1j2eAE8UcZyiBA9zLAnHWJpmGDGDrFJvep4FyWSzeRoHr+dRpLwoMbWc2HNX3G3DtWE/5bOQ0LVK5cwLO/JLp18DGgDNjKxXm1m1JxgADrS1H+gc3uPsuerxkR9c9q83RhH2DFJ4ju9S6rVG8pxVcKmFlIy+hmyHtRknddD1TQA+8k+CKn3mYFukKnh/SbNQzNBPF7QM1T4dovQ0zzuUH7vwHJs5zz0EG68jORUW5nHtuOP/3IP8vV/dhduu+/qmuGU+gp3RMSpjT/K5XcKzifSMA0E63DS13mTRuD5S13AYo+UECA5Qw3R3L+D62NwRG8w6rgzxVuoVItR+VbR0PCfsAgCztm8VQsifWl4N3AyDZMM5PPMK5G/adlklnM4EQttY/YA5jXFfYfdR0rweP1Rws+FEU1sUWu8AZzU2o6xkPlfvnhHguCl1Uyq05JW4RqXB6re8d8V3Att/s+va9gEsvl9lyLVcdHMRFWMdZKFmZApUC2NkllKnZ813jsLSYIPHILNw9559UtCMU9pH9TNI1C9pM47PqrdbqEgi6iLRzVHXSMUC9MgSl4iaO/IaQj393w6V5ql98krK/R3z4g4v9qLV/2g170Iz0xerQCpuCelJ6lQvsjQNX3tLg6fjpQJmEFmPodSq27+T78qhYf/8hubWZ1OBueXkM6ON5LSulPNBdA9NEQKkeTGPZ51fCKqgxXUMR+sublang5pIqTA9pFs5c2VZHVlPU9Nv1+ZNvJ1C3r6VOBOcj9rWjfbDJv6k7fPnedx3elfqKcd4EKJT4ZOpS0XxYg0EjIjy1LNl1BjKDLhQ20V5q4wmCl/uCccZarBd1gxwvoq9rDrdbDkLdvSUbnFs0VmvRi+xPLVKkTB1Whhv83eO974z+vUcY/1tJeuaTS9/frJ1dTNG+vI3xqatBn2060ukrI4nudAWqWU9TwTYafGR6PRoPJK2enUn2ecREYVrCBjcxDAHGRlXkne9+qBQ8R7Q8bFvv9unCU3sUliklkhMCAf2BuRzKKKQscmyhTDFnzuDUvAUdf79Nhrkl0IXcfIqf99Oh06VMWQ3gWQVnvtg8Epj5mns8poMRxgjTeh6JDdhcYzz6tmzGZFtQQ/e4rLSM4UcsSwhTVuEw5QJFjPBkcV21yufem4gHShsVwUclqWZGbFu9VS6EqtRMMcKPZAbW6XJvmzHGwu+SKES6zhyv/EvUtzot9u4j6iCu5no3BrwTfYIrXqTDWf96DJHQbzw+9WRfQDSXrI3Lls4wNNfjA05pc3n0doPmV3BhaOWdZx2dY4n0UeIwfZgLf+mVlxGTsw49fY2MQ2zkzclZxOP3yt0UdXMU7tL6m4kIwgH6EowAoJsb+D+3q7MCcjIhFcOLWRP2Fj+bHpkI8WfhffhNs8TJT1/SFju2ZGQwX4IDr9/765CElY3dSj3akdG8RUE9/RSwnmHh8Wk6O8Y5j/m1nes9/V5k4N9Rcukz7ac61NZSsrqT8kvwg78KGNKsTUvg7bzVMyJxzwm5m+D+o1FmhAxWzitHhpZ8QRa1geD/bsoYSS9QqKgIOzQMXrSzY8jEcEjBuSlvPTrP0rCy1kHnn5UsgOhDovg9kckclvr3jOYfOVccfMDNFgTnjQn8Dd8/dYkSljFxUNoJSwAV3M+/xJaUDCcKMek7O5usnmQDzMl1p5GYjsaRtJQnn+tXTrFWwKRn2nVhO+7fAMlgWQZmjIxMmdJxTTUZe7ri8+2H9AIzCirQwK+uluPiG4ipE5up9x1ajPeN8w0AHTxrLaF8OjYFcGIkZeT70kycUNJWQ94c1M9dST2hO9DVvMzDnD0AD8BdsnsTqMt9Rh/LBgkbRWAQhxIYvQ/3m0kD6icbhaKDi1ax907ieRE5kQFJrwEL5BfHxfTQEQwiAmt6lnCWeuQmTYgdRWTZGADNARuri73U+Jja56S+TtlFnkCGqc723kOeECjdd+2MICZVS1pAXYnFVKyczUsGla1OAs3pURBA0DN3fJePii3KCkXchPrBItC3aLQcaqPdzb/emPpCd5tTswXU3JBkgB8eJux6WO8SDt51Oo+GTAozKw1yCqT2ayuvteoizm32ZTCZ6o5j/iJ94W4l9Q3S5lLG+DZHhhKV6AHASFgxYiincOlPSI6nkMQjBKu/DBEe2ZLByLbB0LLcZ4zHsq/YpyoNn68IVJsukM+c8f8EJ9d1ZG2DB0BhK+/c3sFP6OfyD04sXx1bp+Vn4zfWOJxnDp3qu6f4x6Lz+XtIfTXdIc23cWftGwFd/YX/N1r25dh0ed84cCB2wDk1938yf6cXUmXCl4XXkUYezzqJraXGzbPpyvcz5GS32izmDf9l81kQQ1skZEX72NlQxTtL8izdnbnfRhg8g0q7/TAgym3q3rU2n8B6QcBMisGFGd5WT1nrsYThkSoh/8QzLLqSJQfq7IY+jvQFrvjft7ZHKQEnS68icCmJ8CzeaHkmHj38cecl5H8qCOCmbndgM9erG2rNuMWvUhZ/RINR/3I5BHK/hI7q1NbD2OAjdm3j5Q9/pdEpjhLVFldv9ogajD9g7V5Xb78fUUUYficHkKumcLMpY6kPrzF1b18ZwHPdp4Ilxib3LjPJ+FozWPni/sqpfLyNtFOFGkNCqHgkAnCYtg0AWzZb6YlA2QbLM2jhUdH7L/EXufrbrfIpLPb1nUrAkoy2lfN4EewGyWX+Ry2zx/NKdWYZ1daQkdy62qrdVjQJHKogfSe+9G6hd1WLelUKWt9UXWUJueqnYWtvBoDRQzymnLu9QuDDhXu95l0X7aRwFDSv0vQpAY3w8mVusIpKbMufHMXXGFKW9rGADQgdd1Ni+SZMGcynETkbSLMTD3aBiJNDCgQSgWBN5m2XIj3S4muGlI1958SLF8G1oCrUVYlSetZqDpItPAO6KD07olgI5yiQjfli6/b3si0SId7KG/7qy09Ox/r65iCn7GwlHDm7PVKvjyFmgKNMecS/pJvX6dTu1TFKee8/LiYnd6FdbFM7Qd/avx9PQeuwwKbr+QL62sOhVjHiRm2l1TTAcfLEeSUYbvGT4JY17+Z9rualbLWL+C0VP2gevFRbhkkD4txEyvtpQpr83pgBLn3rxNt62Rh5hVgIr18ieUmIsn/1ydcLAoSonPALsa4a2SU+wvSismURJc3v9WpICP6n8oAI/9UQHzP2jJDca/Zi/OH/TH09hYXSzQ0ug7dIUCEJ1IK3gABzBt0gh4EjcTtB1B6qBoeeyTzJ20LXVDIE9tSCPiuRtADQWjTLKDiA4z6UPiQFZNRh/NwiRsD4An7t25r+o0BdEA0PUHo/lVw7Ke8Fh6ffO5GhJlhQWbaSKKR4SB7sOvqEhB9DKe9JSzvyeBk5QGJzOHQCrFLXVYhR1RovvLndS8xcPrckT3CjAsmkKTwz09SQueonmP/yXZQJv7umfFrI2QJHgfYEFEFYy5z+mJXbGimCWOLy7NfcbgdhpT8lIuSnw5Kgq3TFcagCqp8RbOTW6R+I0qzcnWN0rErtRFxBYawbGWr6OebSo63W/789tqiYnA1p3x8MZ3Dm3/zwgPPo1PdBpOY3BqTe/D0xNLqeBV7fE8L7xSDYP0vqlPfzyjZ2i5AQ8ITjT922a1qhBlsNmJ3Lz2omy62qYOf2BhlXfUrjOb5GRlg/+RH/Atozkr4DS4S0sab6KtdyADcQkaokS0TDpTvEmV9TzNFkozNvOZyWH7d6+1sJjEqDal/ttasBMqW/1EvHucID1/j4yjwl9PTtOulTmzrJ/jcrbAK0iEi2d0xQtTKJzOwQyMF3eMorMpttmS7dntnjXTq61GHAqkKp6X7kQaPWgbdkOSUNV0Fyf4CAjOk92bPxSJuj5tPaxMJTH689D4XoB4I2XFJGlJ9dvRjeQRwaZNGV23HvlG/rmLGzLTfv/7EKHGg2vPzEqYYaNgrbTurRk5zlPqTIDnsxx3SpRLAxb7EV8y5N6qotJAIm+U+e3xVYuiQVPNSXXs8CU6jhVs6alXkGhR/nJdpY3r5GVO7qXviPEFk716zedQBk7O0RUlbrKGaSY/OIOIWCQmRqfACtppBh0THgAUOQCKIdC3FWCgX9gvKQSaoGSMEjBJLOqrpGO/NeXF708WLcGYPPwItlWy4dEl8Z2fktI8BbeeczxoK2YcKnhhBlNVxcGelskSMuR6rISRSnCbBMTsA4vrWfh4+gs1u+UZWjuO+Os5tT30OtW1Ir3ooTFPG/COyc3kUtQxcRTouXssPdLBqGpwB48+HgsdLxCQbDugy3StcjkmF2iq0b/15eTDwcmBd+VlDl1pZcDaiQEAVErlp6K6v6u5EEjCicj88oOwV3pmo5hiGdguySy9A4SsyLTgy9UBoMC3rnGbvczPjus3Q+xwW+vU/i2qWVoASC/+Oh/ZgRRVDAG3jr9q4PC/+sBQUaVWjXipxrqVRJDFtj4CCSwdjdGABb9HHJOrnYvEvUFw1mi4tMt+1OKqdohf6Y8LT602Sg2rAUjiIO7nAgrmsEC1CwHy8vZ7XHpThyrKiMSPBSQ/R2yUBbSVYhuOMaH4acMXE9Hg0JLdih165jJIbSC1d3Q+zQcPF4TSnNcId5J2XA9UJSLYGmgLPU05PGekb/atPizF5Iu65gjvPtY+AGezncIIx00bH+j9cC3tdAVb97sA5rK5KtkjDi/sebrQql3OvnPZH1ESDBwEW07fzS2vG689DZoDhhfH0+tuFGDZjp0KNekfQkWCnC/1le7gBLBNE4T5zRXY+mr//zQf2i1EUMjB4koIlmKlPruFcmgCuqOTI13POLrJan+YzKTrOZE4dlCYQ1uM4tURx5/GIyxQISCd0ptx7YaZWDOgRAdF4o5apDcRBx2nB5JcubEZEjgy1VcvtMDVvpCsRPorhiVp+nsKG0O+O2BNR8JfxZmIaKq7mZ7jchntYSzzNwWQB4ejR5MF2spenf+4P/96TtHH9zU9jw7LMFeWXJqN8cY8Lzon7auZNW0E4ZydzTI6u6Uc7Raz1bihDPHlkz1YvSpCDvQq7IW7bJBqtSfBc8XtApVscZS/QiDw3tCqv7UNfkz0BfwH51LSTaHVhhth6HNDmiEHiKZ6dKSzScdHznpz/V/UIY/O4SRzXh+vZbvdhtZvGS0QnLEIAfI4lHhvXSDAGIP1/y9hMfpL1MHbnILAQmEmRsGpV7tUFm3PpvSBeTP719IzzgV+kG2E6VBSW362CMPo4jnAAqVaYCOu5k4WBkWhSQU9iCetB1pBYDrD/DLY5XUnyl8zjqZobVFLb14k0ujyze52JBLOOCUzE4znHpbCYefcakwwpu6K3HMDvKatt1uzEpBEkIhRBqy/73NRrFi9Tl+Py9hrF7EVaphPcf6QNDkEICcvdF67fRDEzTL9qzoVPlY32zKNepBFXIFivXTq/DMXdaNmfZtRONbk+lhvSq+mkw7uzGAM3MlktZSZVhvlvB95o9G6w0NrOvZeurA7mM/t6nqFDlsKMK1C4t+Jr8RjgW18DeVYq1yEJDqEQgxVQkdTI/mSJdIxknHE/t28NrJ/wGZABmWWApRn/95r986i4evXud4eDmlJYKdCNgIEn2XeZHUZaJeH5Jo/CDttJavz7xt85dPP1/4+dZ/yk0Om9rmn6NiK2cDCYQ1owQL4stBF5g7fpTwo2yTFfI6nBpiui1qbXKxNg+TDOLnJOYtDtdqP4kqHX+mlVA06d6iiJXTsPocB5FCeClzlmdbmW2Dp0YQ+gs/5FAtEXf3Wf6aoN1Tzo/RhKpys+UgNHQoQu/hZ7rPpB+gy4Xv96coEr+zbIis6P1zvOmKxd8gxei0C1VpYJYpUWiVYPGQe8W6AoOd5MwM/iKnoPNwzqZzN82R/6NZIO+cXl9FYPvdvwHWciWPnfnGd+gEzDZ+nEv27mCrSa+x3T5j5Mhm3SDHoG8636PuCxqY0ZzrwM09TiMfJLqRljzNnOgxdgqfCYwqRVG60aIh5aa5w81kmYf2Fz9FXm6f+ux7SEu/PdFY6v5NyttiUMQaXMIwSQO92wYR5vw/WrxE9OgijslSLRXZjEKVr8R3eSXdQcatRiB4OmYkzyeONeYm3MJRyKjKHjGX/vTEIwfjehBRu3GzCBDU62+BipVMlQPtr66vv4/b1lAK0qGSkaRPhmG2gTPbw5H3qkcSwRuzEtRYGEZeWbNSNVaJLeooGMe9/igLdZ7/HA/iNJGK4Oqqdxzsbec7UPnElPNEtOUJXAW3YqoXzNRfmTchVBAko7tOZnjft/LFQAaPUUKrm3locPWnpOJemSCLqDyy+wPGB+hbK32YFLKCn5hNAADs/pjZCbjzreALC86/OSDmL0RZOTKMRlu3Ea6r6LL1M+OfUdzAoaFtWNcWAlUSHD5Apo9M+nJrlT7snwnM0avHJbCj2URHozBjsNukZQtGrgC9Q8hzosBooLxskDDqzpPZLrZ6RR12wkp59PhD2HrV+7ZXKXoOHd3rQRJ0OptUdaBIoQGfyOP5KYTXGISmr3TYnkXDP9EDJ6daT3S84y7rElWug16pwqpV7EKU46J+w/kVQ97j5kHGwBFMiefE1Wi67Z6axl0GxLNz+SztlqRc1sqYSTKuQ3Ti7vv4B+EzLEMp9r1WdRGGKIlBTFIAnbJCKfaO6URVUFyvCDLDujaNerapnT/R4fQ3B0chEysLbOPEFl4Jj8moIl9qJyS2WJsmLWZ7TpKlhhyxsN6aSnbhMSK4v/pA899cU036TgVz2lmvcFx4KI/KLcsAlc1wItW/q0JN2u0XcXZsi6abPRijoBtAkChu4KwEz7OKX0pfmegC+kKNLTXD4HbbCq6+zL3NRt00CJrsxxLkVpFlkXV/AJKQvtlfzXvk6ir1QM2IxL/Wdb65F1fh1rCwXdd7SjNNEwtK8oIF/YU4e4WsMRrwfTs1OLbROBUTa5xGQTEJ99y2/pTpNFrdo4n2Ub2mr9ujLClJTlXMKt70U6TCrrTV/jLIXZpbDUM12jReNwFihacEDi2qrOZTtM6bIQWRayhSlqxSz00kNeCQqGP1546ZYoZnpgdjXfYy8jQ/FCsKbktwTrfPiKVQkKdFDWmzrgHs0TKqUZbp/RHFIHz6szbDTJx3od2DD5Qg3tGholE3hbTjss8atQ0sC1FKITzHe6hIEy/mdaDXJmBsPueR43rXw6nM6KLrcVwR9qqMyn4JtsrXrej3v57I/rroitadMC3B7tJZPyxWkH9C98Cn+aQNC/Y0AOlXaUk+aH80lbnXe+T3E4MT+hwybAi/47uV+jxySNsgSA/Y7K1cmaOBDJZVgtbli9N5nFp6pvBWm4tZE+Zfr50+cR7kqkCn8p6RIN3+Pk8uKavkLe7Skk+GtHw44g8MLPcV+q+VU+LmEHsKvPR+FwVSGUNalbXW3jNQfQMM3oW5t3yo1ysbdXN2iVY2a42mMs0bIGRowlxGu2Izg0ptsJBPcPXHrlFedfPK6qjihkeM3JHD3x95kLpLgHyPOKc5UVvwv8wLR4FRIqS5LEPR+t+O0F/v4k/8xh+V1yYUliTJPGZ1oARoohPt7HweaLkoP+I2uZWrrJ0r4io238d+LtS4e6efQuAK1oT5U3ZXJoCliI2wMnKB5WXeWarADTgzZn7P43oQsemD0aqDWmUWjJnHkF7p+/Iwjiwoc9y1vG6qPgEYmq4etIGPYAqLn8TINxpwUP8CNkXYDOAwXorR6o2zgURs/uy87gxVEHYAizlH9JNpOzPJazfBXiPkTAjVvWoz5W2aKNpu7y1s2z6GgLYTNiD/yaCynk5Gii2W3orGc3Hru9KBEBpCAgcYf691dPz/3GIxyEjahZC+MR4bE3LsyMJ20mXmJme/w1v1UBZXSNFFoZQK3aDwmAzg68ehkcc0cj6Ioa2THP7zffpd5he3F+/lso9uO3xIA3y+QPvuksV8JdpWbQ1xiPS/mGGTF7qB6l4vuZzBO2eLFyBFMUWR7UWCWyKEQoXZ3r71Wpxau/nizDAOiI3WVaDq+Hl90P65aK/cJbui9Z+TDwiW98fwaQCRA0dzuwQ6gwxzwPhswcUrV7PpOwB3+/2wHxdW5P91IW4rP579Gw8xFHR5m2Ybp9VYEuYpruGxtR3eT2PtnMeIycE531tn8ZhtLjNT5MbKxpFkKUyCFnGKD50y+QMCRUTsuZTDasD36XzILfT6svel04Gx6x7O1XprPtWUZLjtFgDFNdwgttWbqXDxeBBOie+/QnQ/IGwWN8m9OsqawJveTj2CowWB9sgPAwPUQMGfQmTMydmhoS5DkhutuixitgOpJl+ABsD0VCeN35tpo9OsGvfGfZxFbk5TnaCJhK/T7vSabvYcM5RB3XfgPDW61oYv652V2rc6uNwPUPR7ykmZCIFwKP1WIsHs3WSRm7xMgj32fbAUYXnyj14P27Gh2bf2JUwqPdCOUjs6/N2CJUtpOcdtzEHLOMNF1KDSZ4pDmZ+jn4JSPS8hnnkKT2KcesyXg3s+J6ECwQb958jASpjfFLl/MfkoxlQQOjn6+h1gS1JTsjD2ftgIrNVlFzPVKF/G7K3zcDRnT1sKW1OEBEw8FfPcYVXsYkgv7uG3SCqBKh1l/pCGymqKT6WFd4MAfRONMm74Um51o33g1KhIOP3B0wBhYZgfEqWRoVhS/OQQvqKqZW0LRT6pl2R7ofhdTbClbeaiaGDI9vLCr8bMIaU+kw+aZ2IBFlaI2cxmTELYoV2LMP/xoWEO7dlxwVuZNHeqV91YzWCimyjnjjdHvErISJVKUfQS8Utd8etf2GzA71RMwUjxnFjvQx+eG4Zf+p0taCFpaAkioe1ew27KWUGOf9xGkP/WyrOH/YDDk/HCx3FFZUcn0GNegv7NeESdeiZR+EiX048Jl8JbLaFCixLwRinogOiHuljfJI4N+RdxEuoi1jmLhyn08K0vyC1zeORMywi42uPR60oAXr3b6ogYSP2lG+motpG48gbLrirq4QJT+EN5Kms/uuHi8EW9E8LZvqB7a1oblrJ10MmToVpdImh4LIgkLKK9gjzlwEfy/vUeoSHuAHurE2mhKQQnEBTUhjpjXu79vi9tcc/lby13xJb/YmmbpbtR9JOwtafKq4rjbSb1WZ/0gcr/oTId7n7IjZ6gkKFll2lgBAtzbBSmu5h1qfjCWYh1ZPydZwQVA4ATKqcJZTz8dvuIElkHY5DJjOSnkLZoGqCmDWPal1d5Dbd5ONKi5LA5VIpIIFDS8CjjxbV6A7aRiC1gs/no7favvNEyLEuApxlaysQ3TcWjnGvTuuA57bpKouRghaabiOkziEscwub6ypOvFTOB834JWxbp252vpVd2xU9ilfYx7FiY7S7fPx8ISsSImiLkwGdNlVqFYGkf7JDNI5KScAR2CUInlrc+vxVPz4wFDKCdsvOT7/D5dEp0VYGLr0TSkgB6/vB0+50fJfFPw8neK/OajG/fC4K4xP/LvvV2zthhmvqHXKJVPR48xiXsP/ElPJc/+QZwJveAyRK2Q6PVMHcZiykbBdVjXZ1wtGb5BmE/fi+pkua6yl7G2Fpi8p8QmVTLfejctuV8UJlLGXf9O6sfJmqZtzdRA1E5Ef1lb3okMMiDEchPGlOuJZ+Epsip9ApZQc3b6vHn+Du5Tr3lJtoT9oY2w/SICp6a4oMfKOyPx177FTjX9aVyhF98wNTEWBUV9i9CLxWHn9CKZ4fUDecM6zGAkF1p3JoP30NrO5SvOh1plNlGbK6cgGGD75VVtsLa4huR6cEQocoZT4YBYBZxdU8508oaLXNjWVw+hFIvHu3I7DPbQDPX3k2WhkagQHviioqNbeIdflh74n2e5LlWUaATzej/pLJ7bhdj5Ur0m/7qhLVeWcM+2M5ZRcZT1CIz/g2nRhxIG07tBgvJz8/8DXx2WW2G3vWqyB3WZ+MRgeOq7gB8S01ChwwkaJYntWoHEpFsjoB6LN1S2oftQSgJoeEQF+7k1RYSRug6tF5lwDjgcbGRvoKyGcm6HzwiLYrEtRHbx05e42TmYUtwlJYEMTfLQJeGcBPpL4zDsVU5vdaYOkVBvWjOo7VrNQawAXGBR8T05hWUi0FoyTB3vIxRQrCSJBspj+1xuNjFbTPHwc3ol49g7rG4FuxuRVPYiGorehYq1ffFNdkvR2phtLtUyUjgaRykZaGcd1BoQURDDGVPp00NFYayVLqCxYVjV2TavPX85OCrnZVhGQ3PDGstBN5lIA32yU2H3LZnnSLRncVDGkk7mytnZ29QUvaf3vTP9QHZtQrlPPkaAagyhsEdv8cNw3MA9ZKDlcQAza0LynW5MyG4EZrW4IlFmtsvAwtw9WYWBKBPLKFa7O6PeEgARob6AwWBUumETuul5IDrLf1flG/jnpFiLQ9ub6Sy9ZgLyO4+nuOyICKOaZDxDFnE3O/J4DNaE22rixkpvc5+SBsVncTjbt8Z0jxG/lM/cED+oPvbec9Q5s1Gn5xyPOMo413+zzUk3A3X2QNF1d0d5EVFSfbBRoR8K50vW7KYlOzErtZOqIFc3WAMdknLlg7TYbTyjyiZa6JBXFr1tCmnjK+UZfvI1H482mIxfDRaM3+ZIdtCD9xapKDQrbYP0yQv9xxwlbpcmyoV9G8QuEAOpgE43gnYenUW1+ct+jTSBM980+mjpP9NSmT5RemGBxxoLfni9drPA70dn+l/D0c1aFLADUhi0HyBB9ypTwX6VlKiJMT36gJ9ibD8SeuMdBO0gQsSPZ2G2AkD+LMdq+gVfJFj2y98vNeFij4M2cVJMWP9tJCsvikhyQ8tcW5fL+UUhCCd4RCtkjD9PCogSMwKNpcCUIj20w7eAGwHX5lNHVMCJlpsSRYy+D04CMuan+0Qm9os4xuNK9u1ihXkMmktO0hS3I19/kU3TBckzP5URCclQX3Tcu2uN4ePxx6GOct6QnbHMzHjsexgxTerVEsoGQm7sMNOs+S1Ty0CoFbCd/OVvuvU3r8Ur17IGg/xauhqonNf7cADkNHjwGfCK573/VpX5yF7a4XDuLAgzLHYksY6iwrfx9VRIdolkA6W1/rZoMJoAOTR9jcDfA5YfzaoEnGlvSOpptnnFLEGQxF/8WIP/MlRo01rXSsAZzYJkT7r3sB7FFjOMefAYfYbKOk88AWEAnCcaA7GaIz5dBWcGtXHxnND9lUWgoM5WlB1Gg0GyfrgYRIH6bc5Oq/18iW7sHZfKomCx//yvM9QcPyjBsvbF7u2ACLLySJ3DnEA/xGRdqu0/h5ppSyRFfTNz//slmm8MCAWz95P2nTos9NTLdo2q7KOW4Bm9bs8H7G5TuTU4Q2LoyYTQZJIj+zI+MIUQhNTXSv211IeTUyXOnkFeYG4udj2yxCyy+THIkOcu5E+I/UCqd0WTLvJcHS6xs9DQC9QOV1/E6Su+v2i7SAxugIOIbsK6zWclYX75BqBkpkMEI5450xDE46KGKlVnOPZOQrryduUmvxitzuaxEKklFd44/1LOpICwfJAXGKH1noXcq18/Dxilxc/gZUBIn7p09RvT3E5kJIFbrMwjy4iH6EWmw4tyaxtJ8DZo4/SbzaEuyyYJ6VeS9zdo3C7DhtkPrZz0vIyvrEDOmPsGMHgZnxuLpyNQlzHFa0uywNfg49+OSZb/jAjjeCMrYQN3IN0+SgYWRk0BduR0moM15syhibQIDP15UUOVTRYiGCJWL5Y271zzAPhQTlSeZ3rCuC2m8mhyHi3PUiy9nd1rovfNqWH/hTMYDW9vA0SvsB6eAgCexT7s3GQ7U+yOTx/joJ+olCsi2MqgPZxfXfjvJ1VUo6/Q+sNc73p2peCiLoaQdHePP5P5I9OxBsTao2Qh+XHKaW0YhG3iXKcdUJhBnmfr/vXaGo6vtCPzOTzjjMd8QICRXiPtDTxaG2VVT+qFEsII/YKDqVxCndBd2eVCjWMmVtifzfhzY0XL61QdWO1Uq2FNx7Cley5gd8fJJzMFmI6eaPxzcAeaU7UbUUpwECJ/8KdbnSKlVab1uuZhKFbvc9bwAioSHqo9nBII+aLq/MDOnpxM6nC3e8TViY4SBonpRwBegyesyFyARzZbJchOK+L4bfBRcTgByTMTzvtesmSckM5hTpiePl3RAQmYs50VpHNVJWkeXvWTkaYkFH+4qn/XwxLGpHkPW49PPfYd6Pi45aLJwdm6Y4B4wsJ9ikJyjUXTJbaRjY3fqq6sjqwjzZVjSke/2yrxhesen9GGNzCqNWHCJ1lF7D3EOfbYHjEpGCgrALBUD+AZazWorDWDcIIFpJlcm+DHGftEFf/KIGOnqXC0Cq9JE+Xsy/oveB2EsG9sDHLLuTVIVcBWz5dzIu8ifVFw6jyzjYUvjF/rx4CotGGP4f7URBa/AC8ywuIiMM+PdvazRytWqMlYIhGF1zDHxU7vPyOQitOfoGsm8GhzVTEF2qG6a6xmoqEPdjQs2sHf85X6DHxT6qbVd8G+3tADLwWCg23eCebMqoDHQKsJRPVmvEN+zn6AxYQqVOwzwsdfiF2XUbrwz/KLPR9O1mDMjCF/9JaF6M4ogjYISinmDFuh5XtWlRHS/Neiy2n/Tr8V4iRlo/gFLdDZ1JiRC16tUYItTWFI94Jbqj/JyutLP4CvAdRRz7FvAXw5RlOcd2fJHn1ePuA9/dpeKDXuS0KE75vJAY+eogSMEBlFIZIsZaIxkwhl2YYDshcWWtpyAYWBtsd5Zqf7ikuFPRekhDefJUF50WhALso3r4W7vyHahWB83Co+M8Owx3CK4NntStvZ6njOn8UC1c1AZ392vsxplSz1Q0/QTZ7rMUFC/V3t4lytWCx4BMajbWdfEaD2CyRed8PtBiMhQq3r8apSrasdnNPl7RC7zQ43KFhvzQLR4yPJQgcQSxdvxbCtv6nLfSdvfZtD4j3S8sBM2BejkdO4mWZsregOmNGdLYkb4sQ1QK5JBwp4qGQw12SeSFbehLaJeFP7LDoWvgcKiNqSnO+l46AqO8hKaeyoGb8V6aMe98OuLAWaQEu2cywKYm4Xh6H50w4g0+nmNQ72ngEVJAW4ZeJTw696lQMhN6e3fJCBhST6KMZPRnv97+jbOrvKt1v3FwYwzC+RzDpouOvPnFSLeOyHfZgFhsKl0pL4rDYSXHZpcDOyHfyBwEBPxxVdWGa5+4LvMwg85KmafLGlu0lSaHS6i/a9J8q7djaCOhVVfE5fOB3waTJBgSXMbX47D/iea6oV7PIe4H88si8W8gNR5dKeZMNWAaxktO7sowhsWpmXcdb72cAq58t+rILYvQmLh3tk5+iOMDXUSuY7KqAmZUCzwVKrE0liStzVTDA/bjITw+2pLHAVoHlsVZLdAiSc8HvuHAS0shPAap+RfexRps9/90vT0xRaclzTn2D7l//RhQ3rCRJfz2PNax9F0sIAn4+DUthRwRyHXH71SvTPRolph5xfoPA0dfbET1a9mN7TlvrKmq7+ZGQwpd7N3n9Rx9tH2aIDPevTWo6U6pQTs6HSPGtDZSSBM+305/1C7vbOSjyJnAJ3l6Fy51Q6LWF/jP74RX/zlleK7OvHoVrKZPMK1hJIxfavh6k+mz36gj26G63NcjIywiXxwOBfv44tQVn4SdmtqCppQk90e4RPvWBhr9ANVeedlN/wU5dx23G1u+gQtlkkpBJp14r7tzEeU57cLDmshLyK+Iwuzd04n1UKyScqN4mKXK+jnUYD0ulZnQTioy+GqJ1V2WGpv1XKBiqe0cBFZ0/We8g/DV7Dl4e6fRmB1NIIDk9XOH5jccWXf7CObroe6tW1Hu0baQ1aYNiloE1vE4fHjpZq8C74f6Rj9+U8u/o62prS6AsP2qQ1+u1r+KR2//hu6xAa9CI62If2+9Art7KcNeXypEUfn1PW5dRzxB2fT5npPhkmnJC8W5QbP023CiV84B+JKnYRliDo99jYgf105dCRLF7qhWy3RNLJlG+vvJOVM9X99q3MwhXV4Pm2PnYjM9B5lrsnf8XNzC3aN/IgOO7+OKk6IUQfY2jyF6oIkImWwXAQJ/QG1wySJw9Z0gaCnTL3iPTK66tAJXDMV6T2oexwQNYHkcwjpH1vK8A1/sNffoYfcEwjHV2H0cIK7FR91Vw9L9kDXfkDA8IFedXXWcbcZQ81ilqy8007u60eNgj/Gy7hXccEHWPwYZIbAg+a1/am0iwetHGdufwvWfLcprCMcsByJGlONNsXjRgWNTTkV/Sk3KpX7T6PkTI0e8GQCgBp8VErsG5A9P/SMRoT8ja2K7fFtooC/abZ9jePMwUNoc5HdR/xWEsa6n9DCCv/AlfOTFHeRcUHJ5CKhS5fnIQ/tabYKE43F+m1xJZKCCE3kCRwVyD0aemWrCAdcxnrUOVnnFydFjNyH0QfhRWZxJbl7EqvG+jhY2spUsV18Peom9Cly4v9bmKwszaXKtblFLb8ZoLaS9V++zYD3EknPj7ZvDiVIx4xgnXv+b2WRYwQhA+w7+tEJoJQUJeWBB/wjBzTLStvgFtq3c5mvM7pbYsTuXbdijOqKi/U7ZR/bDxadQLPhV+VdaatCg2VLCAxbh9e9aAWSLPGB7dXn5hq+g4tV8/RGdJT2OH4HGLG27gfIlu90jhr5AbB6UyBPT6QZUwkEswNLMiJVf62lt9mRzrPja5LEJifd1Z9FDGLq7+O0quh5CAvp/K63Aq35QHugHif3dRS1SxgSJNEj1p41kbXFg1WnN+Q1Nq9A320+8g/Q/UtVLoKwGLWa//bI04RYrbjKufAJ9RBtpTB2vFqpPcsjb1g8lg453xeuju33DRaIVQq/ObJ7HCWhwUBO9kCT1G6WXEnUstDRTOEuKvQBjzLL/bcr0zcbwnZEq5xIE6iY74K82DZRd4ybMysFYLwLs1IWOWYNisovjoSfrtRq3RpuC9o8aVWm5ETSIW4H9fWCOsl4iUb56rTiOzbXRtGm0KLmyrFEERxHL5GPUl+zVo5X9zS/od/7kwzx9CzEpQU/kQVMse9q2ggxooRk9AO8SOz4ORLRRqYD0SGgyxokefFsQ35tO6U1OIN98kjqQMIuPS7ayHmIDAzBAMF+yiScB0jGAFKMKcHO5S7Nnyty1/dsmvkH8B5Ev+O/42KfExK+StEs8xT/hugffrXLChwrV2sFynwYDWM/WvA0gy8iiOUWHf/cx1Kik9l9duYpuF7nPSCqqBPiYWpd1jV45dEz83DFxELVWAZrucvp+rfxyLkahMhSR8JJIaKnn64scA/DcmzZbm3R2afrppNLm2DPWFE3OokSEBFURuURg9T2tPcdljh8254zCQnMA16dc/FrPES4AhCNvkdP0cLRB6a4xXuzL+dyNZAp3DyjmtQCH4fNQboSAaR0TkYS2mvm5M8PuBEhjV+wD5p8s+hjjHhDKaOSClv4D6ev7wVulhr9lHXKLhPi62hh0y4+cBN/bUzy5L7pd76oqwIFYfHNMhH7GS96eRAjayCMyrstuexxN4SiKMqNHVezB29PDigG+BUEamtiNRz5nZ/gbLO4WzY97sBUSDvpwTRyPYALGnrcpArG6qAA22XrsZo70htNXybcihLpQYP9W7DSe78jigDDZPopGLW2fa/ZpktMBcd58HyB2Uf+ZaYTK7EpdLc7ZIE89phtEl+qQLJjPb1x6nSM35G1/pZxbVQdH+B2dKC5JjcIu3aXyTwhW+pRiy0nED4h6ekS3sscJlj8G6tF/0HJNu578kvMQwBgdMTrOj3U1Wh7opNkAT6eW1jtAD0O+rCZGOXFoDXdXcBL94JndGlCFMGj6GtvsxdZmrJJsBQb7M1z/z/NCFYFo4TmNJJVq8PrYE/nnEQXXpOvBgyaNyWvPbVpkGTWZrHRwCyOOsetssoyLhZeiTG2PVLjQAd8TWy+WBk8UNUYSC+uUTuiGNwbth18uzuTJfjtcqpcTI8KoHGaopymT6fh16N06xGuYFhgczq/dhnZFxJqK8VjON46rkL5LFMJfstkSlW6Fktvlz10WjZ7lECDp48FH5rLMzy3Kwnv6EfpgMiFKKnKnPkU5cb2KimG3OLhscpsdxspxvLxmMFVMqSOSlHyYWXz6Z6h1dDZsLZMW4JG+byu7WHo9aSF1eKLje+yz+Rii1gQFlYULSDShcDNTj6r1lxOB7AjER3OzJR9Dk5Pvsb5q8I6vFrleiYfaJKyBZJGi3WIDavvMhQY9UVQ37girXWwI49VcoDCoG/6HKaFz4dSPEzOKK/HF5wE014GMwFlBST6Czaq5S54okg+u7ibS4PKZrWDq+n26m30J1YKOCRXyGun2gMR9VWNahjCWkCZYlIuZe5ClboD67i9j25OcWRLt7AMlooQ8bv+z4iV/Uvv4zmvodWbrWLUk35O51L+XEzG/yNKcnh/TX5bNkgniDb4xWabnQOyKZstcCoFFjBw5dNXmWFTVWyyh26IfAswGzPhb+BIOpKxNm5N01PnQT8xjr5DfM5EgAW92gPS8UJGPtHJanFkVKbyE4OqW5ZMYlnEcqaxaYRDA+aW3Bau4uWAf/0Wj7AqXYjkpdl2617CyxIiA4gRiUyCNDRfmrYfmntjqsgTFLVV6mMxdAJ80+BnI3LxhPnlmFb1jG63XdIwRBpvtMz9Jio1M70g5pkbZYK4zj4xpa2JWGkzlaoJvJtjE7ClC0+Eh6NyCoNZH34CeBZ+V4buOjPSI0UNsAjGiPA4konty7wtce8pp58F6BflC/EJJqLbTQOcOWa+/gCC6tQDZPAIveQTSQkq/imlqvXz2V4eOSEReKk2YHX35Z9PyaSHkhcyd9fvUbRCbgLubUQUTDU9u0107dhTlKylwkVJPM/e613oQPPapCvidc1Pyan1SnebFq6U4vm4CN0DhzNtvdWFkjGh062VE1F8po3xt2RXJAIrAbZg4eWhUTvBcKqAPk/Fpt8Bi3YoEYs9YljNIwnFKYtXgXIurEFhQet7jA1UNI0Z7jBgTL9peEHXzRwfiQ6UgTy2TldSxDBpz0LikY5UL+r5oqpHcQ1kYaI7aWrfrkXSL8M4WDL3J0hIK9wVbG64nM+rbIJmYYKmHA1WrvbjGp53uIiMfAMVjFpJqXKm8iKtJP8sUY23tnsTRzHjHqegK+Lj/OKGCIyyRIUMEIT++/pHTsZVttpNJlxAVvsbLch7WgrTLNgM4QuuidUi+MabqF9gaQ5FbN0CmGXIMPgJPGHgZu7vstIwnUlFRqc6Ap2TP3mWEAPSCOhNarwOmOUZY4FWLdDVUeUz32L5+/5lrpVfBsx2mnBGxgdchfuEVs63eRdfXQ9vhW3s9ePg1f2uIe2njlVJIOgNIUmszMjQEQU8zYDxSJ8lvYaFoTnbZoMn6I+F/TJVEoZytxrBtyaKQ73k9f/RZyWiugS+2DexbegD1inwIBpPSw5WiY8CTbU+U+LE3Nk7rK/EHRRqvSfX6Qs9Ly/3mEwHH8YbNS4/HG22eki3aScB+zlNRLLk/5w2FN7YXhQagAJzNns/t7SHG/hmiFUxX/LrqXZARf8VtA3+JlemLJJNTYN/TyN3+qVa2YzZA+CKH65jxpLK5EILWpACRiZbN3gh5iwzMgynzt1KwA+APxkiswf3xlpoNrYGfNAXwPw51eELE7EKNaBJimVMAqOlnyN65lbv94415qKr3B1f4F9oR8tgNH8OlwCC1IdG65FgGW0e9mFNnN8mVmQSTljRWztkFdQLG5pyQWZhRXmWme+2F5YI9U95v/4ydOKjqX21kxZ8mGCLf7GCm4fZ54uwSK6eA211aTA4whnH8AvsgenvpMjL2LPLEdtZMxx8cdrUXnFyIEZueuv/VZHE2oE0v994NeWPeSaBb9gTq/s3BPJ1RZQvq78eCk72Wwmk2BIaRRhoN/yiKc3wsKjNueOSmRhwWaflfiut2wuX6g3tYu9/DvsTbOdkDr5gtB8MoaAY+w7JgqNLOMb/ygHwHHtWCDLF1cP+UeGvtdhUOeLctvdZDdJxAUgULONe9nwiPxJJUe7MKadmWcRkMgrU4iJ3ZwfBevkP5ZpU2v8Agy1Qs4YelfboaYOMJNjp3Be+EtUR0i8MwCpvpWVEGTvDplCZjrIt/bgpsj++8PT8CnXLxRAdaVN2FLGGGdNOlymMNk/BIgKIgI5THmOGHEg4pvnwbTuK8MD+TR4TAEG2NqqHRTRkw6Hu/1WVHbHDRkvINtHLNKbQgBq75CZ8JJZKTVuYZgDaJS7Yp9NRvvKxbDiUfuoeUH0YkzoCC1Ye3Uq/RK0hZB6ZtyskUC3QGVnor9n0raS6GVCO7bJOMyJ+RRJ7sh9qCFlAvYTgmbGMbX3U4QRoEF48E9CCh6uztVwINGwxvNW8RR1/GpqvIemwVUTeSB78D9PUzuLdZ/ekz0zAfwjEjQfJm6MKRhcy2BVMY5e0jSxw5/zHwAUfo/TrLZFlaYh43O8See3XZ18C2g13JsmdvcR2b4yie7Wxf4yQgasnkc/+ftW33mhoWZetJ8ds3IdUxTBWxpPz5TIEZm0Uc6LOE1cvr5ePu3bKdqckW4eEKkTe3WP+mHnr36K1Z8B04E34JOYOZlT2xtDLi66LSGHMB2uqTdcNSaDBtY0DmQY1O5JyH2mkmavVLLhbuCxRihT9nqN+l3MqkgkbsoodLuxzR+rBB6jH2aqVUDirE8ss2A7sQrQpnkGwXs7Y3bglll0y1c2xTjhai/Ru8Gl927I9cnYxyUm/3MNp2u2oTUOFrA/F4TiTZzqlQ75pxM4QSQz5l/2lHgcx3Oalow7TlNtLMzt0GLe6CqH5FBYSfsP4Ytz+p0qtwHw/4Tv7IyEUa1WCqGGX6KsbrlD1P/ItJluW8X4K7SZxbWMy4YpED0urKJhow6YaqJTjjdKDgtKgvYtlEuUPKg88S6PsjkjA8764al7g1G6X6QjroF2s+XOSTKdeOsbPibuzp53zoy7uAT3A8yjfvlEZ1nBSOjJIzYPSsLwRo0RHIwl3Cx3FbTiV4Stu03z8rSncDaSSz+iKKFzH9muaVAbwhhcc+KeME9NyEAOiBmrn3w9TPLShrjRDil0ILMSyqaEkgdpDZn6GbQ3IZDnleHXLZgsIBskBUCsAePfAvBbTsnrm7eYEheO9VYLUMNTMsiqzBBjmlJOV6fACbovGhtPrM82Z0N5zz7cXhtOBzu/qXk2a8YOoi8liZ8iLXff8TNSBmlnjuMWByA3X91dHFhBXS6TkoV3p87hpVvKXz8+L0+m9N00rFD2NT/XXrnN0kP2tWhf4g4uWDNjH+RqU1Ut9l+UZs61P4Nc0swbosTFelpjfZGjburRkPQx+1ibVeeL051R4Xj9nzOqhPDv1KiG971l3v2rCreeEFJeb59igKAtRjkDIFpHbf9auUQ04Gn5t5cZ95cS8TSYsqTVm82E6R4ZoHGMyWOlwrFXKWvAgbTh/A59cLXruhI8FKMujs1paNEgVjfi6c1dZ27uxtsOqkYq7+VsW4moWM6dIGT2wGUWdabHa4FefNuuYEAqDeEsXA/SDjt3fGT55BSHPy7iax5kAwYGHyoO1CjJto3lM1eKCcthsjnYf7Cigxqz9R6OMt+JLuqkdTtw7Yhvh5FRXEtL6aJTQOJJECFCjW5mvTLOx9hrqrVykk/vhJiyBTieZqdl8dX4/2gbUwsbVvPcCwBbvdIfLLVkM0ChmPSDxhn525qJzDLm31TJE6hcrM9U5M09LPpRVsruSJ/4x3BG0i5SETvEy2bwbZtx6P/CP8WnQ9WmjfoMS3dsnoWvCZiuLkwxfrMYPFjlfh+VxXGsGC6jjoEEWOEhN8pkD5GdiD8PNa7skwdG5e5YEmTIc13yaVW4vYZ0gKjh7kM/OVLQ4TOo+LlfPZ5Ou9ojh4ZhdDTLWTohpPqL7ObrZ2sEaJbI7tRfkHuXExBzQ+pb13MMrC6+gOKwIF/ej95Qna8bvXqqExaWPNztr1YX2SWyq6/d3hsK4uRydqObhCtP9oXCzBRBLhMI9t2bewfNRBGyrveYVDGTC7n6f9hzggbIKFASK+nrcYV16sDoPDURMGm9veZE8TixE8aEGIYBkxroTOEObN0qT0OT766AfbeSqafrw4gW/0rxHngTEzUUMIpB0cYRWoaVHmPAkagBdUByUh9qq1FgAnZGbZq4rouHoXkit/G5NSnCR/CM+C8B8fCAA4dRTzratEwnGWeb3VNyE3I7bEHcoq2k9jIji/D+UylqwWSadfQ5ALjsrWo+eS04J1Ko2Mnk94THJkbAyk5fTWg57/NSvhPf11Ekov8rQZ9V73InIf+SlSTRUBrHw7nYYW+P2kLqWWS6wJk40u1Vumx38I+SQGto+2r2W9sPsRYwfzpWcsfRhOgVtJ76TwsJR1tDTq8knyPc9LEEMWoZTf/Jog8VQ6kJB7/uLszmQYsFoQ3U9cZTEkVQqOucuA4EtQiQrOpp5S0NPOStxKZwHUIz6cHwPN56kOB1Cbj1KsCpA9wfauy3uswzqkv9n80IbVJMBW4PkdT9POKwsppZUlALY3mf7YN4R9IhWt5pDsCPHkAaCEdfptIZWabFBlJwUtCsmIS0Cv3FRC3os3Fc5zQ5mv4riwIZMvdJJL44U5uqlodREPodm/i+dd+7CC7oHhS6J0k2xPfjC32NDiG4Nh5ZoNz33kWhoNEBRlGRbnWtQZhFqcgbcz92wLeqak+VTgXrSw4MNZARy2WCJLtzq0HtUgfMIeiEOVrw8a6bI0EEn2eR5+2SPzpnGqKrcy26Oj9MkkJPtRdJy3N+UPin//1G6IBmBHjuYQVQPyGq41S9ihmTVZoMO+HHC3FCWEZTGcdGzwo0r41AptujLkBTXnqyEuBFppC9872IAMsuBJp87TLhKtEtKhoY3X5n529e+6f74vReHCnH8/jqf6zAyVUybNi8dOFyogVl2DB4ntQ5X0jYIG9WievipBSxc1rwbdz8Fl4Pj9UfTGBQZEkWPxG3t/oSGgkB3wnw7PdI77Zg2oVm+PcKPsTvLhHr524qb4SzMEIz4rMQnHiD8gKYmmSnz+ajv6ZYJpuxPP3Dd9rWIdj025ZaWWyNPqSFXMrl2bCsdnYfYQva02QvecMLGsTLG4/SMAnSDWGn+ultj9TMZIN5HvmZe7QCmPV0+Mnyq3nj+9BGmZU0Me6H/QUFYsszj0xdI6g222znRfGjP2uCm8TgwMJceq9f5rDcthAjEPmgu61eYT7KWzIHJ0e8cK+Qoog+wnZhM55rburafYN3jgiDgZYrI59+kbZhl3xhBzUkkxxQixcmla2yFQcxW3NdkZxQyJ004U5Y6MXjaftDA1KL+tt9xOHOnwlCxCh2B2piIci6eiHxG8LrprX48Hex5YPF1zTDkmMiVKZyzgJTBE9lti54t4cE4lIDrUMy+1fDbwEUgjkzTaZJ7PZkPARYsNFq9Q5Rn9wRZyWhStkBaKJe0uZ89Eg/IVjiXuLdvZWD/GH4PJNrGvKKUiLD4bLh0U3Ep9k+lIY1ucFlFETnHhhm5VT6UGSKvxRfeHHmxS2HUSI4DZm2DpzQ9Jx/XwzYlkq0HFfcxG4iebKeZNnaSsnLOhbs7c5xMgrBUEgDy1hE2JHER0K6Qo2/rl7h19krWR8+ZwWPCZ2jp4OvhYvHlm2W+n2PSh2wKH6kDp+r0NwPjX4NMKHO14gDFuvjYBVar8JxRyPHAmHrrsEUqAM2JmJOXe63V8VNyoXzpCMpf78l/6zQHKzRVHLE9FnIhTzKrJETqtDnp2qKzYhUzwg4wbzAvVUe7qT7BCDDPHxPg8ELFIfJX3FAx8+UPFNTl7IHB7yUADZ+tZLDDVv/meW9zeACmSEv7h/GFSOWu5XbKKEy/QsMEw5B3dqtIsSIgfSh3nA3aLFB0MdoEswIErHTISrWe2RUustplZai3Ahpd7jkm3FS1KiIBWKgn5tZ/IyfzfhPLQ2cvrDBPuLwAwAZlrDCTZoVsWcdhVspVHwT/ht0XJ77bPTxrmUZQ6o/DEwrvg33nQIEbSywbbvONwfi6jpxPf5pKTEeE1EZittV4U1iGBUZlSAHQwHM88Qh6Ag14yCkIW8DeJBMtS7Px2VBaBpm/Ncf+Ahf+hpMvJx70VqD5jA/NZtRNSPbyxTlaiiYIqLlsG3yUpaHzmlnZ3uDNBttKVzIAkMEmfUZfkG/JKmlzDxaCaPj4eCjcy/3K6y7tjhkoIYybLdlOpdKQs9ik8X4C+e/Wa7GCzCmpM93f93QwTil0AkOwrVepnuM2xbf/zN1bIeq86ZE0CQPgbaMMEA0XzWot+RXzLrH4G9rEzVvfZDnsyMDtz6g+MdUi/5RuSLjduV5cKoaTuG7telLlElAfK/B9CcbvrSzb9ftqivKcQzQfTFzK+dy2H4aaiDnO5fQljSM6/APivT+qkQ7sJ8vY6brNWmA9EMXb/REqx88F8MG+KCS+JUyvYPe/r/0ZDQTgxhOs436PBqLlkr+TkPeTBLO2v/8eK5WWFdde40USHO7cHFDvOIEqEN5WPmkw0bc6/J3r+XQ6F8h3ADTRhaFBXfpfbvbK4bEfnBfJGD01mJYYTrhfM31IDZzd6SkvZ5IMYPtfyfml9x7MURA4A7MQjI1OdP8jvuwzpvJDDqIpyPy6EBLyMuy4qa67KSu/pq2ocE8vAcpDB9atfA1SldECeQBVhOnbtiDpU8VvnYux5ZQDhugrbbdg68EfARl3l7XCfRaWOYx2WpPLkL/k/GK9JzIwM6pbtQSF/UJ1KYqGa0T7V5Kr5IUBwETW9lpvAc1IksFopYKKQdtyH3ipBCYSoUlRcCJxUGd7wF5i/SNjrokNN3u+XAx0GNqCTebTdN8QREGyrkDChht8QVL56ybdRYariuoeDK8a9HWq62cxVSEEKxFKHWJ4BiuwCwx4aI+vRhx4FbJzluyEDmVKV7hIs1V1WDeHsTnkV4t+3q5DnPtjLy3LVUasNnMMrquvUJgChLtHfmyS81or6FXmdjE0pojHgmEJkrb5U2alIa2zuOyq0teI1H8BiCpno4Xdw6Wnb0Y5UEmz3jNsHMgz5NCJUVXzsYFxsAMBsG11vYsUu2OFmaUijqPANGz4SX/H/UOLpkyZMvdukGTT200jt3tQ6zWL1MgC9JTpBn8yZBNecG2uMpsriwB0A5zqS1NaTyTJmaxND6OS2KTbxK5xepHxyRU8VjJ5h31zCZr2CJv0w0+q5N8Ht4MQEsprGMxJSXtMhdB3AeXpFlWKuWW+0Hu5GcSggd7qx0u/N/E6xwfXn5qWsU52fNm3HoWRKWr/uqx5PcRH7XjcxLZlvcYSNhxLAg36T/Q3bDvDl/Oc7bTIIIgzeQAPIXVSWC34qKLmKK/pmc62VSzpoGKl02OG5pT9l2k8/JvYeIlx6Fq2mrui3Ijd/Tp9wzZqntd2ZspQXCowYe06OWbvRNwUVgYLGEkfcNstr+GBvZFYBS20jMdp5fy+f7kFlfwhMN9Gzxkg4K/9NVa39GtgmfONWgid+z36Q27TbIsoq+pVL939JS8HzqQTtjS1K3HuR4JjmeOjxDENb+4zd24xrtYumQ/pUqTcDCgt5iBOb9WN/q3ioFvAdS9w138zDZ9JW8lEkbk2PYt7/TBUtJHWpPMoN3GjqSnZYI/h2GuiGzc1uOJLdRScdtDZRG/jWjynKT1mX8NFKHdU6fXvsFo7WjFwr9ozGruhV0bT5I3Nq2GQGha2umorcRShE49l7fKbl0SKCleoMA/DzOP6LVa84DmEtHpFWdZ74t70dHesMOxkm1OennbKyNSvKkqNQnAxvQ0atdQGXchwR5tr/8WUzF6Yf27LeXuX73nf0d+AnynHRr5v45MKlEBFQ0Ij9bjyJZrUYOXM58yS2cg/UpbsdcknMHxE+jlLo6mRJuT0J+jjMAVQ/eGC9BEwmOWruO6M15gtyoMKN8ze2Jjo5sgXEsEiCI7EFbuTJljNmCkIhGxgcXqaFG0iYNj46wRkvH54AZfplqAXoFeWs1VJkE0o+FkF9N9XFacFMphl+wMIyYNyfzxhj6Pem8+uqQ5DLfdjM3g5YTxEN/LxDqtFztTJdhzlm2PvHGLIxfssIEMuj0D4iOttVb9f2cxBM2aDhAjw4GUFZtGTumaePaJyVwGPmwUdGk5OYhWkrqfve3FssiiBQ15C4apZwHhPqTXQ+aZP1S1smjMbwiJjGhf4fl5eqFJfnpACUKDp8Tx1MeI5t8ibdHYydNHafaYFyCPT+Fkf/SKy/5I579FozMwD6/zJ9gGotvX9i7tIzJTVawgDLWgv9tIX43SZVhMTx0CESxmBeD+BlkIGpFI6uhg4vZLiz6SNaqxtwaEnkziIocvX+OEj8ht98EP8pyh/kMI2mE+dhabzHVOQWVVJL/5Fitj0xeCiPpGGxvtilG5ClV0thuoasXUC6LQAA6mTUmN3QcWe1/hsBFhjMk9B6Q2NBodsOVtYvC9/zVXSKiQJ+o4j73pmYzE/VEDYTltisvuZsGLlVI6/UR60hKCOshBiq7b79yljemktWLS9Hu7itDQN5kHClZttsGxRSYueKtKvryG2EuKhRV/GBDEnDT+TYaFxFMW46g+WTMaMsuzmesbEoSn3egyk+ClGbPgklu3KwqGGz0fM8mhucAsDPQhmst+dSpMmEdvQ/sEDpWrX119gwynB9jW6HC/XSrrS2Ck1Ey5wQ+2/ngFfAjZ4p74HIlyuU4cOZT5T/hcsU71Bx+exF1SdXtgN9/kZ9h6ZvtUiutZD30ihGtHlw6mtgYyw/22vY9hQh1kUs6gNpb7begHy+85HQa5D+Ak1pgMiXNEgT9+gg0wROs6xc3iGNvdhBYI44/glY96wditMA5cOTQ9QjwyHhQx/VJAmPK0lexgadf0fVtygfpLPNKMdxLNTS5Y5dSU09Z0tt0ba+0+fEcFNLg4cmPkQeX4QmRTk57Vu4ZWXbIjI3o0nCpO3FFjrtfFWapEZJeUrta9UhunZlBeLWnxEqfsrqjX+TDvm5xqzd7PruXCwMhO0GEmbNsKiCPHCC3+GDpkmIFCj9eR+V9jgE2+R2sz3EamqH0r1m1RsiE9b24bFEHGtfnmf89g2wRKG29QT8EoXs34L6txTaAuJ0JLPrfw1lsjN62qVBlNvZOjjv+9SocIltlWH2GsEHxif7pYb7IuDZR7wOdZrQzftP8tzvSY33ZYTkaBwZdxGlFPDiqpbPGv3Vr81tnY4qRwb0HHUOwx0wOebLGz750ttJZ/UKhqkSQIa/s0/53eDXZtnZS3262rFiOXx4/4cEEeH8RXr+ek2YMVART6bE5MRpAECvLhNTXQ9pizcC39u6rfc4meSlBN6C9PGhrPc4KmZg7SaPKqoSET8q/YVOGsqvpmUxJRDELRd8xu/LPMfvhe3fhurvqR9up7OWJKCNlXuvdB2rU5StVjHvyULbNG/4caHs6uEjjdLADckCfpctIOSjJ1o/NhNOomfjkTPtpgKXgnXDS/yIkVQbKEkTC3INPolt6jCHgSEAcMh9JL8isU34/dFC6o8xfx846BuX7ZtpQ3sHdiJdUcO6ED+VZnqj4+nsX58VibDRp1H4MSINsQjYSjqLWqswzus8mwtBHeHb2JaYph+lICaCa1nShdezJQPkwCevlNAm6hX/jZBvmfmtIa7FzGx0VZ18RiTcSjE7XwJfuOCR4zxaexhKjW2128463j7BHzTbJUinU+HteGtlh3mtH8GRqwiUtDmif9F36UUHRAXtTZ8JBTq4jhSwZ8Qj+b/7Q0D9ZKSkB/Ik7LJNRZTp2LRslbXPfrXTo+O/2MVdPyxQlAZUHB0Y0b84x+7BaNz4+AdLG+FFMFZi+brJziR8G4z7qjy4jN3KuzrSgQvB5lbpZU5TQ5tJodZjtZ1J4Ulv3VCCxkg+FCDiJlftoLu3pn3JDrtV7NzXXVzqZT1hC3KR8SpCw/NM6CqkXBT/pLR1/GWtdEHg/BvNGDuguf4P8m+WYpUq582k3udmd5sPw6GdiEMGQy5VlKQY50vfhrTPC1juYQkMuhf434cFiIGJcnIb7ndwUgFjcG+TXPW82xyTlG9wcb9BJOaOcxN7SsN5SpfDvcR65ORDgqx0CUc0LBQ9bMQtjpQdwWE7D7oFSeKihzjamJZk1Mkd5EcFSTQQ7qm0y979d4sB0+M4VhgUHHNYmZ3SsP4IeoTOpwlbsW5M0/j+7+rbxsuUuzViNC8ifxM/2CAz+neKSgTmCrL56849E3SIxjLKkgkN4dMRrLyP+tyPi46qMffCjwKDQludY5oQdPEGQaHF5KADvNi95EiOPB4dT0k6V7oOOQ+0pztjZBEg35aaGPSlraTazgxUFfI7z8Azq3T2wri8MmxU4YMjjq8JaB4bdztWUhK5x40YHLk0P6aspSMLLgFgDn0bM1yHHn/KR17GceofLT7Em03R90mY9LWbPTqctIzj9Nr7BhCY/E9SnqtH8mCWH3/5T/j8AnTmi+a9gEvLgZ1VFt1kp9gKxtV4kZI5OMZ2jLiE68n/XhXN8fvAr3Rq89BMsI2AyoopvrF6g8wk1Eg8526Cbvzv0QWYiXcycBdgsEBv8KFlMce2pscCqlcULKamdvQS9Hvo/GGxjKp6I6oX5ZNhoqTaUtDIjo9xr/kxD/4O2pWJz2JN39uab7BAJwkPJdTDp2Gig0eHdUN26VdGn2i4nsARJBOcPzRiv1uFwhxPWp9WZEmQsbzrTXXufwwdfZf9MvToCSV15Vcz8u9hqCieqe0Lj6D2cD/PbzABsLAB9w868mXshYOzI9Up01EHL/uLJ6iO4oYJboqlHSzDa5yqTuMeJt/w/tSKExApfJiF3kJcCGtYtRSbAt/A3FrBv6KCvWCLf5f7nLGx2FtV664550nmNmn5f2LZGzXd4Ij1us3l44xAGY0f3c+ggs2J1gHD13KIRRNgl1SS+09Vp1r8IsaWDa/tYIELv6DBth9Qn9MzKCttiqwtCNDr9+EMwGhcNAmlKvCXc0TBTTmXtWuwDG9zzvwZr5zS1xt8zLYHJe8em5NFl0gUP8OVklB4OH0Co3TuHr+djtEROop+ejL86vqovwmk9Mf1kT1GweiqdDNf7i7zcqIF5Ye93INIRG9eG1/2dTulAC9v5Ewuy2f0HFdceWXSy5oK2InMjWWtBuFVXihEJf0CrGDaRDiGqQAddLJer0pTZgQ5OHWzZqg7xZ6pEshhzG1wG+DgftRM2qy4Zufgltd7ccC8w3OBT75qeAQh8TDo+W1cwjmBtdrThzNMjYlM2axGrRPO75XmNSJtIN6Ka1c0Ra75C61VXNgrLhVg0XE1T9UFenqhtvxG1TrEnOx1U5rGdmHwBYhCKmaNksbToneGL8oe8VoNBXNUOjcAavsmCctZmOEnaEIh3A4IBMVN2pPZIjZI/2ECuD/vPLjloNW2KL2bdN79K8dJhKDclZs7YNt1hrMdAYzTagKYVGXDqpbQLG3waFFV4VYX8+PP6hGWqGncm+O+lCNmS7bo3Khoxyr1i2CMjRWkY1iC8YCaC7AMIEbw7n32pvvqESzukCMySUADAfHrbvO+dotJkde0ijrEf6PDSlUMKITlbzgIY4kvx+AfhLj4cj2xRt9caW2pYkjuhfHnxdEbrJpHXjO4MZ5+YP5lmDMdDQCRIqCH2+5FxaSQ2AEtjSFoNA2IkTvkmDS/psDunnLRbWCmzcwxS+rFlWS8EjDGBPgq2fewEfAYBUrXYYMqtNUovmVzrTXpLCs8HAV23j1zyGdel2byeTVG57NJagMAYhrRt3o4cucJhtJDUE1zvTfa4wV2EdPWMVRLyeJBcia6SnIi8XvU4Y8w6yr69QB7ArHNLZM22CKvGd1TAurkJGOe3N4h5AsnIWOlfQgcTmbPzZgCpzktlXAD1IoPZ4xUIQ2uKzcWNpmnWwOfwGxtiVRR1loZVSBl0/UMHRTfX+7D9gZpnpccUGFx3WJa/+0DL/yN4Lta1OcA8ASy30G1ZZrLAatUnY5uCmjA4FeOfLOctSCmVhsBkxIWoz79aF3osan685B3VO15C3l0djEJvdVrK9jxcQSKdLau0+H9Y13cc3eGJMhvCX8C1ZSEAatVRwTWysF09PM4RQw4Wcl9lC5fCZJtf0OR+KIhOF9giVXs52e714fkUkzViH5958kAxAVZJAIwYUGk/I0OBzXsVyFLcQdLLDPVPcrALxoCSOCN1YLwYfDuyIkQ4huCQSX5GOPndTFmVKI4uMze3262n5zNswmO1hFKLTP18Qy2Ta2t/VLpPCBSfzssa8T3hTctBLMJcjKEpuzfYR0iZV2E6LVdG+djXVU6KKb3hngGSk7WViaai2khEpLEzJw+5nB7LbpWwfxF0DNgGbF9bhON3+Kw2bc+ihafn//7nrGrf0jn96p8w0KS6y5DCb+/sqxxT62kMoKLETX9zsJ5brC5x9VbUZniD9PvAWMn/XY62aGxzajMnZRRIXyA1vacCD/ZM/FdsNrb+9p+cgbNrPBgG4u5uIP6Z2oS10idJL9K7KzCoeYrqW/Q0F9dwnhc9OSq665BNNjRDETzKhjjTbtKfVPzUc8jWz+1uJHcb+1WJQYs4IHPDuiUrH+QltTj6ZySVJbPx/v0Yuj+jT32MkCj3CE7Mh7UQtDDKoQteUBlWAS6pKe70nvRz4FdNYlWa5rhOPmG+BaPGkBRqsYk1Py2yeQGAAicwpQRDLES9/uv1LTiP8pbA1OwNahhKB7MSQasigSN/ecbbObNbSYIpurHUchQGrNXZ2aZ1hklsZz+MM+1ompD58lMqbHYW/GW4cGE2aYWbD4TgGrN/ixYrAZ/uXCOBjO11EuVhC2pHCehUEn48zVJIPAnQNH1JcH/EnqDBtO5VgVVS06UIDHR+80WiDUwtmhsWEf33XcOkF4glxm3jTHtFzm/yP8jcL7b3F0lRuN0JzT9JvhtMvPDUnK68Xe5f4CUdkW7b/qIZKvGz/zB099Et41YuUxx8Te0AilsE1Fm5rsxXwzq/xW9HHoVrG1ioFVtyjHhMQDXACiXA1KIk1tktTVpHY3PBHGqpB5tHDTXLWWKWx6q7C/GLtF31n+Zzw/6MX8FL2JiuC3uMBqh7fFySEp/HSAvQJ3Pgg1jOa2582aW9N+mniTgT+UMGB81AvzCKOI98ZEOxZ2bxXobL4HTGtZhVvzu/HDgHVEfg1I014jaGuvVhmNIsb8F0m5HCixud78zzHTi/s3clGOSO5Z4lqadQX7QI8PpdMXwpDdQS/sxwHmhF4ahDhg8vxBlcZ5KVF4eIg//0aEvHcEZSsgZf1Pu/jZPZgaN2Jef7dw1yiwHHZFDIboOJMSex/twE5bUU0xQH/lOOowahwT6tXTYpMD/H4capxfNp9G3bmI4Gv3ZkvYsYYBch6SwV2YXj33/tcVblkFFLWvCNs96zeySVhEpOZ7B8ZnEP0bVsQ8PpFiSaQ02ZMehEw7o+8Ehb8HyYCCrEhdUpygsj6GqcM6UU3Y6049RSQtmuqOsDs2tQ8nSjWnF3MPmqGVJ4IVnosqZdgE/YojcV/SxG0X3ijJQWsZPilti1hAhmGjwitmhVL5LubecU6K2S/40KEOsUr92M5zqjHz4Zss40rj8k7olqDbeTw3YfjnIMXweSkBQ7dSkbGShOjIyg11CFh1khTy+SoYRwvXSqWs+bJ4Kj2wHDROm0wC/t9nN9oQq2TPiPlfhBst7hnMlMtPLds/tKy91jMn8jN7q4wSbPals3hWdbVPmCui+YIHnp9eE8G6D76ku4rdfjZa3uBEo9Ag9BdbgCE40MEG7/IAmlPRhcHjYJ/61+Bq76X2/bod68zt3tCi+4D4Jpg0JhP+4J+u6A8+qGVOXwDo1Y6uhIhbG7ZHxJ0obMe6+pCrTeDodwcqoXF+lTluXd6b54PnKoYwCa52sEAVfxEZBcNbXHBxJxAlwoGNi2qYhaeFGXHMCytKyMiGrKKeM2jGlV1NxJnq/xgTvUF2IBFfgVTvBiZnRHaHV5c722zmYqtMQxJkApyGAvE9Qtc0ZHz567MwMCtjog5MTSux6TMEcc24QTtWZ41RMRu7FcUqo3/5BsTZbAjqLRx/KxENnITSmMyiDg4mD0DueCNmDpXYK2Y6TfOHcxJwpGM2Acw6OPibNHU6ZL5y+dmK8yXB2/PZSnKeQSls1j2Ly1zGHmdn2ORkg7osUiIL1/BfH7JGQnEKQDG571nwC1YPSZZVSdMXGiZgkQj53gHlYov+2n8lG7kkuCfVLASIPiPn1rk2lfg+tfSRvFoiqA6wVa3WBfF0jj9C36JmkXmbK26mZjQC6YixfmT71cfxdxKkGeigN84XO2bs9K9LzRELfrfZBdr2xU7tWwpyvU1rfTEZ4utP0RjZhG53MatWZeoy/cY+2gCDXBisrYEFp6C7XHdycIyCQWpYDO1KOgetvjS8DXxnmwwiEko7BYjnEwco1hIvlLsf/+//bMAeI4AHNTUixumBHON5g9+DMEQAFVzCX9KyBWPOz5M+QILmtnidiAzHbCwNVIldrABI7Gh4knYbUnWJcbs+foG60ByAl271B0RFovMSORdVlAuKG0DOTsFR68pNTfSPajJZPIPXUdgfiPhAxhch583M3S4uxH6vrXXi+SeKxYavUR3JFo0hD4bI+7flU+0+/OtI3DTR9Ppi4Wv4HkqaHYn66o7ddEQBcGwOHbrE7mDNvku0OsAH67INO32kguvUEsaVtO2QK9RUU/jSpdVg9NhIcoZ0oTepGszVjI3YiI8xXHM+PopYtjphTdxMwEzKsfDQBK9p285VY2kwub+SWLd2hDALWDlgZ1iP0b/Jb0XNFpDaFRzuq7Dg35Q0Q8UbIt+nt5VjjnL34GdSaZIeGEJZYvlHcm3gqJnm2R/fX2BMDe2tqZz0aBhmiCnEfygnj+dqYRaTEYgubswVDHVoWY5Zqvak24fETxtvf6DwHmV4kUkwimXdOWZ7ANLTisR1WNo4ZPmyk53mlTPT669aehwkg4AoXh19cM+BKsLeJuxeSbx418ftTqTkz9jOg/234WyYlTOJDBUtiUMes6jKgZjKT8fLKfBCWP6GRpFgatSNuoKdOGiVOfY7m9tGu8XIdndCCSDHLQ+W70frOT+UJTeM/FxgTYPMr3/AxCKVf9v/kQZ0S1vuEczQ1NN/8aupOSfI8sBsudrVqyOBIah5oZQqLFwMJYwavqasxxEVEksgLYKSV4TWYyAlzAHJwKEl/GoATWer15OyxyO04ToRIRkqMqqS3gr0wD2X+9YXRooNxcviNZwlgB63eZwRIXhFJFc0A6XIafiP07AfwT+cxC4WgWSFHFs8VCzje/Rggsu0DXdZhhMOU7mxcFDOmOFar/nQ75V+dTqW+g1WhMu4assYKxr1TK5qgtbJsQ08ZwQ+nZXYOdXXmk+hs99tdUfZaKzvXHJOiG/yWJ7YAMK7m6/JoT/7sYOt0wISWmLz4Ig+dDQCCH4YqvW2YnwiTZ4SSl88aZvDR36zoHcwu2rOZj9V0LSbdEcAyvMcAlJm2AZaSv6zHSb0vQ4ikyAjJ+JxhWm2LYdjJNcPWPiu4y9HU2cDnVUPPLyO0Ty67ssPaORALBwuybvDJo5RAugnRJyoyfm2yxZOt/UIYKJ3vHSOqQz4kchWKLZvXRXC3DHaP5Gzut29NoNU5+EBa/AR+cm/BUJtY9u3JP6ATvDntQMC2irrSQE6072MNIjplgWF70RCgkdwpsSRm/o+a1nwKEMz/Qb9AHwkoriwJCknIpK7d7acVS/4b1bvdSRSW4LuYykQFrMrvWrW8fm4CePmOcRNeN7Y6InUotIBEwRtbGMTPjCyIq/xMGBADGHaXMr7OgBt/KoTxqN3y1ooRP2CdQtV0svDHWtdAyJxkm1kqS95flg3FbKb/3LDL+4mJNIZZW4yDxReCS7nuyVozuDfpy6xJuv/ml9J04DXXFwxOneecWbk8W3A9/PF7vnGgVVOxhrhHFwrEiMgCJ4/wVbcx8zNnktJlelKqYBnuTugKSB0mL9j0J9g0h0rnQbvmhqgw7Bn2B2k3Nyr52t02op2in4XuLrVtvoycP0aQZwHPdUdXXG1Ycu9Iee2M6GIbMynmoS4G2Tr2Xk818jNH45GtvlyuOZ/S7Bvts8SKI31kwaBnaEOVDXdgT0F3aB0TU/VqSNM7G8pYqn7w5iVTwuY2v35iGMLDlijEUKTFN25PZdIipSl64Q/7U+TTcM15aBExBoL/hrwKOle688GMDDfwzHGkBffS7DJdWQ+89jbRniWGwAqpWKE3yaoeN0It0Xw6OxUiAoOCclx1IlUf6CGtMKOOZKY/1u/QhwV5aGBti3bS94wQNzPTvQgL+IQT6aEONzI/RhuqBvxl9/CcW47VyPbk9ahQaHt1lL3ptFvBldcmOKBiMsceULXGB4aLQAalGccS0zhbq9LZdAhDPkRoiXgN8Lm2/hlDQZmWlAYnOoPwAof6betG9JtzNoNe6tNyYDXP1X1TGgUAWjGvIo2RqR6mEnHcnZuFRgbM20bsU0zReLRHjb59At/lgu5szfJf/s2iY4HwA56OCh2KvOOB8uI4NUuq1gxy9dXS6wXyo64rQHRkFbjBgA3dEP0ZJpbu9BPyaRmVrjIA4lqtynIDuNWSpL0qtFQv/CYrjSINdIQ54aBqSrc+fLHnW8AJQ+ZpIqRdNyBdY3oZ0X5lBsvKGZZWw6aN1wnTAN+pxMv6qpiNMk9guH28l/yxQI74gzCIZqcoItK6CNvNT3K7EZAJtzVJAYCV8WLHQ38s0YfSnYBbkuDfQdt2Ml7KMFSFPxT4rG8/pgTdQlu9361tkxA+m82+ewRVLXpwtjfT4VbmkRQ7ViJDXmPj1ujW3poGHgo6NTxOWxQeguU8YTUac15jRFKZAyG7BZ0mC+RiH9KfEYoO8ysHqzm3IYrAHzRDNWyphgO1TlEvJJo2IsFpQxKivk2CCkHhTiog4wTvlrVBXnA19rhpryYrfj1TzGcUcYXcYrxPYvpo79h5/nbI10DQ9yZ+QvZqCldotOB3DmEBfT2NagaaIIePtXR2sIiTi7k1CQFkxKyIyH2pNrpWtM2DQiT7/AhawvWfKcD6f7BOxO6btpo/XcgDiGS5lCC0fIg5K1qCViyBeBUV6Jknmv7MNfuFFImlzB9FCG1H5Reh2+hXtE9bkNkPLYe72FXdOrzW/7//gRsghRP5YEPD8H7y0n52GL8ypuruoKmDudFtUR7oYatROKtiKzqS7UMcL44wwULPajgNo9PrNIDJLi1MHUThcCpNhXBjlmT6WEY9FSDkQMbJt0PWLDbRM+7d8zaqMBuFRMLuiTiYC4Dph3dtdEtoIDq7B49FkgqnUwECnRx5VXTVuaKD7Ot92luAV15XqprrRDQE7DhJ+ddOLmS6QiggkQUyhXG1wGCdHJ1/Z6Qgc57ROW44GuzRzoHwYhiEAAWNjPFtuKpIKxijAJ2+kT0SzrrKmT9ypi44ou7HaTqd+VGTL0REOs0/CsXbwj+/9ZGEpjn6f607G9CUtyTVMbdHAPXdP9/RPaIfFoPFTw52rq1wrpMLTs5vEti9RERpQaK/Lx8egN5kLH/T0elooSLycTWM0RI5TiBpJSm7KC9ZlMF60rQSczmKcxdhJdcMHwyVH337WQjfVCR6xco3blrTAocPp/FFxqQ1WUQWhDjFRoOhoUssBjcsSWD5U31ishyCIe6AFTV7FM7fKJF2Bc8J06Km2NS1b80w6aqgMYm0obiGZIehefDH+cf6n93UpEfNqgNSnlprZMN4lQc4bKp2nb90u5VLHwT5YjOGLyMXwjkYHy/A90CzbWanT0XpKrGGnOkZK7inn//vhoqMGLK5TLaLWAYqBEf7dro1TpE5FDmAySTe7w5fq2xIo7nJaCGaT7xKQ2RPgy0f0jX8M8MsYHpAntxwM3Qb29TcSm+hWf4WQBBz/u3fSr7IuZWb7Kaw0SKECtCHM4Yd5jbbPZ85d/08Zmb6GmPcrbp3On5kaCV24x70erIsWjvKUyNWl1FiH8cua4O5vZgdzHM6pCjQXs6k9l6F+8E8E59Jks60CAWaeqrcw1XBv0RITtVDFrx/nb28mCWwuygfiumj0JHERkrJvu8fPbU70CQO6WyE0j0EX9co37dUbcx150PED5jhJHb97Zi09A03TNdKluzd3bDgxG1MECr45AQVwy/q5cd9yNdy9jKYDQ9dVT2dRL4veoRQMDajT05HknWywbD1IsajV0GKnjPHa/37Pyee6LF6XMI1PQ6zANGDEiHpkMFvG5X11MoCzk/AvH3zgNNX8AoN9MnQt7uSiG8jtM7cnNI25hLMY0ZqmvUCxzdGLbkMoUavs/g69zGkxsUcL2LU4VSKC6aSNHgBivqM+pUHpEOHLt47L3ktQuAenRydEUwc9zp/bgEP7xecAnJrg8sCMuqjs7M0uWUIARjEBZFiP3xEODk8YZ4ozZF/gc1bCZittqsuxEfYUlqJCqrFivHRyb7yOeCmiN9j/RW/4lXQXHVpGKhjsYRHLw6ZcCvzpbCqGa8UMzd0n5K4NV0RoH7qS7KwqtbAzpxwcx3pqnCp/l5un3RNAtXgJ27r2klY7NzX3kWLdcY29sJkQbcDxkNwOMkIlzIu35YNP8oNi+8YMxZpf1/Xa6/fXMZUT1DahHF90URortJx0fYncAX9OcNh6yq0hicGRUPaEIjhAXyhoC7pn2SoCkycLqQztTWemumE2dTMAqp2uafuiLjjwyL6QgabeGVqIEJ1bBpeDag4a1CqrXcoI5uK5RMO9pwb+71t2mYdkedV/LTGLEGhFHSz78z9HVpANMT5oOm/RIP1Jx/4ciju5PCTNo5TeML+tW/jHjhTYaovkDg9VVMcKexK92VcrAplaIYG7Pfbl8mRQwzOP+VQN+85gc/pC2hxjvDOumI64wfPko3pCt4+WIc26pH+77xGmNBVeLE8cRlubnfH+oQBZCBAusBENLYqIEdkuT5rr0+1nHwjO77MaoOGEw/h0v4jGMtDvp5G60+IuWChXD1zR2hiV4N3bx8P2gqlG88EerfSsb0Oj+zfRtTbs444L8uGqyS5ytdXByKQhGnPxJLdOi0CcH/4GsD4eBhF5y7fjHQJzIVErsncHTxBOORjbgbSGSKCNcnr/6IjVEZSsXU0J9yLk0NcNmq2j1j6HT71UFgkXgNxMbIXGpXhEu2ZTCpq6d/Zw1nlL/sgmeUmF9jBY+KwA9V7wVP+ds5/lcQjLuXguOWNBY3dmyvotUzL7GtRLwzL39K6G8IzGObpi24Boo2bf4y01VV9vrhVfbBvjK6m5NLCSoyINabSmGxUQ1RuNiqcoEQ+FlcSfOHsRJ1l2GtnxPLcIcF9a62NDIE8GDz5Zc+6ONc9yw0speWjwrpbmKAafUrg5/LsfkPVFmpojlq3sMUX0gjG5Ar9dYdd0GUl+M8dAvlJkZuLC5y1vCGiTkvwUysBXQSfJCmbAk8TC0KN9ACTxE0cgV6YoOTbdAe1pVwFptJSz1XeLJ1pX7X5QXfEkpQeiKOXn0uJUxn6lj2crMWhoRarW+fMhDZ1jR7TiHvcIQYsDa1Pn1bJioyGCQJGDHe4rsVxShk8TjMBw+gXa+GP1t+amk5pHYrfBOCeCeHwYJeIilRH/aT8+JzvflK97MTNMSv1hh5O9+qs5nXwTgqHm+A2hZdFqJv0kqgzD4IfXugmXnlgeBddjkoCP3GL6SDsjmMjvYQjPA/WdyiWfXpv75buIFH4RtLlmTRtz3TY441x6A/iEvfi6k5PFW6fysz1XoTXpNaA9jivl47kI9tnuHX1wUXCnBnxp91Z13LYrf8Q0rYjyZmcH75MIM157vT70bEhtOH+OR0vujD7Z/1pXtb7MeSAHcTbJ9KRAO0bbtO2tfuJwZG50jsXhRZRDX5DrYmbKQiZQBORk3p2Ah9I0t8wYjJUnudw5Rhf9SyfI5cbbiYkq51icfL8UedJvyOiXAlur8qfAEKEDKs9qkiIkIozeA0FwuxB5I3a5Bmb5L5RQH1C/tNieWrx89gKwr+kymbpOc21HRAijHE8TqaGYEeiYsiEiTj8njfpruptIYrEAu22rs7sHYhzIhdk5S3+dd31fv0fWeBEK4wYe1WhNcCvS6MNti+6HB8lAVy6fDrIzXv9yNHRWDTRrTYsRZKbamP0XRg4/mMfYG3nkWsQYh0pgoM04MAsDXfw08gjHDkKIgjhVKTLgvVyZ3i2NRQ85YQf/R9s+MoQHgMICdPNe9m3ANOB5Vp4K67RjFhtgifMsbXId/vEit83ljWzM2V/YGEzyZ0mfgmAXB/X5K6OisfvX8Z+Zvdo/XA0hChwWgrNCqLEM75bhD6Lv7XiHpdJn1e1EjJv2g8Di5UQoyW+M14AnImT0mmDm+goC0GlYT5rSS8BTaDzPgZ7jxideYO0DQMAi66W4AoS6iMW5ViF55viOyhhU6jfj9U5nMIxLpwwrlQWLLso4NTgGoUyrkP+woolmt6g7yO5YPZJLX+tBTvXBe8fTpJjkjFgderTkm/wOhK9oInWWrS6GyiOk3UE1y3T9ZaqJQ4bOlwVYCzawzoIekzqXiEdnyrhJt9xK6cxQKMr23et31wJrdJKCESz8TLwC7/D2wHSoPtLR5TyQpYY8BZ9HyvHiSJL/+7JTtmWGD2EAZX2q/DtcJcTzE7lV6qOBQqhBUDTWbneabOdx4XfdMxmtX5Ty1SXXwGb3VfqWgAegQaSWv9qoNrdYPy+g19+lQtaAYw3UDpjfalsBvfroN5uizWVwcNMeqK3IORyXOZk2sPJTUkF1eHEcEOjdHEPcJTG0rGCzsYEhdwlKjnTiHr9zMZXuvYhvfdudDVy5TnQGKw+3yEX/9kFzoL19iWWFGNV3Hmr0xls+tOe1pqEohH0Vp5J2tzp32s6B2+HRuBXVNevV9vS1S8jrr9t8+wnYJCVIZOSpIknaWFFjHb2nSMp4tU/j84PJCdzA+ZsY42YalJhvS1D4UyIl8Hks6anTAqCKQMu9W9xcUvI4SZQ2T90QM9ZY/azb33lCcXxYeo/ieqYnSV3j+WlkFQPnVQZjCnVoVW3svoMTnJGZlYbH4eY+mMpeI5IlQYSbiez4LGvCS0PSa/fuqx++b/FDAhFCYR/78N5SwUbanGkeesXd9tyAvjvxhL+VJekoEQ1G18q0NU+drNtJRk5JhTLpNbz1Y0XmyQR3GRGsnHo4sdPmZ7inxHB4iZv0xy/5p+AXXjoGq1cj+JDGzrmo1x1Lqet4Kw/wXnXis4HAa3ETfMWCsVWaL+nGrWDqoK3YH0i201KMV6aAbT0ZuRIprR7ZHLGKudSGBIAaKkhY0qC5wv9B6irWYs19UMoBxshIT58fX22KdiGm/fdmhuB0vY4UiongaJZmo8NaQYW4ChmZ3SBQvf/rBX4DUkA3BJe8Jzc2KpBXyq4OoWestN+DwwMGdM8TOPvmzxJN70eldf4Bf9vsmeqgzgccSLytzb1OTsPS43yVWLguNT+GQyDT/GlyK501Qb8a7WM5CqONQdh9k/N1z/L5v2Ygszgz/XerJEZDi83l/cXxbc9Wv6jsQgo5F8hoh1E6oQUHuCU3HwIm8OQQwUMlp2pHlKWSRris7/YY7IYI3NtYAL+LZq36DQID9uKwtU3e4f9J8fei7Q9q2W5AtC5QVPU9OIU8VSE2hKC2z1hrW8JjNu6pDmRJxISwESbuneyTJzP9bX97yTGyMnevFCCXfcbV5Ga5s+nH5BeWDJmENQf+xJICZhsyfiX0lzdJhVGPU1JeaVqZ2s4988aOal4IK5T+Ye0EKtJ9HXOiB+k2TZXYHR5vPG8R++LtnnOOJKP4y3PhPLfHnubkdVoV3F3CdxzqiKjaKlzRv6314VVeMc2S6pL6KP5MvLKKfIPjBHGwgl+tM22HTvKnj8jDsVIZe8GcN3dLpzNwjjaOZudyu0qytkjJX+GVVuF/Wl0qEitMRbxHL2xbAqzhcHaKrcO4+Pkqzhr24cpvsW9/V0e0W2EsS3yem8VHnjzKE47v4AZV/1HaANU5NwlKQ4c0EUohG5ljHY13QX1wYfxCBqqM+u0j9cTWmLdQ7glN4pEI2LdCg8B1dnb907pw0r1TXb1/gXvopUsVNUnFKCS8X3JZn8mAT6JL7PuK+gV4DOt7t/JgA3ifOaPahDptheNw1hqDgxgQ2JO+YAz4tYZ3QDf739vjDWgVXzBEx93hTup6zkOLHxzHUwDYxNtMcgG3OWTGgW/GlnuLU2B14B1DMPVb1cJ6Cdi1Y3Q8xD5UYDEqhiLejVr1IMLPSIdpBWcN6w5i4N3saTUt2rLnhHCPbaX/TWsoufT/H6w9p1r70NPuIxh6x/I95JUftuYnrbe1P+SuIW75KtZ9IpKtnHCWqbU6R1ARc0/lUfRn7YRo54zFVZYpiFhHfI69Lr5mFBpN37Amv/+/xoNusOQmhHVgEVrQpD/J8Uewt/lgFA/IjvMMri1utaI0/demp9TD8B9D4vHlCVXOBTCdPLyLpqS6+Y8gT6mPEEjgdKX7DPUjinfausNZwSaD1RHNLM0DlV1MsXiZkJKvbrgeSb2ln5CNoBY2RSykrzX2zS2KdGn6/RFwWOfWWeD+1UxEW4Chv6Jdev3FYxHgZSmBahbUFIUE8eQagsNoQ3N0LWXgUWs87xRh35h5ExlttFcsmJ+m4BXkV5rTby4icy8XFdrtypE5FCeRGnNT1rVTT4nC8eLrgy7C9pLV/If/5b9KrHhX2aAzQ5rb6c4cs1b9Yr029BbwNbowLThL8nXFEFWV1AdGUg53kJmtrGq30HLoGDh7tdKR8ka/2juWPUlCWbEdWmsU7jBu3qcjFk/FxcjqhcvP8RLXxRvUvbl/P9UI0fyWqfIN87M+m9cong2DBdfP6ttvr28HjejCJEWRcLhDrwbuyZ5/pOMvD94pyXe/+6BX2dzOUsp0TbTAAOsOUCKAouKDBkMXS0pCNSLB3HsNlwHUHupzTFQSQB2VzZWGoAtU7sn4V7t+KWCclVOCk+UN+dA6W88LXXTJ4+PFwyb5yQ6hE2jzaSQNGWklTW99xfWz4WHq4WEF1qUYBc53s6zEt3tr0Cb+8XMZre4IpRcypNb0Rk9zPBB0UqJgWIyT441oNqeVnEAbdaIvBwaaBpSW8SRwpztokWkN8Rhz2vo4YnblP2dBpOnji3qjA4qAUeghXLYg1oCEc/v16pEvc3JKYw+/E525JPTqdQroDslALqhQc3FZU+9Iz38WGct7fWs4nlIsNUKcseiGE625W4IOtFvl0d0b7pWsmiRIoizZiujm7mZ9nIbn2CwISjT7kbC4/SP9OzEQ5QpJw8I09n9UHJ0VNNVOV536Fztuvb1DQTpZ/RVitWIp18WOSlwpbQthURmPUFObSefHxl1TNz0Fet9oJ5UpnQbBDho5bPZl9nSE4inoLiJccUSHAhrt2UkkFKlW3sn+YJrINWzjmJ/P8Jm2R7lzRvRiUVsw65RvMpPyH8VzyWEz2MbNYah48nvsFDiRxMQhwXmXtBQvtMYvGCaFJId947FjzsAZaPDow/Qd+6f1G0Xhr/imgBdV5KmVun1nGk+JQN8aLJrwdszW5JkuqC2ZgBwZWmtLa0aLmOmkElOe1xB4asQcgzCpXCGcB25Q5cdP0BjvxcsRAokXJHG35WuCvh3506PJlZ54xyDAHZV2F8Xka6er9QkV0bGRTIopkxN1Wr7F5s7qh1q1g634IJu7AiEWs3h1LsvklLqAMFhoEJYpU7akUPq772Nw9pMhnNOAdXDpLUSLCWe9m6d83byHOoQ3glCIJ6ao6z9D3plH9kpj0txr1/doEP4tyBdK+tusY7YZtwRouYnib0icmC3opZh4T3jJoLTuziUDxEyfoJgCQMlAb4m7gk6BcpoZPQTnnCjzwEvSo/B3tZhpIVVFsVMj1u3S27o3DpWqBXER6Bo6UNopRM42A6m2tuITbRebut8Rt/5nLZrjQdFm+FE99MGNqIWozNi7c5QGM1PrjDWv0xisjHt0Pt2oDvNPQVY3OmL4LxAXvcqUOSbRm513HySzigYjHsYNZh3wXoQEaOcwa+Ap8C1aYeS0UWjW3Bux3Pv4sKD2F0EPKNPybyUSltCWZJ0EaAPQQbcD88tkzUKBq7H/YlFUanpw0+PI3YDMOKyhuuAFTLVfR+iqvhdV6cnpG3p9ThcDJG1eLAD8niGDjKN0wBwNJ0399ZArbiAt8ShgVogoVtXjL6J+74mmShORNbcXGHKiATxSzcnbMvusBkXh9ChMtD4CNxSReGHK+9DBS+UMoLYJC8VtAVZub8CZ4EzC24aY5ZkNO5CutjAI9hu7Wkci2vA7xsA5UneSfYx6JAFbvB0OMfYSf3+Rd+DAMJ7T3iEswmu0RVi9p2N04LX+wDqTqf1lH1wYYmHwVs1BRXEulRi68VXWM8fbi8A3yEorwTioYUPe9d275Z1AjvqW7a8RsIyb1XXzDJmrYKN31c8GRqRe1gBhatwzFpQ8uT7ZSxcQcyKALOenNX1KkR82Cw+X7gWcCYvKJkygw4uLVfxTykVWs0q46tPzqIXoGDEO2j8NJHUo3L/MSrAbned1VSiVBXSwTzK1Yr32KBIGJoFvk7mEJd6lRZ6Gs4rFis/QOThQMmZyI6E+Gi0VyR+E0gdaJgvFiCjZvSD7EAuq0ULLjD+mhsaD9xXqlm+q93WXaxZf16LX+mxQZ2nud0vgU54ZAa2IxISE3jn/qopHI1890PsH7UmX/IqRuBe3NaYcVDNDnSN0Ut5HRdFoe6RWrFmNylO4052xaIfp6BvfkaRSDTidtRguJ44vP1eZOcqAmRNSH2iO16Vwrg0IDFHy11B4hcxm5mvDyI2Lbsz1lZPt3J5Jop2esPycN/0XiMkKvQsW/H9l58Gg6GjZOyA9SFUxved2induSfYLRxjSvCTe11IWAibpz8g6a9b4UGhIONgu15gmC/pEQOoYBTSWheGYlVUZewcRDbt+jL5QuSRmJfRdTSHp0H4AGBaneQA+wnWD6SeYguiqZWJacyOUzDZffeoBPVyPm/XxdmdxBV3IJS7hvWon7oGDeL1+TCdit/u0q56i7tn/q0nR0Ja2y13Dkj/SEjLbqmb7O5UBSxs370WJJf3Fo6ZSAf/zYQqzLSYN4uALggwihHnOIrd4+aorGFduyMPq/VW3vzII7gnIPj3z1yHVkO3NwfdUXzMCx5cFzUWmNK3ptFBgcqqUpYicSNip7XvdPWj8WHBpVXYr4/ZQMMg84yU3oI2dA7oGtuw/otRu/sqzYni1y9YEm2gTIr50bvlIAeB+ZAH96Ll4hB9m5sByNSx9D3fa3nH0aIrLXHLCrdaPV2rKFGT0xiIkJ0zxc1W4ZQthYHG9lnbSOgYSDpL2Zd8GB5dhjusxgazq1kSvPlbsvb/SvguGAzYAiGtY/DNlTkHAS9UgDJIHMZojP1Pf9JZWPbnVAU732nutAUP7mDVpoC9kSuwbUQ7Yb0OthS2s5eRcVPbqsjPuX2WXuP7p8NEgXksixx3q9LpUuuX8UBd9PlA7TOAn5lFm68VgEbSX5BpR5kYBjf/neX4kLY26uA9nnH/ufMpztvFtkXnLS+QDil5rZr7jvjkW46DW29o/rIavvRPWal9uty+GSSE1IuGUzEkzN3ctRCydM6p9tSyBIUnybMsuWx/iEfqGjJcJXjIb/kt0lfl+l+Y8RMP40bASQUwFrfNo1avqollbiV2nDSlCABcxg9lFeDg9k7Acwww4340rZJNSIi37HdfbI7Jj0z0+k+ZYUTu+EgLoP67uetSqV2CQHiKnnIeMUmBs1Tu5FVD+GXKvMj2PMoCDOD7cp1HxUR3jNYqQKxiY3ZhT+PfdSoOCjPAQzYh8uaB1ZgposaQ5NDSiBkZR4fOFsSl7j3JPKE2ZJU1q5JVXwVpMplKLJr1R8sQS+bVtmqD6WdVg2CdNV1muoOBqnWDTvny07T2pvmQ34JsV0jI9zXdIyP7fckGxnrKe4CWtkfywkSUeMrPFVvpTQMm9LFJwqKxiTVOinolbgBqgCja9omE9Q1GZx0FCgkptFTqKOwxUQvH7Iuzx6cuIAvHRzX0b87L3a2TJwpHxJXVlsKkpb8GBbv7f5LhPQr1MB/UA68F14FBH7iQ8hb9TIHNRg+nzIxK6wzaRGwbsJyf0VUOfwJutyd/2ptrvY6yoqMHBVAZCva/Pz1DSUlQrZ3MlZIgfD6Bd9nB4/N33eHsi2CIkK870BfIoaPKBCjZSHC8wXIc4OZUTYzeFLRkD5G00EdSin2pQZ4mTJWaYyRhfcm1RHSwfkb+cFCaJgabzpr7bYI4B8JUom6wBNgzWdKN7+2pzeLWMAjRwH8vczx1wrPtyIlTeXJdFIMasjIxq02FZfuKiTH/PxjA8Impexfu1UUGk2bkSjTgTzteOG95ajzptj1FrUKofcDhncubLaASneCnm6V22YhjCAMcmNBbwxm7CbZhJAGEq56owivyt01fWX3vVgu/pH3Nu7oe0Jmo+C+mJHcFjQaOAczbbXpcsnVP+OaGrajLsGSBy3vWCyuw8mPjeq5IF2/iGOK5VZi0gnWS71yaw6pfJp3iXGH0hFE15M6zKiLq5WHlomrnYHWyzKvhh8pdmsXC/Sm+iBAJLsw4QDikgVvjtE3k57uA8kpX8CUjBjAM+ldBhA6VDoC0I1DNrCIRX7WwHxKYNYwZRetD2IRc/RkwL3mWHywPpMXYFagMdMQOAvcs9G5aW7+41a4lcRuKws5GRBvkuHfg2n453EBB/secG3U9gDxn1maD++ub02micbsZc+YW+TGPimwPiHVWgt2Fh3n/l4NYtsW4PIqksc+DKagkWVMyYKJ8hDnT9JOuRYt1NyeG0gCSi7U3FoVcG+zE2xw4xOkc+5a5qPiDoRxufWFu5dmp9CpHVMQ3L+PcG2bMJGjQmvbpGCCF0KxjKtBTsEVOK6Bv/uvFOFqKCWFyzE1M3aMcZL9J+nNCwnlV20KUk7yh1UWGMTSUiuNdY1z6IHzyBju1bpfFPC4zRiXlxcGlgvB/LHV0ZSnj5mwyv9egogycDFCAeSu8iW88vgdN2HAXS2YjBSLZut/1RY8zT38BIXwqdhOYWa8SY7PVU/SyKFGnJ8mOFYOXeg4+2EuE1fqwIux4Sv/mxL4whgEbWcHJIZfs6L052HVarbFpn9hUqwHb+ySCHf7elwF1DJhKoNGlU5l0mh+SZDoac6wYm+v/4g2oVR+wBJDNty1SIVca9J1/Njgmtn77lcNY4uxNaNi0a/iYZ5OTM0fjr5xD6VElQaiAdl/1D4QCASXr1r5lmQrVvqrbvsuTOx9iTELI1uDhd3cCLt0UMj3qPrYWQzZxZysFWubmjbwYHIav7MXkL63tfMd218SxXkocCALrBbwRrFSAZAUAkJboIRxJyhIpl1YfmGP6NpJKEUKgQsR9dMFrtTFW/O7IU2ahVqHo+GNZ8/ioBrcd2GejrJc41tSPZx61viysDWTPt9V+0H7tCO+gKfyFwwfeCIK2ly+pcgKB6sipSbxw0qlSdx9pozTQSrrmLH9uW7QOu5Cf4slt8xKXjzAEQP5xEJ2xQ8IRdqz8M3guXoltuleh3Q0AyQj84V7ZR7HUO7v+o6cWQwAiEsYHFagXgaPGarzdxqHbX4pSoCMM3xacXcDFVZldmBPsV32vfKV/PazhvSVhJM5CqR7F/4O9OCpy7OkbIKi0OT5KpV4z8wSbe3U0aH0Lsu28TUYqviX/PcIjdthjZUuSN13rtRrs/bKNCvxVtzoBpg7vjlVgkDWMIhi4dkol1oTQM2dnfW37eJSVWzKCkQyjGf4l5jBE+FKR3UrL81/aGw99T3XMnQ+bg57FyTKWxKyh7UTBrcqVr/X3vjzSIpqVW0mUzKhUxi7O3liTXWOiBzSU3dJA1Pih1C8pwYByVJ5O7TXHknl44oaTkOO42TyFsIHuDeVArQDKjYjRR0qwFLYqodlIpoDHQqfeQwDOf5mYKBC25PdLZUAuIRE1+mwHqh58VhcVS1RPZJhzZfufaSO5mPNyGy5HL86gE4fRww59hkijMgjq5MKkEIKxVcl6tD5z/73g9/MW+qhq19owvyPe/oyt9d8yPoYZ/ZZQzzeKsyr7bR4juCtw4+P8X7GGb9u2GeMayGHAOz36TBivzBBLvsPpLe+59bHnxG0ivPivLw/kr/V6PdK5nl7eljxevRhonIPeoz7GY/oV/Kfl0wcC5YInNRt9ZhziOJ/DgmU3/zA0UXSXe1IyeAUIDaYFAXTuGVkBXMLwtaEJvWguWVlOegLmLkI/R4rfjD5NZWw9aggOgI8oveQ5OfRZ+/KtsgOAZFsUxp55Cof6gls7nbbji65GqGQS3PkjBM0gqqvuX3dRY5rSRAT4vMB9W05bKKDGyj+Crjd5cS8/TCBcnfZLo3J0yp2RXGfEec1pV3mTmy9qrz1p4SKgn1KY0rxdP8dqWDLMxBMqroMvVVVClcTG8ANW3QTtJa21GojV556x399XiQ7JhqYjYuxfNSrWTyBpFD2EWV5otkw6Hwf68vd/r8It88gotdp7J65gHU1nGMshgk+Ycd8zraundc3pjLutR+gdPScAxRoM6nOJvqEHIe7egYPXQyuzh5o1FlJk9m9dD2u4gwSJsz3RAjgt9kTravAFUmtxMR8T2GLX81CT41IC96AJzK9HGDAgg3MvIhLzymS27213O4DjfLC4CKTeZiRrc386jPMN1a2lAuRqwLGDNY/cR1nTbkE0TtCgP9m+/N6b18GrU7QjKxbr8YyAxWHjV7mbM700LLh2egm7VLkZQaWbucPXa/oDIgILisG538i6OQSPm8+rc5r4Kw9QcoIz8vxomtKc0HVTQcTRrAqobvXZQU0KxA2JtLgfJHkDSjv1ct26ENrr/6I9lFe3ByzYKoGaoAXqeSg/bHpJaXv6n5ohIP1L35TSrJizQvSlGJKkDmxlqlyw6ybg2jA2c13v2+tq+yF+jVUVTprFG6F+7/X7M53D376Pt/F8GVk6UhurwWU2ymoDQam9ZfVGNyRq+MTCAR+iZ/y9KRKNJPF8ueM9iHYgRKQAwLe7x92424se4c2JEMGxZ8g3DgG0nJwu7cb5m94DfwELivgrRqcppQQuXEqq1WiQxSDgQ+vEGOWajHzGnoLWuw8Vmo8+piOPcBwCLlTxAQMUQJtObRIj3CZ9/623eRgsP0AeBbNtHBorjsMRAJnpjNPo/Mj4VNDHUPKXKXGQFISQY+NMhi3SdZmTOH19fjcV7f/qlZYBllgevHN5robtcZ1p7yt8n4OZZEjiYTCf5on4dRO3Ueht4q5V27BLOuJyobo3cWBbPTU95af5EiM9B5FvCPb6+CsHm1Y4g05ESEd1BtKcM/d/FdUKqHIaytm/ccE29UbgbKIfBKvUv7VZCZ+PvhotITijqgyVWaivrbUIzU9qllp91i3FUXy9/LKWAZ0xCA715d1RXjA0lw56SM2qvONvyda0PP5azESrY5Rm6jG1YO+2rmhtLktq4w2PQmH+4wW9lYcpRz7GmAOycczYudZRbMBEyOcJ9MyOZCC33jxzES/PvLgrYr6UlF1hCkA+WeJSfydWRbcDZe6ZfihFwYEio4cBgX5hUjiXbXE1B1Mfkxgs0XJb8iXY5X5uVTTj5V3JfJejNMoAkstawbjR4WByKsUDdRbXaIbHYrI93sbZwuyLH56VkwV3FucMh36sMNX5yVChrMBg28LhNWB8TbwSJGQKhqG04Aca8k1TA58aTF5lmJvxahzDQN/8hwFV9tbxrm37AaWl9SnuMKIQL1wBrFPQ16AGY6k7whxWoOqBuRam71fd0Kpa2QaQ0ufjGDt6D6tcpGPoUnrz1rfS9eQzdchYxbXyBOV8K5KyH+Vn66c9J7RztxOzbrx4M0keoTc4YhpWms/NXV/s1gTDpDaKgMKCRgdvcxLVECaK8mqnRc0TjuACTrFATa6nC9GGqO6kZ1LZfilzl8Ck7sudqFhxTU4/u3ym9txcziUCjTRln1brbaGv2GY5CjYYjNLiIZOAC0mshOZebGtpzCgX8/NFK23+B6eFQpkaloa2hmMZ18JkZSD+YcStGUUZNt5WEK/qDFOkMqakzOqYnB+xy40228nmG5r6dmYeMQRI6s2XOTHYeRFs91P+BCGDieZWxORpWWslsymInGnqupNBCvfcZ8l17vPPM3K5Udb9YVdD9F1qiaLi9ol2HZ1hBE+P2bxXU+avMz3eH7+7AKxCQUiuLgGjRvlohbevFQTwvQGa2dbhPxS471QTDwUTLv26BFSaNTECzCRxWrd30EmXzDgxn9myBt5Gro9tWK2ytfKXSkE2zATpCR7LFk/liqSxVf720cKVw3fyEXZgS/zQ36wdVOE0rm7i53JmjRs5RtU+iVrOZrQPtijnSDJNsKTc6dtpGmNXB1ds040tMLISZH88V2hTooJh/BrDr/YHp1XCxLOhOBQvlKG6v8Q1et9nNoScp9d7MJh2DYL4tIEZMkVm5OWtFp0uknvq57OqMnMxJGzTEYd1WMg7+R87y8WKcK0P0m8rxOInvD9iVmRxw54KGy8sPePu7PrSODHDkq+V6sH9WVVfuPk6kDUTxB+/2RqQ5MFrvPytj1YzNJv5CdjXqXmF40qiwzhuF8xjHD3HVkQKjoPsGniWe3tNidvO3bendAoakmzM4A45Ihjbg68MOHRvw7/vJkJRqynt2dghi9KAprJAvz7KuImQwFkvjQzMbtXjUY3xIc8jI/lm9ZPoNlT/4qFp7MdfBw7obv4AKIe1XMUfQxZaRBf+TyUQ7MB3Wwa+MKiUiHSqvzJFXmntwBvTS8r7F3VA85NxcF8pueKrg0xlIz8hOnVfzp1def5RdXKLsjUtcnteBTkX2DCE9d3ZP7Kk92TV3pph+RhrOMdS9Hoo7wtXgjP6ffGnvG6EPV3MTGZ6DtY4wvtmO+k8RSPeQYU3ovKMmItQBW4/WY451/c4qBzinBOD2M7BLg3/IbdMdHVoyzVjZaaP5RDCw5fsVJ2/VjeiM7/kjvfZu5GT+jtqsJoFy14jl5YfNAeBveo3qTlc01DdwZ00NeUCGa5PCDLp47rW0ZqSSwsMUrr/A+nYhRJJ7+Z2psQsXSkCB/W4k0hw2VNcf/HIj40OZ4737eUGzGsiT+1LD/7MRWlT/WBgcysU24B6UV2JOqbZZjdWuGp/FPwK1hy2CJ2CWzJDyXJTvRr3sU60ig+bKb0tjWGkuvxR9mgGmVRiLw0/62W7UyyMw5Bs3Rd8KWNI8thLWl40xJHjV9WN+FJ0K3DckiquB6xWQ7DqTBiKa8AXKRLjRfOBUM+JsoPkbDxHnyjOeSrvFn8NCDFq484pQK0Y9ht0VeAvEBIBmHO56RJ1HrCo7jRHtP+xxiFc+A5913gZPj0Ie07MXn54xEEsuWi2vLNLbzihfwiQoO87/kdTHP5KhJWJOfliKZlonZU8X/v9St9bpgP5+iXJwwnG5/LSDKtuq67yL2XOiI3766tFonrbmBWcuUlb0GmLRO0/HKCTje3gjpu6c0nb+1l6GzvUONV45wZ2fY4iutK2hof44f15nCzj/L3DcFQPwWCBzwyMByWBFmtieQWAiWz8yNg47+e68AcJ4oaIebGxaRBov1r4U1jeuUP1sc1mf7/nLkHnxH2P/u1WuFhQG8FXfu2LVlwyXlWNdbF2FD2WjlxqaM2mWwN/0Hst8z0+r97JcbDgrlzcVPkptIRoYJ73aPDYhoktx1Zi1x+f+QRweGRORLxvwtzCQgNLkDNmPXe2XzsEHX9S1yoz1Al2FZghXYPV0YNC+gQuhUdH7/DyiaYutCfQxKWDLCmsLpf6iVdHUhA5XPetQc7I/WTrx9n2dTBDbOQv/x6ldumaUUTdtnrlBA9/ULrfYcCl+x9m/l+LG3o97UiTQrw0A1SckCYlFbQdNhsG33c5ywT7/NVnhw3Z5OjJa6BMN4CZhUaHBFL5p116S/+PzMVye5KA06olLuv+iWzH9A3WZDnjf7LxHdqbn2pCbY5R2KZ2TJSW6vxvzMvA9jd3xb9EIdkCTnVbGhtAFP2GLdHEY2mwS3xRyabx9qqnMOt5/mjFUuYk5eR0DusUBNms6nJjJNSWrKkPulXub9fEQGAm7nPzR/YkE31i/Qmq8xf4E/MQWrls1bqHgLKn3q1a5Qae2UGGILz/sIOX5jRcpfctDZPhevxtwDsKXTU3x9v4vCwAPa2kb8TEya0y23fyi9l5b6AA9af8wAZ1TyTqlJ/047fvAnuq3kP7Xg3W9tcRbVJHP6j9x7zDFgZJ/pvM8WFTpvUX/DXGZARD92KqxDVl0UjGYOvbY0jacbzJvot7SQtSS1AJf0PDxtEVuRM0ajmCGUKh2ONvUQ5bqnz0hvHx2GSnbhGdBT8/C41iQjtnyAJ0BH1Ylmhvx5wxCyX5mOfUOWcDa2qFI1Qjl69cIaUEcmhE9LhKlUisPYTjeBzAu6VOviT76g22hEQS43AVoGMdC+D5bV94c1Zh8o9EPdDk6xax0f1Vq2goTzS7J6uWIZLpH28DtAz+glpy0K2S/4OA132ZWQlOngoC8J+FfWg6DPwgVvoGv00N5xiNTkjajyIsG2kW/vVWmjdhrDzYxtUkPIdQbihV7PrDUO2K363MuZESS4GZdI1tov5OZHPeea0wlZSqGHu86zA4o2kcgquNDCHX5xTsYgvn8ngxlT3/h9/eKa0PNHrB169MK7VEQSFN6lEO2jYh4B5C8upI13UyWRFxYEH2KZKBRhyQPTNbSPDEmpaxZNIACJnmpvgRE6HjuMl9/PNjsEx1YUKjBKVjZXPkIFn3OO1IHdzKIJDl4tFTVhyc0fiAH0CFzo1Q3zMWSImpubLgfGbov8TpCxv9kEXoAgpwipeexqPI2te0bKwECKAYYCzZyVRT58ncB+RKQ16aurAU1uNxpmvybl5lsmZ+5Vvw8g/Be/FvR5YZ85PwKLnt7sBCqE4DJO1wC6XQBWnids0S9Bor8REgQdcvdQlLQaZ2k83krx5B4dD3qhbhgpSLMzGHPSqFnbs/TZfaNtPQK0LrwcP+QSwAOl5MSZ9jioltBeWsVdNvDSWgecIxHUK+ppGjtpmRjtz7KguSGLRVc3eFaod9fFiRdwHqwr8bK4S18WUD/xLIbztDbFhSDZTK7+0sDFaIXnAglafYjbfwjOyLgUGGXEc+rhmnSJttWJgpCULeib6jAsvRDy8z020EVvZz/o8d7D9awnc65HycQaliWVl4lvMkajhXeUXOE1g6BB0I6mLZySX3ciiR7HfJ/PrzySo1zC2cfckUsEMwfTv8Pm5y2wfNd8eFis9x0En1cXBWcW7JwSyQvwZoIIM+eTrdGjPZJdkRQltcbftDd4BYAyuusXJ4K4LT8vJhVzEyj07oVI+5KO9aBec4j1g3rcQazUF/6dyy6sYqnIsPC8LqzIV+thFJF1aCJLUpOPjiioE/kKCZukpQGqaMI3KFxz2m3Iz3Sml5uN1E2UbLCwCDKK8XfhO6Em90HrqkbY8VQVnjsRGS6lqQ5P2KuUHO5Rol1kwVQ4cvSqpCIBxr0aE9IQvtJgZUmpXmXCeRKEImB8Rg2O7YhjgLBil0+p3ISB/5C7rBIkxI3CsDNqzJAGB3LKJ0nW+MMBcqYg2aOUPdr3zfRCb04BVEhsagg15qNONGu7Ti5yhMJ0I3bMdxosIyB4SO8YUj/4j0qzb7Lb5T7kQtk2ClIkDJ3vxEfMn0pYZHJvwj5MWVkmTQ0WcoWIrLWyGhVdZb/QJM0ULjiXh9qlIJYabfErAkIJBxFAbylluI6rkhZqyGV2AmXx12GUU+TCWkU+fNsfCE1w472yNBr3GfsD37kBls+M4hvIZs2RebXnKCfBzTnvVVGz3Nn/XAiKYdaTCCEh+MfPX9+5okb+qMWCcV/4fZiXzjFu0Y97NtF5U7qnCqyPiom6CpmN5+WdeF1RBGoZP0F8YVjFjvttkfazHAaRwYjk7JURcKPbVABYLASWZGSW5klAYiR1CUmSM2lTuAPfufzuOYGQnSQfopGJQwuyTN7HRbgm5/y9njkFhccLAwzTJEhTx5tUY1c9wafnyonBJWveNfa70OB7K+tJAuDgwpeBJavYU9k3RNaLzLYqYC+MDR0KaOIpbNbUnzknrCEoxdYrDJ9/ocFYW0WnAVO4Ho16gjGiu4y22jE67/nlU5cxFGn6Mv8Obxsuqw+cX2nE3+ywzq2s3h2BceExD/2qcVam45xjaekKCFk9W4XcjJY2uXmMClb9u8hj9N+0KVpfAaJ5iLjI/+Y7m2qFuMJdk3Qdlaz1+JocPwFhAOWsmiM4EHX90oGtXwQwuyzCWglQYwIZwhIsm/I4vWkl6ENfHqoPhUMqz80R2zTosHfHXZSjeTNrW04PInL3FVjd0RJUgxkc4d+aNoYIR5ouMhkR7rmapANYybYfzAReYRgP33Y6Bs00IOgs0t44GSxZkUT1HCME6GiGQ10TkEXPrA30je/0q1z/j6zsW5Q76qdSLTnMoChcF4otamdlpuMmKTa1U9uXSdfVdE1Fx/wBukiDhnlHMakXkbjlQmiyQYTT/gSOGiusMZaY9fOBGvMilpxixCq+bdL4+nsNNsVwDsy2KNQhrZx+2GDuqFPdnD41Xz0TomwkRzuzC6JQakgR15mJ2uVtPcYTEUavxnYHxzQuvvJV9gCEBVC8SFskH2GdOcPVBIFBD4Ovdj5IEL3KmH9UYgaaW53LiC2PdZzJgiq9RtnPLRbi68fwd5rnw48hFc81qFKmztm70SGeLj35zCyVX6xQ/YVbPbfUCSkYi/1oAV8jaWHT3eXxXmZbRtt6hXYJTlKy7fPcw/lvgP0QjkzNACLuqpsGhjMB5wxmQvPpawRiqK6d3sB6VfjGAAVIaLerM2sT+B7HSW+yyGo9/r7TU6zohW13RLeyLYUIVnfhf8tN0NHQ6UxWki0dUHERqctiEUzfZgjt8Su3uN5r4TsUQEnYDIPKBcnRl7KPlukfxqLNTJMnwhsmkkC07S3YoAhteLXwmkcDn9RvplLIUCo3ZiWXPAUzBGvyJcZ3En/ukgBvi7/u8Ot9dU/YrB3iW/tfFGpOygxWHAGLKdXg3pSDdkUJQHnFSSARyWDF3EOKuILWGkN6ExF0AyzWvTXSfeqz5gA001M/cfObEuphp++fheSBfoQGkl0MWbq6IYTkUkBc1US+YYnolGJD9pLla7TdngJ8mWGgwdR4vF7UVz0DiIfiFUvEuH1SCbKjF91Y7zIxbgh6N27kUlFXTWJaF14o7mn2k2CiYV4w3NPahaeroVa+8omovQ4pQISa2MMLPrAVTw1MlqrYCuKCnnDgttkc+ixWdT2Ty0gtg8ILRDjIc0UsppthNROPjz5os8iYHGxHy87dv+yKneyx1FpB2kao3b5Ve8RJ+kJvngfDQ2s14052vEk1egW019N4BUOAJCjCqipyKhUq3bnFUXrqlSMEpQ0ZXi9lkjm7vTGQCz6ye6oeIKmWZfqayNIt4x9PkjUtUFX6xiKF+xD85XG+AJ6UZ68zfrmQEsSR12hXHSMRAmgzvodwFw7lbF+s9vX9UginedXvM5qN68txLEL0fN8MAvIiKjloZg35uwwavBVVMsI6xfsvxJ1BNUFdZeBySKYI6ettMXVNEhusWnJGdb5GzfESdMjn8bv4fm12NHedOmJ0aLS1JEhjKW6QI9659KFmab+R27GWaeb5NDzDQL2qRIiL+y3nJIq2D10x0/G6eKz1b+x3n0ssF7lI7jDy1bCpMnPfqaPkkIRHxoqApmC0gkr1z0cuz+2ihPHTIH/eQdMGda1fjH7htMJc7XrOuL6x0nXD4uAGUkln3heZfp7LQotDRKuclYPmgYszzhVullGl/3gfOuxKauDKaxdC7W4tJb0ikvmYD5CwPTo+WdDmd96ocS8P2+Wm0laaAU6n6zhj1jpZecPcTqdqt5o72CDM8JVA9bh4cn+hKWXh7Sq+ov0xCTnR1HmBxhC7uFstpbJj5pVzEHEud4NNnQYnl5iSFLu9p6fOO7csFVfAIJnR0YPXMVx8/8zeVOSt0KjeQHkBaK2Rgy7d9++u2t0kQ1/25sHy0Hnzm32FW5rd0axDcEi53HDBrx+kipiwXqm4w711AS+F8aulacc95uKlUdL+xHtDftpKrQpAnNHhC2OfLeCS+pHXYlBzAF9KfOcb0bElLyiyOFFYhG0JFLITYhnU18VSw28fCqWZG5Wcc+EwnNRwO/PN9vzs09T+Je7tbE7Jhqm5xnn3+reWANgPyA8qZ1OLEYS0ng8rmE+WRUQfMkOdY/AGLARI2EBpxG0XuFIaBqAvraxfHarp4coxAGCiHLdhFQqFGu28aNt2VExX4wM8yTKg0RXmUSx1bjK1rpPCxNHVz+TmdTVEaxytN0d8m6/LSXb2krH/YFdecnkEmJOcppM8idJ5NqVvlRMrKT7g39/uv4PFdMtcbFYbwHR3O/w4Wxn/ytQVGQBAUJ5pinjutVzNoKnS4CMlbABg5Wkgqu4bMoGwUqmvm7EL96yQ82MuaCtpiie8FS4Emw3Iyt6jf4VtjQHaxxCvcqAkv4MWeoHFe+VrmZBwwEvu/qu+1udimHJ94x/EFBYJkpZK2syYdEfWnQX5PNiU8GpgkpV+Ba38GlMTzd3d3VZCepFG9X/ts8jb6WimB1YoH89lAA+9mwiTtZX/XURBOHD/UO9pjnldNnoXCk60wfhjQbAJeQZQoBMeI43UW8ciC2r1G6g2JldcUw2/YoOV+tUzb0fbvy906RoChDRSmULw32ggbgo7B7A0vo/hr3V8QlVAav7+OIntJULrin7FpmfnNx9sBQUmB83scNXCP43o4fyAQVkJbIma0TyShXHluB5Bn7U24KDkEsZm317JoJVsmNIcct6RZP+1Y9EYrRfiHyGHhoCi43r3dQa5N/HvmuhhGtykLRNglHfEQhbNR0wHbs/OgrjyDVU3DbCCTVFvDR065qWX1FI55FyFyrw0A53sKoUT/QgnRNbc28VWwYb4bghoXZAs1CE6e8kJmUpQiWsi1HaK1KRGp5lR6X5Qgrn2qquhcT9GRka6ueXkYVF5YP3OLg+nhiC5aMvx9sS1zB5tIsvdo/QxR0qa2M2yk2gqXJIOywAii1tYzOy1p2UR+eToC6WEgv+LVk0Jm+eLKTzxUmZ08XRz3Dg1H0ifIlwfsm8wMuVdGR5K3cKTxjks/8l/AsYl35cPjqS1rUM7B1JvDJ974WWkEt8BY/SoGIXD7a0bb23qpG7WyInP/BInKFbU2DgsNk1NcHCKgU4M+QPaQLkk8id4zY5eIv3MPwEgrubJZpW+YrFkBEhP2SU7LPjzT7PoSc4nAgTSkC2ABCniorwbrRvZBSgno7H7VnsYSs/Fjq9sbOZ0SpC4vGPW3KNM3EdKAW4KIlBWhy5/COYEoak5zeHi4Gw153zlDPDTWGqk25RpOAQ0zBxfJZN2HFaCP/IycMRSyLQkDM5+oI7DRCkgnF1p7UDJVXAM7xamqqCnCYNM0l7woaXep5aXDurI1UspD6rmA13JjK+MS6pNjEeA2GiyOZv/QQ4Vt6ck3+Ojl2u0PjFTndwFZNjpPgnd9SbPuiiyZ28hXNANv4u5ASiJpBeGNelmm5APlzXoFpSmDvAkXu5a7hgWE5H9mAz3ni3pPFXlZUpwvQbLm9pnRoKBH6Aw3T0I5c0WIWo+DE1fQMfM5eVECSciG3BBMPK6mjDkAlD6LcEB2+KlaAhPNp1NJ9XZMM2FX+B+nZw9UumKTJVEl8QIhSJk7eVbmMPh2t2PFonfJEV+zExYNL3KV5bBg48z0te1qPukdHtJw/5vcl2w1evuIlU0soYH2Cppc/OXGOE1P6XIXEhUgTh406hLR9TH6EW9J0HVpH2uAYsKiHHfgTJ8qChIoHbdrzjSu2DgWoRjalIZicPqw3mPs99VBoXRJuoWu8EL2BJr/xlGaDHi7s+rvTuyJsJNpeF/FpurmZEwn1M7tbBt4Rk0qt4Tqf0kBY74z5cUjGSI2Nb9kWcVJ6vOP0PEdkcJBzVbCCcQFv81l8IekxBb7a3BEMz14vCm2I2Wv4GWNy0X1vErA7/eXWSSj0UkRmgC3NbqrHuE4IsiavKWLsmM1XfcUpDIkTaFciLxm046g/G8yu4dTY7RfKQLYjd6+wvuwATPPHZ9jdoFYyFseL56Lwjo24LuTUXhaVzdGYhNLJJ0CSdOhMrzGmqVcwiNOSV8CNtYD1HFtFVKFiv8sdd4c9UuJT6uHSsmqidFx6CTvnalCr3oGYZn0hM7JNE+jlhh0X6f5yXGBqYQLHygIcUBeV+GcbGNNQux+hASEnO6ljhX4hw78fhSYA90YnY9zN+vqR9ZEDa04bg+X817ynNIX7aIWmO8rZBNf3KoEQohiih9PDsRMncK3um+ETwWoH7jAdrZeXwKvOQ4fh5NbuukEAzGb6cG0LufUA4M/ylW98Q2g/1aWMdWbVwuaUrFtnltabaOB0LjO5Uv61SNnsnihnv0bivjvvZO7qzw3Y/mLW4KbdsSDHSc6rVXyhvxspq5TQU539KbPEvCplo192XEV6EF+nRXiEIuVsmgDBeEyOiuxy8eKXKe5IK4XzrIlMNdbrlczv9R23HO1Q5vsNqix5Ud09huMfIFWqo968ptUkjtZBV5dDoUFX05YuiGtS1GwGRHbb7Sw890RhdaGrTxXGHZYHzKq0wUqokGMb6RQ//Y61EP1uQ+7iuVC+UED74f4+KmtC9ef8HMP51c2y906K3pp5Ijydgv9b9wQGoP9hxRMKhFKW9nB7JjtcpP5k0RJSUGl3/3ihiuCbCcez8imjDyAjDrn2A7QqbH8f1qNN+hCOmZTiqD9eXRsnVOzJXL1xBakhTzbjB3jkf2bNST05xBggANwMoGFYw5J4/jQL4CdARI5ORG8guL7pGd0njRmxHj4sEwtQfmn51Ut/BmOLanRM2GsAaK2jJuC1+x29NAmA2jeLRwtiy1N2ixC4ijRmS2GfwYN9XhOK9/PMo0q3XfUCNdP0uWV9z8TIBe0LUMj/KHAp2Vop5ijMOgLaUA+afSYGGc2Lh/vgW2oZNLVKF04S3t/Wf7T1RHmeIM+jFMTZCbSJ9VcpVgEtBxivmonYgpIxOaJB9/1GpaiOw38E78YJ4r4vUjsUoTtZQJOB2R6GgcF85GbiDb2EMZAZfkwCuKiPuhF5ealtT9MeBXtj6r5mpHjCndtspdL6qXURGUf7hMnkwuSCMvxvxeZalgR4wcZVuo/NH7iWXNJRJKzUN1UIcE70q97S4mnYYV5eu7gX55GwGItZz6mtS/CpbDNbl5hmE8TXR7WwV8GtDbzbWQiGNQ2pvZLU89/FIueVclxXqhEAGaYgZGaQz2GwJgZ1ghUFWaQgG4Aj0CUi4kYMyetmcj50ZiUdqUpkEez4wUjOx1ZdkBn+aGSDW76ae4/ccq+nBQ1WotWPC4cvjI+dh3YfwJDVi/4M+Aq59cybZchpB2osCFMMcbojgjvcxDe0vA9gZjkBmY0/LjLOH56l78eeo5IlqS4/S7/OBth2ZZcLiQZNr567zIjU0dhdJZatdPNNNJLXMA90g5VybZCgq9k0ERbYI/QVA6Pb8Stm9MINrIgg0XnGHYpecnlByt8Pl7+C03xQ0MkppdUl2hwfr32Wx3OoITNotyf6fO7Z0hoipFhI0oWK29WzyEFPkSjz7RQh66145RG1yEqyIVyBXT1Nv7Hj5i9YKzm3qAhpH15EnGekSK8ujsuNsYad1MsXuA5Aa9DQfdr9GyKXvJq5pJQLLKSUXfl4y8OCcQLsCADmG6egqSHpmCyERdhjE9e59nP+8R1CxtOx1H0KdjSPHc9Mmnci0mrlaisNPfGZn9R6a66jVHwNSyFaF00aZ2gZYhtmN/t4Zis961g1T4RvUe14NBbvpKBDzIdOoriRdm3BgEtFCeAlxAzjvIBA1tM/tzT9Gvh079NKaDzbjacNf+KLc/yGMAG2siZUSPiYU00/ip4Rp8feBTKALgy6KM2VvAbEHiVfpNyQf+DgGWAvjHQocWgDM1RhU2ZhigCk4XdNowdR8ym8NKCCNFYgC5FKFIlVUcrbcc5ZCVOX7qB5mWVdPlbFJ3M2KxAWEUghlRPT/+fBP2Fb1BQQgBY1tTChdnKZe5CYWP0fxT8NLzFzeWB/F/NAZ9bYQN4OG0OIYalt5Feb1FYi+QYFQO/4A3k2jeFXONA/RuGGvcLRnFvlX+MJx+DwydKVaM0MxkI0HPiBxPYOc4HDQppLNVU5FyLvsS2da//lS5S547W8tyhizmq5b9aK6I7kgqI9DQNalBqtpYb9MMY6koOQpOIdORGlKB3BXXIuNG+71lGYgCOEtfnzyMUFYVGyGqoc/7+H0G3/xty/k1MEhfrfQFsIt1GvMdbJ8dkdlBkbifDxoHJfvw79QXhDPCi2w5O9dPDV6gyoMq9nUevcDKkl3rn1MX55zYfHttUjE9GAysaaJNpW1VqiNE1Y0A5A4RlYHvK8W5OYIjrXIGjvzvFvKzAAwkP7NZvnlJsXt+s01hvjkPojpDghHTAvGT6YXlynSfFQJUKuHCwVzQGhSlBxvepNOuifjlFutli8d8uMPPvCK6A1BiAoviN/G93jz51sKsVeARpMSYBWXEIF/yHMeGomv+qRQtzD4+rHHHElj7yNDQxNuFfCganADTRN4r276knGnxHcmOy1QN/vpOATHloquJSLZ4uRwtogq1Py9siFOXz03Qv1oib4u0sSjd6z5tCw42xK/8TsrEVUPJOHdFIFOd7JruR3+C1HWkqEGnhiMbEBCgL3hchrc0ceBaHzkk4S+rnlsHoxhyClirDLLKLgvw01MesNb0oaPkrdUP+hSJLGO60cy/rGhMMmD/T1z37Rg7hulcY1152fd4aspsOo3JPlkJsdxM+5RQuKiSpGesuztI5YwIASPX5pEJrU+MADaXUHxYQFlGRP80su9PNMllnC6LvBlxwQgOiZPEdi6jklJaeO4b++ffyQ9389lAgL/szQHQsdXbxX1xe3lBY3tUo+k5XSb0K+gN9XLim9Z4PnAiDJc2K5s/xKZS6kY4OAH9x3h60Ph41nKjMzHSZssZkgZIGpE9dY55dXXIY9sF8UheDhD5auMAwRpnusgZ4bcR1SOIA89hUpvD6Dkz++L8AxrHp1QCTrnveZv+vl9sdkdjhNX2XarXBCHae9Yzlg2Oau0GzvDY4OVav04XS5GY/9dtsfZAEx6wS/Qc3nCxY1ud9RG+gI0znaFXzQehN6wBqkUaUQTlPE5qHrPigrIjNxyRX7FCOvn3ZOeWaLGbTiGHUptqvwzEeJEQFaiXnt3zg8pOIraSqP9u0z4QwfcSMjgZEo1QvlZ/wQwEkMkC8QwaSkt77icqPXcSEbThsjTIiJQB2dtvzMMpBWyFZ3f5islUjOuUCS3XEldMH4prgmgBTMVl8LIeX3VjdxghS9KsdpOMuwJl7onl1p11ZnmpXHQPGKyP3Bh4f8OUMhFYJEWTdM44mCsWM3WyPbA/fz1o/5yfJHsC92gALssPfCw6ntQtc2UHfAtKXgHkrmDbB3MAetLgjhR5EPWNUBhvCeTWGaz8e2noQlujPbmjNvWjhVAoSmCoU2euw+205+oWeiRGAPfWuHjBvHmLFC40kGjvsTEdMp6qkuL2Dk49w/MzzuFLgGbp60gcSKbuQTZLMjvjYSc1Xa4pPr+Dd8kZudB2njlc5pzJc155A6vP2fwm6GdobhA7kciBf1c9hNIL7PfwxG/U3LGvYa/hYHTQaln7hJkvlzCjibu0MUWoUQl7S6UhZOY3j2qTLkT/06RseirT63l+BY5c9n5/iiHE0nolPP/efRKo2Ig2vW2KBHBMUcoxMGOfJ4SIvgCE3AZTZPI+7a8fsmfHQg++CZvYwhzyoMaKYyx4Yqlx4iKaKTQ+oCptmS/hfejUUQH03yKnT7P+v4IJ1zaJ3k0puivJj74ieVOJpmqt4YvR4C0qr7Do+XSTwexRDOYEgqbPE+pJnf24wdiW78gAqE6nzgty2Qz5mOV6Kz/e9uDQKwUBPRVsj3y+4CbmJmj3hYGLBJ1kaXCWTLUR3vuqaNAmp6PRTpPoM6MuyZsH/YJxBrJy2yZUcu/L93LNx0hKyZfOSwjZOoJvXr9CxWL7VHOLvrq4AacA+cHyPmmRBxSFWpPFseRdqUny7zDJtZtBbRTH45+lV1mZDZuT6hR6zb/LPj8+ZqHzu7ZMS6ozfqnHkft+AlJH3JjvEFTY9NYCaXcjyTwYOJ+x9W1nJbQwHieAErML0a4I3CYFIOgGJ5WZjsLZELpKKCUDSZmyoa8y9JHSl5PlBXmqPdq81DWgGdGHCdWctdZ1ekHIjAXLlNb56DPkKLwQ0dLF+9NjEatoRxSsOHRT+HnoR9GapqTQRF0tCDzGCUF5O62HCPdo8ubepQxmRF9un+ag6OM9eZYtXZcaOdVOefiTlx3U5bQigjJ/JNYK8luYl4A0/Le7e4It6GZzovYSmWDXIcQF+u7hYlIoJt2aP82kBF7RfuLSuAP7xDsZJ+I5rI4DVxGU1GUt9/gXaP6feHgSXEr/9JweixTEB8884qAOxrf12X2kUYNo5n1Z+my4nlYzexrfvwk88RGYdMUOFMiHpFXNIY8QEVFlp1eQUiWglPjdfi+RFXBQRMQ440NJs5IoJ6DCsAJm1yi3ClCYSOxxPlVQLUeLwDnmK4bdbo9GdAJPzZysNMzuXwIo2nPXX0UGbugbPGRDM+JZhSv6Ty72lwAzdG6HBqDxN9tOlXNPH4HWa8O92Lb9ywgCNn+jWgHu0v8HJ8Qqyaj1xO6u0qQ4bqQNnsF0Fr1qollUKYz7oAWoZwMvTxSABTFrkb+w6/EhnGB38bU75YvKa/le+f59MWtmSBPWoGzLPtVrKMIHuR3WVCDFmxrYWRfCMTbECHRd9pg/peIy+W8ppwebqOHPFVhzsl1LyXxQEs5AAjLz7J8Hj4HjcH1+lDIvfC0zcGgAfK8MF/uP/R7aqB4xrYm3iKkImZ+3qpF3DM7x4ah9A15hmTaXB+HFlQM7Vql+Jtb/OUgzmJeQAYsFmZOCqCuA+kMhGEwnIh0Xvr3HeChK0XkY8uP1hwXwPVbIkBYDv8bXLpCmMi5O3izHB6HGoXFQynucexdG+rONZ0xxiVDHVhxaEft1KuZRcwaC/ijfgTh4sUU7dNb2WNFOduoJlEkIoL0aFx3sdZr7Fv7/QBBdypWSzaS69LipUd2IoRQX4VrXtDHazhipSDpvLh88DZTBjMPgD9/a3AUEX2uRrEEV55fsUp5VHK3+YxjlzJhNrKK8gIRf9/+PmaUkcUV1WS1IL5Kh8XOQHDHlwCi8cpxFwlRXogYlBPbSCxnT4WluYBrUrOANJaJQBBGyZye40cwQyTUWiRQSD8Xl+CF1mKXqyRxh8s+K/N/jssYa95bJpmBqIe3LjzjOgtk4qaX6WGL22dIeS+CywwEnUmWJuEBevBtY0iRmG8qA4FbDCZ66JWapbpPklZmXHjObQDOrVEKaXMi0TVKOZbEyeo1X3dHmqqNkpmdjbvHuqNxpiyd0KfvUQQSgMHN+P79q6jX9ICqJCO7m8kDcq/6a5u2Fyt6OLbiEvb77pW6S7TuuK3UyApovtyn6iHxdtCcfHzya+x1a1U/gP5RsS0dwboB5gDtN8vZmCtDl/Iz3dZ2hKz9/SQqJlWv/fsdGomBwJWktE3ICdIFwYEfyavXV4+FWHTdfdXDOJIVs8fQRMJljhWd6uTcdFOaktIOTOxDuiiSopiNgVFqwKNL5qJZ6BE8sRdRu97jjRqgkIM0NJvloRprCBhkBqjp95MF+gGaWW6vMwIoqaKkv3RxkEGEL6Ziikfzekee8AGZKtVgMVDBWwGM76zEIFr0cOWTDBZqtUTWxE1HO/c8ugikB7QZB6X+LUPa8/+A0STbIcN6VlrdXMjW8lKn0s8ntx1pdm7D1WFm9TB24weljjJ6EkwEm6PHtFUCSTpERM9zW7CNoacgGSixMWq7L6T9Vx3rHQvPmCGR+WGfHWs79JolSNmmeM6eqRL4SVz9+7zO7Uhy5PWER4TRbLC4WZg4yFNScBPD8Bl+scUsBmciOrUMN0MHAjn0DqTaDdWGFx7wEFVHGVqqWOt7xezmHmxGcsBHvh9zoVKCc+d38/wRI1gXM+MAZmp2pODduBl1AnCCADCiPDEi+jZdmM0XldCuYqdB5wqgx7GDEKNE3Mwknkp/MrhVVUMorXX5SF9mUbXya52zOcxrAfxad8iugGnHXtAaiiHkf7fwwZU6xcda3GKnQoha8udqCGMwH/7c+bl3nCmvIWO5PDWV8Zqx4e8tOVSkhz99QhC1oFc7wn8eE+oIjbQzxT1dyfl6Rq7ehvhHbzjFTOgfHtvKrmgmbzoTh5PQbLBSiONVpfxA4AuL9gpqV62FGYEXjYFGHUVEhI2s4D2TaLKrz55AlcOM1BeIwQt8G5Ln6+c43Cc1XyE0o4eGJRYWODlpqH+bAlV4x4JaOPfMTs98HPJOODMa9k9BuEkxyUZlQCy6W///E4cI3VjMgH6vAoJ/gLhiL5bO4SltOI3T/Qfygc8DPBj5q9ySEjt1ItZWL4w3bDUjwws8pR1tEZsrfkJV73a7hu7mbZ772hAiKo/fSyNIvGPuj3sqWVGzMtGEQgwpTGYhSaYNpR6hKL0/VhO49huOmNln52FTTz5C8FhxdNyL1RuyGnTgc5/YsWNtyv2r9DeOVs0BaMI4osMhjlsYp/AKM5wJ+JRubGBz6MYnldqVZZlYVEBNJYRhZdxYOU91L+hLyGNHgJKGeNcqNzhqLTvLKd+rfq34yyLrgH6NpNlPzTjjWNi3vSISsJ1SUN6tUQ8tGpsDtSi73yKVO84RO7DOoNZyKkJKORIQU9J0bgTUJk/gvFDPacAlzcdregd7HOZlLDG+iFa9+svw92lXXz1nSo87MLc8teHaGltiOJn5HrWdghZSk5vZHUeGeoA4pHo1+86ocnECqKZAh1QyebgLNSaRzsZIDpOhqQdy3CYWrLtX09LWUIUq6xWvU36dOVw0xO8NEWNTptO+IAsEaPwKinI+XpPUkJdu2IETv09ys9huMRvVWh6saK5RoAyM7GYJPqj5ZffE3r7UNAbdBmdAA/8WCumaDDp9Qkiu8dGW/Pcp/5ztt8RN4EJr9d+VXFI8NQMqm7QJOhe6uNfTtL7TaY1hmWLMuDwxSljUS+om5Un1p+ksv++24Aw00z8LxSznPJoZeiFOf4mJ+B2t826aXEqUitMkcPAnygBtAryACiPNTRHZ1vUEuQVUHSmU2wfs1LbZ077tp+CMKH7ZoYgVqiWY85l1dkJoYnjTyKuFQDGXrbTrh+0mHOWu7QCZmAN0/ZNXnsO1CqWeeJmYWU3cGcg5Ri6S147dmOGw1+n7phDCGlxFdcUTlr73rw8KM/zw+v0k31PlsNjd2GoiLU1FoASFhjzMZr5t30rx/lIZRF2Rj4CrOHxAQFY9AWG1FNjqK88DA+iEtNEej+zjnPuM9CbAgYdwe9LZtblx6eDhDmqjeu34BCcNG+0HVSP9oFPO3yJyRtKtCO5TV3RZSZDyKqDpP7gNeUmBgkZXFTI6dWt4n81RGtlg3oh8PkUu8gpFyAwilFWrwTdfenFiVgHcEqrm/NlbQS15OnUK7Ibld+9e3sTIeqqiktG0hYEGmqm334Q/NcOSNA3EYh/CWLveSmJC2+9uKdhQsK9W1DU0ai9mJ5e/WmHkY94UjhlE1mkzSAcp9xBrZYeeUGwWAnT+rCUuTQL/Fy6XuMD+2YwQpy5OMCfIXYDdPfAvRv1jM7eLOJ0PCJxxS1vOSmoXaxvJRRfiFiGH38RbUn4iQh10TZfXQwKdQU+P8efqds8fD+Av6UOcopOeBb08vICcrjQFxFF8pECa5GdyD04NLih9Lz0OXv+Xhxek629mLpRjZRMiP8Z9fgLO5MrE9Hp4rod10uRkkj/vjjjWeMRlBVF8yZmMmXKnsn8lUvNVklJ5K1X2gLp+zQsn9DeOXjDdU9dKlhFOq1Myh/jG+MKfmghAjX/yQ7qy3P068AjcbAj9p7+WbHz28K0PJ0UCJOkPdNnrFzeqSbIZ2dSGgW4tglqJO5XdIk1+SOCHC+m2tEnaxaF8Z57viKSB2Jrk+kRgtrVO5U5SV3J30/Hb4y6UuxSXImyfRKaaVHQrdV/T02mbKY6WduNTxGbabE5Lh9pj3wYJvgjIXw4e80/myVOKpE0YIsT3ntpr+48MnTjC4rKtHIyz9DTuLk8vghBjd0Hms5DgqAkHtQVDug+ZBlzmgz26ctmdtBoB5YjN1EWY7v+3wmHCOaLq1c0m5SsIRzvHEAbsdlhLUkTvAThxX83taKtd6WD6D8po4hB+rT5tOx1L3GifrK3Wx80+wUdTAJwFpn0cSTcWdTBzhpEhhTXcDkfdzNVnZnYnVExkSF1XnEp5lme6WvYMAVnkIVmvOq29sxL1uFFLySDzd98dtXSoNR0YuOGNYAsWvOywLKHuQtejTk6nx/GaFFdclZ9QYWEx/TWJoqoXtpupR+J+/2OfxnDcIpW/X+MBy2QlItr+SwYyu0VAYco8yI/1sKjImdJPoBoQhDlR9C1QHlKSPP/UdFODLhCBJxnkO8S7c7m/YrPfHVYewNnPU8hByjk0w0LAOZVwKgisu7lTBE2CUGLVFVOyWJ62q1J0WBemFKXO2JDdDzwgg1ewuyxzrDq8p6RnX0V34Z35KFiURRfdXEQor0f8QNV0CmxKbZUQhwjUFTtjFZ7asAlaQg8zG2KLoxzmGSrpWtSFTeR3pPHs85tZJ4CzAzeOLq8VyvTnXsNCMK2fC/57XadtND5WRgViyvqnUySBKpO8tyA3NtDn6dkC1Ywn/qELExQrSPXz2hqDH2KKlSGh6Y7C6kd+bFmD1cnk8f+BlTSdPY4AKlrzES63aT+B9jReVTK2A+QsxrOlFyK4walPLJGRpRukMCxmFaWZHkxHii1elAqPKm1XPPSzXkJgWpcHyS9ymMUjnJUz9sL2pk8/H1aQe2G/ZENr7XmUI2tdGR9pKZMdEToDHCf30H3TcvGQ5Wi9JdYeaAC6kQbYYbvwWRVPZhBZvMPt2C1hpUP0U3aLJ4OuFUVKgD1lXRqnBcYzA4JVqu/s52bt06g1YzxtKWBZu+0Bd5swxFRij+Rz+WhQCm++H2cTcklMqI0FEtLVu05MGkAYN4AjluA/R2JSz6b7nNkFg9QcPLQ2mhmhded4GPfwkzusw/A0VInfu82+c0aToL+YGjwgpwtkVJaYnx2hkzdQT5oKUyPJyJOYfI43iX86FiXudvxZ9YPhPtVAW+LoC/FNE+Ru+5WIV6fQnV69KqlPyCGT8GE/h/RAIdZoCK33WLIS9mZ2C7/uXHjT2BcPwujwiAahqZ5YLuF3OjCfbI6I53i6MxqmdppXrMYV14ki8Iho9z75w8AuFBVDj/whDgnRpGeMfCRffrXRGOtf8e2LKsDR4xmJ0wWaodxbcVIGjjbAlc6vNUpFUEkyvzKLC2sMEQmU9FrFwq8lk4BB7ZIwoCHhp2DDCfJsX23blL9dDtd2njDAFYEM1EcrJsVZtfvQ0JVhyhudSDjZFw+VbMZnbnXODdcRKOdanQjqWahgIGi8ET3c+fe+zY3x8UhFVtyCDUIHR/GD9O+2g+ZE/ZKQ95VYqKelOQVe30aek5fG7V2CTWAyT+6VyQWttH1CtiA8DwXMHCFs8NdyrQZUWdH4XUzzCyO70DKpmw61gE8uaO4JB2y9opKfwOTTI8eKPVH/L6daA5aBbXJI99OPkIsZuOJz8tm5WKa31ixiuOfUmMLkOCu+3HYdcOvphG8NOnFkYDkMIc9H8cbCCwedq+h4Q0KS9YxS+cYxDHwMyUfSp9LYeBXIMdKhE/938oSdWQ5WkN+Ekzh9Telzm2M85Fn9F2xNu9l+Dx3UlCZ5iGJXk2/5R9xvw5rx9OQuVX81o8TU6CuoaG84sOFVaj5OW1KaW7otgnQ85qMCPXSKK6Fd8Br2U5ZWBOy108PUzK+Q3mOdRlkGJLap1xezoEkXM4p3DZFmkHTZoSJC+L68evYdd/hi2nMR1qIYj0gHVhLnLyYSaKCs5y7uPnovWG3FsYaW0gwzng/Ts304QWpcbV+othMitsUF9BeqImc/Z7UjabaicwLynFUiUBaUcXALqz+dEQaArRoR0tNGzo+trgfU+z82+EthYvjcVD0lFi3BTDhgR/N8rPONs2AWYqPMYfmXJuCieiJMAm0D1vB2WdPeqO6xZtWdMBpso4l1yccj6ZyAtnd2FQCgLYzIrrG+wl6md1g7yxs1BJdF/vwO+HETho5BitHWuW4AbouQbBHj8aF+nFv51PuNPFD3wEzRKWQA6GZZw6+fHlD5FNge+XhjA1SM29XbcsSPQL0shX6TdQeX5wpH2ksap2DaDuFyucv82nPweasL+MCLCxS6UMdRv7dEJtP9aLZVyCE0+JmKYPwRNl6XiYLUrVv/hIJmDuQTipm6h49Cb4zXjU3i5VeGPe8zCIt6i+2nyZ+/+yat7eer08WMtx+awBeNlYU8/ouve2HFLkNDpnRByJ52cnpsGw5TYMi09H2CRMgqfRiiTyJIMlwmc3ctOEWTSwp13hc8ficc2ZjAEpUeQoSjQF54PJiPDSOp424Qen6xLXhPRX4Kh8VmDkwSABG9bHUAc7B+0HV6MH/i9AlFr7rez0zxjc3q08s3IBR4afKEC/UzXMvIBCkLLF4+Bhz91OMI3DsbUDMGO0IT7b/J41ylkOTa7xW6HNcdNpWhWgfixldhQZwhT9/yiUz3oHTbL4ku9FzvG0yVR4Yp3hCNzXgc19lyGlsRcAha5xgTQqOR/I1ZMzeUPnLFl6fwdozrI1BV2kYdBdti7khwUrSgjLVzOguzAjKS+ObCxFSBuH0m1Wn30nbT3cNEaSh4fPEt1CeuUUgIbPLIdyJGsnufC4Iia2GX+o0+MNEQaBMTTCFhQb+GzkozPIFAINy0R7fRijWKBVtSmhIX7+YvQhBBezavaTCfyHFVWkEMVTwDJ4p/zC//36dVSjJoByrFwSzsIj08WXzqEjMMPUR7rbZvO3gZ8sXU2i/YAo314AQ/DoYmT2OHhBoWSTfiwlLGKcNlmrvcIirHENYGllar1EHnM27UgI8UNQ2KLrC+1eMr5ZVvYT17vcbmc/plVmrhqPJSoeD7LT4KW7e0Vmly1Wdt9MZnjrevsS2FY1gluQ9Kk+psJAAKkczS8LqQen36wxKVYnEJPuTwI20fLHWLI4v5jHWkxK6qMiBQxqkTFMJEgJ5Q7mOrdFbYHjd+gDIUdBrvXzPb5bl3wJbByQJNTwWiz30To6CIMS+sOO/VqihITPu0C/ynPhi61zEN+cVl5jb9zuCPLKaK7ZYIaZXdJzLycwDABb3DOjJmTXuoZzi/YpqP5yrGZLi/cccsGIuA3WXjxp8f4uRDg1oCP5kh1x7u5hH8+a1zgutAiXw0GC2cgmrfTEhFQuNk1VJai9CZfOddvw7ETtjZDL0g5qZlmTersnxVCMlBPYQZ+wcmxBYsK43o/m8iLjlA/E3UUWVvggAvnAeDov5AlaXNKo7CL7cElEp6rSAxDy8eKLbWgpVf/hB09BumrxfjakKpxXs7nKJ6OfN6iyXuH/haH/taIj28j4EP6lHdU384pNVLCECa1fEVGXopzqe4xSd07YYUY7VBVs9BH4hGzo+DOtNk4aquxm99CSZ26ed1XhqnW6Zkx/2jWA9TC3</script>
    <script>
	Object.keys(localStorage).forEach(key => {
        if (key.startsWith('icon-')) {
          localStorage.removeItem(key);
        }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       canvasGridEnabled: true,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
       rackGridEnabled: true,
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          const fovSection = document.getElementById("fov-section");
          if (fovSection) {
            if (data.shape === "camera" || data.shape === "cctv") {
              fovSection.style.display = "block";
              document.getElementById("fov-enabled").checked = data.fovEnabled || false;
              document.getElementById("fov-angle").value = data.fovAngle || 90;
              document.getElementById("fov-angle-value").textContent = (data.fovAngle || 90) + "¬∞";
              document.getElementById("fov-distance").value = data.fovDistance || 150;
              document.getElementById("fov-distance-value").textContent = data.fovDistance || 150;
              document.getElementById("fov-rotation").value = data.fovRotation || 0;
              document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
              document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
              document.getElementById("fov-animate").checked = data.fovAnimate || false;
              document.getElementById("fov-sweep").value = data.fovSweep || 120;
              document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
              document.getElementById("fov-speed").value = data.fovSpeed || 4;
              document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
            } else {
              fovSection.style.display = "none";
            }
          }
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
	  const now = performance.now();
	  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
	  lastMinimapRender = now;
	  
	  const minimapViewport = document.getElementById("minimap-viewport");
	  const minimapSvg = document.getElementById("minimap");
	  if (!minimapViewport || !minimapSvg) return;
	  const vb = getViewBox();
	  minimapViewport.setAttribute("x", vb.x);
	  minimapViewport.setAttribute("y", vb.y);
	  minimapViewport.setAttribute("width", vb.width);
	  minimapViewport.setAttribute("height", vb.height);
	  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
	  const frag = document.createDocumentFragment();
	  EDGE_DATA.list.forEach((edge) => {
	  if (edge.type === "custom") return;
	  const fromNode = NODE_DATA[edge.from];
	  const toNode = NODE_DATA[edge.to];
	  if (!fromNode || !toNode) return;
	  if (currentView.mode === "rack") {
		if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
	  } else {
		if (fromNode.assignedRack || toNode.assignedRack) return;
	  }
	  const p1 = savedPositions[edge.from];
	  const p2 = savedPositions[edge.to];
	  if (!p1 || !p2) return;
	  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	   line.setAttribute("x1", p1.x);
	   line.setAttribute("y1", p1.y);
	   line.setAttribute("x2", p2.x);
	   line.setAttribute("y2", p2.y);
	   line.classList.add("minimap-edge");
	   frag.appendChild(line);
	  });
Object.entries(savedPositions).forEach(([id, pos]) => {
	  const node = NODE_DATA[id];
	  if (!node) return;
	  if (currentView.mode === "rack") {
		if (node.assignedRack !== currentView.rackId) return;
	  } else {
		if (node.assignedRack) return;
	  }
	  
	  if ((node.shape === "camera" || node.shape === "cctv") && node.fovEnabled) {
	    const fovAngle = node.fovAngle || 90;
	    const fovDistance = (node.fovDistance || 150) * 0.8;
	    const fovRotation = node.fovRotation || 0;
	    const fovColor = node.fovColor || "#f59e0b";
	    const fovAnimate = node.fovAnimate || false;
	    const fovSweep = node.fovSweep || 120;
	    const fovSpeed = node.fovSpeed || 4;
	    
	    if (fovAngle < 360) {
	      const angleRad = (fovAngle * Math.PI) / 180;
	      const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
	      
	      const startAngle = rotationRad - angleRad / 2;
	      const endAngle = rotationRad + angleRad / 2;
	      
	      const x1 = pos.x + Math.cos(startAngle) * fovDistance;
	      const y1 = pos.y + Math.sin(startAngle) * fovDistance;
	      const x2 = pos.x + Math.cos(endAngle) * fovDistance;
	      const y2 = pos.y + Math.sin(endAngle) * fovDistance;
	      
	      const largeArc = fovAngle > 180 ? 1 : 0;
	      
	      const fovGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
	      fovGroup.classList.add("minimap-node");
	      
	      const fovPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
	      fovPath.setAttribute("d", `M ${pos.x},${pos.y} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
	      fovPath.style.fill = fovColor + "44";
	      fovPath.style.stroke = fovColor;
	      fovPath.style.strokeWidth = "2";
	      fovGroup.appendChild(fovPath);
	      
	      if (fovAnimate) {
	        const animationName = `minimap-fov-sweep-${id}`;
	        const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
	        styleEl.textContent = `
	          @keyframes ${animationName} {
	            0%, 100% { transform: rotate(0deg); }
	            50% { transform: rotate(${fovSweep}deg); }
	          }
	        `;
	        fovGroup.appendChild(styleEl);
	        
	        const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
	        const animationOffset = elapsedSeconds % fovSpeed;
	        
	        fovGroup.style.transformOrigin = `${pos.x}px ${pos.y}px`;
	        fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
	        fovGroup.style.animationDelay = `-${animationOffset}s`;
	      }
	      
	      frag.appendChild(fovGroup);
	    }
	  }
	  
	  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	   circle.setAttribute("cx", pos.x);
	   circle.setAttribute("cy", pos.y);
	   circle.setAttribute("r", 40);
	   circle.classList.add("minimap-node");
	  frag.appendChild(circle);
	   });
	   minimapSvg.insertBefore(frag, minimapViewport);	
	  }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         MobileManager.updateCanvasHint();
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72¬∞";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const lockBody = document.createElementNS(ns, "rect");
        lockBody.setAttribute("x", -size * 0.6);
        lockBody.setAttribute("y", -size * 0.15);
        lockBody.setAttribute("width", size * 1.2);
        lockBody.setAttribute("height", size * 1);
        lockBody.setAttribute("rx", 4);
        g.appendChild(lockBody);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const plugBody = document.createElementNS(ns, "rect");
        plugBody.setAttribute("x", -size * 0.7);
        plugBody.setAttribute("y", -size * 0.6);
        plugBody.setAttribute("width", size * 1.4);
        plugBody.setAttribute("height", size * 1.2);
        plugBody.setAttribute("rx", 6);
        g.appendChild(plugBody);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const speakerBody = document.createElementNS(ns, "rect");
        speakerBody.setAttribute("x", -size * 0.6);
        speakerBody.setAttribute("y", -size);
        speakerBody.setAttribute("width", size * 1.2);
        speakerBody.setAttribute("height", size * 2);
        speakerBody.setAttribute("rx", size * 0.3);
        g.appendChild(speakerBody);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const hubBody = document.createElementNS(ns, "rect");
        hubBody.setAttribute("x", -size * 0.9);
        hubBody.setAttribute("y", -size * 0.5);
        hubBody.setAttribute("width", size * 1.8);
        hubBody.setAttribute("height", size);
        hubBody.setAttribute("rx", 8);
        g.appendChild(hubBody);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const vacBody = document.createElementNS(ns, "circle");
        vacBody.setAttribute("r", size);
        g.appendChild(vacBody);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function updateFovCone(nodeId) {
         const node = NODE_DATA[nodeId];
         if (!node) return;
         
         const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
         if (!nodeGroup) return;
         
         const existingFov = nodeGroup.querySelector(".fov-group");
         if (existingFov) existingFov.remove();
         
         if ((node.shape !== "camera" && node.shape !== "cctv") || !node.fovEnabled) return;
         
         const ns = "http://www.w3.org/2000/svg";
         const fovAngle = node.fovAngle || 90;
         const fovDistance = node.fovDistance || 150;
         const fovRotation = node.fovRotation || 0;
         const fovColor = node.fovColor || "#f59e0b";
         const fovAnimate = node.fovAnimate || false;
         const fovSweep = node.fovSweep || 120;
         const fovSpeed = node.fovSpeed || 4;
         
         const fovGroup = document.createElementNS(ns, "g");
         fovGroup.classList.add("fov-group");
         
         const fovPath = document.createElementNS(ns, "path");
         
         if (fovAngle >= 360) {
           fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
         } else {
           const angleRad = (fovAngle * Math.PI) / 180;
           const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
           
           const startAngle = rotationRad - angleRad / 2;
           const endAngle = rotationRad + angleRad / 2;
           
           const x1 = Math.cos(startAngle) * fovDistance;
           const y1 = Math.sin(startAngle) * fovDistance;
           const x2 = Math.cos(endAngle) * fovDistance;
           const y2 = Math.sin(endAngle) * fovDistance;
           
           const largeArc = fovAngle > 180 ? 1 : 0;
           
           fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
         }
         
         fovPath.style.fill = fovColor + "33";
         fovPath.style.stroke = fovColor;
         fovPath.style.strokeWidth = "2";
         fovPath.style.pointerEvents = "none";
         fovPath.classList.add("fov-cone");
         
         fovGroup.appendChild(fovPath);
         
         if (fovAnimate && fovAngle < 360) {
           const animationName = `fov-sweep-${nodeId}`;
           
           const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
           styleEl.textContent = `
             @keyframes ${animationName} {
               0%, 100% { transform: rotate(0deg); }
               50% { transform: rotate(${fovSweep}deg); }
             }
           `;
           fovGroup.appendChild(styleEl);
           
    const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
    const animationOffset = elapsedSeconds % fovSpeed;
    
    fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
    fovGroup.style.animationDelay = `-${animationOffset}s`;
    fovGroup.style.transformOrigin = "0 0";
  }
  
  nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
}
      function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const flowArrowBig = document.createElementNS(ns, "path");
        flowArrowBig.id = "flow-arrow-big";
        flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
        defs.appendChild(flowArrowBig);
        const flowArrowSmall = document.createElementNS(ns, "path");
        flowArrowSmall.id = "flow-arrow-small";
        flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
        defs.appendChild(flowArrowSmall);
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);

        const wallPattern = document.createElementNS(ns, "pattern");
        wallPattern.id = "wall-hatch";
        wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
        wallPattern.setAttribute("width", "8");
        wallPattern.setAttribute("height", "8");
        wallPattern.setAttribute("patternTransform", "rotate(45)");
        const wallLine = document.createElementNS(ns, "line");
        wallLine.setAttribute("x1", "0");
        wallLine.setAttribute("y1", "0");
        wallLine.setAttribute("x2", "0");
        wallLine.setAttribute("y2", "8");
        wallLine.setAttribute("stroke", "#666");
        wallLine.setAttribute("stroke-width", "2");
        wallPattern.appendChild(wallLine);
        defs.appendChild(wallPattern);

        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         if (PAGE_STATE.rackGridEnabled !== false) {
          for (let u = 0; u <= rackCapacity; u++) {
           const y = RACK_START_Y + u * rackUHeight;
           const line = document.createElementNS(ns, "line");
           line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
           line.setAttribute("y1", y);
           line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
           line.setAttribute("y2", y);
           line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
           line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
           line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
           rackGroup.appendChild(line);
           if (u < rackCapacity) {
            const uNumber = rackCapacity - u;
            const text = document.createElementNS(ns, "text");
            text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
            text.setAttribute("y", y + rackUHeight / 2);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            text.style.fontSize = "14px";
            text.style.fontWeight = "bold";
            text.textContent = `U${uNumber}`;
            rackGroup.appendChild(text);
            const textRight = document.createElementNS(ns, "text");
            textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
            textRight.setAttribute("y", y + rackUHeight / 2);
            textRight.setAttribute("text-anchor", "middle");
            textRight.setAttribute("dominant-baseline", "middle");
            textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            textRight.style.fontSize = "14px";
            textRight.style.fontWeight = "bold";
            textRight.textContent = `U${uNumber}`;
            rackGroup.appendChild(textRight);
           }
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else if (lineStyle === "wall") {
           poly.style.stroke = "url(#wall-hatch)";
           poly.style.strokeWidth = (edge.width || 4) * 3;
           poly.style.strokeDasharray = "none";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const animDir = PAGE_STATE.animationDirection || "all";
          const shouldAnimatePoly = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
          if (shouldAnimatePoly) {
           poly.style.opacity = "0.25";
           const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
           const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
           const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
           const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
           const arrowCount = 3;
           const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
           if (direction === "forward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
             arrow.classList.add("edge-arrow-forward");
             svg.appendChild(arrow);
            }
           }
           if (direction === "backward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
             arrow.classList.add("edge-arrow-backward");
             svg.appendChild(arrow);
            }
           }
          }
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const edgeDirection = edge.direction || "none";
         const edgeLineStyle = edge.lineStyle || "solid";
         if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
         else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
         if (edgeDirection === "forward") {
          path.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (edgeDirection === "backward") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (edgeDirection === "both") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
          path.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
         if (shouldAnimate && !edgeFaded) {
          path.style.opacity = "0.25";
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (edgeDirection === "forward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (edgeDirection === "backward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         const nodeRotation = NODE_DATA[id].rotation || 0;
         g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         if ((node.shape === "camera" || node.shape === "cctv") && node.fovEnabled) {
           const fovAngle = node.fovAngle || 90;
           const fovDistance = node.fovDistance || 150;
           const fovRotation = node.fovRotation || 0;
           const fovColor = node.fovColor || "#f59e0b";
           const fovAnimate = node.fovAnimate || false;
           const fovSweep = node.fovSweep || 120;
           const fovSpeed = node.fovSpeed || 4;
           
           const fovGroup = document.createElementNS(ns, "g");
           fovGroup.classList.add("fov-group");
           
           const fovPath = document.createElementNS(ns, "path");
           
           if (fovAngle >= 360) {
             fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
           } else {
             const angleRad = (fovAngle * Math.PI) / 180;
             const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
             
             const startAngle = rotationRad - angleRad / 2;
             const endAngle = rotationRad + angleRad / 2;
             
             const x1 = Math.cos(startAngle) * fovDistance;
             const y1 = Math.sin(startAngle) * fovDistance;
             const x2 = Math.cos(endAngle) * fovDistance;
             const y2 = Math.sin(endAngle) * fovDistance;
             
             const largeArc = fovAngle > 180 ? 1 : 0;
             
             fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
           }
           
           fovPath.style.fill = fovColor + "33";
           fovPath.style.stroke = fovColor;
           fovPath.style.strokeWidth = "2";
           fovPath.style.pointerEvents = "none";
           fovPath.classList.add("fov-cone");
           
           fovGroup.appendChild(fovPath);
           
           if (fovAnimate && fovAngle < 360) {
             const animationName = `fov-sweep-${id}`;
             
             const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
             styleEl.textContent = `
               @keyframes ${animationName} {
                 0%, 100% { transform: rotate(0deg); }
                 50% { transform: rotate(${fovSweep}deg); }
               }
             `;
             fovGroup.appendChild(styleEl);
             
    const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
    const animationOffset = elapsedSeconds % fovSpeed;
    
    fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
    fovGroup.style.animationDelay = `-${animationOffset}s`;
    fovGroup.style.transformOrigin = "0 0";
  }
  
  g.appendChild(fovGroup);
}
        g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         });
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          });
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
          if (data.shape === "camera" || data.shape === "cctv") {
            fovSection.style.display = "block";
            document.getElementById("fov-enabled").checked = data.fovEnabled || false;
            document.getElementById("fov-angle").value = data.fovAngle || 90;
            document.getElementById("fov-angle-value").textContent = (data.fovAngle || 90) + "¬∞";
            document.getElementById("fov-distance").value = data.fovDistance || 150;
            document.getElementById("fov-distance-value").textContent = data.fovDistance || 150;
            document.getElementById("fov-rotation").value = data.fovRotation || 0;
            document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
            document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
            document.getElementById("fov-animate").checked = data.fovAnimate || false;
            document.getElementById("fov-sweep").value = data.fovSweep || 120;
            document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
            document.getElementById("fov-speed").value = data.fovSpeed || 4;
            document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
          } else {
            fovSection.style.display = "none";
          }
        }
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        document.getElementById("fov-enabled").onchange = function() {
          if (!currentNodeId) return;
          pushUndo("toggle fov");
          NODE_DATA[currentNodeId].fovEnabled = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-angle").oninput = function() {
          document.getElementById("fov-angle-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-distance").oninput = function() {
          document.getElementById("fov-distance-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-rotation").oninput = function() {
          document.getElementById("fov-rotation-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-color").oninput = function() {
          if (!currentNodeId) return;
          pushUndo("change fov color");
          NODE_DATA[currentNodeId].fovColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-animate").onchange = function() {
          if (!currentNodeId) return;
          pushUndo("toggle fov animation");
          NODE_DATA[currentNodeId].fovAnimate = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-sweep").oninput = function() {
          document.getElementById("fov-sweep-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-speed").oninput = function() {
          document.getElementById("fov-speed-value").textContent = this.value + "s";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        const currentRotation = NODE_DATA[id].rotation || 0;
        document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
        document.getElementById("rotation-value").value = currentRotation;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          });
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           });
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        document.getElementById("edge-animate").checked = edge.animate === true;
        document.getElementById("edge-animation-style").value = edge.animationStyle || "";
        document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         });
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         });
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         });
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         });
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         });
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const rotationSlider = document.getElementById("rotation-slider");
       const rotationInput = document.getElementById("rotation-value");
       const resetRotationBtn = document.getElementById("reset-rotation");
       rotationSlider.addEventListener("input", () => {
         const newRotation = parseInt(rotationSlider.value, 10);
         rotationInput.value = newRotation;
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       rotationInput.addEventListener("input", () => {
         const newRotation = parseInt(rotationInput.value, 10) || 0;
         rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       resetRotationBtn.addEventListener("click", () => {
         pushUndo("reset rotation");
         NODE_DATA[currentNodeId].rotation = 0;
         rotationSlider.value = 0;
         rotationInput.value = 0;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
         }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };

       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
          fovSection.style.display = (shape === "camera" || shape === "cctv") ? "block" : "none";
        }
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animate").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animate");
        edge.animate = e.target.checked;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("animate-connections-toggle").addEventListener("change", (e) => {
        PAGE_STATE.animateConnections = e.target.checked;
        forgeTheTopology();
       });
       document.getElementById("animation-style-select").addEventListener("change", (e) => {
        PAGE_STATE.animationStyle = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-direction-select").addEventListener("change", (e) => {
        PAGE_STATE.animationDirection = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-speed-select").addEventListener("change", (e) => {
        PAGE_STATE.animationSpeed = parseFloat(e.target.value);
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("edge-animation-style").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation style");
        edge.animationStyle = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation speed");
        edge.animationSpeed = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         });
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchUpHandler);
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          });
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawToggleBtn.classList.add("done-btn-active");
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        drawToggleBtn.classList.remove("done-btn-active");
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        });
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.classList.add("done-btn-active");
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.classList.remove("done-btn-active");
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
        document.getElementById("text-rotation-val").value = textItem.rotation || 0;
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("text-rotation").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           textItem.rotation = parseInt(e.target.value) || 0;
           document.getElementById("text-rotation-val").value = textItem.rotation;
           forgeTheTopology();
         }
       });
       document.getElementById("text-rotation-val").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           const val = parseInt(e.target.value) || 0;
           textItem.rotation = val;
           document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
           forgeTheTopology();
         }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("animate-connections-toggle").checked = PAGE_STATE.animateConnections || false;
       document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
       document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
       document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        rebuildThemeDropdown();
        updateDeleteButton();
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.rackGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
		 pushUndo('import json');
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       savedStyleSets: savedStyleSets,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false,
        fovEnabled: source.fovEnabled || false,
        fovAngle: source.fovAngle || 90,
        fovDistance: source.fovDistance || 150,
        fovRotation: source.fovRotation || 0,
        fovColor: source.fovColor || "#f59e0b",
        fovAnimate: source.fovAnimate || false,
        fovSweep: source.fovSweep || 120,
        fovSpeed: source.fovSpeed || 4
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        });
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
        btn.style.display = select.value.startsWith("mytheme-") ? "block" : "none";
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.dropdown').forEach(dropdown => {
    const btn = dropdown.querySelector('.dropdown-btn');
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!btn || !menu) return;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.dropdown-menu.open').forEach(m => {
        if (m !== menu) m.classList.remove('open');
      });
      menu.classList.toggle('open');
    });
  });
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
    }
  });
  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
      }, 100);
    });
  });
  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
function printTopology() {
  const svg = document.getElementById('map');
  if (!svg) { window.print(); return; }
  const originalViewBox = svg.getAttribute('viewBox');
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  let hasContent = false;
  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode !== 'rack' && node.assignedRack) return;
    const size = savedSizes[id] || 50;
    hasContent = true;
    minX = Math.min(minX, pos.x - size);
    minY = Math.min(minY, pos.y - size);
    maxX = Math.max(maxX, pos.x + size);
    maxY = Math.max(maxY, pos.y + size);
  });
  RECT_DATA.list.forEach(rect => {
    hasContent = true;
    minX = Math.min(minX, rect.x);
    minY = Math.min(minY, rect.y);
    maxX = Math.max(maxX, rect.x + rect.width);
    maxY = Math.max(maxY, rect.y + rect.height);
  });
  TEXT_DATA.list.forEach(text => {
    hasContent = true;
    minX = Math.min(minX, text.x - 100);
    minY = Math.min(minY, text.y - 50);
    maxX = Math.max(maxX, text.x + 300);
    maxY = Math.max(maxY, text.y + 50);
  });
  EDGE_DATA.list.forEach(edge => {
    if (edge.points && edge.points.length > 0) {
      edge.points.forEach(p => {
        hasContent = true;
        minX = Math.min(minX, p.x - 10);
        minY = Math.min(minY, p.y - 10);
        maxX = Math.max(maxX, p.x + 10);
        maxY = Math.max(maxY, p.y + 10);
      });
    }
  });
  if (!hasContent) { window.print(); return; }
  const padding = 100;
  minX -= padding; minY -= padding; maxX += padding; maxY += padding;
  const width = maxX - minX;
  const height = maxY - minY;
  const grid = document.getElementById('canvas-grid');
  const gridDisplay = grid ? grid.style.display : '';
  if (grid) grid.style.display = 'none';
  svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  const originalWidth = svg.style.width;
  const originalHeight = svg.style.height;
  svg.style.width = '100%';
  svg.style.height = '100%';
  setTimeout(() => {
    window.print();
    setTimeout(() => {
      svg.setAttribute('viewBox', originalViewBox);
      svg.style.width = originalWidth;
      svg.style.height = originalHeight;
      if (grid) grid.style.display = gridDisplay;
    }, 500);
  }, 100);
}
function exportJSONFile() {
  const data = captureTheQuickening();
  const jsonStr = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
  a.download = `${safeTitle}.json`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent("export", `Exported JSON: ${a.download}`);
}
function exportCSV() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
  csv += `# Exported from The One File on ${timestamp}\n`;
  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
  csv += headers.join(',') + '\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
    const row = [
      csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
      node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
      csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
      node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
      node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
      size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
    ];
    csv += row.join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported CSV: ${a.download}`);
}
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const str = String(val);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}
document.getElementById('import-csv-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    const lines = text.split(/\r?\n/);
    let config = null;
    let dataLines = [];
    let headers = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
        try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
        continue;
      }
      if (trimmed.startsWith('#')) continue;
      if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
      dataLines.push(trimmed);
    }
    if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
    const nameIdx = headers.indexOf('name');
    if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
    const nodes = dataLines.map(line => {
      const values = parseCSVLine(line);
      const node = {};
      headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
      return node;
    });
    const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add';
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `‚Ä¢ ${nodes.length} nodes in CSV data\n` +
        `‚Ä¢ ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `‚Ä¢ ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
    if (hasConfig) {
      Object.assign(PAGE_STATE, config.pageState || config.page);
      if (config.canvasView || config.canvas) {
        const canvasConfig = config.canvasView || config.canvas;
        canvasState.zoom = canvasConfig.zoom || 1;
        canvasState.panX = canvasConfig.panX || 0;
        canvasState.panY = canvasConfig.panY || 0;
      }
      if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
      wieldThePower();
    }
    let gridX = 200, gridY = 200;
    const spacing = 150;
    const perRow = Math.ceil(Math.sqrt(nodes.length));
    let gridIndex = 0;
    nodes.forEach((n) => {
      let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!baseId) baseId = 'node';
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
      NODE_DATA[nodeId] = {
        name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
        tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
        notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
        layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
        uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
        isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
      };
      const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      if (hasPosition) {
        savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
      } else {
        const row = Math.floor(gridIndex / perRow);
        const col = gridIndex % perRow;
        savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
        gridIndex++;
      }
      if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
      if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
    });
    forgeTheTopology();
    updateViewBox();
    logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
    alert(`Successfully imported ${nodes.length} nodes`);
  } catch (err) {
    console.error('CSV import error:', err);
    alert('Failed to import CSV: ' + err.message);
  }
});
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
    else { current += char; }
  }
  result.push(current);
  return result;
}

function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
  md += `## Legend\n\n`;
  if (Object.keys(EDGE_LEGEND).length > 0) {
    Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
  } else { md += `_No legend entries_\n`; }
  md += '\n## Nodes\n\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] || null;
    md += `### ${id}\n`;
    md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
    md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
    md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
    md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
    md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
    md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
    md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
    if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
    if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
    md += '\n';
  });
  md += `## Connections\n\n`;
  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
    EDGE_DATA.list.forEach(edge => {
      const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
      const toPort = edge.toPort ? ` (${edge.toPort})` : '';
      md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
      md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
      md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
      md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
      md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
      if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
      if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No connections_\n\n`; }
  md += `## Zones\n\n`;
  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
    RECT_DATA.list.forEach(rect => {
      md += `### ${rect.id}\n`;
      md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
      md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
      md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
      if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No zones_\n\n`; }
  md += `## Text Labels\n\n`;
  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
    TEXT_DATA.list.forEach(text => {
      md += `### ${text.id}\n`;
      md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
      md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
      md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
      md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
      md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
      md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
    });
  } else { md += `_No text labels_\n\n`; }
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.md`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported Markdown: ${a.download}`);
}

document.getElementById('import-markdown-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
      } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
  } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
  }
});

document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-export-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-import-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
});
document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
});	  
    </script>
</body></html>