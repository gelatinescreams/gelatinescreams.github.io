<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
		pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      function searchNodes(query) {
   if (!query) {
    clearSearchHighlight();
    return [];
   }
   query = query.toLowerCase();
   const results = [];
   Object.entries(NODE_DATA).forEach(([id, data]) => {
    try {
     const nameMatch = data.name && data.name.toLowerCase().includes(query);
     const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
     const roleMatch = data.role && data.role.toLowerCase().includes(query);
     const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
     const macMatch = data.mac && data.mac.toLowerCase().includes(query);
     const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
     if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
      results.push(id);
     }
    } catch (e) {
     console.warn("Search error for node:", id, e);
    }
   });
   highlightSearchResults(results);
   return results;
}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
if (searchInput) {
 searchInput.addEventListener("input", (e) => {
  searchNodes(e.target.value);
 });
}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()">${escapeHtml(e.fromPort) || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()">${escapeHtml(e.toPort) || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        pushUndo("clear all");
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      stopAutoPing();
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>