<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
	  .toggle-switch{position:relative;display:inline-block;min-width:44px !important;height:24px;flex-shrink:0;vertical-align:middle;}
		.toggle-switch input{opacity:0;width:0;height:0;position:absolute;}
		.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#475569;transition:.25s;border-radius:24px;}
		.toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#e2e8f0;transition:.25s;border-radius:50%;}
		.toggle-switch input:checked+.toggle-slider{background:var(--accent);}
		.toggle-switch input:checked+.toggle-slider:before{transform:translateX(20px);}
		.anim-zone-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;}
		.anim-zone-row label{color:var(--text-main);font-size:14px;}
		.anim-zone-section{font-size:11px;color:var(--text-soft);margin:12px 0 6px;text-transform:uppercase;letter-spacing:0.05em;border-bottom:1px solid var(--edge-main);padding-bottom:4px;}
		.anim-zone-header{font-size:12px;color:var(--accent);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.05em;font-weight:600;}
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
	  .fov-group {
        transition: opacity 0.3s ease;
      }
      g[data-node-id]:not(:hover) .fov-group {
        opacity: 0.7;
      }
      g[data-node-id]:hover .fov-group {
        opacity: 1;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 8px;
      fill: none;
      }
      .minimap-wall {
      pointer-events: none;
      }
      .minimap-rect {
      pointer-events: none;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      pointer-events: auto;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
      .style-row {
      display: contents;
      }
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }

.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}

@media print {
  @page {
    size: landscape;
    margin: 0.5cm;
  }
  html, body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: visible !important;
  }
  body * {
    visibility: hidden;
  }
  #canvas-viewport,
  #canvas-viewport *,
  #map,
  #map * {
    visibility: visible;
  }
  #canvas-viewport {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100vw !important;
    height: 100vh !important;
    overflow: visible !important;
  }
  #map {
    position: absolute !important;
    left: 0 !important;
    top: 0 !important;
    width: 100% !important;
    height: 100% !important;
    background: white !important;
    background-image: none !important;
  }
  #canvas-grid {
    display: none !important;
  }
  main, .topology-panel {
    display: block !important;
    position: static !important;
    overflow: visible !important;
  }

  #map circle[class*="node"],
  #map .node-shape,
  #map .node-group circle,
  #map .node-group rect,
  #map .node-group path,
  #map .node-group polygon {
    fill: white !important;
    stroke: #000 !important;
    stroke-width: 2px !important;
  }

  #map text {
    fill: #000 !important;
    stroke: none !important;
  }
  #map .edge,
  #map polyline,
  #map line:not([class*="grid"]) {
    stroke: #333 !important;
  }
  #map .rect-group rect {
    stroke: #333 !important;
  }
  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
  .draw-toolbar, .topology-toolbar, .legend-container,
  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
    display: none !important;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                  <option value="defaulted">Default</option>
                  <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
              </div>
            </div>
			<div class="style-row">
			 <label>  
			  <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save Custom Theme</button>
			 </label>
			  <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding: 4px 8px; background: var(--danger); color: rgb(255, 255, 255); border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: block;" disabled="">Delete Custom Theme</button>
			</div>
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
			<div class="style-row">
              <label>Tag(s) Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Tag(s) Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Tag(s) Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="canvas-grid-enabled" checked="">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Show Grid</label>
              <input type="checkbox" id="rack-grid-enabled" checked="">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Animations &amp; Zones</summary>
          <div class="style-content">
            <div class="style-row"><label>All Animations</label><label class="toggle-switch"><input type="checkbox" id="anim-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Type</div>
            <div class="style-row"><label>Sweep (Pan)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-sweep" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Pulse (Breathe)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-pulse" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Rings (Emanate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-rings" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Spin (Rotate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-spin" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections (Flow)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:12px;color:var(--accent);text-transform:uppercase;letter-spacing:0.05em;font-weight:600;margin-top:16px;padding-top:12px;border-top:1px solid var(--edge-main);">Zone (Animation Cone) Setings</div>
            <div class="style-row"><label>All Zones</label><label class="toggle-switch"><input type="checkbox" id="zone-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
           <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">üîí</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ‚ñæ</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-data-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <span style="border-left: 1px solid var(--edge-main); height: 20px; margin: 0 4px;"></span>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
            <option value="wall">Wall</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-zone-copy" title="Copy zone style">üì° Copy Zone</button>
          <button id="bulk-zone-paste" title="Paste zone style">üì° Paste Zone</button>
          <button id="bulk-zone-toggle" title="Toggle zones on selected">üì° Toggle Zones</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--edge-main);">
            <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em;">Coverage Zones</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
              <button id="bulk-zone-copy-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Copy Zone</span></button>
              <button id="bulk-zone-paste-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Paste Zone</span></button>
              <button id="bulk-zone-toggle-mobile" class="bulk-action-btn">üì°<br><span style="font-size: 12px;">Toggle Zones</span></button>
            </div>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint" style="cursor: pointer;"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-5.584863670202822 -99.90831573327841 4031.4509771376233 3023.5882328532175" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-5.584863670202822" y="-99.90831573327841" width="4031.4509771376233" height="3023.5882328532175"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">99%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Connection &amp; Zone Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Connection</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="fov-section" style="display: block; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Coverage Zone</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Preset:</label>
                <select id="fov-preset" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                  <option value="">-- Apply Preset --</option>
                  <option value="security-cam">Security Camera</option>
                  <option value="ptz-cam">PTZ Camera</option>
                  <option value="motion-detect">Motion Detector</option>
                  <option value="wifi-strong">WiFi</option>
                  <option value="wifi-extended">WiFi Extender</option>
                  <option value="smoke-alarm">Smoke Alarm</option>
                  <option value="sprinkler-arc">Sprinkler Arc</option>
                </select>
                <button id="fov-save-preset" title="Save as preset" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üíæ</button>
                <button id="fov-copy-style" title="Copy zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üìã</button>
                <button id="fov-paste-style" title="Paste zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">üì•</button>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Show Zone:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">360¬∞</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">200</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Inner Radius:</label>
                <input type="range" id="fov-inner-radius" min="0" max="200" value="0" style="flex: 1;">
                <span id="fov-inner-radius-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0¬∞</span>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Fill</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-opacity" min="5" max="80" value="20" style="flex: 1;">
                  <span id="fov-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">20%</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Gradient:</label>
                  <input type="checkbox" id="fov-gradient" style="width: 18px; height: 18px; cursor: pointer;">
                  <span style="color: var(--text-soft); font-size: 12px; margin-left: 8px;">Fade toward edge</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Border</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-border-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Width:</label>
                  <input type="range" id="fov-border-width" min="0" max="10" value="2" style="flex: 1;">
                  <span id="fov-border-width-value" style="min-width: 40px; text-align: right; color: var(--text-main);">2</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Style:</label>
                  <select id="fov-border-style" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-border-opacity" min="0" max="100" value="100" style="flex: 1;">
                  <span id="fov-border-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">100%</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Label</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Text:</label>
                  <input type="text" id="fov-label" placeholder="e.g. Detection Zone" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Position:</label>
                  <select id="fov-label-position" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="center">Center</option>
                    <option value="edge">Edge</option>
                    <option value="outside">Outside</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Size:</label>
                  <input type="range" id="fov-label-size" min="8" max="32" value="14" style="flex: 1;">
                  <span id="fov-label-size-value" style="min-width: 40px; text-align: right; color: var(--text-main);">14px</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Color:</label>
                  <input type="color" id="fov-label-color" value="#ffffff" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Bold:</label>
                  <input type="checkbox" id="fov-label-bold" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Background:</label>
                  <input type="checkbox" id="fov-label-bg" style="width: 18px; height: 18px; cursor: pointer;">
                  <input type="color" id="fov-label-bg-color" value="#000000" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; margin-left: 8px;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset X:</label>
                  <input type="range" id="fov-label-offset-x" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-x-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset Y:</label>
                  <input type="range" id="fov-label-offset-y" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-y-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Animation</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Type:</label>
                  <select id="fov-animation-type" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="sweep">Sweep (Pan)</option>
                    <option value="pulse">Pulse (Breathe)</option>
                    <option value="rings">Rings (Emanate)</option>
                    <option value="spin">Spin (Rotate)</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120¬∞</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">127</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          <optgroup label="Smart Home">
            <option value="thermostat">Thermostat</option>
            <option value="doorbell">Video Doorbell</option>
            <option value="smart-lock">Smart Lock</option>
            <option value="smart-bulb">Smart Bulb</option>
            <option value="smart-plug">Smart Plug</option>
            <option value="smart-speaker">Smart Speaker</option>
            <option value="smart-tv">Smart TV</option>
            <option value="hub">Smart Hub</option>
            <option value="smoke-detector">Smoke Detector</option>
            <option value="motion-sensor">Motion Sensor</option>
            <option value="garage">Garage Door</option>
            <option value="sprinkler">Sprinkler</option>
            <option value="vacuum">Robot Vacuum</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
              <option value="wall">Wall</option>
            </select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">¬∞</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
        if (key.startsWith('icon-')) {
          localStorage.removeItem(key);
        }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       data.ping.responseTime = null;
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       const timeout = data.ping.timeout || 3000;
       const startTime = performance.now();
       try {
        const result = await Promise.race([
         new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve('online');
          img.onerror = () => resolve('check-fetch');
          img.src = `${url}/favicon.ico?_=${Date.now()}`;
         }),
         new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
        ]);
        if (result === 'check-fetch') {
         await Promise.race([
          fetch(url, { method: 'HEAD', mode: 'no-cors' }),
          new Promise((_, reject) => setTimeout(() => reject(new Error('timeout')), timeout))
         ]);
        }
        data.ping.status = 'online';
        data.ping.responseTime = Math.round(performance.now() - startTime);
       } catch (error) {
        data.ping.status = 'offline';
        data.ping.responseTime = null;
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      async function checkAllNodesStatus() {
       const nodesToCheck = Object.keys(NODE_DATA).filter(nodeId => {
        const data = NODE_DATA[nodeId];
        return data && data.ping && data.ping.enabled;
       });
       const batchSize = 5;
       for (let i = 0; i < nodesToCheck.length; i += batchSize) {
        const batch = nodesToCheck.slice(i, i + batchSize);
        await Promise.all(batch.map(nodeId => checkNodeStatus(nodeId)));
       }
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         zoneLegend: ZONE_LEGEND,
         zonePresets: ZONE_PRESETS,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            ZONE_LEGEND = saved.zoneLegend || {};
            ZONE_PRESETS = saved.zonePresets || {};
            loadCustomPresets();
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       canvasGridEnabled: true,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
       rackGridEnabled: true,
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  let ZONES_VISIBLE = true;
const ANIM_SETTINGS = {
  masterAnim: true,
  masterZones: true,
  animTypes: { sweep: true, pulse: true, rings: true, spin: true, connections: true },
  animCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true, connections: true },
  zoneCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true }
};
function getShapeCategory(shape) {
  const map = {
    "camera": "camera", "cctv": "camera", "ptz-cam": "camera",
    "doorbell": "doorbell",
    "motion-sensor": "motion", "motion-detect": "motion",
    "smoke-detector": "smoke", "smoke-alarm": "smoke",
    "access-point": "wifi", "wifi": "wifi", "router": "wifi", "wifi-strong": "wifi", "wifi-weak": "wifi",
    "sensor": "sensor", "iot": "sensor",
    "sprinkler": "sprinkler", "sprinkler-arc": "sprinkler"
  };
  return map[shape] || null;
}
function isAnimationAllowed(shape, animType) {
  if (!ANIM_SETTINGS.masterAnim) return false;
  if (!ANIM_SETTINGS.animTypes[animType]) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.animCategories[cat]) return false;
  return true;
}
function isZoneAllowed(shape) {
  if (!ANIM_SETTINGS.masterZones) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.zoneCategories[cat]) return false;
  return true;
}
function applyAnimZoneSettings() {
  document.querySelectorAll(".fov-group").forEach(g => {
    const nodeEl = g.closest("g[data-node-id]");
    if (!nodeEl) return;
    const nodeId = nodeEl.dataset.nodeId;
    const node = NODE_DATA[nodeId];
    if (!node) return;
    const cat = getShapeCategory(node.shape);
    const zoneVisible = ANIM_SETTINGS.masterZones && (!cat || ANIM_SETTINGS.zoneCategories[cat]);
    g.style.display = zoneVisible ? "" : "none";
    if (zoneVisible && node.fovAnimate) {
      const animType = node.fovAnimationType || "sweep";
      const animAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes[animType] && (!cat || ANIM_SETTINGS.animCategories[cat]);
      g.style.animationPlayState = animAllowed ? "running" : "paused";
      g.querySelectorAll("circle").forEach(c => c.style.animationPlayState = animAllowed ? "running" : "paused");
    }
  });
  const connAnimAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes.connections && ANIM_SETTINGS.animCategories.connections;
  document.querySelectorAll(".edge-arrow-forward, .edge-arrow-backward").forEach(a => {
    a.style.animationPlayState = connAnimAllowed ? "running" : "paused";
  });
}
let ZONE_LEGEND = {};
let ZONE_PRESETS = {};
let copiedZoneStyle = null;

function hasCoverageZone(shape) {
  const supportedShapes = [
    "camera", "cctv", "doorbell",
    "motion-sensor", "smoke-detector",
    "access-point", "wifi", "router",
    "sensor", "iot", "sprinkler"
  ];
  return supportedShapes.includes(shape);
}

function getCoverageDefaults(shape) {
  const defaults = {
    "camera": { angle: 90, distance: 150, animationType: "sweep" },
    "cctv": { angle: 90, distance: 150, animationType: "sweep" },
    "doorbell": { angle: 120, distance: 100, animationType: "sweep" },
    "motion-sensor": { angle: 120, distance: 100, animationType: "pulse" },
    "smoke-detector": { angle: 360, distance: 80, animationType: "pulse" },
    "access-point": { angle: 360, distance: 200, animationType: "rings" },
    "wifi": { angle: 360, distance: 200, animationType: "rings" },
    "router": { angle: 360, distance: 200, animationType: "rings" },
    "sensor": { angle: 90, distance: 100, animationType: "pulse" },
    "iot": { angle: 90, distance: 100, animationType: "pulse" },
    "sprinkler": { angle: 90, distance: 120, animationType: "spin" }
  };
  return defaults[shape] || { angle: 90, distance: 150, animationType: "sweep" };
}

function toggleAllZones() {
  ANIM_SETTINGS.masterZones = !ANIM_SETTINGS.masterZones;
  const masterCheckbox = document.getElementById("zone-master");
  if (masterCheckbox) masterCheckbox.checked = ANIM_SETTINGS.masterZones;
  applyAnimZoneSettings();
}

function copyZoneStyle(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return false;
  if (!hasCoverageZone(node.shape)) {
    alert("This node type doesn't support coverage zones");
    return false;
  }
  copiedZoneStyle = {
    fovEnabled: node.fovEnabled,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovRotation: node.fovRotation,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovLabel: node.fovLabel,
    fovLabelPosition: node.fovLabelPosition,
    fovLabelSize: node.fovLabelSize,
    fovLabelColor: node.fovLabelColor,
    fovLabelBold: node.fovLabelBold,
    fovLabelBg: node.fovLabelBg,
    fovLabelBgColor: node.fovLabelBgColor,
    fovLabelOffsetX: node.fovLabelOffsetX,
    fovLabelOffsetY: node.fovLabelOffsetY,
    fovAnimate: node.fovAnimate,
    fovAnimationType: node.fovAnimationType,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  return true;
}

function pasteZoneStyle(nodeId) {
  if (!copiedZoneStyle) {
    alert("No zone style copied. Copy a zone style first.");
    return false;
  }
  const node = NODE_DATA[nodeId];
  if (!node) return false;
  if (!hasCoverageZone(node.shape)) {
    alert("This node type doesn't support coverage zones");
    return false;
  }
  pushUndo("paste zone style");
  Object.assign(node, copiedZoneStyle);
  updateFovCone(nodeId);
  return true;
}

function applyZonePreset(preset) {
  if (!currentNodeId) return;
  const presets = {
    "security-cam": { fovEnabled: true, fovAngle: 90, fovDistance: 150, fovColor: "#f59e0b", fovOpacity: 20, fovAnimationType: "sweep", fovAnimate: false },
    "ptz-cam": { fovEnabled: true, fovAngle: 60, fovDistance: 200, fovColor: "#f59e0b", fovOpacity: 25, fovAnimationType: "sweep", fovAnimate: true, fovSweep: 180, fovSpeed: 8 },
    "motion-detect": { fovEnabled: true, fovAngle: 120, fovDistance: 100, fovColor: "#10b981", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: true, fovSpeed: 3 },
    "wifi-strong": { fovEnabled: true, fovAngle: 360, fovDistance: 150, fovColor: "#3b82f6", fovOpacity: 10, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 4 },
    "wifi-extended": { fovEnabled: true, fovAngle: 360, fovDistance: 250, fovColor: "#3b82f6", fovOpacity: 8, fovGradient: true, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 5 },
    "smoke-alarm": { fovEnabled: true, fovAngle: 360, fovDistance: 80, fovColor: "#ef4444", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: false },
    "sprinkler-arc": { fovEnabled: true, fovAngle: 90, fovDistance: 120, fovColor: "#06b6d4", fovOpacity: 20, fovAnimationType: "spin", fovAnimate: true, fovSpeed: 6 }
  };
  const allPresets = { ...presets, ...ZONE_PRESETS };
  const settings = allPresets[preset];
  if (!settings) return;
  pushUndo("apply zone preset");
  Object.assign(NODE_DATA[currentNodeId], settings);
  updateFovCone(currentNodeId);
  claimTheImmortal(currentNodeId);
}

function saveCustomZonePreset() {
  if (!currentNodeId) return;
  const node = NODE_DATA[currentNodeId];
  if (!node.fovEnabled) {
    alert("Enable the zone first before saving as preset");
    return;
  }
  const name = prompt("Enter preset name:");
  if (!name || !name.trim()) return;
  const presetId = "custom-" + name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
  ZONE_PRESETS[presetId] = {
    fovEnabled: true,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovAnimationType: node.fovAnimationType,
    fovAnimate: node.fovAnimate,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  const select = document.getElementById("fov-preset");
  if (select && !select.querySelector(`option[value="${presetId}"]`)) {
    const opt = document.createElement("option");
    opt.value = presetId;
    opt.textContent = name.trim() + " ‚òÖ";
    select.appendChild(opt);
  }
  alert("Preset saved: " + name.trim());
}

function bulkCopyZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select at least one node first");
    return;
  }
  const firstId = [...selectedNodes][0];
  if (copyZoneStyle(firstId)) {
    alert("Zone style copied from first selected node");
  }
}

function bulkPasteZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  if (!copiedZoneStyle) {
    alert("Copy a zone style first");
    return;
  }
  pushUndo("bulk paste zone style");
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      Object.assign(node, copiedZoneStyle);
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Zone style pasted to ${count} node(s)`);
}

function bulkToggleZones() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  pushUndo("bulk toggle zones");
  const firstNode = NODE_DATA[[...selectedNodes][0]];
  const newState = !(firstNode?.fovEnabled);
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      node.fovEnabled = newState;
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Toggled zones on ${count} node(s) to ${newState ? 'ON' : 'OFF'}`);
}

function loadCustomPresets() {
  const select = document.getElementById("fov-preset");
  if (!select) return;
  Object.keys(ZONE_PRESETS).forEach(id => {
    if (!select.querySelector(`option[value="${id}"]`)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id.replace(/-/g, " ").replace("custom ", "") + " ‚òÖ";
      select.appendChild(opt);
    }
  });
}

function updateZoneLegend() {
  const container = document.getElementById("edge-legend");
  if (!container) return;
  container.querySelectorAll(".zone-legend-item").forEach(el => el.remove());
  container.querySelectorAll(".zone-legend-title").forEach(el => el.remove());
  const zoneColors = new Set();
  Object.values(NODE_DATA).forEach(node => {
    if (hasCoverageZone(node.shape) && node.fovEnabled && node.fovColor) {
      zoneColors.add(node.fovColor);
    }
  });
  
  if (zoneColors.size === 0) return;
  const zoneTitle = document.createElement("div");
  zoneTitle.className = "legend-title zone-legend-title";
  zoneTitle.textContent = "Zone Legend";
  zoneTitle.style.marginTop = "12px";
  zoneTitle.style.paddingTop = "8px";
  zoneTitle.style.borderTop = "1px solid var(--edge-main)";
  container.appendChild(zoneTitle);
  zoneColors.forEach(color => {
    if (!ZONE_LEGEND[color]) {
      ZONE_LEGEND[color] = "Coverage Zone";
    }
    const item = document.createElement("div");
    item.className = "legend-item zone-legend-item";
    item.addEventListener("mousedown", (e) => e.stopPropagation());
    item.addEventListener("click", (e) => e.stopPropagation());
    
    const swatch = document.createElement("span");
    swatch.className = "legend-swatch";
    swatch.style.backgroundColor = color;
    swatch.style.opacity = "0.5";
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", (e) => {
      e.stopPropagation();
      const nodeWithColor = Object.entries(NODE_DATA).find(([id, n]) => 
        hasCoverageZone(n.shape) && n.fovEnabled && n.fovColor === color
      );
      if (nodeWithColor) {
        claimTheImmortal(nodeWithColor[0]);
      }
    });
    
    const label = document.createElement("span");
    label.className = "legend-label";
    label.textContent = ZONE_LEGEND[color];
    label.contentEditable = true;
    label.addEventListener("focus", () => label.classList.add("editing"));
    label.addEventListener("blur", () => {
      label.classList.remove("editing");
      ZONE_LEGEND[color] = label.textContent.trim() || "Coverage Zone";
    });
    label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        label.blur();
      }
    });
    
    item.append(swatch, label);
    container.appendChild(item);
  });
  
  updateLegendVisibility();
}
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          const fovSection = document.getElementById("fov-section");
          if (fovSection) {
            if (hasCoverageZone(data.shape)) {
              fovSection.style.display = "block";
              const defaults = getCoverageDefaults(data.shape);
              document.getElementById("fov-enabled").checked = data.fovEnabled || false;
              document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
              document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "¬∞";
              document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
              document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
              document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
              document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
              document.getElementById("fov-rotation").value = data.fovRotation || 0;
              document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
              document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
              document.getElementById("fov-opacity").value = data.fovOpacity || 20;
              document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
              document.getElementById("fov-gradient").checked = data.fovGradient || false;
              document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
              document.getElementById("fov-border-width").value = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
              document.getElementById("fov-border-opacity").value = data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100;
              document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100) + "%";
              document.getElementById("fov-label").value = data.fovLabel || "";
              document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
              document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
              document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
              document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
              document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
              document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
              document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
              document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
              document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
              document.getElementById("fov-animate").checked = data.fovAnimate || false;
              document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
              document.getElementById("fov-sweep").value = data.fovSweep || 120;
              document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
              document.getElementById("fov-speed").value = data.fovSpeed || 4;
              document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
            } else {
              fovSection.style.display = "none";
            }
          }
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge, .minimap-wall, .minimap-rect").forEach(el => el.remove());
  const frag = document.createDocumentFragment();
  const ns = "http://www.w3.org/2000/svg";
  const dotColor = PAGE_STATE.minimapDots || "#94a3b8";

  if (RECT_DATA && RECT_DATA.list && currentView.mode !== "rack") {
    RECT_DATA.list.forEach((rect) => {
      if (rect.lineStyle === "wall") {
        const wallRect = document.createElementNS(ns, "rect");
        wallRect.setAttribute("x", rect.x);
        wallRect.setAttribute("y", rect.y);
        wallRect.setAttribute("width", rect.width);
        wallRect.setAttribute("height", rect.height);
        wallRect.style.fill = rect.color || "#666";
        wallRect.style.fillOpacity = "0.6";
        wallRect.style.stroke = rect.borderColor || rect.color || "#666";
        wallRect.style.strokeWidth = "4";
        wallRect.classList.add("minimap-wall");
        frag.appendChild(wallRect);
      }
    });
  }

  EDGE_DATA.list.forEach((edge) => {
    if (edge.type === "custom") {
      if (Array.isArray(edge.points) && edge.points.length >= 2) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", edge.points.map(p => `${p.x},${p.y}`).join(" "));
        polyline.classList.add("minimap-edge");
        frag.appendChild(polyline);
      }
      return;
    }
    const fromNode = NODE_DATA[edge.from];
    const toNode = NODE_DATA[edge.to];
    if (!fromNode || !toNode) return;
    if (currentView.mode === "rack") {
      if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
    } else {
      if (fromNode.assignedRack || toNode.assignedRack) return;
    }
    const p1 = savedPositions[edge.from];
    const p2 = savedPositions[edge.to];
    if (!p1 || !p2) return;
    const routing = edge.routing || PAGE_STATE.defaultEdgeRouting || "curved";
    
    if (routing === "orthogonal") {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const polyline = document.createElementNS(ns, "polyline");
      let points;
      if (Math.abs(dx) > Math.abs(dy)) {
        const midX = p1.x + dx / 2;
        points = `${p1.x},${p1.y} ${midX},${p1.y} ${midX},${p2.y} ${p2.x},${p2.y}`;
      } else {
        const midY = p1.y + dy / 2;
        points = `${p1.x},${p1.y} ${p1.x},${midY} ${p2.x},${midY} ${p2.x},${p2.y}`;
      }
      polyline.setAttribute("points", points);
      polyline.classList.add("minimap-edge");
      frag.appendChild(polyline);
    } else {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);
      line.classList.add("minimap-edge");
      frag.appendChild(line);
    }
  });

  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode === "rack") {
      if (node.assignedRack !== currentView.rackId) return;
    } else {
      if (node.assignedRack) return;
    }
    const nodeSize = savedSizes[id] || 55;
    const s = nodeSize * 0.5;
    
    if (node.isRack) {
      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", pos.x - s);
      rect.setAttribute("y", pos.y - s);
      rect.setAttribute("width", s * 2);
      rect.setAttribute("height", s * 2);
      rect.style.fill = dotColor;
      rect.classList.add("minimap-node");
      frag.appendChild(rect);
    } else if (hasCoverageZone(node.shape)) {
      const diamond = document.createElementNS(ns, "polygon");
      const points = `${pos.x},${pos.y - s} ${pos.x + s},${pos.y} ${pos.x},${pos.y + s} ${pos.x - s},${pos.y}`;
      diamond.setAttribute("points", points);
      diamond.style.fill = "none";
      diamond.style.stroke = dotColor;
      diamond.style.strokeWidth = "6";
      diamond.classList.add("minimap-node");
      frag.appendChild(diamond);
    } else {
      const circle = document.createElementNS(ns, "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", s);
      circle.style.fill = dotColor;
      circle.classList.add("minimap-node");
      frag.appendChild(circle);
    }
  });

  minimapSvg.insertBefore(frag, minimapViewport);
}
	  
	  
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         MobileManager.updateCanvasHint();
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72¬∞";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const lockBody = document.createElementNS(ns, "rect");
        lockBody.setAttribute("x", -size * 0.6);
        lockBody.setAttribute("y", -size * 0.15);
        lockBody.setAttribute("width", size * 1.2);
        lockBody.setAttribute("height", size * 1);
        lockBody.setAttribute("rx", 4);
        g.appendChild(lockBody);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const plugBody = document.createElementNS(ns, "rect");
        plugBody.setAttribute("x", -size * 0.7);
        plugBody.setAttribute("y", -size * 0.6);
        plugBody.setAttribute("width", size * 1.4);
        plugBody.setAttribute("height", size * 1.2);
        plugBody.setAttribute("rx", 6);
        g.appendChild(plugBody);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const speakerBody = document.createElementNS(ns, "rect");
        speakerBody.setAttribute("x", -size * 0.6);
        speakerBody.setAttribute("y", -size);
        speakerBody.setAttribute("width", size * 1.2);
        speakerBody.setAttribute("height", size * 2);
        speakerBody.setAttribute("rx", size * 0.3);
        g.appendChild(speakerBody);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const hubBody = document.createElementNS(ns, "rect");
        hubBody.setAttribute("x", -size * 0.9);
        hubBody.setAttribute("y", -size * 0.5);
        hubBody.setAttribute("width", size * 1.8);
        hubBody.setAttribute("height", size);
        hubBody.setAttribute("rx", 8);
        g.appendChild(hubBody);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const vacBody = document.createElementNS(ns, "circle");
        vacBody.setAttribute("r", size);
        g.appendChild(vacBody);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function updateFovCone(nodeId) {
        const node = NODE_DATA[nodeId];
        if (!node) return;
        
        const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
        if (!nodeGroup) return;
        const existingFov = nodeGroup.querySelector(".fov-group");
        if (existingFov) existingFov.remove();
        if (!hasCoverageZone(node.shape) || !node.fovEnabled) return;
        
        const ns = "http://www.w3.org/2000/svg";
        const defaults = getCoverageDefaults(node.shape);
        const fovAngle = node.fovAngle || defaults.angle;
        const fovDistance = node.fovDistance || defaults.distance;
        const fovInnerRadius = node.fovInnerRadius || 0;
        const fovRotation = node.fovRotation || 0;
        const fovColor = node.fovColor || "#f59e0b";
        const fovOpacity = node.fovOpacity || 20;
        const fovGradient = node.fovGradient || false;
        const fovBorderColor = node.fovBorderColor || "#f59e0b";
        const fovBorderWidth = node.fovBorderWidth ?? 2;
        const fovBorderStyle = node.fovBorderStyle || "solid";
        const fovBorderOpacity = node.fovBorderOpacity ?? 100;
        const fovLabel = node.fovLabel || "";
        const fovAnimate = node.fovAnimate || false;
        const fovAnimationType = node.fovAnimationType || defaults.animationType;
        const fovSweep = node.fovSweep || 120;
        const fovSpeed = node.fovSpeed || 4;
        
        const fovGroup = document.createElementNS(ns, "g");
        fovGroup.classList.add("fov-group");
        if (!ZONES_VISIBLE) fovGroup.style.display = "none";
        
        if (fovGradient) {
          const gradientId = `fov-gradient-${nodeId}`;
          const defs = document.createElementNS(ns, "defs");
          const gradient = document.createElementNS(ns, "radialGradient");
          gradient.id = gradientId;
          gradient.setAttribute("cx", "0");
          gradient.setAttribute("cy", "0");
          gradient.setAttribute("r", fovDistance);
          gradient.setAttribute("gradientUnits", "userSpaceOnUse");
          const stop1 = document.createElementNS(ns, "stop");
          stop1.setAttribute("offset", fovInnerRadius / fovDistance);
          stop1.setAttribute("stop-color", fovColor);
          stop1.setAttribute("stop-opacity", fovOpacity / 100);
          const stop2 = document.createElementNS(ns, "stop");
          stop2.setAttribute("offset", "1");
          stop2.setAttribute("stop-color", fovColor);
          stop2.setAttribute("stop-opacity", "0");
          gradient.appendChild(stop1);
          gradient.appendChild(stop2);
          defs.appendChild(gradient);
          fovGroup.appendChild(defs);
        }
        
        const fovPath = document.createElementNS(ns, "path");
        
        if (fovAngle >= 360) {
          if (fovInnerRadius > 0) {
            fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
            fovPath.setAttribute("fill-rule", "evenodd");
          } else {
            fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
          }
        } else {
          const angleRad = (fovAngle * Math.PI) / 180;
          const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
          const startAngle = rotationRad - angleRad / 2;
          const endAngle = rotationRad + angleRad / 2;
          const x1 = Math.cos(startAngle) * fovDistance;
          const y1 = Math.sin(startAngle) * fovDistance;
          const x2 = Math.cos(endAngle) * fovDistance;
          const y2 = Math.sin(endAngle) * fovDistance;
          const largeArc = fovAngle > 180 ? 1 : 0;
          if (fovInnerRadius > 0) {
            const ix1 = Math.cos(startAngle) * fovInnerRadius;
            const iy1 = Math.sin(startAngle) * fovInnerRadius;
            const ix2 = Math.cos(endAngle) * fovInnerRadius;
            const iy2 = Math.sin(endAngle) * fovInnerRadius;
            fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
          } else {
            fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
          }
        }
        
        if (fovGradient) {
          fovPath.style.fill = `url(#fov-gradient-${nodeId})`;
        } else {
          const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
          fovPath.style.fill = fovColor + opacityHex;
        }
        
        const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
        fovPath.style.stroke = fovBorderColor + borderOpacityHex;
        fovPath.style.strokeWidth = fovBorderWidth;
        if (fovBorderStyle === "dashed") {
          fovPath.style.strokeDasharray = "10,5";
        } else if (fovBorderStyle === "dotted") {
          fovPath.style.strokeDasharray = "3,3";
        }
        fovPath.style.pointerEvents = "none";
        fovPath.classList.add("fov-cone");
        
        fovGroup.appendChild(fovPath);
        
        if (fovLabel) {
          const fovLabelPosition = node.fovLabelPosition || "center";
          const fovLabelSize = node.fovLabelSize || 14;
          const fovLabelColor = node.fovLabelColor || "#ffffff";
          const fovLabelBold = node.fovLabelBold || false;
          const fovLabelBg = node.fovLabelBg || false;
          const fovLabelBgColor = node.fovLabelBgColor || "#000000";
          let labelDistance;
          if (fovLabelPosition === "center") {
            labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
          } else if (fovLabelPosition === "edge") {
            labelDistance = fovDistance * 0.75;
          } else {
            labelDistance = fovDistance + fovLabelSize + 8;
          }
          const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
          const fovLabelOffsetX = node.fovLabelOffsetX || 0;
          const fovLabelOffsetY = node.fovLabelOffsetY || 0;
          const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
          const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
          if (fovLabelBg) {
            const bgRect = document.createElementNS(ns, "rect");
            const textWidth = fovLabel.length * fovLabelSize * 0.6;
            const textHeight = fovLabelSize * 1.4;
            bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
            bgRect.setAttribute("y", labelY - textHeight / 2);
            bgRect.setAttribute("width", textWidth + 12);
            bgRect.setAttribute("height", textHeight);
            bgRect.setAttribute("rx", "4");
            bgRect.style.fill = fovLabelBgColor;
            bgRect.style.opacity = "0.8";
            bgRect.style.pointerEvents = "none";
            fovGroup.appendChild(bgRect);
          }
          const labelEl = document.createElementNS(ns, "text");
          labelEl.setAttribute("x", labelX);
          labelEl.setAttribute("y", labelY);
          labelEl.setAttribute("text-anchor", "middle");
          labelEl.setAttribute("dominant-baseline", "middle");
          labelEl.style.fill = fovLabelColor;
          labelEl.style.fontSize = fovLabelSize + "px";
          labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
          labelEl.style.fontFamily = "system-ui, sans-serif";
          labelEl.style.pointerEvents = "none";
          labelEl.textContent = fovLabel;
          fovGroup.appendChild(labelEl);
        }
        
        if (fovAnimate) {
          const animationName = `fov-anim-${nodeId}`;
          const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
          
          if (fovAnimationType === "sweep" && fovAngle < 360) {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0%, 100% { transform: rotate(0deg); }
                50% { transform: rotate(${fovSweep}deg); }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
            fovGroup.style.transformOrigin = "0 0";
          } else if (fovAnimationType === "pulse") {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0%, 100% { transform: scale(1); opacity: 1; }
                50% { transform: scale(1.1); opacity: 0.7; }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
            fovGroup.style.transformOrigin = "0 0";
          } else if (fovAnimationType === "rings") {
            for (let i = 1; i <= 3; i++) {
              const ring = document.createElementNS(ns, "circle");
              ring.setAttribute("cx", "0");
              ring.setAttribute("cy", "0");
              ring.setAttribute("r", fovDistance * 0.3 * i);
              ring.style.fill = "none";
              ring.style.stroke = fovBorderColor;
              ring.style.strokeWidth = "2";
              ring.style.opacity = "0";
              const ringAnimName = `${animationName}-ring-${i}`;
              const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
              ringStyle.textContent = `
                @keyframes ${ringAnimName} {
                  0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
                  100% { r: ${fovDistance}; opacity: 0; }
                }
              `;
              ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
              ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
              fovGroup.appendChild(ringStyle);
              fovGroup.appendChild(ring);
            }
          } else if (fovAnimationType === "spin") {
            styleEl.textContent = `
              @keyframes ${animationName} {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `;
            fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
            fovGroup.style.transformOrigin = "0 0";
          }
          
          if (fovAnimationType !== "rings") {
            fovGroup.appendChild(styleEl);
            const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
            const animationOffset = elapsedSeconds % fovSpeed;
            fovGroup.style.animationDelay = `-${animationOffset}s`;
          }
        }
        
        nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
      }
       
      function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const flowArrowBig = document.createElementNS(ns, "path");
        flowArrowBig.id = "flow-arrow-big";
        flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
        defs.appendChild(flowArrowBig);
        const flowArrowSmall = document.createElementNS(ns, "path");
        flowArrowSmall.id = "flow-arrow-small";
        flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
        defs.appendChild(flowArrowSmall);
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);

        const wallPattern = document.createElementNS(ns, "pattern");
        wallPattern.id = "wall-hatch";
        wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
        wallPattern.setAttribute("width", "8");
        wallPattern.setAttribute("height", "8");
        wallPattern.setAttribute("patternTransform", "rotate(45)");
        const wallLine = document.createElementNS(ns, "line");
        wallLine.setAttribute("x1", "0");
        wallLine.setAttribute("y1", "0");
        wallLine.setAttribute("x2", "0");
        wallLine.setAttribute("y2", "8");
        wallLine.setAttribute("stroke", "#666");
        wallLine.setAttribute("stroke-width", "2");
        wallPattern.appendChild(wallLine);
        defs.appendChild(wallPattern);

        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         if (PAGE_STATE.rackGridEnabled !== false) {
          for (let u = 0; u <= rackCapacity; u++) {
           const y = RACK_START_Y + u * rackUHeight;
           const line = document.createElementNS(ns, "line");
           line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
           line.setAttribute("y1", y);
           line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
           line.setAttribute("y2", y);
           line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
           line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
           line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
           rackGroup.appendChild(line);
           if (u < rackCapacity) {
            const uNumber = rackCapacity - u;
            const text = document.createElementNS(ns, "text");
            text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
            text.setAttribute("y", y + rackUHeight / 2);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("dominant-baseline", "middle");
            text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            text.style.fontSize = "14px";
            text.style.fontWeight = "bold";
            text.textContent = `U${uNumber}`;
            rackGroup.appendChild(text);
            const textRight = document.createElementNS(ns, "text");
            textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
            textRight.setAttribute("y", y + rackUHeight / 2);
            textRight.setAttribute("text-anchor", "middle");
            textRight.setAttribute("dominant-baseline", "middle");
            textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
            textRight.style.fontSize = "14px";
            textRight.style.fontWeight = "bold";
            textRight.textContent = `U${uNumber}`;
            rackGroup.appendChild(textRight);
           }
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else if (lineStyle === "wall") {
           poly.style.stroke = "url(#wall-hatch)";
           poly.style.strokeWidth = (edge.width || 4) * 3;
           poly.style.strokeDasharray = "none";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const animDir = PAGE_STATE.animationDirection || "all";
          const shouldAnimatePoly = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
          if (shouldAnimatePoly) {
           poly.style.opacity = "0.25";
           const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
           const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
           const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
           const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
           const arrowCount = 3;
           const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
           if (direction === "forward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
             arrow.classList.add("edge-arrow-forward");
             svg.appendChild(arrow);
            }
           }
           if (direction === "backward" || direction === "both") {
            for (let i = 0; i < arrowCount; i++) {
             const arrow = document.createElementNS(ns, "use");
             arrow.setAttribute("href", arrowId);
             arrow.style.fill = arrowColor;
             arrow.style.offsetPath = `path('${polyPathD}')`;
             arrow.style.animationDuration = animDuration + "s";
             arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
             arrow.classList.add("edge-arrow-backward");
             svg.appendChild(arrow);
            }
           }
          }
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const edgeDirection = edge.direction || "none";
         const edgeLineStyle = edge.lineStyle || "solid";
         if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
         else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
         if (edgeDirection === "forward") {
          path.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (edgeDirection === "backward") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (edgeDirection === "both") {
          path.setAttribute("marker-start", "url(#arrow-backward)");
          path.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
         if (shouldAnimate && !edgeFaded) {
          path.style.opacity = "0.25";
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (edgeDirection === "forward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (edgeDirection === "backward" || edgeDirection === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${pathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         const nodeRotation = NODE_DATA[id].rotation || 0;
         g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         if (hasCoverageZone(node.shape) && node.fovEnabled) {
           const defaults = getCoverageDefaults(node.shape);
           const fovAngle = node.fovAngle || defaults.angle;
           const fovDistance = node.fovDistance || defaults.distance;
           const fovInnerRadius = node.fovInnerRadius || 0;
           const fovRotation = node.fovRotation || 0;
           const fovColor = node.fovColor || "#f59e0b";
           const fovOpacity = node.fovOpacity || 20;
           const fovGradient = node.fovGradient || false;
           const fovBorderColor = node.fovBorderColor || "#f59e0b";
           const fovBorderWidth = node.fovBorderWidth ?? 2;
           const fovBorderStyle = node.fovBorderStyle || "solid";
           const fovBorderOpacity = node.fovBorderOpacity ?? 100;
           const fovLabel = node.fovLabel || "";
           const fovAnimate = node.fovAnimate || false;
           const fovAnimationType = node.fovAnimationType || defaults.animationType;
           const fovSweep = node.fovSweep || 120;
           const fovSpeed = node.fovSpeed || 4;
           
           const fovGroup = document.createElementNS(ns, "g");
           fovGroup.classList.add("fov-group");
           if (!ZONES_VISIBLE) fovGroup.style.display = "none";
           
           if (fovGradient) {
             const gradientId = `fov-gradient-${id}`;
             const defs = document.createElementNS(ns, "defs");
             const gradient = document.createElementNS(ns, "radialGradient");
             gradient.id = gradientId;
             gradient.setAttribute("cx", "0");
             gradient.setAttribute("cy", "0");
             gradient.setAttribute("r", fovDistance);
             gradient.setAttribute("gradientUnits", "userSpaceOnUse");
             const stop1 = document.createElementNS(ns, "stop");
             stop1.setAttribute("offset", fovInnerRadius / fovDistance);
             stop1.setAttribute("stop-color", fovColor);
             stop1.setAttribute("stop-opacity", fovOpacity / 100);
             const stop2 = document.createElementNS(ns, "stop");
             stop2.setAttribute("offset", "1");
             stop2.setAttribute("stop-color", fovColor);
             stop2.setAttribute("stop-opacity", "0");
             gradient.appendChild(stop1);
             gradient.appendChild(stop2);
             defs.appendChild(gradient);
             fovGroup.appendChild(defs);
           }
           
           const fovPath = document.createElementNS(ns, "path");
           
           if (fovAngle >= 360) {
             if (fovInnerRadius > 0) {
               fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
               fovPath.setAttribute("fill-rule", "evenodd");
             } else {
               fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
             }
           } else {
             const angleRad = (fovAngle * Math.PI) / 180;
             const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
             const startAngle = rotationRad - angleRad / 2;
             const endAngle = rotationRad + angleRad / 2;
             const x1 = Math.cos(startAngle) * fovDistance;
             const y1 = Math.sin(startAngle) * fovDistance;
             const x2 = Math.cos(endAngle) * fovDistance;
             const y2 = Math.sin(endAngle) * fovDistance;
             const largeArc = fovAngle > 180 ? 1 : 0;
             if (fovInnerRadius > 0) {
               const ix1 = Math.cos(startAngle) * fovInnerRadius;
               const iy1 = Math.sin(startAngle) * fovInnerRadius;
               const ix2 = Math.cos(endAngle) * fovInnerRadius;
               const iy2 = Math.sin(endAngle) * fovInnerRadius;
               fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
             } else {
               fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
             }
           }
           
           if (fovGradient) {
             fovPath.style.fill = `url(#fov-gradient-${id})`;
           } else {
             const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
             fovPath.style.fill = fovColor + opacityHex;
           }
           
           const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
           fovPath.style.stroke = fovBorderColor + borderOpacityHex;
           fovPath.style.strokeWidth = fovBorderWidth;
           if (fovBorderStyle === "dashed") {
             fovPath.style.strokeDasharray = "10,5";
           } else if (fovBorderStyle === "dotted") {
             fovPath.style.strokeDasharray = "3,3";
           }
           fovPath.style.pointerEvents = "none";
           fovPath.classList.add("fov-cone");
           
           fovGroup.appendChild(fovPath);
           
           if (fovLabel) {
             const fovLabelPosition = node.fovLabelPosition || "center";
             const fovLabelSize = node.fovLabelSize || 14;
             const fovLabelColor = node.fovLabelColor || "#ffffff";
             const fovLabelBold = node.fovLabelBold || false;
             const fovLabelBg = node.fovLabelBg || false;
             const fovLabelBgColor = node.fovLabelBgColor || "#000000";
             let labelDistance;
             if (fovLabelPosition === "center") {
               labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
             } else if (fovLabelPosition === "edge") {
               labelDistance = fovDistance * 0.75;
             } else {
               labelDistance = fovDistance + fovLabelSize + 8;
             }
             const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
             const fovLabelOffsetX = node.fovLabelOffsetX || 0;
             const fovLabelOffsetY = node.fovLabelOffsetY || 0;
             const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
             const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
             if (fovLabelBg) {
               const bgRect = document.createElementNS(ns, "rect");
               const textWidth = fovLabel.length * fovLabelSize * 0.6;
               const textHeight = fovLabelSize * 1.4;
               bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
               bgRect.setAttribute("y", labelY - textHeight / 2);
               bgRect.setAttribute("width", textWidth + 12);
               bgRect.setAttribute("height", textHeight);
               bgRect.setAttribute("rx", "4");
               bgRect.style.fill = fovLabelBgColor;
               bgRect.style.opacity = "0.8";
               bgRect.style.pointerEvents = "none";
               fovGroup.appendChild(bgRect);
             }
             const labelEl = document.createElementNS(ns, "text");
             labelEl.setAttribute("x", labelX);
             labelEl.setAttribute("y", labelY);
             labelEl.setAttribute("text-anchor", "middle");
             labelEl.setAttribute("dominant-baseline", "middle");
             labelEl.style.fill = fovLabelColor;
             labelEl.style.fontSize = fovLabelSize + "px";
             labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
             labelEl.style.fontFamily = "system-ui, sans-serif";
             labelEl.style.pointerEvents = "none";
             labelEl.textContent = fovLabel;
             fovGroup.appendChild(labelEl);
           }
           
           if (fovAnimate) {
             const animationName = `fov-anim-${id}`;
             const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
             
             if (fovAnimationType === "sweep" && fovAngle < 360) {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0%, 100% { transform: rotate(0deg); }
                   50% { transform: rotate(${fovSweep}deg); }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
               fovGroup.style.transformOrigin = "0 0";
             } else if (fovAnimationType === "pulse") {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0%, 100% { transform: scale(1); opacity: 1; }
                   50% { transform: scale(1.1); opacity: 0.7; }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
               fovGroup.style.transformOrigin = "0 0";
             } else if (fovAnimationType === "rings") {
               for (let i = 1; i <= 3; i++) {
                 const ring = document.createElementNS(ns, "circle");
                 ring.setAttribute("cx", "0");
                 ring.setAttribute("cy", "0");
                 ring.setAttribute("r", fovDistance * 0.3 * i);
                 ring.style.fill = "none";
                 ring.style.stroke = fovBorderColor;
                 ring.style.strokeWidth = "2";
                 ring.style.opacity = "0";
                 const ringAnimName = `${animationName}-ring-${i}`;
                 const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
                 ringStyle.textContent = `
                   @keyframes ${ringAnimName} {
                     0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
                     100% { r: ${fovDistance}; opacity: 0; }
                   }
                 `;
                 ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
                 ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
                 fovGroup.appendChild(ringStyle);
                 fovGroup.appendChild(ring);
               }
             } else if (fovAnimationType === "spin") {
               styleEl.textContent = `
                 @keyframes ${animationName} {
                   0% { transform: rotate(0deg); }
                   100% { transform: rotate(360deg); }
                 }
               `;
               fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
               fovGroup.style.transformOrigin = "0 0";
             }
             
             if (fovAnimationType !== "rings") {
               fovGroup.appendChild(styleEl);
               const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
               const animationOffset = elapsedSeconds % fovSpeed;
               fovGroup.style.animationDelay = `-${animationOffset}s`;
             }
           }
           
           g.appendChild(fovGroup);
         }
        g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         });
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId);
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else if (rect.lineStyle === "wall") {
             rectEl.style.fill = rect.color;
             rectEl.style.fillOpacity = "0.5";
             rectEl.style.stroke = rect.borderColor || rect.color;
             rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
             const hatchGroup = document.createElementNS(ns, "g");
             hatchGroup.classList.add("wall-hatch-lines");
             hatchGroup.style.pointerEvents = "none";
             const spacing = 12;
             const hatchColor = rect.borderColor || rect.color;
             for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
               const line = document.createElementNS(ns, "line");
               line.setAttribute("x1", rect.x + i);
               line.setAttribute("y1", rect.y);
               line.setAttribute("x2", rect.x + i - rect.height);
               line.setAttribute("y2", rect.y + rect.height);
               line.style.stroke = hatchColor;
               line.style.strokeWidth = "2";
               hatchGroup.appendChild(line);
             }
             const clipId = "clip-" + rect.id;
             const clipPath = document.createElementNS(ns, "clipPath");
             clipPath.id = clipId;
             const clipRect = document.createElementNS(ns, "rect");
             clipRect.setAttribute("x", rect.x);
             clipRect.setAttribute("y", rect.y);
             clipRect.setAttribute("width", rect.width);
             clipRect.setAttribute("height", rect.height);
             clipPath.appendChild(clipRect);
             defs.appendChild(clipPath);
             hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
             g.appendChild(hatchGroup);
           }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
		updateZoneLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          });
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
            if (hasCoverageZone(data.shape)) {
              fovSection.style.display = "block";
              const defaults = getCoverageDefaults(data.shape);
              document.getElementById("fov-enabled").checked = data.fovEnabled || false;
              document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
              document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "¬∞";
              document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
              document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
              document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
              document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
              document.getElementById("fov-rotation").value = data.fovRotation || 0;
              document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "¬∞";
              document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
              document.getElementById("fov-opacity").value = data.fovOpacity || 20;
              document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
              document.getElementById("fov-gradient").checked = data.fovGradient || false;
              document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
              document.getElementById("fov-border-width").value = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth !== undefined ? data.fovBorderWidth : 2;
              document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
              document.getElementById("fov-border-opacity").value = data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100;
              document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity !== undefined ? data.fovBorderOpacity : 100) + "%";
              document.getElementById("fov-label").value = data.fovLabel || "";
              document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
              document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
              document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
              document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
              document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
              document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
              document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
              document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
              document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
              document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
              document.getElementById("fov-animate").checked = data.fovAnimate || false;
              document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
              document.getElementById("fov-sweep").value = data.fovSweep || 120;
              document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "¬∞";
              document.getElementById("fov-speed").value = data.fovSpeed || 4;
              document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
            } else {
              fovSection.style.display = "none";
            }
          }
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage zone");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  if (this.checked && !NODE_DATA[currentNodeId].fovColor) {
    NODE_DATA[currentNodeId].fovColor = document.getElementById("fov-color").value || "#f59e0b";
  }
  updateFovCone(currentNodeId);
  updateZoneLegend();
};
        document.getElementById("fov-angle").oninput = function() {
          document.getElementById("fov-angle-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-distance").oninput = function() {
          document.getElementById("fov-distance-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-rotation").oninput = function() {
          document.getElementById("fov-rotation-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovColor = this.value;
          updateFovCone(currentNodeId);
          updateZoneLegend();
        };
        document.getElementById("fov-animate").onchange = function() {
          if (!currentNodeId) return;
          pushUndo("toggle fov animation");
          NODE_DATA[currentNodeId].fovAnimate = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-sweep").oninput = function() {
          document.getElementById("fov-sweep-value").textContent = this.value + "¬∞";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-speed").oninput = function() {
          document.getElementById("fov-speed-value").textContent = this.value + "s";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-inner-radius").oninput = function() {
          document.getElementById("fov-inner-radius-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovInnerRadius = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-opacity").oninput = function() {
          document.getElementById("fov-opacity-value").textContent = this.value + "%";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovOpacity = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-gradient").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovGradient = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-width").oninput = function() {
          document.getElementById("fov-border-width-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderWidth = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-style").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderStyle = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-border-opacity").oninput = function() {
          document.getElementById("fov-border-opacity-value").textContent = this.value + "%";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovBorderOpacity = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabel = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-position").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelPosition = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-size").oninput = function() {
          document.getElementById("fov-label-size-value").textContent = this.value + "px";
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelSize = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bold").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBold = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bg").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBg = this.checked;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-bg-color").oninput = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelBgColor = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-offset-x").oninput = function() {
          document.getElementById("fov-label-offset-x-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelOffsetX = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-label-offset-y").oninput = function() {
          document.getElementById("fov-label-offset-y-value").textContent = this.value;
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovLabelOffsetY = parseInt(this.value);
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-animation-type").onchange = function() {
          if (!currentNodeId) return;
          NODE_DATA[currentNodeId].fovAnimationType = this.value;
          updateFovCone(currentNodeId);
        };
        document.getElementById("fov-preset").addEventListener("change", function() {
          if (this.value) {
            applyZonePreset(this.value);
            this.value = "";
          }
        });
        document.getElementById("fov-save-preset").addEventListener("click", saveCustomZonePreset);
        document.getElementById("fov-copy-style").addEventListener("click", function() {
          if (currentNodeId && copyZoneStyle(currentNodeId)) {
            alert("Zone style copied!");
          }
        });
        document.getElementById("fov-paste-style").addEventListener("click", function() {
          if (currentNodeId && pasteZoneStyle(currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        });
        document.getElementById("bulk-zone-copy").addEventListener("click", bulkCopyZoneStyle);
        document.getElementById("bulk-zone-paste").addEventListener("click", bulkPasteZoneStyle);
        document.getElementById("bulk-zone-toggle").addEventListener("click", bulkToggleZones);
        document.getElementById("bulk-zone-copy-mobile").addEventListener("click", bulkCopyZoneStyle);
        document.getElementById("bulk-zone-paste-mobile").addEventListener("click", bulkPasteZoneStyle);
        document.getElementById("bulk-zone-toggle-mobile").addEventListener("click", bulkToggleZones);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        const currentRotation = NODE_DATA[id].rotation || 0;
        document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
        document.getElementById("rotation-value").value = currentRotation;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          });
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           });
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        const statusText = statusTexts[data.ping.status] || statusTexts.unknown;
		statusEl.textContent = data.ping.responseTime ? `${statusText} (${data.ping.responseTime}ms)` : statusText;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        document.getElementById("edge-animate").checked = edge.animate === true;
        document.getElementById("edge-animation-style").value = edge.animationStyle || "";
        document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       hint.style.cursor = "pointer";
       let hintDismissed = false;
       const dismissHint = () => { hintDismissed = true; hint.classList.remove("visible"); };
       hint.addEventListener("click", dismissHint);
       hint.addEventListener("touchend", (e) => { e.preventDefault(); dismissHint(); });
       setTimeout(() => {
        if (hintDismissed) return;
        hint.classList.add("visible");
        setTimeout(() => { if (!hintDismissed) hint.classList.remove("visible"); }, 4000);
       }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         });
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         });
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         });
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         });
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         });
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
		updateMinimap();
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
		updateMinimap();
       });
       const rotationSlider = document.getElementById("rotation-slider");
       const rotationInput = document.getElementById("rotation-value");
       const resetRotationBtn = document.getElementById("reset-rotation");
       rotationSlider.addEventListener("input", () => {
         const newRotation = parseInt(rotationSlider.value, 10);
         rotationInput.value = newRotation;
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       rotationInput.addEventListener("input", () => {
         const newRotation = parseInt(rotationInput.value, 10) || 0;
         rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
         pushUndo("rotate node");
         NODE_DATA[currentNodeId].rotation = newRotation;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
         }
       });
       resetRotationBtn.addEventListener("click", () => {
         pushUndo("reset rotation");
         NODE_DATA[currentNodeId].rotation = 0;
         rotationSlider.value = 0;
         rotationInput.value = 0;
         const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
         if (nodeGroup) {
           const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
           nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
         }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };

       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        const fovSection = document.getElementById("fov-section");
        if (fovSection) {
          const oldShape = NODE_DATA[currentNodeId].shape;
          fovSection.style.display = hasCoverageZone(shape) ? "block" : "none";
          if (hasCoverageZone(shape) && !hasCoverageZone(oldShape)) {
            const defaults = getCoverageDefaults(shape);
            document.getElementById("fov-angle").value = defaults.angle;
            document.getElementById("fov-angle-value").textContent = defaults.angle + "¬∞";
            document.getElementById("fov-distance").value = defaults.distance;
            document.getElementById("fov-distance-value").textContent = defaults.distance;
            document.getElementById("fov-animation-type").value = defaults.animationType;
            NODE_DATA[currentNodeId].fovAngle = defaults.angle;
            NODE_DATA[currentNodeId].fovDistance = defaults.distance;
            NODE_DATA[currentNodeId].fovAnimationType = defaults.animationType;
          }
        }
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
        if (el) el.style.stroke = color;
        forgeTheLegend();
		updateZoneLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animate").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animate");
        edge.animate = e.target.checked;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("animation-style-select").addEventListener("change", (e) => {
        PAGE_STATE.animationStyle = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-direction-select").addEventListener("change", (e) => {
        PAGE_STATE.animationDirection = e.target.value;
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("animation-speed-select").addEventListener("change", (e) => {
        PAGE_STATE.animationSpeed = parseFloat(e.target.value);
        if (PAGE_STATE.animateConnections) forgeTheTopology();
       });
       document.getElementById("edge-animation-style").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation style");
        edge.animationStyle = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge animation speed");
        edge.animationSpeed = e.target.value || "";
        if (PAGE_STATE.animateConnections || edge.animate === true) forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         });
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchUpHandler);
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          });
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawToggleBtn.classList.add("done-btn-active");
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        drawToggleBtn.classList.remove("done-btn-active");
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
		 updateZoneLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        });
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.classList.add("done-btn-active");
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.classList.remove("done-btn-active");
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
        document.getElementById("text-rotation-val").value = textItem.rotation || 0;
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("text-rotation").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           textItem.rotation = parseInt(e.target.value) || 0;
           document.getElementById("text-rotation-val").value = textItem.rotation;
           forgeTheTopology();
         }
       });
       document.getElementById("text-rotation-val").addEventListener("input", (e) => {
         if (!currentTextId) return;
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
           pushUndo("rotate text");
           const val = parseInt(e.target.value) || 0;
           textItem.rotation = val;
           document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
           forgeTheTopology();
         }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("add-line-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
	   document.getElementById("anim-master").addEventListener("change", e => { ANIM_SETTINGS.masterAnim = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-sweep").addEventListener("change", e => { ANIM_SETTINGS.animTypes.sweep = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-pulse").addEventListener("change", e => { ANIM_SETTINGS.animTypes.pulse = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-rings").addEventListener("change", e => { ANIM_SETTINGS.animTypes.rings = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-spin").addEventListener("change", e => { ANIM_SETTINGS.animTypes.spin = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-type-connections").addEventListener("change", e => { ANIM_SETTINGS.animTypes.connections = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.animCategories.camera = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.animCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.animCategories.motion = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.animCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.animCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("anim-cat-connections").addEventListener("change", e => { ANIM_SETTINGS.animCategories.connections = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-master").addEventListener("change", e => { ANIM_SETTINGS.masterZones = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.camera = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.motion = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
		document.getElementById("zone-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
       document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
       document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
       document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        rebuildThemeDropdown();
        updateDeleteButton();
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       document.getElementById("add-line-color").value = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
       PAGE_STATE.rackGridEnabled = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
		 pushUndo('import json');
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
        if (typeof updateZoneLegend === 'function') updateZoneLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       zoneLegend: ZONE_LEGEND,
       zonePresets: ZONE_PRESETS,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       savedStyleSets: savedStyleSets,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false,
        fovEnabled: source.fovEnabled || false,
        fovAngle: source.fovAngle || 90,
        fovDistance: source.fovDistance || 150,
        fovInnerRadius: source.fovInnerRadius || 0,
        fovRotation: source.fovRotation || 0,
        fovColor: source.fovColor || "#f59e0b",
        fovOpacity: source.fovOpacity || 20,
        fovGradient: source.fovGradient || false,
        fovBorderColor: source.fovBorderColor || "#f59e0b",
        fovBorderWidth: source.fovBorderWidth !== undefined ? source.fovBorderWidth : 2,
        fovBorderStyle: source.fovBorderStyle || "solid",
        fovBorderOpacity: source.fovBorderOpacity !== undefined ? source.fovBorderOpacity : 100,
        fovLabel: source.fovLabel || "",
        fovLabelPosition: source.fovLabelPosition || "center",
        fovLabelSize: source.fovLabelSize || 14,
        fovLabelColor: source.fovLabelColor || "#ffffff",
        fovLabelBold: source.fovLabelBold || false,
        fovLabelBg: source.fovLabelBg || false,
        fovLabelBgColor: source.fovLabelBgColor || "#000000",
        fovLabelOffsetX: source.fovLabelOffsetX || 0,
        fovLabelOffsetY: source.fovLabelOffsetY || 0,
        fovAnimate: source.fovAnimate || false,
        fovAnimationType: source.fovAnimationType || "sweep",
        fovSweep: source.fovSweep || 120,
        fovSpeed: source.fovSpeed || 4
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        });
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
		btn.style.display = "block";
		btn.disabled = !select.value.startsWith("mytheme-");
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
        if (typeof updateZoneLegend === "function") updateZoneLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.dropdown').forEach(dropdown => {
    const btn = dropdown.querySelector('.dropdown-btn');
    const menu = dropdown.querySelector('.dropdown-menu');
    if (!btn || !menu) return;
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      document.querySelectorAll('.dropdown-menu.open').forEach(m => {
        if (m !== menu) m.classList.remove('open');
      });
      menu.classList.toggle('open');
    });
  });
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.dropdown')) {
      document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
    }
  });
  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(() => {
        document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
      }, 100);
    });
  });
  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
function printTopology() {
  const svg = document.getElementById('map');
  if (!svg) { window.print(); return; }
  const originalViewBox = svg.getAttribute('viewBox');
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  let hasContent = false;
  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode !== 'rack' && node.assignedRack) return;
    const size = savedSizes[id] || 50;
    hasContent = true;
    minX = Math.min(minX, pos.x - size);
    minY = Math.min(minY, pos.y - size);
    maxX = Math.max(maxX, pos.x + size);
    maxY = Math.max(maxY, pos.y + size);
  });
  RECT_DATA.list.forEach(rect => {
    hasContent = true;
    minX = Math.min(minX, rect.x);
    minY = Math.min(minY, rect.y);
    maxX = Math.max(maxX, rect.x + rect.width);
    maxY = Math.max(maxY, rect.y + rect.height);
  });
  TEXT_DATA.list.forEach(text => {
    hasContent = true;
    minX = Math.min(minX, text.x - 100);
    minY = Math.min(minY, text.y - 50);
    maxX = Math.max(maxX, text.x + 300);
    maxY = Math.max(maxY, text.y + 50);
  });
  EDGE_DATA.list.forEach(edge => {
    if (edge.points && edge.points.length > 0) {
      edge.points.forEach(p => {
        hasContent = true;
        minX = Math.min(minX, p.x - 10);
        minY = Math.min(minY, p.y - 10);
        maxX = Math.max(maxX, p.x + 10);
        maxY = Math.max(maxY, p.y + 10);
      });
    }
  });
  if (!hasContent) { window.print(); return; }
  const padding = 100;
  minX -= padding; minY -= padding; maxX += padding; maxY += padding;
  const width = maxX - minX;
  const height = maxY - minY;
  const grid = document.getElementById('canvas-grid');
  const gridDisplay = grid ? grid.style.display : '';
  if (grid) grid.style.display = 'none';
  svg.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
  const originalWidth = svg.style.width;
  const originalHeight = svg.style.height;
  svg.style.width = '100%';
  svg.style.height = '100%';
  setTimeout(() => {
    window.print();
    setTimeout(() => {
      svg.setAttribute('viewBox', originalViewBox);
      svg.style.width = originalWidth;
      svg.style.height = originalHeight;
      if (grid) grid.style.display = gridDisplay;
    }, 500);
  }, 100);
}
function exportJSONFile() {
  const data = captureTheQuickening();
  const jsonStr = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonStr], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
  a.download = `${safeTitle}.json`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent("export", `Exported JSON: ${a.download}`);
}
function exportCSV() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
  csv += `# Exported from The One File on ${timestamp}\n`;
  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
  csv += headers.join(',') + '\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
    const row = [
      csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
      node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
      csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
      node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
      node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
      size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
    ];
    csv += row.join(',') + '\n';
  });
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported CSV: ${a.download}`);
}
function csvEscape(val) {
  if (val === null || val === undefined) return '';
  const str = String(val);
  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
    return '"' + str.replace(/"/g, '""') + '"';
  }
  return str;
}
document.getElementById('import-csv-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    const lines = text.split(/\r?\n/);
    let config = null;
    let dataLines = [];
    let headers = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
        try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
        continue;
      }
      if (trimmed.startsWith('#')) continue;
      if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
      dataLines.push(trimmed);
    }
    if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
    const nameIdx = headers.indexOf('name');
    if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
    const nodes = dataLines.map(line => {
      const values = parseCSVLine(line);
      const node = {};
      headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
      return node;
    });
    const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add';
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `‚Ä¢ ${nodes.length} nodes in CSV data\n` +
        `‚Ä¢ ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `‚Ä¢ ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      if (typeof updateZoneLegend === 'function') updateZoneLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
    if (hasConfig) {
      Object.assign(PAGE_STATE, config.pageState || config.page);
      if (config.canvasView || config.canvas) {
        const canvasConfig = config.canvasView || config.canvas;
        canvasState.zoom = canvasConfig.zoom || 1;
        canvasState.panX = canvasConfig.panX || 0;
        canvasState.panY = canvasConfig.panY || 0;
      }
      if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
      wieldThePower();
    }
    let gridX = 200, gridY = 200;
    const spacing = 150;
    const perRow = Math.ceil(Math.sqrt(nodes.length));
    let gridIndex = 0;
    nodes.forEach((n) => {
      let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
      if (!baseId) baseId = 'node';
      let nodeId = baseId;
      let counter = 1;
      while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
      NODE_DATA[nodeId] = {
        name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
        tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
        notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
        layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
        uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
        isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
      };
      const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
      if (hasPosition) {
        savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
      } else {
        const row = Math.floor(gridIndex / perRow);
        const col = gridIndex % perRow;
        savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
        gridIndex++;
      }
      if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
      if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
    });
    forgeTheTopology();
    updateViewBox();
    logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
    alert(`Successfully imported ${nodes.length} nodes`);
  } catch (err) {
    console.error('CSV import error:', err);
    alert('Failed to import CSV: ' + err.message);
  }
});
function parseCSVLine(line) {
  const result = [];
  let current = '';
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
      else { inQuotes = !inQuotes; }
    } else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
    else { current += char; }
  }
  result.push(current);
  return result;
}

function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
  md += `## Legend\n\n`;
  if (Object.keys(EDGE_LEGEND).length > 0) {
    Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
  } else { md += `_No legend entries_\n`; }
  md += '\n## Nodes\n\n';
  Object.entries(NODE_DATA).forEach(([id, node]) => {
    const pos = savedPositions[id] || { x: 0, y: 0 };
    const size = savedSizes[id] || 50;
    const styles = savedStyles[id] || null;
    md += `### ${id}\n`;
    md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
    md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
    md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
    md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
    md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
    md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
    md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
    if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
    if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
    md += '\n';
  });
  md += `## Connections\n\n`;
  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
    EDGE_DATA.list.forEach(edge => {
      const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
      const toPort = edge.toPort ? ` (${edge.toPort})` : '';
      md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
      md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
      md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
      md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
      md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
      if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
      if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No connections_\n\n`; }
  md += `## Zones\n\n`;
  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
    RECT_DATA.list.forEach(rect => {
      md += `### ${rect.id}\n`;
      md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
      md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
      md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
      if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
      md += '\n';
    });
  } else { md += `_No zones_\n\n`; }
  md += `## Text Labels\n\n`;
  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
    TEXT_DATA.list.forEach(text => {
      md += `### ${text.id}\n`;
      md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
      md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
      md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
      md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
      md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
      md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
    });
  } else { md += `_No text labels_\n\n`; }
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${safeTitle}.md`;
  a.click();
  URL.revokeObjectURL(url);
  logAuditEvent('export', `Exported Markdown: ${a.download}`);
}

document.getElementById('import-markdown-file')?.addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
      } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    if (typeof updateZoneLegend === 'function') updateZoneLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
  } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
  }
});

document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-export-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
  document.getElementById('mobile-import-modal').classList.add('active');
  document.getElementById('topbar-menu').classList.remove('open');
});
document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
});
document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
});	  
    </script>
</body></html>