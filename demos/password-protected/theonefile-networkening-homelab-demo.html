<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;">
          <div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"><option value="core-router-2">Core Router 2</option><option value="fw-external-1">External FW 1</option><option value="fw-external-2">External FW 2</option><option value="fw-internal">Internal FW</option><option value="core-switch-1">Core Switch 1</option><option value="core-switch-2">Core Switch 2</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option><option value="wlc-primary">WLC Primary</option><option value="wlc-secondary">WLC Secondary</option><option value="mobile-zone-hq">HQ Mobile Zone</option><option value="mobile-zone-guest">Guest WiFi Zone</option><option value="mobile-zone-iot">IoT Device Zone</option><option value="branch-router-ny">NYC Branch Router</option><option value="branch-router-la">LA Branch Router</option><option value="branch-router-chi">Chicago Branch Router</option><option value="branch-router-lon">London Branch Router</option><option value="branch-router-tokyo">Tokyo Branch Router</option><option value="cloud-aws">AWS Cloud</option><option value="cloud-azure">Azure Cloud</option><option value="cloud-gcp">GCP Cloud</option><option value="isp-primary">ISP Primary</option><option value="isp-secondary">ISP Secondary</option><option value="proxy-server-1">Proxy Server 1</option><option value="proxy-server-2">Proxy Server 2</option><option value="vpn-concentrator">VPN Concentrator</option><option value="nac-server">NAC Server</option><option value="voip-cluster">VoIP Cluster</option><option value="video-conf">Video Conference</option><option value="security-cameras">Security Cameras</option><option value="dev-server-1">Dev Server 1</option><option value="dev-server-2">Dev Server 2</option><option value="test-environment">Test Environment</option><option value="erp-system">ERP System</option><option value="crm-system">CRM System</option><option value="endpoint-1000">Corporate Endpoints</option><option value="dist-switch-floor1">Floor 1 Switch</option><option value="dist-switch-floor2">Floor 2 Switch</option><option value="dist-switch-floor3">Floor 3 Switch</option><option value="dist-switch-floor4">Floor 4 Switch</option><option value="ap-floor1-zone1">AP Floor 1 Zone 1</option><option value="ap-floor2-zone1">AP Floor 2 Zone 1</option><option value="ap-floor3-zone1">AP Floor 3 Zone 1</option><option value="ap-floor4-zone1">AP Floor 4 Zone 1</option><option value="ups-dc-1">UPS DC-1</option><option value="ups-dc-2">UPS DC-2</option><option value="cooling-1">CRAC Unit 1</option><option value="cooling-2">CRAC Unit 2</option></select>
<input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1254.5197896196048 -147.55422459755366 2648.185035176588 1986.138776382441" style=""><defs><marker id="arrow-forward" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="context-stroke"></path></marker><marker id="arrow-backward" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M9,0 L9,6 L0,3 z" fill="context-stroke"></path></marker></defs><rect x="100" y="100" width="3800" height="2800" fill="none" stroke="#4755694D" stroke-width="20" stroke-dasharray="10 5" rx="8"></rect><g id="canvas-grid"><line x1="100" y1="100" x2="100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="150" y1="100" x2="150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="200" y1="100" x2="200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="250" y1="100" x2="250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="300" y1="100" x2="300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="350" y1="100" x2="350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="400" y1="100" x2="400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="450" y1="100" x2="450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="500" y1="100" x2="500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="550" y1="100" x2="550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="600" y1="100" x2="600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="650" y1="100" x2="650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="700" y1="100" x2="700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="750" y1="100" x2="750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="800" y1="100" x2="800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="850" y1="100" x2="850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="900" y1="100" x2="900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="950" y1="100" x2="950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1000" y1="100" x2="1000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1050" y1="100" x2="1050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1100" y1="100" x2="1100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1150" y1="100" x2="1150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1200" y1="100" x2="1200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1250" y1="100" x2="1250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1300" y1="100" x2="1300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1350" y1="100" x2="1350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1400" y1="100" x2="1400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1450" y1="100" x2="1450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1500" y1="100" x2="1500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1550" y1="100" x2="1550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1600" y1="100" x2="1600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1650" y1="100" x2="1650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1700" y1="100" x2="1700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1750" y1="100" x2="1750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1800" y1="100" x2="1800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1850" y1="100" x2="1850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="1900" y1="100" x2="1900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="1950" y1="100" x2="1950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2000" y1="100" x2="2000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2050" y1="100" x2="2050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2100" y1="100" x2="2100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2150" y1="100" x2="2150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2200" y1="100" x2="2200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2250" y1="100" x2="2250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2300" y1="100" x2="2300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2350" y1="100" x2="2350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2400" y1="100" x2="2400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2450" y1="100" x2="2450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2500" y1="100" x2="2500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2550" y1="100" x2="2550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2600" y1="100" x2="2600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2650" y1="100" x2="2650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2700" y1="100" x2="2700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2750" y1="100" x2="2750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2800" y1="100" x2="2800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2850" y1="100" x2="2850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="2900" y1="100" x2="2900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="2950" y1="100" x2="2950" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3000" y1="100" x2="3000" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3050" y1="100" x2="3050" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3100" y1="100" x2="3100" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3150" y1="100" x2="3150" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3200" y1="100" x2="3200" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3250" y1="100" x2="3250" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3300" y1="100" x2="3300" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3350" y1="100" x2="3350" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3400" y1="100" x2="3400" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3450" y1="100" x2="3450" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3500" y1="100" x2="3500" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3550" y1="100" x2="3550" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3600" y1="100" x2="3600" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3650" y1="100" x2="3650" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3700" y1="100" x2="3700" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3750" y1="100" x2="3750" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3800" y1="100" x2="3800" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="3850" y1="100" x2="3850" y2="2900" stroke="#47556966" stroke-width="2"></line><line x1="3900" y1="100" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="100" x2="3900" y2="100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="150" x2="3900" y2="150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="200" x2="3900" y2="200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="250" x2="3900" y2="250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="300" x2="3900" y2="300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="350" x2="3900" y2="350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="400" x2="3900" y2="400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="450" x2="3900" y2="450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="500" x2="3900" y2="500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="550" x2="3900" y2="550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="600" x2="3900" y2="600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="650" x2="3900" y2="650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="700" x2="3900" y2="700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="750" x2="3900" y2="750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="800" x2="3900" y2="800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="850" x2="3900" y2="850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="900" x2="3900" y2="900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="950" x2="3900" y2="950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1000" x2="3900" y2="1000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1050" x2="3900" y2="1050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1100" x2="3900" y2="1100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1150" x2="3900" y2="1150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1200" x2="3900" y2="1200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1250" x2="3900" y2="1250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1300" x2="3900" y2="1300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1350" x2="3900" y2="1350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1400" x2="3900" y2="1400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1450" x2="3900" y2="1450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1500" x2="3900" y2="1500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1550" x2="3900" y2="1550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1600" x2="3900" y2="1600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1650" x2="3900" y2="1650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1700" x2="3900" y2="1700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1750" x2="3900" y2="1750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1800" x2="3900" y2="1800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1850" x2="3900" y2="1850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="1900" x2="3900" y2="1900" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="1950" x2="3900" y2="1950" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2000" x2="3900" y2="2000" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2050" x2="3900" y2="2050" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2100" x2="3900" y2="2100" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2150" x2="3900" y2="2150" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2200" x2="3900" y2="2200" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2250" x2="3900" y2="2250" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2300" x2="3900" y2="2300" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2350" x2="3900" y2="2350" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2400" x2="3900" y2="2400" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2450" x2="3900" y2="2450" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2500" x2="3900" y2="2500" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2550" x2="3900" y2="2550" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2600" x2="3900" y2="2600" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2650" x2="3900" y2="2650" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2700" x2="3900" y2="2700" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2750" x2="3900" y2="2750" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2800" x2="3900" y2="2800" stroke="#47556933" stroke-width="1"></line><line x1="100" y1="2850" x2="3900" y2="2850" stroke="#47556966" stroke-width="2"></line><line x1="100" y1="2900" x2="3900" y2="2900" stroke="#47556933" stroke-width="1"></line></g><g class="rect-group" data-rect-id="rect-1765238219615"><rect class="rect-shape" x="2680.053955078125" y="251.44879150390625" width="814.10400390625" height="389.26678466796875" style="fill: rgb(236, 9, 153); fill-opacity: 0.3; stroke: rgb(236, 9, 153); stroke-width: 2px; stroke-dasharray: none; cursor: move;"></rect><g class="rect-delete-btn" style="cursor: pointer; display: none;"><circle cx="3484.157958984375" cy="261.44879150390625" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="3484.157958984375" y="261.44879150390625" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" class="edge" data-edge-id="internet-internet-copy-1765238145151" data-from="internet" data-to="internet-copy" style="stroke: rgb(85, 226, 8); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2085.4680212352528 370.70595670887826 2066.9677515897347 473.4119134177565" fill="none" data-edge-id="internet-internet-copy-1765238145151" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" class="edge" data-edge-id="internet-copy-opnsense-copy-1765238187451" data-from="internet-copy" data-to="opnsense-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1920.4039088162972 569.9938683738112 1773.8400660428597 666.5758233298659" fill="none" data-edge-id="internet-copy-opnsense-copy-1765238187451" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1765238242477" data-from="internet-copy" data-to="docker-copy" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 1999.08282329894 627.8447547749242 1931.1978950081452 782.2775961320921" fill="none" data-edge-id="internet-copy-docker-copy-1765238242477" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-1-1765238244637" data-from="internet-copy" data-to="docker-copy-1" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2112.546995662221 620.5620704487524 2158.1262397347077 767.7122274797483" fill="none" data-edge-id="internet-copy-docker-copy-1-1765238244637" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" class="edge" data-edge-id="internet-copy-docker-copy-2-1765238246233" data-from="internet-copy" data-to="docker-copy-2" style="stroke: rgb(76, 0, 255); stroke-width: 4;"></path><path d="M 2066.9677515897347 473.4119134177565 Q 2204.617064021596 552.590055067893 2342.2663764534577 631.7681967180296" fill="none" data-edge-id="internet-copy-docker-copy-2-1765238246233" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" class="edge" data-edge-id="internet-opnsense-copy-1-1765238266117" data-from="internet" data-to="opnsense-copy-1" style="stroke: rgb(128, 255, 0); stroke-width: 4;"></path><path d="M 2103.968290880771 268 Q 2430.923885484287 287.80585580459456 2757.879480087803 307.6117116091891" fill="none" data-edge-id="internet-opnsense-copy-1-1765238266117" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="opnsense-copy-1-dns-1765238347996" data-from="opnsense-copy-1" data-to="dns" style="stroke: rgb(251, 0, 255); stroke-width: 4;"></path><path d="M 2757.879480087803 307.6117116091891 Q 2979.171899521397 314.04065142852505 3200.4643189549906 320.469591247861" fill="none" data-edge-id="opnsense-copy-1-dns-1765238347996" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" class="edge" data-edge-id="dns-desktop-1765238386101" data-from="dns" data-to="desktop" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3200.4643189549906 320.469591247861 Q 3086.0821778417094 400.59916888457974 2971.700036728428 480.7287465212985" fill="none" data-edge-id="dns-desktop-1765238386101" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" class="edge" data-edge-id="phone-dns-1765238391156" data-from="phone" data-to="dns" style="stroke: rgb(255, 0, 208); stroke-width: 4;"></path><path d="M 3312.857751572178 502.58220111114224 Q 3256.6610352635844 411.5258961795016 3200.4643189549906 320.469591247861" fill="none" data-edge-id="phone-dns-1765238391156" style="stroke: transparent; stroke-width: 20; cursor: pointer;"></path><polyline class="edge" data-edge-id="custom-1765239449323" fill="none" marker-end="url(#arrow-forward)" points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" style="stroke: rgb(249, 115, 22); stroke-width: 4; stroke-dasharray: none;"></polyline><polyline points="2936.464111328125,786.07958984375 3184.112060546875,887.6153564453125 2763.110107421875,981.7216796875" data-edge-id="custom-1765239449323" style="fill: none; stroke: transparent; stroke-width: 20; cursor: pointer;"></polyline><g class="node-group" data-node-id="internet" transform="translate(2103.968290880771,268)" style="cursor: grab;"><circle r="252" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="201.6" height="201.6" x="-100.8" y="-100.8" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"><path d="M144.3 214.1c0 6.3.7 11.4 1.9 15.2 1.4 3.7 3.1 7.8 5.4 12.3.9 1.4 1.2 2.7 1.2 3.9 0 1.7-1 3.4-3.2 5.1l-10.7 7.2c-1.5 1-3.1 1.5-4.4 1.5-1.7 0-3.4-.9-5.1-2.4-2.4-2.6-4.4-5.3-6.1-8-1.7-2.9-3.4-6.1-5.3-10-13.3 15.7-30 23.5-50.1 23.5-14.3 0-25.7-4.1-34.1-12.3-8.3-8.2-12.6-19.1-12.6-32.7 0-14.5 5.1-26.2 15.5-35.1S60.8 169 78.4 169c5.8 0 11.7.5 18.1 1.4s12.8 2.2 19.6 3.7v-12.4c0-12.9-2.7-22-8-27.2-5.4-5.3-14.6-7.8-27.8-7.8-6 0-12.1.7-18.4 2.2s-12.4 3.4-18.4 5.8c-2.7 1.2-4.8 1.9-6 2.2s-2 .5-2.7.5c-2.4 0-3.6-1.7-3.6-5.3v-8.3c0-2.7.3-4.8 1.2-6s2.4-2.4 4.8-3.6c6-3.1 13.1-5.6 21.5-7.7 8.3-2.2 17.2-3.2 26.6-3.2 20.3 0 35.1 4.6 44.6 13.8 9.4 9.2 14.1 23.2 14.1 41.9v55.2zM75.2 240c5.6 0 11.4-1 17.5-3.1 6.1-2 11.6-5.8 16.2-10.9 2.7-3.2 4.8-6.8 5.8-10.9s1.7-9 1.7-14.8v-7.2c-4.9-1.2-10.2-2.2-15.7-2.9-5.4-.7-10.7-1-16-1-11.4 0-19.8 2.2-25.4 6.8S51 207.1 51 215.6c0 8 2 14 6.3 18.1 4.1 4.2 10 6.3 17.9 6.3m136.7 18.4c-3.1 0-5.1-.5-6.5-1.7-1.4-1-2.6-3.4-3.6-6.6l-40-131.6c-1-3.4-1.5-5.6-1.5-6.8 0-2.7 1.4-4.3 4.1-4.3h16.7c3.2 0 5.4.5 6.6 1.7 1.4 1 2.4 3.4 3.4 6.6l28.6 112.7 26.6-112.7c.9-3.4 1.9-5.6 3.2-6.6 1.4-1 3.7-1.7 6.8-1.7H270c3.2 0 5.4.5 6.8 1.7 1.4 1 2.6 3.4 3.2 6.6l26.9 114.1 29.5-114.1c1-3.4 2.2-5.6 3.4-6.6 1.4-1 3.6-1.7 6.6-1.7h15.8c2.7 0 4.3 1.4 4.3 4.3 0 .9-.2 1.7-.3 2.7-.2 1-.5 2.4-1.2 4.3l-41 131.6q-1.5 5.1-3.6 6.6c-1.4 1-3.6 1.7-6.5 1.7h-14.6c-3.2 0-5.4-.5-6.8-1.7s-2.6-3.4-3.2-6.8l-26.4-109.8L236.7 250c-.9 3.4-1.9 5.6-3.2 6.8-1.4 1.2-3.7 1.7-6.8 1.7zm218.8 4.6c-8.9 0-17.7-1-26.2-3.1-8.5-2-15.2-4.3-19.6-6.8-2.7-1.5-4.6-3.2-5.3-4.8s-1-3.2-1-4.8v-8.7c0-3.6 1.4-5.3 3.9-5.3 1 0 2 .2 3.1.5 1 .3 2.6 1 4.3 1.7 5.8 2.6 12.1 4.6 18.7 6 6.8 1.4 13.5 2 20.3 2 10.7 0 19.1-1.9 24.9-5.6s8.9-9.2 8.9-16.2c0-4.8-1.5-8.7-4.6-11.9s-8.9-6.1-17.2-8.9l-24.7-7.7c-12.4-3.9-21.6-9.7-27.2-17.4-5.6-7.5-8.5-15.8-8.5-24.7 0-7.2 1.5-13.5 4.6-18.9s7.2-10.2 12.3-14c5.1-3.9 10.9-6.8 17.7-8.9 6.8-2 14-2.9 21.5-2.9 3.7 0 7.7.2 11.4.7 3.9.5 7.5 1.2 11.1 1.9 3.4.9 6.6 1.7 9.7 2.7s5.4 2 7.2 3.1c2.4 1.4 4.1 2.7 5.1 4.3 1 1.4 1.5 3.2 1.5 5.6v8c0 3.6-1.4 5.4-3.9 5.4-1.4 0-3.6-.7-6.5-2q-14.55-6.6-32.7-6.6c-9.7 0-17.4 1.5-22.6 4.8s-8 8.2-8 15.2c0 4.8 1.7 8.9 5.1 12.1s9.7 6.5 18.7 9.4l24.2 7.7c12.3 3.9 21.1 9.4 26.4 16.3s7.8 15 7.8 23.8c0 7.3-1.5 14-4.4 19.8-3.1 5.8-7.2 10.9-12.4 15-5.3 4.3-11.6 7.3-18.9 9.5-8 2.5-16 3.7-24.7 3.7" style="fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path><path d="M462.9 345.7c-56 41.4-137.4 63.3-207.4 63.3-98.1 0-186.5-36.3-253.2-96.6-5.3-4.8-.5-11.2 5.8-7.5 72.2 41.9 161.3 67.3 253.4 67.3 62.2 0 130.4-12.9 193.3-39.5 9.3-4.2 17.3 6.2 8.1 13m23.3-26.5c-7.2-9.2-47.3-4.4-65.6-2.2-5.4.7-6.3-4.1-1.4-7.7 32-22.5 84.6-16 90.8-8.5 6.1 7.7-1.7 60.3-31.7 85.5-4.6 3.9-9 1.9-7-3.2 6.9-16.9 22.1-54.9 14.9-63.9" style="fill-rule: evenodd; clip-rule: evenodd; fill: rgb(255, 255, 255); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-47.040000000000006" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Internet</text><text class="node-sub" x="0" y="67.2" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="internet-copy" transform="translate(2066.9677515897347,473.4119134177565)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M512 160.2V400H400V112H112V0h240.4zM112 112H0v240.4L160.2 512H400V400H112z" style="fill:#de3c07"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy" transform="translate(1773.8400660428597,666.5758233298659)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M462.2 512H49.8C22.3 512 0 489.7 0 462.2V49.8C0 22.3 22.3 0 49.8 0h412.4C489.7 0 512 22.3 512 49.8v412.4c0 27.5-22.3 49.8-49.8 49.8" style="fill:#2e2f33"></path><path d="M108.2 63.9h140.9c97.2 0 154.6 30.4 154.6 129.5v3.4c0 99.4-57.2 129.5-154.5 129.5h-30.7V447H108.2zm134.5 177.8c30.1 0 46-11.2 46-44.6v-3.9c0-33.2-15.8-44.6-46-44.6h-24.2v93.1zM313 358h90.3v90.1H313z" style="fill:#f7f6f3"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy" transform="translate(1931.1978950081452,782.2775961320921)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M438.6 0H73.4C33.1 0 .3 32.8.3 73.1v365.7c0 40.3 32.8 73.1 73.1 73.1h365.3c40.3 0 73.1-32.8 73.1-73.1V73.1C511.7 32.8 478.9 0 438.6 0" style="fill-rule:evenodd;clip-rule:evenodd;fill:#8b3bd0"></path><path d="M356.8 53.6v261.3c0 39.3-13.9 72.8-41.8 100.7s-61.4 41.8-100.7 41.8l-23.8-95h23.8c13 0 24.1-4.6 33.2-13.8 9.5-9.5 14.3-20.7 14.3-33.7V148.6H157.3v-95z" style="fill:#fff"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker2</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-1" transform="translate(2158.1262397347077,767.7122274797483)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M0 0h512v512H0z" style="fill:#111827"></path><path d="M170.7 85.3 369.8 256 170.7 426.7z" style="fill:#f59e0b"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker3</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="docker-copy-2" transform="translate(2342.2663764534577,631.7681967180296)" style="cursor: grab;"><circle r="123" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="98.39999999999999" height="98.39999999999999" x="-49.199999999999996" y="-49.199999999999996"><path d="M501.4 212.3c-11.5-8-38-11-58.6-7-2.4-20-13.5-37.5-32.7-53l-11-8-7.7 11.5c-9.6 15-14.4 36-13 56 .5 7 2.9 19.5 10.1 30.5-6.7 4-20.7 9-38.9 9H2.3l-1 4c-3.4 20-3.4 82.5 36 130.5 29.8 36.5 74 55 132.1 55 125.9 0 219.1-60.5 262.8-170 17.3.5 54.3 0 73-37.5.5-1 1.4-3 4.8-10.5l1.9-4zM280 71.3h-52.8v50H280zm0 60h-52.8v50H280zm-62.5 0h-52.8v50h52.8zm-62.4 0h-52.8v50h52.8zm-62.5 60H39.8v50h52.8zm62.5 0h-52.8v50h52.8zm62.4 0h-52.8v50h52.8zm62.5 0h-52.8v50H280zm62.4 0h-52.8v50h52.8z" style="fill:#2396ed"></path></svg></g><text class="node-label" x="0" y="-22.96" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Docker 4</text><text class="node-sub" x="0" y="32.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="opnsense-copy-1" transform="translate(2757.879480087803,307.6117116091891)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" viewBox="0 0 512 512" width="66" height="66" x="-33" y="-33"><path d="M503.1 465.4v2.1c-6 25.5-28.4 44.5-55 44.5H7.3v-46.6h38.3v7.3h403c1.1 0 2 0 2.9-.1 1.8-.1 3.6-.6 5.2-1.3 2.9-1.3 5.3-3.3 7-5.9zM63.9 0c-26.5 0-49 19-55 44.5V47H48c2.7-4.3 7.3-7.2 12.6-7.6 1-.1 2-.1 3.2-.1h402.6V47h38.3V0z" style="fill:#898b8d"></path><path d="M466.1 157.7V197H319.5v-39.3zM45.9 315.4v39.3h146.6v-39.3zm0-157.7V197h146.6v-39.3zm273.6 157.7v39.3h146.6v-39.3z" style="fill:#58595b"></path><path d="M83.8 78.6H428v39.3H83.8zm0 315.9H428v39.3H83.8z" style="fill:#403f41"></path><linearGradient id="opnsense-v1_svg__a" x1="-1460.617" x2="-1375.11" y1="1248.095" y2="1248.095" gradientTransform="matrix(.1853 .356 .6722 -.353 -90.66 993.802)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="m466.5 78.6 38.2-20.5.1-39.5-38.3 20.7" style="fill:url(#opnsense-v1_svg__a)"></path><linearGradient id="opnsense-v1_svg__b" x1="4.634" x2="50.301" y1="462.6" y2="462.6" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 64.5v-8.9c0-5.3 2.6-10 6.5-13l-34-18.5c-6.7 9.5-10.8 21.3-10.9 34l38.3 20.6v-14c.1-.1.1-.2.1-.2" style="fill:url(#opnsense-v1_svg__b)"></path><linearGradient id="opnsense-v1_svg__c" x1="-1587.887" x2="-1498.137" y1="-2208.165" y2="-2208.165" gradientTransform="matrix(-.1853 -.356 -.6722 .353 -1743.836 694.098)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M45.6 472.7v-38.9L7.3 454.5v39.7l39.9-21.5z" style="fill:url(#opnsense-v1_svg__c)"></path><linearGradient id="opnsense-v1_svg__d" x1="460.439" x2="504.436" y1="53" y2="53" gradientTransform="matrix(1 0 0 -1 0 514)" gradientUnits="userSpaceOnUse"><stop offset="0" style="stop-color:#737373"></stop><stop offset="1" style="stop-color:#333"></stop></linearGradient><path d="M466.5 456.4c0 5.5-2.7 10.3-6.9 13.2l34.2 18.4c6.8-9.5 10.8-21.2 10.9-33.8L466.5 434v12.8" style="fill:url(#opnsense-v1_svg__d)"></path><linearGradient id="opnsense-v1_svg__e" x1="2521.902" x2="2684.464" y1="-2476.233" y2="-2476.233" gradientTransform="matrix(-1.508 -1.0166 -3.1265 -1.519 -3697.438 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 197v-.4l-72.4-38.9H45.9v.2l72.5 39.1z" style="fill:url(#opnsense-v1_svg__e)"></path><linearGradient id="opnsense-v1_svg__f" x1="-1594.953" x2="-1432.391" y1="278.458" y2="278.458" gradientTransform="matrix(1.508 -1.0166 3.1265 -1.519 1804.196 -937.952)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 157.7h-74l-72.6 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__f)"></path><linearGradient id="opnsense-v1_svg__g" x1="-4327.142" x2="-4164.581" y1="1572.387" y2="1572.387" gradientTransform="matrix(1.508 1.0166 3.1265 1.519 1863.938 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M466.1 354.7v-.4l-72.4-38.9h-74.2v.2l72.6 39.1z" style="fill:url(#opnsense-v1_svg__g)"></path><linearGradient id="opnsense-v1_svg__h" x1="-413.668" x2="-246.99" y1="-1046.618" y2="-1046.618" gradientTransform="matrix(-1.508 1.0166 -3.1265 1.519 -3638.692 2252.352)" gradientUnits="userSpaceOnUse"><stop offset=".107" style="stop-color:#58595b"></stop><stop offset="1" style="stop-color:#000"></stop></linearGradient><path d="M192.5 315.4h-74.1l-72.5 39.1v.2h74.2l72.4-38.9z" style="fill:url(#opnsense-v1_svg__h)"></path><linearGradient id="opnsense-v1_svg__i" x1="74.725" x2="261.062" y1="132.65" y2="132.65" gradientTransform="matrix(.9914 0 0 -1 -66.782 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 157.7V197L7.3 97.4V58.1z" style="fill:url(#opnsense-v1_svg__i)"></path><linearGradient id="opnsense-v1_svg__j" x1="-2461.056" x2="-2274.718" y1="132.65" y2="132.65" gradientTransform="matrix(-.9914 0 0 -1 -1935.19 260.2)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 157.7V197l185.5-99.6V58.1z" style="fill:url(#opnsense-v1_svg__j)"></path><linearGradient id="opnsense-v1_svg__k" x1="-2291.845" x2="-2105.508" y1="-739.55" y2="-739.55" gradientTransform="matrix(-.9914 0 0 1 -1767.435 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M319.2 355.2v-39.8L504.7 415v39.7z" style="fill:url(#opnsense-v1_svg__k)"></path><linearGradient id="opnsense-v1_svg__l" x1="-94.103" x2="91.934" y1="-739.55" y2="-739.55" gradientTransform="matrix(.9914 0 0 1 100.993 1124.6)" gradientUnits="userSpaceOnUse"><stop offset=".237" style="stop-color:#a6a8ab"></stop><stop offset="1" style="stop-color:#404040"></stop></linearGradient><path d="M192.8 355.2v-39.8L7.3 415v39.7z" style="fill:url(#opnsense-v1_svg__l)"></path><path d="m319.2 276.1 108.9 58.5v-39.7l-35.3-18.8h111.9v-39.8H392.8l35.3-18.8v-39.3l-108.9 58.1zM83.8 334.6l109-58.5v-39.8l-109-58.1v39.3l35.7 18.8H7.3v39.8h111.9l-35.3 18.8v39.7z" style="fill:#e24525"></path></svg></g><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">OPNSENSE GUEST</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="phone" transform="translate(3312.857751572178,502.58220111114224)" style="cursor: grab;"><circle r="181.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-54.45" y="-121" width="108.9" height="242" rx="8"></rect><rect x="-45.980000000000004" y="-102.85" width="91.96000000000001" height="193.60000000000002" rx="4" style="fill: rgb(30, 41, 59);"></rect><rect x="-18.15" y="99.22" width="36.3" height="7.26" rx="2" style="fill: rgb(71, 85, 105);"></rect></g><text class="node-label" x="0" y="-33.88" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Phone</text><text class="node-sub" x="0" y="48.400000000000006" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="desktop" transform="translate(2971.700036728428,480.7287465212985)" style="cursor: grab;"><circle r="220.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"><rect x="-132.3" y="-117.60000000000001" width="264.6" height="176.4" rx="4"></rect><rect x="-110.25" y="-95.55" width="220.5" height="132.3" rx="2" style="fill: rgb(30, 41, 59);"></rect><rect x="-22.05" y="58.800000000000004" width="44.1" height="44.1"></rect><rect x="-73.5" y="102.89999999999999" width="147" height="22.05" rx="2"></rect></g><text class="node-label" x="0" y="-41.160000000000004" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Desktop</text><text class="node-sub" x="0" y="58.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="dns" transform="translate(3200.4643189549906,320.469591247861)" style="cursor: grab;"><circle r="82.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><path d="
             M -44 11
             Q -60.50000000000001 11 -60.50000000000001 -5.5
             Q -60.50000000000001 -27.5 -38.5 -27.5
             Q -38.5 -49.5 -11 -49.5
             Q 5.5 -60.50000000000001 27.5 -44
             Q 55 -44 60.50000000000001 -16.5
             Q 71.5 -5.5 60.50000000000001 11
             Q 60.50000000000001 27.5 38.5 27.5
             L -27.5 27.5
             Q -49.5 27.5 -49.5 11
             Z
            " class="node-circle" style="fill: rgb(30, 41, 59); stroke: rgb(71, 85, 105);"></path><text class="node-label" x="0" y="-15.400000000000002" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">DNS</text><text class="node-sub" x="0" y="22" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;">0.0.0.0</text></g><g class="node-group" data-node-id="racked" transform="translate(2645.5845448279656,970.7820678889219)" style="cursor: grab;"><circle r="205.5" class="node-hit-area" style="fill: transparent; stroke: none; cursor: grab;"></circle><g class="node-circle"><svg xmlns="http://www.w3.org/2000/svg" id="mdi-server-security" viewBox="0 0 24 24" width="164.4" height="164.4" x="-82.2" y="-82.2" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"><path d="M3,1H19A1,1 0 0,1 20,2V6A1,1 0 0,1 19,7H3A1,1 0 0,1 2,6V2A1,1 0 0,1 3,1M3,9H19A1,1 0 0,1 20,10V10.67L17.5,9.56L11,12.44V15H3A1,1 0 0,1 2,14V10A1,1 0 0,1 3,9M3,17H11C11.06,19.25 12,21.4 13.46,23H3A1,1 0 0,1 2,22V18A1,1 0 0,1 3,17M8,5H9V3H8V5M8,13H9V11H8V13M8,21H9V19H8V21M4,3V5H6V3H4M4,11V13H6V11H4M4,19V21H6V19H4M17.5,12L22,14V17C22,19.78 20.08,22.37 17.5,23C14.92,22.37 13,19.78 13,17V14L17.5,12M17.5,13.94L15,15.06V17.72C15,19.26 16.07,20.7 17.5,21.06V13.94Z" style="fill: rgb(1, 8, 19); stroke: rgb(255, 255, 255);"></path></svg></g><text class="node-label" x="0" y="-38.36000000000001" style="font-size: 18px; fill: rgb(226, 232, 240); font-family: Inter, system-ui, sans-serif; pointer-events: none;">Racked</text><text class="node-sub" x="0" y="54.800000000000004" style="font-size: 13px; fill: rgb(148, 163, 184); font-family: Inter, system-ui, sans-serif; pointer-events: none;"></text></g><g class="text-group" data-text-id="text-1765238422602"><text class="text-element" x="2466.35986328125" y="741.6801147460938" dominant-baseline="middle" style="fill: rgb(226, 232, 240); font-size: 40px; font-weight: normal; font-style: normal; text-anchor: start; text-decoration: none; opacity: 1; cursor: move; user-select: none;"><tspan x="2466.35986328125" dy="0">Double click on desktop</tspan><tspan x="2466.35986328125" dy="48">or long press on mobile</tspan><tspan x="2466.35986328125" dy="48">to enter rack canvas view</tspan></text><g class="text-delete-btn" style="cursor: pointer; display: none;"><circle cx="2486.35986328125" cy="701.6801147460938" r="12" style="fill: rgb(245, 101, 101); stroke: white; stroke-width: 2;"></circle><text x="2486.35986328125" y="701.6801147460938" text-anchor="middle" dominant-baseline="middle" style="fill: white; font-size: 16px; font-weight: bold; pointer-events: none;">√ó</text></g></g></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <line x1="2103.968290880771" y1="268" x2="2066.9677515897347" y2="473.4119134177565" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1773.8400660428597" y2="666.5758233298659" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="1931.1978950081452" y2="782.2775961320921" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2158.1262397347077" y2="767.7122274797483" class="minimap-edge"></line><line x1="2066.9677515897347" y1="473.4119134177565" x2="2342.2663764534577" y2="631.7681967180296" class="minimap-edge"></line><line x1="2103.968290880771" y1="268" x2="2757.879480087803" y2="307.6117116091891" class="minimap-edge"></line><line x1="2757.879480087803" y1="307.6117116091891" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><line x1="3200.4643189549906" y1="320.469591247861" x2="2971.700036728428" y2="480.7287465212985" class="minimap-edge"></line><line x1="3312.857751572178" y1="502.58220111114224" x2="3200.4643189549906" y2="320.469591247861" class="minimap-edge"></line><circle cx="2103.968290880771" cy="268" r="40" class="minimap-node"></circle><circle cx="2066.9677515897347" cy="473.4119134177565" r="40" class="minimap-node"></circle><circle cx="1773.8400660428597" cy="666.5758233298659" r="40" class="minimap-node"></circle><circle cx="1931.1978950081452" cy="782.2775961320921" r="40" class="minimap-node"></circle><circle cx="2158.1262397347077" cy="767.7122274797483" r="40" class="minimap-node"></circle><circle cx="2342.2663764534577" cy="631.7681967180296" r="40" class="minimap-node"></circle><circle cx="2757.879480087803" cy="307.6117116091891" r="40" class="minimap-node"></circle><circle cx="3312.857751572178" cy="502.58220111114224" r="40" class="minimap-node"></circle><circle cx="2971.700036728428" cy="480.7287465212985" r="40" class="minimap-node"></circle><circle cx="3200.4643189549906" cy="320.469591247861" r="40" class="minimap-node"></circle><circle cx="2645.5845448279656" cy="970.7820678889219" r="40" class="minimap-node"></circle><rect class="minimap-viewport" id="minimap-viewport" x="1254.5197896196048" y="-147.55422459755366" width="2648.185035176588" height="1986.138776382441"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">151%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <div class="badge-row" id="node-tags"><span class="badge" style="cursor: pointer; position: relative;"><span>core</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>tier-1</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; position: relative;"><span>redundant</span><span style="opacity: 0.6; margin-left: 4px; font-size: 10px;"> ‚úï</span></span><span class="badge" style="cursor: pointer; opacity: 0.6; border-style: dashed;">+ Add Tag</span></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"><li><span style="flex: 1 1 0%;">Primary core router</span><span class="delete-note">‚úï</span></li><li><span style="flex: 1 1 0%;">BGP peering enabled</span><span class="delete-note">‚úï</span></li></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateLayout() {
          const main = document.querySelector("main");
          if (!main) return;
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.innerHTML = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateLayout();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
      function updateViewBox() {
       const svg = document.getElementById("map");
       const vb = getViewBox();
       svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`, );
       const zoomLevel = document.getElementById("zoom-level");
       if (zoomLevel) {
        zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
       }
       updateMinimap();
      }
      function updateMinimap() {
       const minimapViewport = document.getElementById("minimap-viewport");
       const minimapSvg = document.getElementById("minimap");
       if (!minimapViewport || !minimapSvg) return;
       const vb = getViewBox();
       minimapViewport.setAttribute("x", vb.x);
       minimapViewport.setAttribute("y", vb.y);
       minimapViewport.setAttribute("width", vb.width);
       minimapViewport.setAttribute("height", vb.height);
       const minimapNodes = minimapSvg.querySelectorAll(".minimap-node");
       minimapNodes.forEach((n) => n.remove());
       const minimapEdges = minimapSvg.querySelectorAll(".minimap-edge");
       minimapEdges.forEach((e) => e.remove());
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const fromNode = NODE_DATA[edge.from];
        const toNode = NODE_DATA[edge.to];
        if (!fromNode || !toNode) return;
        if (currentView.mode === "rack") {
         if (fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (fromNode.assignedRack || toNode.assignedRack) {
          return;
         }
        }
        const p1 = savedPositions[edge.from];
        const p2 = savedPositions[edge.to];
        if (!p1 || !p2) return;
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line", );
        line.setAttribute("x1", p1.x);
        line.setAttribute("y1", p1.y);
        line.setAttribute("x2", p2.x);
        line.setAttribute("y2", p2.y);
        line.classList.add("minimap-edge");
        minimapSvg.insertBefore(line, minimapViewport);
       });
       Object.entries(savedPositions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) {
          return;
         }
        } else {
         if (node.assignedRack) {
          return;
         }
        }
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle", );
        circle.setAttribute("cx", pos.x);
        circle.setAttribute("cy", pos.y);
        circle.setAttribute("r", 40);
        circle.classList.add("minimap-node");
        minimapSvg.insertBefore(circle, minimapViewport);
       });
      }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId].name} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
        const gridGroup = document.createElementNS(ns, "g");
        gridGroup.id = "canvas-grid";
        const gridSize = PAGE_STATE.canvasGridSize || 50;
        const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
        const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
        for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", x);
         line.setAttribute("y1", CANVAS_PADDING);
         line.setAttribute("x2", x);
         line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
         line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", CANVAS_PADDING);
         line.setAttribute("y1", y);
         line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
         line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
         gridGroup.appendChild(line);
        }
        svg.appendChild(gridGroup);
       }
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
        const handleConfirm = () => {
         onConfirm();
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        const handleCancel = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", function bgHandler(e) {
         if (e.target === modal) {
          handleCancel();
          modal.removeEventListener("click", bgHandler);
         }
        });
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = nodesInRack.map(([nid, n]) => {
           const tags = (n.tags || []).map(t => `<span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">${t}</span>`).join('');
           return `<div style="padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;" onclick="claimTheImmortal('${nid}')">
            <span style="color: var(--text-main);">${n.name}</span>${tags}
           </div>`;
          }).join('');
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
        document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (isSelecting) {
          updateSelection(e);
          return;
         }
         if (!canvasState.isPanning) return;
         const dx = e.clientX - canvasState.panStartX;
         const dy = e.clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const moveDx = Math.abs(e.touches[0].clientX - emptyTapStartX);
        const moveDy = Math.abs(e.touches[0].clientY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        const dx = e.touches[0].clientX - canvasState.panStartX;
         const dy = e.touches[0].clientY - canvasState.panStartY;
         const rect = viewport.getBoundingClientRect();
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const canvasDx = (dx / rect.width) * viewWidth;
         const canvasDy = (dy / rect.height) * viewHeight;
         canvasState.panX = panStartViewX - canvasDx;
         canvasState.panY = panStartViewY - canvasDy;
         constrainPan();
         updateViewBox();
        });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
		pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
        const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
      return {
        nodes: JSON.parse(JSON.stringify(NODE_DATA)),
        edges: JSON.parse(JSON.stringify(EDGE_DATA)),
        positions: JSON.parse(JSON.stringify(savedPositions)),
        sizes: JSON.parse(JSON.stringify(savedSizes)),
        styles: JSON.parse(JSON.stringify(savedStyles)),
        legend: JSON.parse(JSON.stringify(EDGE_LEGEND)),
        rects: JSON.parse(JSON.stringify(RECT_DATA)),
        texts: JSON.parse(JSON.stringify(TEXT_DATA))
        };
      }
      function pushUndo(action = "") {
       const state = captureState();
       undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		// forgeTheTopology(); getting ready to implement new core canvas performance system
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${textItem.content.substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
      function searchNodes(query) {
   if (!query) {
    clearSearchHighlight();
    return [];
   }
   query = query.toLowerCase();
   const results = [];
   Object.entries(NODE_DATA).forEach(([id, data]) => {
    try {
     const nameMatch = data.name && data.name.toLowerCase().includes(query);
     const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
     const roleMatch = data.role && data.role.toLowerCase().includes(query);
     const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
     const macMatch = data.mac && data.mac.toLowerCase().includes(query);
     const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
     if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
      results.push(id);
     }
    } catch (e) {
     console.warn("Search error for node:", id, e);
    }
   });
   highlightSearchResults(results);
   return results;
}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "flex";
       document.getElementById("modal-input").focus();
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        document.getElementById("edit-modal").style.display = "none";
        claimTheImmortal(id);
        forgeTheTopology();
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       const cancelHandler = () => {
        document.getElementById("edit-modal").style.display = "none";
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       document.getElementById("edit-modal").addEventListener("click", function bgHandler(e) {
        if (e.target === document.getElementById("edit-modal")) {
         cancelHandler();
         document.getElementById("edit-modal").removeEventListener("click", bgHandler);
        }
       });
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
if (searchInput) {
 searchInput.addEventListener("input", (e) => {
  searchNodes(e.target.value);
 });
}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.from}'); focusOnSelected()">${fromName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.fromPort || "-"}</td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${e.to}'); focusOnSelected()">${toName}</td><td style="padding: 10px; font-family: monospace; color: var(--accent); cursor: pointer;" onclick="document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${e.id}'); focusOnSelected()">${e.toPort || "-"}</td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${notes || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${timeStr}</div>
                <div class="details">${version.description} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${tab.name}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `<div class="audit-entry ${event.type}">
              <div class="time">[${timeStr}] ${event.tab}</div>
              <div class="action">[${event.type.toUpperCase()}] ${event.description}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${name}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${name}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${name}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        pushUndo("clear all");
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
		logAuditEvent("clear", "Cleared all data from canvas");
        clearAllModal.classList.remove("active");
      autoPingEnabled = false;
      autoPingInterval = 30;
      PAGE_STATE.autoPingEnabled = false;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      stopAutoPing();
      document.getElementById("auto-ping-enabled").checked = false;
      document.getElementById("auto-ping-settings").style.display = "none";
      document.getElementById("auto-ping-interval").value = autoPingInterval;
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
       });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>