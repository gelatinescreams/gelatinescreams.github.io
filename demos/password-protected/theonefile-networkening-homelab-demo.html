<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 45px; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ==================================================================================
      * The One File: The Networkening
      * !!!!!!!!!!!!!!!!!!!NOTE: THIS IS THE ONLINE VERSION!!!!!!!!!!!!!!!!!!!!!!
      * Online version uses 3 cdn calls from cdn.jsdelivr.net to display additional icons
      * Since 3.0 Online version uses http as a form of ping to display uptime
      * "There can be only one". A all in one file topology maker.
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ==================================================================================
      -->
    <style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      max-height: calc(100vh - var(--topbar-height, 100px) - 120px);
      overflow-y: auto;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
	  .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
	  .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: var(--canvas-hint-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      color: var(--canvas-hint-color, var(--text-soft));
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      .ping-indicator {
      fill: #6b7280;
      stroke: #4b5563;
      stroke-width: 1;
      }
      .ping-indicator.online {
      fill: #10b981;
      stroke: #059669;
      }
      .ping-indicator.offline {
      fill: #ef4444;
      stroke: #dc2626;
      }
      .ping-indicator.checking {
      fill: #f59e0b;
      stroke: #d97706;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "‚ñº";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 999999;
      justify-content: center;
      align-items: center;
      overflow: auto;
      }
      .modal.active {
      display: inline-grid;
      }
      .modal-content {
      background: var(--panel-alt);
      padding: 25px;
      border-radius: 8px;
      border: 1px solid var(--edge-main);
      min-width: 300px;
      max-width: 90%;
      }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
	 .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
	  .node-group.layer-faded {
      pointer-events: none;
      }
      .edge.layer-faded {
      pointer-events: none;
      }
      .node-group.search-highlight .node-circle,
      .node-group.search-highlight rect,
      .node-group.search-highlight polygon {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
  opacity: 0.15;
  pointer-events: none;
}
.node-group.search-faded .node-label,
.node-group.search-faded .node-sub {
  opacity: 0.3;
}
.edge-group.search-faded,
.edge.search-faded {
  opacity: 0.1;
}
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
     .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
	  .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
	  input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      }
      .topology-toolbar {
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      }
      .icon-picker-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 999999999;
      justify-content: center;
      align-items: center;
      }
      .icon-picker-modal.active {
      display: flex;
      }
      .icon-picker-content {
      background: var(--panel);
      border-radius: 12px;
      width: 90%;
      max-width: 800px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      border: 1px solid var(--edge-main);
      }
      .icon-picker-header {
      padding: 20px;
      border-bottom: 1px solid var(--edge-main);
      }
      .icon-picker-header h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      }
      .icon-picker-tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      }
      .icon-picker-tab {
      padding: 8px 16px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      color: var(--text-soft);
      font-size: 14px;
      transition: all 0.2s;
      }
      .icon-picker-tab:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .icon-picker-tab.active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .icon-picker-search {
      width: 100%;
      padding: 10px 15px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      color: var(--text-main);
      font-size: 14px;
      }
      .icon-picker-search::placeholder {
      color: var(--text-soft);
      }
      .icon-picker-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
      }
      .icon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 10px;
      }
      .icon-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 15px 10px;
      background: var(--panel-alt);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .icon-item:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: scale(1.05);
      }
      .icon-item svg {
      width: 32px;
      height: 32px;
      fill: var(--text-main);
      }
      .icon-item:hover svg {
      fill: var(--bg);
      }
      .icon-item-name {
      margin-top: 8px;
      font-size: 10px;
      color: var(--text-soft);
      text-align: center;
      word-break: break-word;
      }
      .icon-item:hover .icon-item-name {
      color: var(--bg);
      }
      .icon-picker-loading {
      text-align: center;
      padding: 40px;
      color: var(--text-soft);
      }
      .icon-picker-footer {
      padding: 15px 20px;
      border-top: 1px solid var(--edge-main);
      display: flex;
      justify-content: flex-end;
      }
      .icon-btn-cancel {
      padding: 8px 20px;
      background: var(--panel-alt);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      }
      .icon-btn-cancel:hover {
      background: var(--edge-main);
      }
      .icon-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 4px 8px;
      background: var(--panel-alt);
      border-radius: 4px;
      font-size: 12px;
      margin: 2px;
      }
      .icon-badge svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
      }
      .pick-icon-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      margin-top: 8px;
      width: 100%;
      }
      .pick-icon-btn:hover {
      opacity: 0.9;
      }
      @media (max-width: 768px) {
      .icon-picker-content {
      width: 95%;
      max-height: 90vh;
      }
      .modal-content {
      background: var(--panel-alt);
      }
      #search-input {
      width: 100%;
      }
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode .resize-handle,
      body.view-only-mode .edge-control-point {
        display: none !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY ‚Ä¢ click 5√ó to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="icon-picker-modal" id="icon-picker-modal">
      <div class="icon-picker-content">
        <div class="icon-picker-header">
          <h3>Select Icon</h3>
          <div class="icon-picker-tabs">
            <button class="icon-picker-tab" data-library="mdi">MDI</button>
            <button class="icon-picker-tab" data-library="simple">Simple Icons</button>
            <button class="icon-picker-tab active" data-library="selfhst">selfh.st/icons</button>
          </div>
          <input type="text" class="icon-picker-search" id="icon-search" placeholder="Search icons..." style="display: none;">
        </div>
        <div class="icon-picker-body" id="icon-picker-body">
        </div>
        <div class="icon-picker-footer">
          <button class="icon-btn-cancel" id="icon-picker-cancel">Cancel</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes ‚Ä¢ 65 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes ‚Ä¢ 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">üóëÔ∏è</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;">
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Section name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Name</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long-press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double-tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
	<div class="modal-content">
        <h2>Settings</h2>
        <details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable all editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
		    <div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
       </details>
	   <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90¬∞)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Import / Export / Upgrade JSON</summary>
          <div class="style-content">
            <button id="export-data-btn" style="width:100%;margin-bottom:10px;padding:10px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Export JSON</button>
            <button id="import-data-btn" style="width:100%;padding:10px;background:var(--panel);color:var(--text-main);border:1px solid var(--edge-main);border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Import JSON</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
         <details class="style-section">
          <summary>Auto Status Checking</summary>
          <div class="style-content">
            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px; cursor: pointer;">
            <input type="checkbox" id="auto-ping-enabled" style="cursor: pointer;">
            <span style="font-size: 14px; font-weight: 600;">Enable automatic status checking</span>
            </label>
            <div id="auto-ping-settings" style="display: none; padding-left: 20px; border-left: 2px solid var(--edge-main);">
              <div class="style-row" style="margin-bottom: 12px;">
                <label>Check Interval (seconds):</label>
                <input type="number" id="auto-ping-interval" min="5" max="3600" value="30" style="width: 80px; padding: 6px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
              </div>
              <div style="padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main); font-size: 12px; color: var(--text-soft);">
                <div style="margin-bottom: 4px;"><span id="auto-ping-next-check">Next check in: --</span></div>
                <div><span id="auto-ping-last-run">Last run: 1:15:07 PM</span></div>
              </div>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--text-soft); font-style: italic;">
              Automatically checks all ping enabled nodes at the specified interval. I recommend 30 to 60 seconds for local networks.
            </p>
			</div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
          <input type="text" id="new-node-name" placeholder="e.g. web server, jellyfin">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
          <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
          <button class="pick-icon-btn" id="pick-new-node-tag-icon-btn" style="margin-top: 10px;">Add Icon Tag</button>
          <div id="new-node-icon-tags" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Icon Tags:</label>
            <div id="new-node-icon-tags-list" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;"></div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Node Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Basic Shapes</label>
          <select id="new-node-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-node-icon-btn" style="margin-top: 10px;"> Or search web icons</button>
          <div id="selected-node-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-node-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="https://cdn.jsdelivr.net/gh/selfhst/icons@master/png/docker.png" width="24" height="24"></image>
              </svg>
              <span>docker</span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Ping / Status Monitoring</div>
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
          <input type="checkbox" id="new-node-pingable" style="cursor: pointer;">
          <span style="color: var(--text-soft); font-size: 13px;">Enable ping/status check for this node</span>
          </label>
          <div id="new-node-ping-options" style="display: block; padding-left: 24px; border-left: 2px solid var(--edge-main);">
            <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Protocol</label>
            <select id="new-node-ping-protocol" style="margin-bottom: 12px;">
              <option value="http">HTTP (port 80) uses IP field</option>
              <option value="https">HTTPS (port 443) uses IP field</option>
              <option value="custom">Custom URL</option>
            </select>
            <div id="new-node-custom-url-container" style="display: block;">
              <label style="display: block; margin-bottom: 4px; color: var(--text-soft); font-size: 13px;">Custom URL</label>
              <input type="text" id="new-node-custom-url" placeholder="e.g. http://192.168.1.1:8080">
            </div>
            <label style="display: block; margin-bottom: 4px; margin-top: 8px; color: var(--text-soft); font-size: 13px;">
            Timeout (ms)
            </label>
            <input type="number" id="new-node-ping-timeout" value="3000" min="1000" max="10000" step="500">
          </div>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Basic Information</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
          <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01, Production-01">
          <label style="display: block;margin-bottom: 4px;margin-top: 12px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
          <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Tags</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Text Tags (comma separated)</label>
          <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1, Row A">
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Appearance</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
          <select id="new-rack-shape">
            <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
          </select>
          <button class="pick-icon-btn" id="pick-rack-icon-btn" style="margin-top: 10px;">Or Search Web Icons</button>
          <div id="selected-rack-icon" style="margin-top: 10px; display: none;">
            <label style="display: block; margin-bottom: 8px; color: var(--text-soft); font-size: 13px;">Selected Icon:</label>
            <div class="icon-badge" id="selected-rack-icon-preview">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
                <image href="" width="24" height="24"></image>
              </svg>
              <span></span>
            </div>
          </div>
        </div>
        <div style="background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
          <div style="font-weight: 600; color: var(--text-main); margin-bottom: 12px; font-size: 14px;">Rack Configuration</div>
          <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
          <select id="new-rack-capacity">
            <option value="42" selected="">42U (Standard Full Rack)</option>
            <option value="48">48U (Large Rack)</option>
            <option value="24">24U (Half Rack)</option>
            <option value="12">12U (Small/Wall Mount)</option>
            <option value="6">6U (Mini Rack)</option>
          </select>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save File</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
          <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
          <span title="Encrypt data with password">Encrypt</span>
          </label>
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">‚Üê Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">‚Ü∂</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">‚Ü∑</button>
<input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="check-all-ping-btn" title="Check status of all enabled nodes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600">Check Pings</button>
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
        <button onclick="screenshotCanvas()" title="Export canvas as PNG image" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">PNG</button>
        <button onclick="exportCanvasSVG()" title="Export canvas as SVG vector" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">SVG</button>
        <button id="settings-btn" title="Page settings">‚öôÔ∏è</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">‚ò∞</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">‚úï</button>
          <button id="draw-toggle" title="Draw custom line">‚úèÔ∏è</button>
          <button id="rect-toggle" title="Draw zone">‚ñ≠</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Right</option>
            <option value="backward">‚Üê Left</option>
            <option value="both">‚Üî Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">‚úï</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
	      <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">     
		 <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">‚Üí Forward</option>
            <option value="backward">‚Üê Backward</option>
            <option value="both">‚Üî Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">‚úï</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">‚¨Ö Left</button>
          <button id="bulk-align-right" title="Align right">‚û° Right</button>
          <button id="bulk-align-top" title="Align top">‚¨Ü Top</button>
          <button id="bulk-align-bottom" title="Align bottom">‚¨á Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">‚Üî Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">‚Üï Distribute V</button>
          <button id="bulk-clone" title="Clone selected">üìã Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="display: none">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius:20px;border-top-right-radius:20px;padding:20px;padding-bottom:(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">‚úï</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">‚¨Ö<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">‚û°<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">‚¨Ü<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">‚¨á<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">‚Üî<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">‚Üï<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">üîí<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">‚≠ï<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">üìã<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">üóë<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint"></div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">‚úï</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="1070.1654680146785 -170.2288153174373 3002.171020164141 2251.628265123106" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">‚úï</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="1070.1654680146785" y="-170.2288153174373" width="3002.171020164141" height="2251.628265123106"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">133%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto; display: none;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px; display: none;">Add Line</button>
     </section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="flex: 1; cursor: pointer; color: var(--text-main);">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="flex: 1; cursor: pointer; color: var(--text-main);">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="flex: 1; cursor: pointer; color: var(--text-main);">2U</span>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="dc-rack-a1">DC Rack A1</option><option value="dc-rack-a2">DC Rack A2</option><option value="dc-rack-b1">DC Rack B1</option><option value="dc-rack-b2">DC Rack B2</option><option value="dmz-rack">DMZ Rack</option><option value="mgmt-rack">Management Rack</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
              <option value="6">6U</option>
            </select>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px; width: 80px;">Layer:</span>
            <select id="node-layer" style="flex: 1; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-role" id="node-role">Core Routing</div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">‚Üî</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-tag-input" placeholder="Add tag..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-tag-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button class="pick-icon-btn" id="pick-tag-icon-btn">Add Icon Tag</button>
          <div class="section-label">Size</div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select"><option value="custom-icon">Custom Icon</option>
                  <optgroup label="Basic Shapes">
            <option value="circle">Circle</option>
            <option value="square">Square</option>
            <option value="rectangle">Rectangle</option>
            <option value="triangle">Triangle</option>
            <option value="hexagon">Hexagon</option>
            <option value="diamond">Diamond</option>
            <option value="star">Star</option>
            <option value="stop-sign">Stop Sign</option>
            <option value="octagon">Octagon</option>
            <option value="pentagon">Pentagon</option>
            <option value="cross">Cross</option>
            <option value="rounded-square">Rounded Square</option>
            <option value="pill">Pill</option>
            <option value="parallelogram">Parallelogram</option>
            <option value="trapezoid">Trapezoid</option>
          </optgroup>
          <optgroup label="Computers &amp; Devices">
            <option value="server">Server</option>
            <option value="pc">PC / Desktop</option>
            <option value="laptop">Laptop</option>
            <option value="phone">Phone / Mobile</option>
            <option value="printer">Printer</option>
            <option value="pi">Raspberry Pi</option>
            <option value="sensor">Sensor / IoT</option>
          </optgroup>
          <optgroup label="Network Equipment">
            <option value="router">Router</option>
            <option value="switch">Switch</option>
            <option value="firewall">Firewall</option>
            <option value="access-point">Access Point</option>
            <option value="load-balancer">Load Balancer</option>
            <option value="gateway">Gateway</option>
            <option value="vpn">VPN / Tunnel</option>
            <option value="nas">NAS / Storage</option>
          </optgroup>
          <optgroup label="Cloud &amp; Services">
            <option value="cloud">Cloud</option>
            <option value="database">Database</option>
			<option value="docker">Docker</option>
            <option value="container">Container</option>
            <option value="vm">Virtual Machine</option>
            <option value="kubernetes">Kubernetes</option>
            <option value="api">API / Endpoint</option>
            <option value="queue">Queue / Message</option>
            <option value="lambda">Lambda / Function</option>
            <option value="bucket">Bucket / S3</option>
          </optgroup>
          <optgroup label="Security &amp; Monitoring">
            <option value="shield">Shield</option>
            <option value="camera">Camera / CCTV</option>
            <option value="monitor">Monitor / Dashboard</option>
          </optgroup>
                </select>
              </div>
              <button class="pick-icon-btn" id="pick-shape-icon-btn">Or Search Web Icons</button>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif">System UI</option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace">Courier</option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif">Times</option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="
                margin-top: 12px;
                padding-top: 10px;
                border-top: 1px solid var(--edge-main);
                ">
                <div style="font-size: 12px;color: var(--text-soft);margin-bottom: 8px;text-transform: uppercase;">Text Position</div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div style="margin-top: 16px; font-size: 12px; color: var(--text-soft); text-transform: uppercase;">
                  Ping Indicator Position
                </div>
                <div class="style-row">
                  <label>Ping X:</label>
                  <input type="number" id="ping-offset-x" min="-200" max="200" value="0" style="width: 60px;">
                </div>
                <div class="style-row">
                  <label>Ping Y:</label>
                  <input type="number" id="ping-offset-y" min="-200" max="200" value="0" style="width: 60px;">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <details class="style-section">
            <summary>Ping / Status Monitoring</summary>
            <div class="style-content">
              <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; cursor: pointer;">
              <input type="checkbox" id="node-pingable" style="cursor: pointer;">
              <span style="font-size: 14px;">Enable status check for this node</span>
              </label>
              <div id="node-ping-options" style="display: none;">
                <div class="style-row">
                  <label>Protocol:</label>
                  <select id="node-ping-protocol">
                    <option value="http">HTTP (port 80)</option>
                    <option value="https">HTTPS (port 443)</option>
                    <option value="custom">Custom URL</option>
                  </select>
                </div>
                <div id="node-custom-url-container" style="display: block; margin-top: 8px;">
                  <label style="display: block; margin-bottom: 4px; font-size: 13px;">Custom URL:</label>
                  <input type="text" id="node-custom-url" placeholder="e.g. http://192.168.1.1:8080" style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;">
                </div>
                <div class="style-row" style="margin-top: 8px;">
                  <label>Timeout (ms):</label>
                  <input type="number" id="node-ping-timeout" value="3000" min="1000" max="10000" step="500" style="width: 100px;">
                </div>
                <div style="margin-top: 12px; padding: 10px; background: var(--panel); border-radius: 6px; border: 1px solid var(--edge-main);">
                  <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px;">Current Status:</div>
                  <div id="node-ping-status" style="font-size: 14px; font-weight: 600; color: var(--accent);">‚óè Online</div>
                  <div id="node-ping-last-check" style="font-size: 11px; color: var(--text-soft); margin-top: 4px;">Last checked: 2:25:19 PM</div>
                </div>
                <button id="check-ping-now" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Check Status Now</button>
              </div>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90¬∞)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">‚Üí Forward</option>
              <option value="backward">‚Üê Backward</option>
              <option value="both">‚Üî Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-port-fields">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="style-row" id="edge-port-fields-to">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);font-size: 14px;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
		  <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Text</button>
        </div>
     <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              ‚Ä¢ <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              ‚Ä¢ <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              ‚Ä¢ <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
	Object.keys(localStorage).forEach(key => {
       if (key.startsWith('icon-selfhst-')) {
        const val = localStorage.getItem(key);
        if (val && val.includes('<image href=')) {
         localStorage.removeItem(key);
        }
       }
      });
      const IconLibrary = {
       libraries: {
        mdi: {
         name: 'Material Design Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/svg/',
         metaUrl: 'https://cdn.jsdelivr.net/npm/@mdi/svg@latest/meta.json',
         icons: []
        },
        simple: {
         name: 'Simple Icons',
         cdnBase: 'https://cdn.jsdelivr.net/npm/simple-icons@latest/icons/',
         indexUrl: 'https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json',
         icons: []
        },
        selfhst: {
         name: 'selfh.st/icons',
         cdnBase: 'https://cdn.jsdelivr.net/gh/selfhst/icons@master/svg/',
         indexUrl: 'https://raw.githubusercontent.com/selfhst/icons/refs/heads/main/index.json',
         icons: []
        }
       },
       currentLibrary: 'selfhst',
       iconCache: {},
       indexCache: {},
       indexLoading: {},
       async loadLibraryIndex(library) {
        if (this.indexCache[library]) {
         return this.indexCache[library];
        }
        if (this.indexLoading[library]) {
         return this.indexLoading[library];
        }
        const lib = this.libraries[library];
        this.indexLoading[library] = (async () => {
         try {
          if (library === 'selfhst') {
           const response = await fetch(lib.indexUrl);
           const data = await response.json();
           const icons = data.filter(item => item.SVG === "Yes").map(item => ({
            name: item.Reference,
            displayName: item.Name,
            tags: item.Tags ? item.Tags.split(',').map(t => t.trim()).filter(t => t) : [],
            category: item.Category
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'simple') {
           const response = await fetch('https://cdn.jsdelivr.net/npm/@iconify-json/simple-icons@latest/icons.json');
           const data = await response.json();
           const icons = Object.keys(data.icons).map(slug => ({
            name: slug,
            displayName: data.icons[slug].title || slug,
            tags: data.aliases && data.aliases[slug] ? [data.aliases[slug].parent] : [],
            hex: data.icons[slug].hex
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          } else if (library === 'mdi') {
           const response = await fetch(lib.metaUrl);
           const data = await response.json();
           const icons = data.map(item => ({
            name: item.name,
            displayName: item.name,
            tags: item.tags || [],
            author: item.author
           }));
           this.indexCache[library] = icons;
           lib.icons = icons;
           return icons;
          }
         } catch (error) {
          console.error(`Failed to load index for ${library}:`, error);
          this.indexCache[library] = [];
          lib.icons = [];
          return [];
         } finally {
          delete this.indexLoading[library];
         }
        })();
        return this.indexLoading[library];
       },
       async getIcon(library, name) {
        const cacheKey = `${library}-${name}`;
        if (this.iconCache[cacheKey]) {
         return this.iconCache[cacheKey];
        }
        const cached = localStorage.getItem(`icon-${cacheKey}`);
        if (cached) {
         this.iconCache[cacheKey] = cached;
         return cached;
        }
        const lib = this.libraries[library];
        const url = `${lib.cdnBase}${name}.svg`;
        try {
         const response = await fetch(url);
         if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
         }
         const svg = await response.text();
         this.iconCache[cacheKey] = svg;
         localStorage.setItem(`icon-${cacheKey}`, svg);
         return svg;
        } catch (error) {
         console.error(`Failed to fetch icon ${cacheKey}:`, error);
         return null;
        }
       },
       searchIcons(library, query) {
        const lib = this.libraries[library];
        if (!lib.icons.length) return [];
        const q = query.toLowerCase();
        return lib.icons.filter(icon => {
         const nameMatch = icon.name.toLowerCase().includes(q);
         const displayMatch = icon.displayName && icon.displayName.toLowerCase().includes(q);
         const tagMatch = icon.tags && icon.tags.some(t => t.toLowerCase().includes(q));
         const categoryMatch = icon.category && icon.category.toLowerCase().includes(q);
         return nameMatch || displayMatch || tagMatch || categoryMatch;
        }).slice(0, 50);
       }
      };
      let iconPickerCallback = null;
      let selectedNodeIconData = null;
      let selectedRackIconData = null;
      let newNodeIconTags = [];
      let freeDrawMode = false;
      async function checkNodeStatus(nodeId) {
       const data = NODE_DATA[nodeId];
       if (!data || !data.ping || !data.ping.enabled) return;
       data.ping.status = 'checking';
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
       let url;
       if (data.ping.protocol === 'custom') {
        url = data.ping.customUrl;
       } else {
        const ip = data.ip || '0.0.0.0';
        const protocol = data.ping.protocol || 'http';
        url = `${protocol}://${ip}`;
       }
       if (!url) {
        data.ping.status = 'unknown';
        updatePingIndicator(nodeId);
        if (currentNodeId === nodeId) {
         updatePingStatusDisplay(nodeId);
        }
        return;
       }
       try {
        const controller = new AbortController();
        const timeout = data.ping.timeout || 3000;
        const timeoutId = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(url, {
         method: 'HEAD',
         mode: 'no-cors',
         signal: controller.signal
        });
        clearTimeout(timeoutId);
        data.ping.status = 'online';
       } catch (error) {
        data.ping.status = 'offline';
       }
       data.ping.lastCheck = new Date().toISOString();
       updatePingIndicator(nodeId);
       if (currentNodeId === nodeId) {
        updatePingStatusDisplay(nodeId);
       }
      }
      function rgbaToHex(val) {
      if (!val) return "#000000";
      if (val.startsWith("#")) return val;
      const m = val.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!m) return "#000000";
      const r = Number(m[1]).toString(16).padStart(2, "0");
      const g = Number(m[2]).toString(16).padStart(2, "0");
      const b = Number(m[3]).toString(16).padStart(2, "0");
      return `#${r}${g}${b}`;
      }
      function updatePingIndicator(nodeId) {
      const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
      if (!nodeGroup) return;
      const data = NODE_DATA[nodeId];
      if (!data || !data.ping || !data.ping.enabled) {
       const existingIndicator = nodeGroup.querySelector('.ping-indicator');
       if (existingIndicator) existingIndicator.remove();
       return;
      }
      let indicator = nodeGroup.querySelector('.ping-indicator');
      const label = nodeGroup.querySelector('.node-label');
      if (!indicator && label) {
       indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
       indicator.classList.add('ping-indicator');
       nodeGroup.appendChild(indicator);
      }
      if (indicator && label) {
       const size = savedSizes[nodeId] || getDefaultSize();
       const radius = Math.max(4, size * 0.06);
       indicator.setAttribute('r', radius);
       const labelBBox = label.getBBox();
       const labelX = parseFloat(label.getAttribute('x') || 0);
       const labelY = parseFloat(label.getAttribute('y') || 0);
       const styles = resolveStylesForNode(nodeId);
      const offX = styles.pingOffsetX || 0;
      const offY = styles.pingOffsetY || 0;
      indicator.setAttribute('cx', (labelX - labelBBox.width / 2 - radius * 1.1) + offX);
      indicator.setAttribute('cy', (labelY - radius * 0.7) + offY);
      }
      if (indicator) {
       indicator.classList.remove('online', 'offline', 'checking');
       if (data.ping.status) indicator.classList.add(data.ping.status);
      }
      }
      function checkAllNodesStatus() {
       Object.keys(NODE_DATA).forEach(nodeId => {
        const data = NODE_DATA[nodeId];
        if (data && data.ping && data.ping.enabled) {
         checkNodeStatus(nodeId);
        }
       });
      }
      function startAutoPing() {
       stopAutoPing();
       checkAllNodesStatus();
       updateAutoPingLastRun();
       autoPingSecondsRemaining = autoPingInterval;
       autoPingTimer = setInterval(() => {
        checkAllNodesStatus();
        updateAutoPingLastRun();
        autoPingSecondsRemaining = autoPingInterval;
       }, autoPingInterval * 1000);
       autoPingCountdown = setInterval(() => {
        autoPingSecondsRemaining--;
        updateAutoPingCountdown();
        if (autoPingSecondsRemaining <= 0) {
         autoPingSecondsRemaining = autoPingInterval;
        }
       }, 1000);
       updateAutoPingCountdown();
      }
      function stopAutoPing() {
       if (autoPingTimer) {
        clearInterval(autoPingTimer);
        autoPingTimer = null;
       }
       if (autoPingCountdown) {
        clearInterval(autoPingCountdown);
        autoPingCountdown = null;
       }
       autoPingSecondsRemaining = 0;
       updateAutoPingCountdown();
      }
      function updateAutoPingCountdown() {
       const nextCheckEl = document.getElementById('auto-ping-next-check');
       if (nextCheckEl) {
        if (autoPingSecondsRemaining > 0 && autoPingEnabled) {
         const mins = Math.floor(autoPingSecondsRemaining / 60);
         const secs = autoPingSecondsRemaining % 60;
         if (mins > 0) {
          nextCheckEl.textContent = `Next check in: ${mins}m ${secs}s`;
         } else {
          nextCheckEl.textContent = `Next check in: ${secs}s`;
         }
        } else {
         nextCheckEl.textContent = 'Next check in: --';
        }
       }
      }
      function updateAutoPingLastRun() {
       const lastRunEl = document.getElementById('auto-ping-last-run');
       if (lastRunEl) {
        const now = new Date();
        lastRunEl.textContent = `Last run: ${now.toLocaleTimeString()}`;
       }
      }
      function openIconPicker(callback) {
       iconPickerCallback = callback;
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.add('active');
       const searchInput = document.getElementById('icon-search');
       searchInput.style.display = 'none';
       loadIconsForCurrentLibrary();
      }
      function closeIconPicker() {
       const modal = document.getElementById('icon-picker-modal');
       modal.classList.remove('active');
       iconPickerCallback = null;
      }
      async function loadIconsForCurrentLibrary() {
       const body = document.getElementById('icon-picker-body');
       const libNames = {
        mdi: 'MDI (Material Design Icons)',
        simple: 'Simple Icons',
        selfhst: 'selfh.st/icons'
       };
       body.innerHTML = `<div style="padding: 20px;"><p style="color: var(--text-soft); margin-bottom: 15px; text-align: center;">Search ${libNames[IconLibrary.currentLibrary]}:</p><input type="text" id="icon-search-field" placeholder="Search icons..." style="width: 100%; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-size: 16px; margin-bottom: 20px;"><div id="icon-grid-container" style="max-height: 400px; overflow-y: auto;"><div style="text-align: center; color: var(--text-soft); padding: 40px;">Loading icons...</div></div></div>`;
       const searchField = document.getElementById('icon-search-field');
       const gridContainer = document.getElementById('icon-grid-container');
       await IconLibrary.loadLibraryIndex(IconLibrary.currentLibrary);
       const renderIcons = (icons) => {
        if (!icons || icons.length === 0) {
         gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">No icons found</div>';
         return;
        }
        const grid = document.createElement('div');
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; padding: 10px;';
        icons.forEach(icon => {
         const item = document.createElement('div');
         item.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 15px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; transition: all 0.2s;';
         item.onmouseover = () => {
          item.style.background = 'var(--panel)';
          item.style.borderColor = 'var(--accent)';
         };
         item.onmouseout = () => {
          item.style.background = 'var(--panel-alt)';
          item.style.borderColor = 'var(--edge-main)';
         };
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 48px; height: 48px; display: flex; align-items: center; justify-content: center;';
         iconPreview.innerHTML = '<div style="color: var(--text-soft); font-size: 12px;">...</div>';
         IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '48');
            svgEl.setAttribute('height', '48');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.innerHTML = '';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('div');
         name.textContent = icon.displayName || icon.name;
         name.style.cssText = 'font-size: 11px; color: var(--text-soft); text-align: center; word-break: break-word; max-width: 100%;';
         item.appendChild(iconPreview);
         item.appendChild(name);
         item.addEventListener('click', async () => {
          const svg = await IconLibrary.getIcon(IconLibrary.currentLibrary, icon.name);
          if (iconPickerCallback && svg) {
           iconPickerCallback({
            library: IconLibrary.currentLibrary,
            name: icon.name,
            svg: svg
           });
          }
          closeIconPicker();
         });
         grid.appendChild(item);
        });
        gridContainer.innerHTML = '';
        gridContainer.appendChild(grid);
       };
       gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
       let searchTimeout;
       searchField.addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        const query = e.target.value.trim();
        searchTimeout = setTimeout(() => {
         if (!query) {
          gridContainer.innerHTML = '<div style="text-align: center; color: var(--text-soft); padding: 40px;">Type to search icons</div>';
          return;
         }
         const results = IconLibrary.searchIcons(IconLibrary.currentLibrary, query);
         renderIcons(results);
        }, 300);
       });
       searchField.focus();
      }
      async function displayIcons(icons) {
       const body = document.getElementById('icon-picker-body');
       const grid = document.createElement('div');
       grid.className = 'icon-grid';
       for (const icon of icons) {
        const item = document.createElement('div');
        item.className = 'icon-item';
        const svg = await IconLibrary.getIcon(icon.library, icon.name);
        if (svg) {
         const parser = new DOMParser();
         const doc = parser.parseFromString(svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         if (svgEl) {
          item.innerHTML = svgEl.outerHTML;
         }
        } else {
         item.innerHTML = '<svg width = "32" height = "32"><rect width = "32" height = "32" fill = "currentColor"/> </svg>';
        }
        const name = document.createElement('div');
        name.className = 'icon-item-name';
        name.textContent = icon.name;
        item.appendChild(name);
        item.addEventListener('click', () => {
         if (iconPickerCallback) {
          iconPickerCallback({
           library: icon.library,
           name: icon.name,
           svg: svg
          });
         }
         closeIconPicker();
        });
        grid.appendChild(item);
       }
       body.innerHTML = '';
       body.appendChild(grid);
      }
      window.addEventListener('DOMContentLoaded', () => {
       document.querySelectorAll('.icon-picker-tab').forEach(tab => {
        tab.addEventListener('click', () => {
         document.querySelectorAll('.icon-picker-tab').forEach(t => t.classList.remove('active'));
         tab.classList.add('active');
         IconLibrary.currentLibrary = tab.dataset.library;
         loadIconsForCurrentLibrary();
        });
       });
       document.getElementById('icon-picker-cancel').addEventListener('click', closeIconPicker);
       document.getElementById('icon-picker-modal').addEventListener('click', (e) => {
        if (e.target.id === 'icon-picker-modal') {
         closeIconPicker();
        }
       });
      });
      let textDrawMode = false;
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let autoPingEnabled = false;
      let autoPingInterval = 30;
      let autoPingTimer = null;
      let autoPingCountdown = null;
      let autoPingSecondsRemaining = 0;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollback_history";
      let rollbackVersions = [];
      const MAX_ROLLBACK_VERSIONS = 50;
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileNetworkeningAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let clipboard = null;
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof isViewOnly === 'function' && isViewOnly()) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
          this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
      function ensureLegendMiniButton() {
		if (legendMiniBtn) return legendMiniBtn;
		const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		};
		const preventTouch = (e) => { e.preventDefault(); };
		const existing = document.getElementById("edge-legend-mini");
		if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		}
		const panel = document.querySelector(".topology-panel");
		if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			 function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
		  function ensureTopologyToolbarMiniButton() {
	   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
	   const handleClick = (e) => {
		e.stopPropagation();
		e.preventDefault();
		topologyToolbarCollapsed = false;
		updateTopologyToolbarVisibility();
	   };
	   const preventTouch = (e) => { e.preventDefault(); };
	   const existing = document.getElementById("topology-toolbar-mini");
	   if (existing) {
		existing.addEventListener("click", handleClick);
		existing.addEventListener("touchstart", preventTouch, { passive: false });
		existing.addEventListener("touchend", handleClick);
		topologyToolbarMiniBtn = existing;
		return existing;
	   }
	   const panel = document.querySelector(".topology-panel");
	   if (!panel) return null;
	   const btn = document.createElement("button");
	   btn.type = "button";
	   btn.id = "topology-toolbar-mini";
	   btn.className = "legend-mini-btn";
	   btn.textContent = "Add Line";
	   btn.style.top = "10px";
	   btn.style.left = "auto";
	   btn.style.right = "40px";
	   btn.addEventListener("click", handleClick);
	   btn.addEventListener("touchstart", preventTouch, { passive: false });
	   btn.addEventListener("touchend", handleClick);
	   panel.appendChild(btn);
	   topologyToolbarMiniBtn = btn;
	   return btn;
	}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (!toolbar || !mini) return;
       if (typeof isViewOnly === 'function' && isViewOnly()) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
        return;
       }
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File: The Networkening",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
       canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
      let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
	  
	function updateViewBox() {
	  const svg = document.getElementById("map");
	  const vb = getViewBox();
	  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
	  const zoomLevel = document.getElementById("zoom-level");
	  if (zoomLevel) {
		zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
	  }
	  if (canvasState.zoom < 0.5) {
		svg.classList.add("low-zoom");
	  } else {
		svg.classList.remove("low-zoom");
	  }
	  updateMinimap();
	  populateRackDropdown();
	}
	  
	let lastMinimapRender = 0;
	const MINIMAP_THROTTLE = 100;

	function updateMinimap() {
	  const now = performance.now();
	  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
	  lastMinimapRender = now;
	  
	  const minimapViewport = document.getElementById("minimap-viewport");
	  const minimapSvg = document.getElementById("minimap");
	  if (!minimapViewport || !minimapSvg) return;
	  const vb = getViewBox();
	  minimapViewport.setAttribute("x", vb.x);
	  minimapViewport.setAttribute("y", vb.y);
	  minimapViewport.setAttribute("width", vb.width);
	  minimapViewport.setAttribute("height", vb.height);
	  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
	  const frag = document.createDocumentFragment();
	  EDGE_DATA.list.forEach((edge) => {
	  if (edge.type === "custom") return;
	  const fromNode = NODE_DATA[edge.from];
	  const toNode = NODE_DATA[edge.to];
	  if (!fromNode || !toNode) return;
	  if (currentView.mode === "rack") {
		if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
	  } else {
		if (fromNode.assignedRack || toNode.assignedRack) return;
	  }
	  const p1 = savedPositions[edge.from];
	  const p2 = savedPositions[edge.to];
	  if (!p1 || !p2) return;
	  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	   line.setAttribute("x1", p1.x);
	   line.setAttribute("y1", p1.y);
	   line.setAttribute("x2", p2.x);
	   line.setAttribute("y2", p2.y);
	   line.classList.add("minimap-edge");
	   frag.appendChild(line);
	  });
	  Object.entries(savedPositions).forEach(([id, pos]) => {
	  const node = NODE_DATA[id];
	  if (!node) return;
	  if (currentView.mode === "rack") {
		if (node.assignedRack !== currentView.rackId) return;
	  } else {
		if (node.assignedRack) return;
	  }
	  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	   circle.setAttribute("cx", pos.x);
	   circle.setAttribute("cy", pos.y);
	   circle.setAttribute("r", 40);
	   circle.classList.add("minimap-node");
	  frag.appendChild(circle);
	   });
	   minimapSvg.insertBefore(frag, minimapViewport);	
	  }
      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "‚ñ∂";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "‚óÄ";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (viewOnlyMode) {
        if (addNodeBtn) addNodeBtn.style.display = "none";
        if (addRackBtn) addRackBtn.style.display = "none";
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
         const el = document.getElementById(id);
         if (el) el.style.display = "none";
        });
        document.body.classList.remove("view-only-inspect");
       } else {
        if (addNodeBtn) addNodeBtn.style.display = "";
        if (addRackBtn) addRackBtn.style.display = "";
       }
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
       if (!viewOnlyMode) {
        if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
        if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
       }
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        Object.keys(NODE_DATA).forEach(nodeId => {
         if (!NODE_DATA[nodeId].ping) {
          NODE_DATA[nodeId].ping = {
           enabled: false,
           protocol: 'http',
           customUrl: '',
           timeout: 3000,
           status: 'unknown',
           lastCheck: null
          };
         }
        });
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
        if (initialState.iconCache) {
         IconLibrary.iconCache = initialState.iconCache;
        }
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (PAGE_STATE.autoPingEnabled !== undefined) {
        autoPingEnabled = PAGE_STATE.autoPingEnabled;
       }
       if (PAGE_STATE.autoPingInterval !== undefined) {
        autoPingInterval = PAGE_STATE.autoPingInterval;
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        if (initialState.currentTabIndex !== undefined) {
          currentTabIndex = initialState.currentTabIndex;
          const currentTab = documentTabs[currentTabIndex];
          if (currentTab) {
            NODE_DATA = currentTab.nodes || NODE_DATA;
            EDGE_DATA = currentTab.edges || EDGE_DATA;
            savedPositions = currentTab.positions || savedPositions;
            savedSizes = currentTab.sizes || savedSizes;
            savedStyles = currentTab.styles || savedStyles;
            EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
            RECT_DATA = currentTab.rects || RECT_DATA;
            TEXT_DATA = currentTab.texts || TEXT_DATA;
            if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
          }
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       if (autoPingEnabled) {
        startAutoPing();
       }
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "Œª";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const styles = resolveStylesForNode(id);
       if (styles.icon && styles.icon.library && styles.icon.name) {
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-circle");
        IconLibrary.getIcon(styles.icon.library, styles.icon.name).then(svgText => {
         if (svgText) {
          const parser = new DOMParser();
          const doc = parser.parseFromString(svgText, 'image/svg+xml');
          const svgEl = doc.querySelector('svg');
          if (svgEl) {
           svgEl.setAttribute('width', size * 1.2);
           svgEl.setAttribute('height', size * 1.2);
           svgEl.setAttribute('x', -size * 0.6);
           svgEl.setAttribute('y', -size * 0.6);
           if (styles.circleColor) {
            svgEl.style.fill = styles.circleColor;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.fill = styles.circleColor;
            });
           }
           if (styles.circleBorder) {
            svgEl.style.stroke = styles.circleBorder;
            svgEl.querySelectorAll('path, circle, rect, polygon, ellipse').forEach(el => {
             el.style.stroke = styles.circleBorder;
            });
           }
           g.innerHTML = svgEl.outerHTML;
          }
         }
        });
        return g;
       }
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "‚úï";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
         if (!EDGE_LEGEND[color]) {
          EDGE_LEGEND[color] = "you can edit me too";
         }
         const item = document.createElement("div");
         item.className = "legend-item";
         item.addEventListener("mousedown", (e) => e.stopPropagation());
         item.addEventListener("click", (e) => e.stopPropagation());
         const swatch = document.createElement("span");
         swatch.className = "legend-swatch";
         swatch.style.backgroundColor = color;
         swatch.style.cursor = "pointer";
         swatch.addEventListener("click", (e) => {
          e.stopPropagation();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         });
         let swatchTouchStart = null;
         let swatchTouchMoved = false;
         swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
          passive: false
         });
         swatch.addEventListener("touchend", (e) => {
          if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
           if (edgeWithColor) {
            selectTheConnection(edgeWithColor.id);
           }
          }
          swatchTouchStart = null;
          swatchTouchMoved = false;
         }, {
          passive: false
         });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
           label.contentEditable = true;
           label.addEventListener("focus", () => {
            label.classList.add("editing");
           });
           label.addEventListener("blur", () => {
            label.classList.remove("editing");
            const text = label.textContent.trim() || "you can edit me too";
            EDGE_LEGEND[color] = text;
           });
           label.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
             e.preventDefault();
             label.blur();
            }
           });
          }
          item.append(swatch, label); container.appendChild(item);
         }); updateLegendVisibility();
       }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
       function forgeTheTopology() {
        if (!NODE_DATA || !EDGE_DATA) {
         console.warn("forgeTheTopology called before data initialized");
         return;
        }
        const svg = document.getElementById("map");
        svg.innerHTML = "";
        const ns = "http://www.w3.org/2000/svg";
        const defs = document.createElementNS(ns, "defs");
        const markerForward = document.createElementNS(ns, "marker");
        markerForward.id = "arrow-forward";
        markerForward.setAttribute("markerWidth", "10");
        markerForward.setAttribute("markerHeight", "10");
        markerForward.setAttribute("refX", "9");
        markerForward.setAttribute("refY", "3");
        markerForward.setAttribute("orient", "auto");
        markerForward.setAttribute("markerUnits", "strokeWidth");
        const pathForward = document.createElementNS(ns, "path");
        pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
        pathForward.setAttribute("fill", "context-stroke");
        markerForward.appendChild(pathForward);
        defs.appendChild(markerForward);
        const markerBackward = document.createElementNS(ns, "marker");
        markerBackward.id = "arrow-backward";
        markerBackward.setAttribute("markerWidth", "10");
        markerBackward.setAttribute("markerHeight", "10");
        markerBackward.setAttribute("refX", "0");
        markerBackward.setAttribute("refY", "3");
        markerBackward.setAttribute("orient", "auto");
        markerBackward.setAttribute("markerUnits", "strokeWidth");
        const pathBackward = document.createElementNS(ns, "path");
        pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
        pathBackward.setAttribute("fill", "context-stroke");
        markerBackward.appendChild(pathBackward);
        defs.appendChild(markerBackward);
        svg.appendChild(defs);
        const boundary = document.createElementNS(ns, "rect");
        boundary.setAttribute("x", CANVAS_PADDING);
        boundary.setAttribute("y", CANVAS_PADDING);
        boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
        boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
        boundary.setAttribute("fill", "none");
        boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
        boundary.setAttribute("stroke-width", "20");
        boundary.setAttribute("stroke-dasharray", "10 5");
        boundary.setAttribute("rx", "8");
        svg.appendChild(boundary);
		if (currentView.mode !== "rack") {
		 const gridGroup = document.createElementNS(ns, "g");
		 gridGroup.id = "canvas-grid";
		 const gridSize = PAGE_STATE.canvasGridSize || 50;
		 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
		 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
		 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", x);
		  line.setAttribute("y1", CANVAS_PADDING);
		  line.setAttribute("x2", x);
		  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
		  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
		  const line = document.createElementNS(ns, "line");
		  line.setAttribute("x1", CANVAS_PADDING);
		  line.setAttribute("y1", y);
		  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
		  line.setAttribute("y2", y);
		  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
		  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
		  gridGroup.appendChild(line);
		 }
		 svg.appendChild(gridGroup);
		}
       if (currentView.mode === "rack" && currentView.rackId) {
         const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
         const rackGroup = document.createElementNS(ns, "g");
         rackGroup.id = "rack-visualization";
         const rackFrame = document.createElementNS(ns, "rect");
         rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
         rackFrame.setAttribute("y", RACK_START_Y);
         rackFrame.setAttribute("width", RACK_WIDTH);
         rackFrame.setAttribute("height", rackCapacity * rackUHeight);
         rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
         rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
         rackFrame.setAttribute("stroke-width", "3");
         rackFrame.setAttribute("rx", "4");
         rackGroup.appendChild(rackFrame);
         for (let u = 0; u <= rackCapacity; u++) {
          const y = RACK_START_Y + u * rackUHeight;
          const line = document.createElementNS(ns, "line");
          line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
          line.setAttribute("y1", y);
          line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
          line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
          line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
          rackGroup.appendChild(line);
          if (u < rackCapacity) {
           const uNumber = rackCapacity - u;
           const text = document.createElementNS(ns, "text");
           text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
           text.setAttribute("y", y + rackUHeight / 2);
           text.setAttribute("text-anchor", "middle");
           text.setAttribute("dominant-baseline", "middle");
           text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           text.style.fontSize = "14px";
           text.style.fontWeight = "bold";
           text.textContent = `U${uNumber}`;
           rackGroup.appendChild(text);
           const textRight = document.createElementNS(ns, "text");
           textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
           textRight.setAttribute("y", y + rackUHeight / 2);
           textRight.setAttribute("text-anchor", "middle");
           textRight.setAttribute("dominant-baseline", "middle");
           textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
           textRight.style.fontSize = "14px";
           textRight.style.fontWeight = "bold";
           textRight.textContent = `U${uNumber}`;
           rackGroup.appendChild(textRight);
          }
         }
         svg.appendChild(rackGroup);
        }
        const centerX = CANVAS_WIDTH / 2;
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
		   if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		    if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", 8);
      handle.style.fill = "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
            if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
        groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        const centerY = CANVAS_HEIGHT / 2;
        let positions = {};
        Object.keys(NODE_DATA).forEach((id) => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          if (!node || node.assignedRack !== currentView.rackId) {
           return;
          }
         }
         positions[id] = savedPositions[id] || {
          x: centerX,
          y: centerY
         };
        });
        if (Object.keys(savedPositions).length === 0) {
         const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return true;
         });
         const baseY = centerY - 300;
         if (nodeIds.length > 0) {
          positions[nodeIds[0]] = {
           x: centerX,
           y: baseY
          };
          const remaining = nodeIds.slice(1);
          const radius = 350;
          const startAngle = Math.PI * 0.3;
          const endAngle = Math.PI * 0.7;
          remaining.forEach((id, i) => {
           const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
           positions[id] = {
            x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
            y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
           };
          });
         }
        }
        Object.keys(positions).forEach((id) => {
         let pos = savedPositions[id] || positions[id];
         const nodeSize = savedSizes[id] || 55;
         pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
         pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
         positions[id] = {
          x: pos.x,
          y: pos.y
         };
         savedPositions[id] = {
          x: pos.x,
          y: pos.y
         };
        });
        const edgePairCount = {};
        const edgePairIndex = {};
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         edgePairCount[key] = (edgePairCount[key] || 0) + 1;
        });
        EDGE_DATA.list.forEach((edge) => {
         if (edge.type === "custom") return;
         const key = [edge.from, edge.to].sort().join("||");
         if (!edgePairIndex[key]) edgePairIndex[key] = 0;
         edge._pairIndex = edgePairIndex[key];
         edge._pairTotal = edgePairCount[key];
         edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
          const customEdgeFaded = currentView.mode !== "rack" && edge.from && edge.to && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
          const poly = document.createElementNS(ns, "polyline");
          poly.classList.add("edge");
          if (customEdgeFaded) {
           poly.style.opacity = "0.25";
           poly.classList.add("layer-faded");
          }
          poly.dataset.edgeId = edge.id;
          poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
          poly.style.strokeWidth = edge.width || 4;
          poly.setAttribute("fill", "none");
          const lineStyle = edge.lineStyle || "solid";
          if (lineStyle === "dashed") {
           poly.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           poly.style.strokeDasharray = "2,4";
          } else {
           poly.style.strokeDasharray = "none";
          }
          const direction = edge.direction || "none";
          if (direction === "forward") {
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          } else if (direction === "backward") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
          } else if (direction === "both") {
           poly.setAttribute("marker-start", "url(#arrow-backward)");
           poly.setAttribute("marker-end", "url(#arrow-forward)");
          }
          const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
          poly.setAttribute("points", ptsStr);
          const polyHit = document.createElementNS(ns, "polyline");
          polyHit.setAttribute("points", ptsStr);
          polyHit.style.fill = "none";
          polyHit.style.stroke = "transparent";
          polyHit.style.strokeWidth = "20";
          polyHit.style.cursor = "pointer";
          polyHit.dataset.edgeId = edge.id;
          polyHit.addEventListener("click", (e) => {
           e.stopPropagation();
           selectTheConnection(edge.id);
          });
          let edgeTouchStart = null;
          let edgeTouchMoved = false;
          polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
           passive: false
          });
          let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
           passive: false
          });
          polyHit.addEventListener("touchend", (e) => {
           if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
            e.stopPropagation();
            e.preventDefault();
            selectTheConnection(edge.id);
           }
           edgeTouchStart = null;
           edgeTouchMoved = false;
          }, {
           passive: false
          });
          poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
          if (currentView.mode === "rack") {
           return;
          }
          if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
  groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => { lineDragging = false; };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
		   c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
         }
         const p1 = positions[edge.from];
         const p2 = positions[edge.to];
         if (!p1 || !p2) return;
         const edgeFaded = currentView.mode !== "rack" && (!isNodeVisible(edge.from) || !isNodeVisible(edge.to));
         const pairTotal = edge._pairTotal || 1;
         const pairIndex = edge._pairIndex || 0;
         const routing = edge.routing || "curved";
         let pathD;
         if (routing === "straight") {
          pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
         } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const len = Math.sqrt(dx * dx + dy * dy) || 1;
          const perpX = -dy / len;
          const perpY = dx / len;
          let offsetAmount = 0;
          if (pairTotal > 1) {
           offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
          }
          const ctrlX = midX + perpX * offsetAmount;
          const ctrlY = midY + perpY * offsetAmount;
          pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
         }
         const path = document.createElementNS(ns, "path");
         path.setAttribute("d", pathD);
         path.setAttribute("fill", "none");
         path.classList.add("edge");
         if (edgeFaded) {
          path.style.opacity = "0.25";
          path.classList.add("layer-faded");
         }
         if (edge.type === "backup") path.classList.add("backup");
         path.dataset.edgeId = edge.id;
         path.dataset.from = edge.from;
         path.dataset.to = edge.to;
         path.style.stroke = edge.color;
         path.style.strokeWidth = edge.width;
         const pathHit = document.createElementNS(ns, "path");
         pathHit.setAttribute("d", pathD);
         pathHit.setAttribute("fill", "none");
         pathHit.style.stroke = "transparent";
         pathHit.style.strokeWidth = "20";
         pathHit.style.cursor = "pointer";
         pathHit.dataset.edgeId = edge.id;
         pathHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let pathTouchStart = null;
         let pathTouchMoved = false;
         pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
          passive: false
         });
         let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
          passive: false
         });
         pathHit.addEventListener("touchend", (e) => {
          if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          pathTouchStart = null;
          pathTouchMoved = false;
         }, {
          passive: false
         });
         path.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         if (currentView.mode === "rack") {
          const fromNode = NODE_DATA[edge.from];
          const toNode = NODE_DATA[edge.to];
          if (!fromNode || !toNode ||
              fromNode.assignedRack !== currentView.rackId ||
              toNode.assignedRack !== currentView.rackId) {
           return;
          }
         }
         svg.appendChild(path);
         svg.appendChild(pathHit);
         if (edge.fromPort || edge.toPort) {
          const ns = "http://www.w3.org/2000/svg";
          if (edge.fromPort) {
           const fromLabel = document.createElementNS(ns, "text");
           fromLabel.textContent = edge.fromPort;
           fromLabel.setAttribute("x", p1.x);
           fromLabel.setAttribute("y", p1.y - 10);
           fromLabel.setAttribute("text-anchor", "middle");
           fromLabel.style.fill = "#94a3b8";
           fromLabel.style.fontSize = "12px";
           fromLabel.style.fontWeight = "600";
           fromLabel.style.pointerEvents = "none";
           fromLabel.classList.add("port-label");
           svg.appendChild(fromLabel);
          }
          if (edge.toPort) {
           const toLabel = document.createElementNS(ns, "text");
           toLabel.textContent = edge.toPort;
           toLabel.setAttribute("x", p2.x);
           toLabel.setAttribute("y", p2.y - 10);
           toLabel.setAttribute("text-anchor", "middle");
           toLabel.style.fill = "#94a3b8";
           toLabel.style.fontSize = "12px";
           toLabel.style.fontWeight = "600";
           toLabel.style.pointerEvents = "none";
           toLabel.classList.add("port-label");
           svg.appendChild(toLabel);
          }
         }
        });
        Object.entries(positions).forEach(([id, pos]) => {
         const node = NODE_DATA[id];
         if (!node) return;
         if (currentView.mode === "rack") {
          if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
         } else {
          if (node.assignedRack) return;
         }
         const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
         g.classList.add("node-group");
         g.dataset.nodeId = id;
         g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
         if (currentView.mode !== "rack" && !isNodeVisible(id)) {
          g.style.opacity = "0.25";
          g.classList.add("layer-faded");
         }
         let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
         const styles = resolveStylesForNode(id);
         const ns = "http://www.w3.org/2000/svg";
         const hitArea = document.createElementNS(ns, "circle");
         hitArea.setAttribute("r", r * 1.5);
         hitArea.style.fill = "transparent";
         hitArea.style.stroke = "none";
         hitArea.style.cursor = "grab";
         hitArea.classList.add("node-hit-area");
         const shapeEl = createNodeShape(id, r);
         const titleOffsetX = styles.titleOffsetX || 0;
         const titleOffsetY = styles.titleOffsetY || 0;
         const subOffsetX = styles.subOffsetX || 0;
         const subOffsetY = styles.subOffsetY || 0;
         const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         label.classList.add("node-label");
         label.setAttribute("x", titleOffsetX);
         label.setAttribute("y", -r * 0.28 + titleOffsetY);
         const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
         label.textContent = NODE_DATA[id].name;
		label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         label.style.pointerEvents = "none";
         const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
         sub.classList.add("node-sub");
         sub.setAttribute("x", subOffsetX);
         sub.setAttribute("y", r * 0.4 + subOffsetY);
         const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
         sub.textContent = NODE_DATA[id].ip;
		sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
         sub.style.pointerEvents = "none";
         g.append(hitArea, shapeEl, label, sub);
         if (NODE_DATA[id]?.locked) {
           const lockIndicator = document.createElementNS(ns, "text");
           lockIndicator.textContent = "üîí";
           lockIndicator.setAttribute("x", r * 0.7);
           lockIndicator.setAttribute("y", -r * 0.7);
           lockIndicator.style.fontSize = (r * 0.3) + "px";
           lockIndicator.style.pointerEvents = "none";
           lockIndicator.classList.add("lock-indicator");
           g.appendChild(lockIndicator);
         }
         if (NODE_DATA[id]?.groupId) {
           const groupIndicator = document.createElementNS(ns, "circle");
           groupIndicator.setAttribute("r", r + 4);
           groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
           groupIndicator.style.strokeWidth = "3";
           groupIndicator.style.strokeDasharray = "5,5";
           groupIndicator.style.pointerEvents = "none";
           groupIndicator.classList.add("group-indicator");
           g.insertBefore(groupIndicator, g.firstChild);
         }
         let isDragging = false;
         let startX, startY;
         let initialPositions = {};
         let longPressTimer = null;
         let longPressTriggered = false;
         g.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          return false;
         });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
         g.addEventListener("touchend", (e) => {
          if (longPressTimer) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
          }
          if (longPressTriggered) {
           e.preventDefault();
           e.stopPropagation();
           longPressTriggered = false;
          }
         });
         let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
         g.addEventListener("mousedown", (e) => {
          if (isViewOnly()) return;
          if (e.button === 2) {
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          isDragging = true;
		  pushUndo("move nodes");
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          g.style.cursor = "grabbing";
          hitArea.style.cursor = "grabbing";
          e.stopPropagation();
         });
         const handleMouseMove = (e) => {
          if (!isDragging) return;
          e.preventDefault();
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          pt.x = e.clientX;
          pt.y = e.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const dx = svgP.x - startX;
          const dy = svgP.y - startY;
          const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
          nodesToMove.forEach(nodeId => {
           if (!initialPositions[nodeId]) return;
           const initialPos = initialPositions[nodeId];
           let newX = initialPos.x + dx;
           let newY = initialPos.y + dy;
           const nodeSize = savedSizes[nodeId] || 55;
           newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
           newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
           savedPositions[nodeId] = { x: newX, y: newY };
           positions[nodeId] = { x: newX, y: newY };
           if (nodeId === id) {
            pos.x = newX;
            pos.y = newY;
           }
           const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
          document.querySelectorAll(".edge").forEach((edgeEl) => {
           const fromId = edgeEl.dataset.from;
           const toId = edgeEl.dataset.to;
           if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
         document.addEventListener("mousemove", handleMouseMove);
         document.addEventListener("mouseup", handleMouseUp);
         let touchStartTime = 0;
         let touchStartX = 0;
         let touchStartY = 0;
         let touchMoved = false;
       g.addEventListener("touchstart",
         (e) => {
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          let nodesToCollect = [];
          if (selectedNodes.has(id)) {
           nodesToCollect = Array.from(selectedNodes);
          } else {
           nodesToCollect = [id];
          }
          const groupIds = new Set();
          nodesToCollect.forEach(nodeId => {
           const groupId = NODE_DATA[nodeId]?.groupId;
           if (groupId) {
             groupIds.add(groupId);
           }
          });
          if (groupIds.size > 0) {
           Object.keys(NODE_DATA).forEach(nodeId => {
             const nodeGroupId = NODE_DATA[nodeId]?.groupId;
             if (nodeGroupId && groupIds.has(nodeGroupId)) {
               if (!nodesToCollect.includes(nodeId)) {
                 nodesToCollect.push(nodeId);
               }
             }
           });
          }
          nodesToCollect = nodesToCollect.filter(nodeId => !NODE_DATA[nodeId]?.locked);
          if (nodesToCollect.length === 0) {
           return;
          }
          initialPositions = {};
          nodesToCollect.forEach(nodeId => {
           const nodePos = savedPositions[nodeId];
           if (nodePos) {
            initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
           }
          });
          e.stopPropagation();
         }, {
          passive: false
         }, );
         g.addEventListener("touchmove", (e) => {
		  if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         const nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
            const p1 = savedPositions[fromId] || positions[fromId] || {
             x: 600,
             y: 350
            };
            const p2 = savedPositions[toId] || positions[toId] || {
             x: 600,
             y: 350
            };
            if (edgeEl.tagName === "line") {
             edgeEl.setAttribute("x1", p1.x);
             edgeEl.setAttribute("y1", p1.y);
             edgeEl.setAttribute("x2", p2.x);
             edgeEl.setAttribute("y2", p2.y);
            } else if (edgeEl.tagName === "path") {
             const edgeId = edgeEl.dataset.edgeId;
             const edge = EDGE_DATA.list.find(
              (e) => e.id === edgeId, );
             if (edge) {
              const pairTotal = edge._pairTotal || 1;
              const pairIndex = edge._pairIndex || 0;
              const midX = (p1.x + p2.x) / 2;
              const midY = (p1.y + p2.y) / 2;
              const dx = p2.x - p1.x;
              const dy = p2.y - p1.y;
              const len = Math.sqrt(dx * dx + dy * dy) || 1;
              const perpX = -dy / len;
              const perpY = dx / len;
              let offsetAmount = 0;
              if (pairTotal > 1) {
               offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
              }
              const ctrlX = midX + perpX * offsetAmount;
              const ctrlY = midY + perpY * offsetAmount;
              edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
             }
            }
           }
          });
         }, {
          passive: false
         });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
         g.style.cursor = "grab";
         g.addEventListener("click", (e) => {
          if (!isDragging) {
           if (isViewOnly()) {
            handleViewOnlyClick(id, 'node');
            return;
           }
           claimTheImmortal(id);
          }
         });
         svg.appendChild(g);
        });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
      if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "√ó";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            rectStartX = rect.x;
            rectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           });
      const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => { if (initialPositions[nodeId]) { savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy }; } });
      selectedRects.forEach(rectId => { if (rectId === rect.id) return; const r = RECT_DATA.list.find(x => x.id === rectId); if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; } });
      selectedTexts.forEach(textId => { const t = TEXT_DATA.list.find(x => x.id === textId); if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; } });
      selectedEdges.forEach(edgeId => { const ed = EDGE_DATA.list.find(x => x.id === edgeId); if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); } });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		    if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		   if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
			   if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
				 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
         groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "√ó";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
       groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
        Object.keys(NODE_DATA).forEach(nodeId => {
         updatePingIndicator(nodeId);
        });
        forgeTheLegend();
        updateMinimap();
        if (currentSearchQuery && currentSearchResults.length > 0) {
         highlightSearchResults(currentSearchResults, true);
        }
       }
       const _forgeTheTopologyImpl = forgeTheTopology;
       forgeTheTopology = function(immediate = false) {
        if (immediate || forgeImmediate) {
         forgeImmediate = false;
         clearTimeout(forgeDebounceTimer);
         _forgeTheTopologyImpl();
         return;
        }
        clearTimeout(forgeDebounceTimer);
        forgeDebounceTimer = setTimeout(() => {
         _forgeTheTopologyImpl();
        }, 16);
       };
       function forgeTheTopologyImmediate() {
        forgeImmediate = true;
        forgeTheTopology();
       }
       function showEditModal(title, currentValue, onSave) {
        const modal = document.getElementById("edit-modal");
        const input = document.getElementById("modal-input");
        const titleEl = document.getElementById("modal-title");
        const saveBtn = document.getElementById("modal-save");
        const cancelBtn = document.getElementById("modal-cancel");
        titleEl.textContent = title;
        input.value = currentValue;
        modal.classList.add("active");
        input.focus();
        input.select();
        const cleanup = () => {
         modal.classList.remove("active");
         saveBtn.removeEventListener("click", handleSave);
         cancelBtn.removeEventListener("click", handleCancel);
         input.removeEventListener("keypress", handleEnter);
         modal.removeEventListener("click", bgHandler);
        };
        const handleSave = () => {
         if (input.value.trim()) {
          onSave(input.value.trim());
         }
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const handleEnter = (e) => {
         if (e.key === "Enter") handleSave();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        saveBtn.addEventListener("click", handleSave);
        cancelBtn.addEventListener("click", handleCancel);
        input.addEventListener("keypress", handleEnter);
        modal.addEventListener("click", bgHandler);
       }
       function challengeTheImmortal(message, onConfirm) {
        const modal = document.getElementById("confirm-modal");
        const messageEl = document.getElementById("confirm-message");
        const deleteBtn = document.getElementById("confirm-delete");
        const cancelBtn = document.getElementById("confirm-cancel");
        messageEl.textContent = message;
        modal.classList.add("active");
	    const cleanup = () => {
         modal.classList.remove("active");
         deleteBtn.removeEventListener("click", handleConfirm);
         cancelBtn.removeEventListener("click", handleCancel);
         modal.removeEventListener("click", bgHandler);
        };
        const handleConfirm = () => {
         onConfirm();
         cleanup();
        };
        const handleCancel = () => {
         cleanup();
        };
        const bgHandler = (e) => {
         if (e.target === modal) handleCancel();
        };
        deleteBtn.addEventListener("click", handleConfirm);
        cancelBtn.addEventListener("click", handleCancel);
        modal.addEventListener("click", bgHandler);
       }
       const pageTitleEl = document.getElementById("page-title");
       if (pageTitleEl) {
        pageTitleEl.addEventListener("click", () => {
         showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
          (newTitle) => {
           PAGE_STATE.title = newTitle;
           wieldThePower();
          }, );
        });
       }
       function editNodeName(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node name");
         NODE_DATA[id].name = newName;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const label = nodeGroup.querySelector(".node-label");
          if (label) label.textContent = newName;
         }
         if (currentNodeId === id) {
          document.getElementById("node-name").textContent = newName;
         }
        });
       }
       function editNodeIp(id) {
        if (!NODE_DATA[id]) return;
        showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
         if (!NODE_DATA[id]) return;
         pushUndo("edit node ip");
         NODE_DATA[id].ip = newIp;
         const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
         if (nodeGroup) {
          const sub = nodeGroup.querySelector(".node-sub");
          if (sub) sub.textContent = newIp;
         }
         if (currentNodeId === id) {
          document.getElementById("node-ip").textContent = newIp;
         }
        });
       }
       function claimTheImmortal(id) {
	   if (isViewOnly()) return;
        if (!NODE_DATA[id]) return;
        currentNodeId = id;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        const data = NODE_DATA[id];
        document.querySelectorAll(".node-group").forEach((n) => {
         n.classList.toggle("active", n.dataset.nodeId === id);
        });
        document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        const toolbar = document.getElementById("topology-toolbar");
        if (!topologyToolbarCollapsed) {
         toolbar.style.display = "flex";
        }
        updateTopologyToolbarVisibility();
        document.getElementById("node-name").textContent = data.name;
        document.getElementById("node-ip").textContent = data.ip;
        document.getElementById("node-mac").textContent = data.mac || "--";
        document.getElementById("node-rack").textContent = data.rackUnit || "--";
        document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
        document.getElementById("node-role").textContent = data.role;
        populateRackDropdown();
        const assignedRackSelect = document.getElementById("node-assigned-rack");
        if (assignedRackSelect) {
         assignedRackSelect.value = data.assignedRack || "";
        }
        const rackCapacitySelect = document.getElementById("node-rack-capacity");
        if (rackCapacitySelect) {
         rackCapacitySelect.value = data.rackCapacity || "42";
        }
        const isRack = data.isRack === true;
        const isAssignedToRack = !!data.assignedRack;
        const assignedRackRow = document.getElementById("assigned-rack-row");
        const rackCapacityRow = document.getElementById("rack-capacity-row");
        const uheightRow = document.getElementById("uheight-row");
        if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
        if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
        if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
		const delBtn = document.getElementById("delete-node-btn");
        if (delBtn) delBtn.textContent = isRack ? "Delete Rack" : "Delete Node";
		const rackContentsSection = document.getElementById("rack-contents-section");
        const rackContentsList = document.getElementById("rack-contents-list");
        const rackContentsCount = document.getElementById("rack-contents-count");
        if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         rackContentsCount.textContent = nodesInRack.length;
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 8px 4px; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic; padding: 8px 4px;">No nodes assigned</div>';
         }
         rackContentsSection.style.display = "block";
         } else {
         rackContentsSection.style.display = "none";
         }
        }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '‚Üî';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
        document.getElementById("node-ip").onclick = () => editNodeIp(id);
        document.getElementById("node-mac").onclick = () => editNodeMac(id);
        document.getElementById("node-rack").onclick = () => editNodeRack(id);
        document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
        const currentSize = savedSizes[id] || getDefaultSize();
        document.getElementById("size-slider").value = currentSize;
        document.getElementById("size-value").textContent = currentSize;
        const styleEntry = savedStyles[id] || {};
        const resolvedStyles = resolveStylesEntry(styleEntry);
        const scopeKey = currentStyleScope || "all";
        const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
        const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
        const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
        const circleColorInput = document.getElementById("circle-color");
        const titleColorInput = document.getElementById("title-color");
        const titleFontSelect = document.getElementById("title-font");
        const titleSizeInput = document.getElementById("title-size");
        const subColorInput = document.getElementById("sub-color");
        const subFontSelect = document.getElementById("sub-font");
        const subSizeInput = document.getElementById("sub-size");
        const shapeSelect = document.getElementById("shape-select");
        const scopeSelect = document.getElementById("style-scope");
        circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
        subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
        subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
        const hasWebIcon = resolvedStyles.icon && resolvedStyles.icon.library;
        const customOpt = shapeSelect.querySelector('option[value="custom-icon"]');
        if (hasWebIcon) {
         if (!customOpt) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
        } else {
         if (customOpt) customOpt.remove();
         shapeSelect.value = data.shape || "circle";
        }
        const layerSelect = document.getElementById("node-layer");
        if (layerSelect) {
         layerSelect.value = data.layer || "physical";
        }
        scopeSelect.value = currentStyleScope || "all";
        document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
        document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
        document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
        document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
      const pingOffsetXInput = document.getElementById("ping-offset-x");
      const pingOffsetYInput = document.getElementById("ping-offset-y");
      if (pingOffsetXInput && pingOffsetYInput) {
      pingOffsetXInput.value =
       (scopedStyles.pingOffsetX !== undefined
         ? scopedStyles.pingOffsetX
         : (resolvedStyles.pingOffsetX !== undefined
             ? resolvedStyles.pingOffsetX
             : 0));
      pingOffsetYInput.value =
       (scopedStyles.pingOffsetY !== undefined
         ? scopedStyles.pingOffsetY
         : (resolvedStyles.pingOffsetY !== undefined
             ? resolvedStyles.pingOffsetY
             : 0));
      }
        const tagEl = document.getElementById("node-tags");
        tagEl.innerHTML = "";
        data.tags.forEach((tag, i) => {
         const b = document.createElement("span");
         b.className = "badge";
         const isIconTag = typeof tag === 'object' && tag.type === 'icon';
         if (!isIconTag && typeof tag === 'string' && tag.toLowerCase().includes("wg")) b.classList.add("wg");
         b.style.cursor = "pointer";
         b.style.position = "relative";
         const tagContent = document.createElement("span");
         if (isIconTag) {
          b.classList.add("icon-badge");
          IconLibrary.getIcon(tag.library, tag.name).then(svgText => {
           if (svgText) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if (svgEl) {
             svgEl.setAttribute('width', '16');
             svgEl.setAttribute('height', '16');
             tagContent.innerHTML = '';
             tagContent.appendChild(svgEl);
             const nameSpan = document.createElement('span');
             nameSpan.textContent = tag.name;
             nameSpan.style.marginLeft = '4px';
             tagContent.appendChild(nameSpan);
            }
           }
          });
         } else {
          tagContent.textContent = tag;
          tagContent.addEventListener("click", (e) => {
           e.stopPropagation();
           showEditModal("Edit Tag", tag, (newTag) => {
            if (newTag) {
             pushUndo("edit tag");
             data.tags[i] = newTag;
             claimTheImmortal(id);
            }
           });
          });
         }
         const deleteTag = document.createElement("span");
         deleteTag.textContent = " ‚úï";
         deleteTag.style.opacity = "0.6";
         deleteTag.style.marginLeft = "4px";
         deleteTag.style.fontSize = "10px";
         deleteTag.addEventListener("click", (e) => {
          e.stopPropagation();
          pushUndo("delete tag");
          data.tags.splice(i, 1);
          claimTheImmortal(id);
         });
         b.append(tagContent, deleteTag);
         tagEl.append(b);
        });
        const addTagBtn = document.createElement("span");
        addTagBtn.className = "badge";
        addTagBtn.style.cursor = "pointer";
        addTagBtn.style.opacity = "0.6";
        addTagBtn.style.borderStyle = "dashed";
        addTagBtn.textContent = "+ Add Tag";
        addTagBtn.addEventListener("click", () => {
         showEditModal("Add Tag(s) : comma separated", "",
          (newTagStr) => {
           if (newTagStr) {
            pushUndo("add tags");
            const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
            newTags.forEach((t) => data.tags.push(t));
            claimTheImmortal(id);
           }
          }, );
        });
        tagEl.append(addTagBtn);
        const notesEl = document.getElementById("node-notes");
        notesEl.innerHTML = "";
        data.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const noteText = document.createElement("span");
         noteText.textContent = note;
         noteText.style.flex = "1";
         const deleteBtn = document.createElement("span");
         deleteBtn.className = "delete-note";
         deleteBtn.textContent = "‚úï";
         deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          challengeTheImmortal("Are you sure you want to delete this note?",
           () => {
            pushUndo("delete note");
            data.notes.splice(i, 1);
            claimTheImmortal(id);
           }, );
         });
         li.append(noteText, deleteBtn);
         noteText.addEventListener("dblclick", () => {
          noteText.classList.add("editing");
          noteText.contentEditable = true;
          noteText.focus();
         });
         noteText.addEventListener("blur", () => {
          noteText.classList.remove("editing");
          noteText.contentEditable = false;
          pushUndo("edit note");
          data.notes[i] = noteText.textContent;
         });
         notesEl.append(li);
        });
        const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
        const pingEnabled = data.ping && data.ping.enabled;
        document.getElementById('node-pingable').checked = pingEnabled;
        document.getElementById('node-ping-options').style.display = pingEnabled ? 'block' : 'none';
        if (data.ping) {
         document.getElementById('node-ping-protocol').value = data.ping.protocol || 'http';
         document.getElementById('node-custom-url').value = data.ping.customUrl || '';
         document.getElementById('node-ping-timeout').value = data.ping.timeout || 3000;
         document.getElementById('node-custom-url-container').style.display =
          data.ping.protocol === 'custom' ? 'block' : 'none';
         updatePingStatusDisplay(id);
        }
       }
       function updatePingStatusDisplay(nodeId) {
        const data = NODE_DATA[nodeId];
        if (!data || !data.ping) return;
        const statusEl = document.getElementById('node-ping-status');
        const lastCheckEl = document.getElementById('node-ping-last-check');
        const statusColors = {
         online: 'var(--accent)',
         offline: 'var(--danger)',
         checking: '#f59e0b',
         unknown: 'var(--text-soft)'
        };
        const statusTexts = {
         online: '‚óè Online',
         offline: '‚óè Offline',
         checking: '‚óè Checking...',
         unknown: '‚óè Unknown'
        };
        statusEl.textContent = statusTexts[data.ping.status] || statusTexts.unknown;
        statusEl.style.color = statusColors[data.ping.status] || statusColors.unknown;
        if (data.ping.lastCheck) {
         const checkTime = new Date(data.ping.lastCheck);
         lastCheckEl.textContent = `Last checked: ${checkTime.toLocaleTimeString()}`;
        } else {
         lastCheckEl.textContent = 'Never checked';
        }
       }
       function selectTheConnection(id) {
	   if (isViewOnly()) return;
        currentEdgeId = id;
        currentNodeId = null;
        currentRectId = null;
        currentTextId = null;
		if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "block";
        document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
        const edge = EDGE_DATA.list.find((e) => e.id === id);
        if (!edge) return;
        const directionSymbols = {
         none: "‚áÑ",
         forward: "‚Üí",
         backward: "‚Üê",
         both: "‚Üî",
        };
        const dirSymbol = directionSymbols[edge.direction] || "‚áÑ";
        let titleText = "Custom line";
        if (edge.from || edge.to) {
         const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
         const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
         titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
        }
        document.getElementById("edge-title").textContent = titleText;
        const widthInput = document.getElementById("edge-width");
        const colorInput = document.getElementById("edge-color");
        const directionSelect = document.getElementById("edge-direction");
        const lineStyleSelect = document.getElementById("edge-line-style");
        const routingSelect = document.getElementById("edge-routing");
        widthInput.value = edge.width;
        colorInput.value = edge.color;
        directionSelect.value = edge.direction || "none";
        lineStyleSelect.value = edge.lineStyle || "solid";
        routingSelect.value = edge.routing || "curved";
        const fromPortInput = document.getElementById("edge-from-port");
        const toPortInput = document.getElementById("edge-to-port");
        const portFieldsFrom = document.getElementById("edge-port-fields");
        const portFieldsTo = document.getElementById("edge-port-fields-to");
        if (edge.type === "custom") {
         if (portFieldsFrom) portFieldsFrom.style.display = "none";
         if (portFieldsTo) portFieldsTo.style.display = "none";
        } else {
         if (portFieldsFrom) portFieldsFrom.style.display = "flex";
         if (portFieldsTo) portFieldsTo.style.display = "flex";
         if (fromPortInput) {
          fromPortInput.value = edge.fromPort || "";
          fromPortInput.onchange = () => updateEdgePortLabels(id);
         }
         if (toPortInput) {
          toPortInput.value = edge.toPort || "";
          toPortInput.onchange = () => updateEdgePortLabels(id);
         }
        }
        const list = document.getElementById("edge-notes");
        list.innerHTML = "";
        edge.notes.forEach((note, i) => {
         const li = document.createElement("li");
         const txt = document.createElement("span");
         txt.textContent = note;
         txt.style.flex = "1";
         const del = document.createElement("span");
         del.className = "delete-note";
         del.textContent = "‚úï";
         del.addEventListener("click", (e) => {
          e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
           pushUndo("delete edge note");
           edge.notes.splice(i, 1);
           selectTheConnection(id);
          });
         });
         txt.addEventListener("dblclick", () => {
          txt.classList.add("editing");
          txt.contentEditable = true;
          txt.focus();
         });
        txt.addEventListener("blur", () => {
          txt.classList.remove("editing");
          txt.contentEditable = false;
          pushUndo("edit edge note");
          edge.notes[i] = txt.textContent;
         });
         li.append(txt, del);
         list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
       window.addEventListener("resize", () => {
        forgeTheTopology();
        if (currentEdgeId) {
         selectTheConnection(currentEdgeId);
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         claimTheImmortal(currentNodeId);
        } else {
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         }
        }
       });
       (function initZoomPan() {
        const viewport = document.getElementById("canvas-viewport");
        const svg = document.getElementById("map");
        const hint = document.getElementById("canvas-hint");
        setTimeout(() => {
         hint.classList.add("visible");
         setTimeout(() => hint.classList.remove("visible"), 4000);
        }, 1000);
        viewport.addEventListener("wheel",
         (e) => {
          e.preventDefault();
          const rect = viewport.getBoundingClientRect();
          const mouseX = (e.clientX - rect.left) / rect.width;
          const mouseY = (e.clientY - rect.top) / rect.height;
          const delta = e.deltaY > 0 ? 0.9 : 1.1;
          zoomTo(canvasState.zoom * delta, mouseX, mouseY);
         }, {
          passive: false
         }, );
        let initialPinchDistance = 0;
        let initialPinchZoom = 1;
        let pinchCenter = {
         x: 0.5,
         y: 0.5
        };
        let threeFingerTapStart = 0;
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.touches.length === 3) {
           e.preventDefault();
           threeFingerTapStart = Date.now();
          }
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           initialPinchZoom = canvasState.zoom;
           const rect = viewport.getBoundingClientRect();
           const centerX = (touch1.clientX + touch2.clientX) / 2;
           const centerY = (touch1.clientY + touch2.clientY) / 2;
           pinchCenter.x = (centerX - rect.left) / rect.width;
           pinchCenter.y = (centerY - rect.top) / rect.height;
          }
         }, {
          passive: false
         }, );
        viewport.addEventListener("touchend", (e) => {
         if (e.touches.length === 0 && threeFingerTapStart > 0) {
          const duration = Date.now() - threeFingerTapStart;
          if (duration < 500) {
           e.preventDefault();
           undo();
           if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
          }
          threeFingerTapStart = 0;
         }
        }, { passive: false });
        viewport.addEventListener("touchmove",
         (e) => {
          if (e.touches.length === 2) {
           e.preventDefault();
           const touch1 = e.touches[0];
           const touch2 = e.touches[1];
           const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
           if (initialPinchDistance > 0) {
            const scale = currentDistance / initialPinchDistance;
            const newZoom = initialPinchZoom * scale;
            zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
           }
          }
         }, {
          passive: false
         }, );
        let panStartViewX = 0;
        let panStartViewY = 0;
        let lastEmptyTapTime = 0;
        let emptyTapTimeout = null;
        let emptyTapMoved = false;
        let emptyTapStartX = 0;
        let emptyTapStartY = 0;
        viewport.addEventListener("touchend", (e) => {
          if (currentView.mode !== "rack") return;
          if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
          if (emptyTapMoved) {
            emptyTapMoved = false;
            return;
          }
          const currentTime = new Date().getTime();
          const tapGap = currentTime - lastEmptyTapTime;
          if (tapGap < 300 && tapGap > 0) {
            e.preventDefault();
            exitRack();
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
            lastEmptyTapTime = 0;
            if (emptyTapTimeout) {
              clearTimeout(emptyTapTimeout);
              emptyTapTimeout = null;
            }
          } else {
            lastEmptyTapTime = currentTime;
            if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
            emptyTapTimeout = setTimeout(() => {
              lastEmptyTapTime = 0;
            }, 300);
          }
        }, { passive: false });
        viewport.addEventListener("mousedown", (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
         if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
          e.preventDefault();
          canvasState.isPanning = true;
          canvasState.panStartX = e.clientX;
          canvasState.panStartY = e.clientY;
          panStartViewX = canvasState.panX;
          panStartViewY = canvasState.panY;
          viewport.classList.add("panning");
         }
        });
        viewport.addEventListener("touchstart",
         (e) => {
          if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
           return;
          }
          if (freeDrawMode || rectDrawMode) {
           return;
          }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
          }
         }, {
          passive: false
         }, );
        let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
        document.addEventListener("mouseup", () => {
         if (isSelecting) {
          endSelection();
         }
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("touchend", () => {
         if (canvasState.isPanning) {
          canvasState.isPanning = false;
          viewport.classList.remove("panning");
         }
        });
        document.addEventListener("keydown", (e) => {
         const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
         if (e.code === "Space" && !e.repeat && !isEditing) {
          e.preventDefault();
          canvasState.spacePressed = true;
          viewport.style.cursor = "grab";
         }
        });
        document.addEventListener("keyup", (e) => {
         if (e.code === "Space") {
          canvasState.spacePressed = false;
          viewport.style.cursor = "";
         }
        });
        document.getElementById("zoom-in-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        });
        document.getElementById("zoom-out-btn").addEventListener("click", () => {
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        });
        document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
        document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
        const minimapContainer = document.getElementById("minimap-container");
        const minimapSvg = document.getElementById("minimap");
        let minimapDragging = false;
        minimapContainer.addEventListener("mousedown", (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimap(e);
        });
        minimapContainer.addEventListener("touchstart",
         (e) => {
          e.preventDefault();
          minimapDragging = true;
          updatePanFromMinimapTouch(e);
         }, {
          passive: false
         }, );
        document.addEventListener("mousemove", (e) => {
         if (minimapDragging) {
          updatePanFromMinimap(e);
         }
        });
        document.addEventListener("touchmove", (e) => {
         if (minimapDragging && e.touches[0]) {
          updatePanFromMinimapTouch(e);
         }
        });
        document.addEventListener("mouseup", () => {
         minimapDragging = false;
        });
        document.addEventListener("touchend", () => {
         minimapDragging = false;
        });
        function updatePanFromMinimap(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const x = (e.clientX - rect.left) / rect.width;
         const y = (e.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        function updatePanFromMinimapTouch(e) {
         const rect = minimapContainer.getBoundingClientRect();
         const touch = e.touches[0];
         const x = (touch.clientX - rect.left) / rect.width;
         const y = (touch.clientY - rect.top) / rect.height;
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
         canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
         constrainPan();
         updateViewBox();
        }
        document.addEventListener("keydown", (e) => {
         if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
         if (
          (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
         } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
         } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          resetView();
         }
        });
        setTimeout(() => {
         fitToContent();
        }, 100);
       })();
       const sizeSlider = document.getElementById("size-slider");
       const sizeValue = document.getElementById("size-value");
       const resetSizeBtn = document.getElementById("reset-size");
       sizeSlider.addEventListener("input", () => {
        const newSize = parseInt(sizeSlider.value, 10);
        sizeValue.textContent = newSize;
        pushUndo("resize node");
        savedSizes[currentNodeId] = newSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const newShape = createNodeShape(currentNodeId, newSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -newSize * 0.28);
          const labelSize = styles.titleSize || newSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", newSize * 0.4);
          const subSize = styles.subSize || newSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
       updatePingIndicator(currentNodeId);
        }
       });
       resetSizeBtn.addEventListener("click", () => {
        pushUndo("reset size");
        delete savedSizes[currentNodeId];
        const defaultSize = getDefaultSize();
        sizeSlider.value = defaultSize;
        sizeValue.textContent = defaultSize;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (nodeGroup) {
         const oldShape = nodeGroup.querySelector(".node-circle");
         if (oldShape) oldShape.remove();
         const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
         const newShape = createNodeShape(currentNodeId, defaultSize);
         nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
         const styles = resolveStylesForNode(currentNodeId);
         if (styles.circleColor) newShape.style.fill = styles.circleColor;
      if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
         const label = nodeGroup.querySelector(".node-label");
         const sub = nodeGroup.querySelector(".node-sub");
         if (label) {
          label.setAttribute("y", -defaultSize * 0.28);
          const labelSize = styles.titleSize || defaultSize * 0.33;
          label.style.fontSize = labelSize + "px";
         }
         if (sub) {
          sub.setAttribute("y", defaultSize * 0.4);
          const subSize = styles.subSize || defaultSize * 0.24;
          sub.style.fontSize = subSize + "px";
         }
          updatePingIndicator(currentNodeId);
        }
       });
       const applyStyle = (property, value) => {
        pushUndo("style change");
        const styleEntry = ensureStyleEntry(currentNodeId);
        const scopeKey = currentStyleScope || "all";
        if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
        styleEntry[scopeKey][property] = value;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
        if (!nodeGroup) return;
        const shapeEl = nodeGroup.querySelector(".node-circle");
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        const isWebIcon = shapeEl && shapeEl.querySelector('svg');
        if (property === "circleColor" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.fill = value);
         } else {
          shapeEl.style.fill = value;
         }
        } else if (property === "circleBorder" && shapeEl) {
         if (isWebIcon) {
          shapeEl.querySelectorAll('svg, path, circle, rect, polygon, ellipse').forEach(el => el.style.stroke = value);
         } else {
          shapeEl.style.stroke = value;
         }
        } else if (property === "titleColor" && label) label.style.fill = value;
        else if (property === "titleFont" && label) label.style.fontFamily = value;
        else if (property === "titleSize" && label) label.style.fontSize = value + "px";
        else if (property === "subColor" && sub) sub.style.fill = value;
        else if (property === "subFont" && sub) sub.style.fontFamily = value;
        else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
       };
       document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
       document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
       document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
       document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
       document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
       document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
       document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
       document.getElementById("title-offset-y").addEventListener("input", (e) => {
        applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("title-offset-x").addEventListener("input", (e) => {
        applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-y").addEventListener("input", (e) => {
        applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
       document.getElementById("sub-offset-x").addEventListener("input", (e) => {
        applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
        forgeTheTopology();
        if (currentNodeId) claimTheImmortal(currentNodeId);
       });
      document.getElementById("ping-offset-x").addEventListener("input", (e) => {
      applyStyle("pingOffsetX", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("ping-offset-y").addEventListener("input", (e) => {
      applyStyle("pingOffsetY", parseInt(e.target.value, 10) || 0);
      updatePingIndicator(currentNodeId);
      if (currentNodeId) claimTheImmortal(currentNodeId);
      });
       document.getElementById("reset-styles").addEventListener("click", () => {
        delete savedStyles[currentNodeId];
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("style-scope").addEventListener("change", (e) => {
        currentStyleScope = e.target.value || "all";
        claimTheImmortal(currentNodeId);
       });
       document.getElementById("shape-select").addEventListener("change", (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        const shape = e.target.value || "circle";
        if (shape === 'custom-icon') return;
        pushUndo("change shape");
        NODE_DATA[currentNodeId].shape = shape;
        if (savedStyles[currentNodeId]) {
         Object.keys(savedStyles[currentNodeId]).forEach(scope => {
          if (savedStyles[currentNodeId][scope] && savedStyles[currentNodeId][scope].icon) {
           delete savedStyles[currentNodeId][scope].icon;
          }
         });
        }
        const customOpt = e.target.querySelector('option[value="custom-icon"]');
        if (customOpt) customOpt.remove();
        forgeTheTopology();
       });
       const addNoteBtn = document.getElementById("add-note-btn");
       const noteInput = document.getElementById("new-note-input");
       addNoteBtn.addEventListener("click", () => {
        const newNote = noteInput.value.trim();
        if (newNote && currentNodeId && NODE_DATA[currentNodeId]) {
         pushUndo("add note");
         NODE_DATA[currentNodeId].notes.push(newNote);
         claimTheImmortal(currentNodeId);
         noteInput.value = "";
        }
       });
       noteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addNoteBtn.click();
        }
       });
       document.getElementById('node-pingable').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
        if (!NODE_DATA[currentNodeId].ping) {
         NODE_DATA[currentNodeId].ping = {
          enabled: false,
          protocol: 'http',
          customUrl: '',
          timeout: 3000,
          status: 'unknown',
          lastCheck: null
         };
        }
        NODE_DATA[currentNodeId].ping.enabled = e.target.checked;
        document.getElementById('node-ping-options').style.display = e.target.checked ? 'block' : 'none';
        forgeTheTopology();
       });
       document.getElementById('node-ping-protocol').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.protocol = e.target.value;
        document.getElementById('node-custom-url-container').style.display =
         e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('node-custom-url').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.customUrl = e.target.value.trim();
       });
       document.getElementById('node-ping-timeout').addEventListener('change', (e) => {
        if (!currentNodeId || !NODE_DATA[currentNodeId].ping) return;
        NODE_DATA[currentNodeId].ping.timeout = parseInt(e.target.value) || 3000;
       });
       document.getElementById('check-ping-now').addEventListener('click', () => {
        if (!currentNodeId) return;
        checkNodeStatus(currentNodeId);
       });
       document.getElementById("edge-width").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const v = parseInt(document.getElementById("edge-width").value, 10);
        if (Number.isNaN(v) || v <= 0) return;
        pushUndo("edit edge");
        edge.width = v;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.strokeWidth = v;
       });
       document.getElementById("edge-color").addEventListener("input", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        const color = document.getElementById("edge-color").value;
        pushUndo("edit edge");
        edge.color = color;
        const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
        if (el) el.style.stroke = color;
        forgeTheLegend();
       });
       document.getElementById("edge-direction").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.direction = document.getElementById("edge-direction").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-line-style").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge");
        edge.lineStyle = document.getElementById("edge-line-style").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       document.getElementById("edge-routing").addEventListener("change", () => {
        if (!currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
        pushUndo("edit edge routing");
        edge.routing = document.getElementById("edge-routing").value;
        forgeTheTopology();
        selectTheConnection(currentEdgeId);
       });
       const addEdgeNoteBtn = document.getElementById("add-edge-note");
       const newEdgeNoteInput = document.getElementById("new-edge-note");
       addEdgeNoteBtn.addEventListener("click", () => {
        const txt = newEdgeNoteInput.value.trim();
        if (!txt || !currentEdgeId) return;
        const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
        if (!edge) return;
		pushUndo("add edge note");
        edge.notes.push(txt);
        newEdgeNoteInput.value = "";
        selectTheConnection(currentEdgeId);
       });
       newEdgeNoteInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
         addEdgeNoteBtn.click();
        }
       });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "‚úï";
      del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
	  document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this box?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
       document.getElementById("delete-edge").addEventListener("click", () => {
        if (!currentEdgeId) return;
        challengeTheImmortal("Are you sure you want to delete this line?",
         () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(
           (e) => e.id !== currentEdgeId, );
          currentEdgeId = null;
          forgeTheTopology();
          const availableNodes = Object.keys(NODE_DATA);
          if (availableNodes.length > 0) {
           claimTheImmortal(availableNodes[0]);
          } else {
           document.getElementById("node-panel").style.display = "none";
           document.getElementById("edge-panel").style.display = "none";
           document.getElementById("topology-toolbar", ).style.display = "none";
          }
         }, );
       });
       document.getElementById("add-line-btn").addEventListener("click", () => {
        if (!currentNodeId) return;
        const select = document.getElementById("add-line-select");
        const directionSelect = document.getElementById("add-line-direction");
        const colorInput = document.getElementById("add-line-color");
        const routingSelect = document.getElementById("add-line-routing");
        const targetId = select.value;
        if (!targetId || targetId === currentNodeId) return;
        const direction = directionSelect.value || "none";
        const lineColor = colorInput.value || "#475569";
        const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
        const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
        const newEdge = {
         id: newId,
         from: currentNodeId,
         to: targetId,
         width: 4,
         color: lineColor,
         direction: direction,
         routing: routing,
         type: "main",
         notes: [],
         fromPort: "",
         toPort: "",
        };
        pushUndo("add edge");
        EDGE_DATA.list.push(newEdge);
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
       let freeDrawPoints = [];
       let freeDrawPolylineEl = null;
       let freeDrawPointEls = [];
       const drawToggleBtn = document.getElementById("draw-toggle");
       const drawUndoBtn = document.getElementById("draw-undo");
       const drawColorInput = document.getElementById("draw-color");
       const drawStyleSelect = document.getElementById("draw-style");
       const drawArrowSelect = document.getElementById("draw-arrow");
       const svgMap = document.getElementById("map");
       function updateFreeDrawGraphics() {
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
         freeDrawPolylineEl = document.createElementNS(ns, "polyline");
         freeDrawPolylineEl.classList.add("edge", "free-preview");
         freeDrawPolylineEl.setAttribute("fill", "none");
         svg.appendChild(freeDrawPolylineEl);
        }
        if (freeDrawPolylineEl) {
         if (freeDrawPoints.length === 0) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         } else {
          const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
          freeDrawPolylineEl.setAttribute("points", ptsStr);
          freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
          freeDrawPolylineEl.style.strokeWidth = 3;
          const lineStyle = drawStyleSelect.value || "solid";
          if (lineStyle === "dashed") {
           freeDrawPolylineEl.style.strokeDasharray = "10,5";
          } else if (lineStyle === "dotted") {
           freeDrawPolylineEl.style.strokeDasharray = "2,4";
          } else {
           freeDrawPolylineEl.style.strokeDasharray = "none";
          }
         }
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        freeDrawPoints.forEach((p, idx) => {
         const c = document.createElementNS(ns, "circle");
         c.classList.add("free-point");
         c.setAttribute("cx", p.x);
         c.setAttribute("cy", p.y);
         c.setAttribute("r", 5);
         c.dataset.index = String(idx);
         c.addEventListener("mousedown", (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const moveHandler = (ev) => {
           if (!dragging) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.clientX;
           pt.y = ev.clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const upHandler = () => {
           dragging = false;
           document.removeEventListener("mousemove", moveHandler);
           document.removeEventListener("mouseup", upHandler);
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
         });
         c.addEventListener("touchstart",
          (e) => {
           if (!freeDrawMode) return;
           e.preventDefault();
           e.stopPropagation();
           let dragging = true;
           const svgEl = svgMap;
           const touchMoveHandler = (ev) => {
            if (!dragging || !ev.touches[0]) return;
            const pt = svgEl.createSVGPoint();
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
            const i = parseInt(c.dataset.index, 10);
            if (Number.isNaN(i) || !freeDrawPoints[i]) return;
            freeDrawPoints[i].x = svgP.x;
            freeDrawPoints[i].y = svgP.y;
            updateFreeDrawGraphics();
           };
           const touchUpHandler = () => {
            dragging = false;
            document.removeEventListener("touchmove", touchMoveHandler, );
            document.removeEventListener("touchend", touchUpHandler, );
           };
           document.addEventListener("touchmove", touchMoveHandler);
           document.addEventListener("touchend", touchUpHandler);
          }, {
           passive: false
          }, );
         svg.appendChild(c);
         freeDrawPointEls.push(c);
        });
        drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
       }
       function addFreeDrawPoint(x, y) {
        freeDrawPoints.push({
         x,
         y
        });
        updateFreeDrawGraphics();
       }
       function startFreeDraw() {
        freeDrawMode = true;
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        svgMap.style.cursor = "crosshair";
        drawToggleBtn.textContent = "Done";
        drawUndoBtn.style.display = "none";
       }
       function finishFreeDraw() {
        freeDrawMode = false;
        svgMap.style.cursor = "";
        drawToggleBtn.textContent = "‚úèÔ∏è";
        if (freeDrawPoints.length >= 2) {
         const color = drawColorInput.value || "#475569";
         const lineStyle = drawStyleSelect.value || "solid";
         const arrowDir = drawArrowSelect.value || "none";
         const newId = "custom-" + Date.now();
         const pointsCopy = freeDrawPoints.map((p) => ({
          x: p.x,
          y: p.y,
         }));
         EDGE_DATA.list.push({
          id: newId,
          type: "custom",
          color,
          width: 4,
          lineStyle: lineStyle,
          direction: arrowDir,
          points: pointsCopy,
          notes: [],
         });
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheTopology();
         selectTheConnection(newId);
        } else {
         freeDrawPoints = [];
         if (freeDrawPolylineEl) {
          freeDrawPolylineEl.remove();
          freeDrawPolylineEl = null;
         }
         freeDrawPointEls.forEach((el) => el.remove());
         freeDrawPointEls = [];
         forgeTheLegend();
        }
        drawUndoBtn.style.display = "none";
       }
       drawToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (freeDrawMode) {
         finishFreeDraw();
        } else {
         startFreeDraw();
        }
       });
       drawUndoBtn.addEventListener("click", () => {
        if (!freeDrawMode || !freeDrawPoints.length) return;
        freeDrawPoints.pop();
        updateFreeDrawGraphics();
       });
       const drawToolbar = document.getElementById("draw-toolbar");
       drawToolbar.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawToolbar.addEventListener("click", (e) => {
        if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
         e.stopPropagation();
        }
       });
       drawStyleSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawArrowSelect.addEventListener("change", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawColorInput.addEventListener("input", () => {
        if (freeDrawMode) {
         updateFreeDrawGraphics();
        }
       });
       drawStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawArrowSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       drawColorInput.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       svgMap.addEventListener("click", (e) => {
        if (!freeDrawMode) return;
        if (e.button !== 0) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        addFreeDrawPoint(svgP.x, svgP.y);
       });
       svgMap.addEventListener("touchend",
        (e) => {
         if (!freeDrawMode) return;
         const target = e.target;
         if (target && target.classList && target.classList.contains("free-point")) return;
         if (e.changedTouches && e.changedTouches[0]) {
          e.preventDefault();
          const svgEl = svgMap;
          const pt = svgEl.createSVGPoint();
          pt.x = e.changedTouches[0].clientX;
          pt.y = e.changedTouches[0].clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          addFreeDrawPoint(svgP.x, svgP.y);
         }
        }, {
         passive: false
        }, );
       const settingsBtn = document.getElementById("settings-btn");
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function updateRectPreview() {
        if (!rectPreviewEl || !rectStartPoint) return;
        const ns = "http://www.w3.org/2000/svg";
        const svg = svgMap;
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
       }
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "‚ñ≠";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
		updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
         const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
       const textToggleBtn = document.getElementById("text-toggle");
       function startTextMode() {
        textDrawMode = true;
        svgMap.style.cursor = "crosshair";
        textToggleBtn.textContent = "Done";
        textToggleBtn.style.background = "var(--accent)";
        textToggleBtn.style.color = "var(--bg)";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        if (rectDrawMode) {
         finishRectDraw();
        }
        updateTextDeleteButtons();
       }
       function finishTextMode() {
        textDrawMode = false;
        svgMap.style.cursor = "";
        textToggleBtn.textContent = "T";
        textToggleBtn.style.background = "";
        textToggleBtn.style.color = "";
        updateTextDeleteButtons();
       }
       textToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (textDrawMode) {
         finishTextMode();
        } else {
         startTextMode();
        }
       });
       function handleTextPlacement(e) {
        if (!textDrawMode) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const newId = "text-" + Date.now();
      pushUndo("add text");
        TEXT_DATA.list.push({
         id: newId,
         x: svgP.x,
         y: svgP.y,
         content: "New Text",
         fontSize: 18,
         color: "#e2e8f0",
         fontWeight: "normal",
         fontStyle: "normal",
         textAlign: "start",
         textDecoration: "none",
         bgColor: "#000000",
         bgEnabled: false,
         opacity: 1
        });
        forgeTheTopology();
        showTextPanel(newId);
       }
       svgMap.addEventListener("click", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        e.preventDefault();
        e.stopPropagation();
        handleTextPlacement(e);
       });
       svgMap.addEventListener("touchend", (e) => {
        if (!textDrawMode) return;
        if (e.target.closest('.text-delete-btn')) return;
        if (e.target.closest('.text-group')) return;
        if (e.touches.length > 0) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const fakeEvent = {
         clientX: touch.clientX,
         clientY: touch.clientY,
         preventDefault: () => {},
         stopPropagation: () => {}
        };
        handleTextPlacement(fakeEvent);
       }, { passive: false });
       function showTextPanel(textId) {
	   if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
        document.getElementById("text-content").value = textItem.content;
        document.getElementById("text-font-size").value = textItem.fontSize;
        document.getElementById("text-color").value = textItem.color;
        document.getElementById("text-font-weight").value = textItem.fontWeight;
        document.getElementById("text-font-style").value = textItem.fontStyle;
        document.getElementById("text-align").value = textItem.textAlign;
        document.getElementById("text-decoration").value = textItem.textDecoration;
        document.getElementById("text-bg-color").value = textItem.bgColor;
        document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
        document.getElementById("text-opacity").value = textItem.opacity;
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       }
       function updateTextDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.text-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = textDrawMode ? 'block' : 'none';
        });
       }
       function deleteText(textId) {
      pushUndo("delete text");
        TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        forgeTheTopology();
        if (currentTextId === textId) {
         document.getElementById("text-panel").style.display = "none";
         currentTextId = null;
        }
       }
       document.getElementById("text-content").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
      pushUndo("edit text");
         textItem.content = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-size").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontSize = parseInt(e.target.value);
         forgeTheTopology();
        }
       });
       document.getElementById("text-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.color = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-weight").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontWeight = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-font-style").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.fontStyle = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-align").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textAlign = e.target.value;
         forgeTheTopology();
        }
       });
        document.getElementById("text-decoration").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.textDecoration = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-color").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgColor = e.target.value;
         forgeTheTopology();
        }
       });
       document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.bgEnabled = e.target.checked;
         forgeTheTopology();
        }
       });
       document.getElementById("text-opacity").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         pushUndo("edit text");
         textItem.opacity = parseFloat(e.target.value);
         document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
         forgeTheTopology();
        }
       });
       document.getElementById("delete-text").addEventListener("click", () => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
         challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
          deleteText(currentTextId);
         });
        }
       });
       const settingsModal = document.getElementById("settings-modal");
       const settingsClose = document.getElementById("settings-close");
       settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = rgbaToHex(PAGE_STATE.background) || "#050608";
       document.getElementById("topbar-bg-color").value = rgbaToHex(PAGE_STATE.topbarBg) || "#0b0e13";
       document.getElementById("topbar-border-color").value = rgbaToHex(PAGE_STATE.topbarBorder) || "#1f2533";
       document.getElementById("panel-color").value = rgbaToHex(PAGE_STATE.panel) || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
	   document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = rgbaToHex(PAGE_STATE.accent) || "#4fd1c5";
       document.getElementById("danger-color").value = rgbaToHex(PAGE_STATE.danger) || "#f56565";
       document.getElementById("text-main-color").value = rgbaToHex(PAGE_STATE.textMain) || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
        document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
        document.getElementById("auto-ping-interval").value = autoPingInterval;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
        settingsModal.classList.add("active");
       });
       settingsClose.addEventListener("click", () => {
        settingsModal.classList.remove("active");
       });
	   document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
       settingsModal.addEventListener("click", (e) => {
        if (e.target === settingsModal) {
         settingsModal.classList.remove("active");
        }
       });
       document.getElementById("page-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.background = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBg = e.target.value;
        wieldThePower();
       });
       document.getElementById("topbar-border-color").addEventListener("input", (e) => {
        PAGE_STATE.topbarBorder = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-color").addEventListener("input", (e) => {
        PAGE_STATE.panel = e.target.value;
        wieldThePower();
       });
       document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
	  document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
       document.getElementById("accent-color").addEventListener("input", (e) => {
        PAGE_STATE.accent = e.target.value;
        wieldThePower();
       });
       document.getElementById("danger-color").addEventListener("input", (e) => {
        PAGE_STATE.danger = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-main-color").addEventListener("input", (e) => {
        PAGE_STATE.textMain = e.target.value;
        wieldThePower();
       });
       document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
         const headerResizer = document.getElementById('header-resizer');
         const sidebarResizer = document.getElementById('sidebar-resizer');
         const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
         let isResizing = false;
         let currentResizer = null;
         let startY = 0;
         let startX = 0;
         let startHeight = 0;
         let startWidth = 0;
         function getClientPos(e) {
           if (e.touches && e.touches.length > 0) {
             return { x: e.touches[0].clientX, y: e.touches[0].clientY };
           }
           return { x: e.clientX, y: e.clientY };
         }
         function startResize(resizer, type, e) {
           isResizing = true;
           currentResizer = type;
           const pos = getClientPos(e);
           if (type === 'header') {
             startY = pos.y;
             startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
           } else if (type === 'sidebar') {
             startX = pos.x;
             startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
           } else if (type === 'mobile-footer') {
             startY = pos.y;
             const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
             startHeight = (currentVh / 100) * window.innerHeight;
           }
           resizer.classList.add('resizing');
           document.body.classList.add('resizing');
           document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
           e.preventDefault();
         }
         if (headerResizer) {
           headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
           headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
         }
         if (sidebarResizer) {
           sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
           sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
         }
         if (mobileFooterResizer) {
           mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
           mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
         }
         function handleMove(e) {
           if (!isResizing) return;
           const pos = getClientPos(e);
           if (currentResizer === 'header') {
             const deltaY = pos.y - startY;
             const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
             document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
           } else if (currentResizer === 'sidebar') {
             const deltaX = startX - pos.x;
             const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
             document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
           } else if (currentResizer === 'mobile-footer') {
             const deltaY = startY - pos.y;
             const newHeight = startHeight + deltaY;
             const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
             document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
           }
           e.preventDefault();
         }
         document.addEventListener('mousemove', handleMove);
         document.addEventListener('touchmove', handleMove, { passive: false });
         function handleEnd() {
           if (isResizing) {
             isResizing = false;
             if (currentResizer === 'header') {
               PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
               headerResizer.classList.remove('resizing');
             } else if (currentResizer === 'sidebar') {
               PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
               sidebarResizer.classList.remove('resizing');
             } else if (currentResizer === 'mobile-footer') {
               PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
               mobileFooterResizer.classList.remove('resizing');
             }
             document.body.classList.remove('resizing');
             document.body.style.cursor = '';
             currentResizer = null;
           }
         }
         document.addEventListener('mouseup', handleEnd);
         document.addEventListener('touchend', handleEnd);
         document.addEventListener('touchcancel', handleEnd);
       })();
       document.getElementById("auto-ping-enabled").addEventListener("change", (e) => {
        autoPingEnabled = e.target.checked;
        PAGE_STATE.autoPingEnabled = autoPingEnabled;
        document.getElementById("auto-ping-settings").style.display = autoPingEnabled ? 'block' : 'none';
        if (autoPingEnabled) {
         startAutoPing();
        } else {
         stopAutoPing();
        }
       });
       document.getElementById("auto-ping-interval").addEventListener("change", (e) => {
        const newInterval = parseInt(e.target.value, 10);
        if (newInterval >= 5 && newInterval <= 3600) {
         autoPingInterval = newInterval;
         PAGE_STATE.autoPingInterval = autoPingInterval;
         if (autoPingEnabled) {
          startAutoPing();
         }
        }
       });
       document.getElementById("export-data-btn").addEventListener("click", () => {
        const data = captureTheQuickening();
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], {
         type: "application/json"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        const timestamp = new Date().toISOString().split("T")[0];
        a.download = `${safeTitle}-data-${timestamp}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		logAuditEvent("export", `Exported JSON: ${a.download}`);
       });
       document.getElementById("import-data-btn").addEventListener("click", () => {
        document.getElementById("import-data-file").click();
       });
       document.getElementById("import-data-file").addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        try {
         const text = await file.text();
         const data = JSON.parse(text);
         if (!data.nodeData || !data.edgeData) {
          alert("Invalid data file. Missing required fields.");
          return;
         }
         const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;         if (!confirm(confirmMsg)) {
          e.target.value = "";
          return;
         }
         NODE_DATA = data.nodeData || {};
         EDGE_DATA = data.edgeData || {
          list: []
         };
         EDGE_LEGEND = data.edgeLegend || {};
         RECT_DATA = data.rectData || { list: [] };
         TEXT_DATA = data.textData || { list: [] };
         savedPositions = data.nodePositions || {};
         savedSizes = data.nodeSizes || {};
         savedStyles = data.nodeStyles || {};
         if (data.page) {
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
          wieldThePower();
         }
      if (data.autoPingEnabled !== undefined) {
      autoPingEnabled = data.autoPingEnabled;
      PAGE_STATE.autoPingEnabled = autoPingEnabled;
      document.getElementById("auto-ping-enabled").checked = autoPingEnabled;
      }
      if (data.autoPingInterval !== undefined) {
      autoPingInterval = data.autoPingInterval;
      PAGE_STATE.autoPingInterval = autoPingInterval;
      document.getElementById("auto-ping-interval").value = autoPingInterval;
      }
         if (data.canvas) {
          canvasState.zoom = data.canvas.zoom || 1;
          canvasState.panX = data.canvas.panX || 0;
          canvasState.panY = data.canvas.panY || 0;
         }
         if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        forgeTheLegend();
        logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
      if (autoPingEnabled) {
      startAutoPing();
      } else {
      stopAutoPing();
      }
         const nodeIds = Object.keys(NODE_DATA);
         if (nodeIds.length > 0) {
          claimTheImmortal(nodeIds[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
         alert("Data imported successfully!");
         e.target.value = "";
        } catch (err) {
         console.error("Import error:", err);
         alert(`Failed to import data: ${err.message}`);
         e.target.value = "";
        }
       });
       const saveHelpBtn = document.getElementById("save-help-btn");
       const saveInfoModal = document.getElementById("save-info-modal");
       const saveInfoClose = document.getElementById("save-info-close");
       saveHelpBtn.addEventListener("click", () => {
        saveInfoModal.classList.add("active");
       });
       saveInfoClose.addEventListener("click", () => {
        saveInfoModal.classList.remove("active");
       });
       saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
       async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
       async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
       function isEncrypted(data) {
        return typeof data === "string" && data.startsWith("ENCRYPTED:");
       }
       function captureTheQuickening() {
      const currentTab = documentTabs[currentTabIndex];
      currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
      currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
      currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
      currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
      currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
      currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
      currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
      currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
      currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
      return {
      nodeData: NODE_DATA,
       edgeData: EDGE_DATA,
       rectData: RECT_DATA,
       textData: TEXT_DATA,
       edgeLegend: EDGE_LEGEND,
       nodePositions: savedPositions,
       nodeSizes: savedSizes,
       nodeStyles: savedStyles,
       iconCache: IconLibrary.iconCache,
       page: PAGE_STATE,
       autoPingEnabled: autoPingEnabled,
       autoPingInterval: autoPingInterval,
       canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
       },
       savedTopologyView: savedTopologyView,
       documentTabs: documentTabs,
       currentTabIndex: currentTabIndex,
       encryptedSections: encryptedSections,
	   auditLog: auditLog,
       };
      }
       function assembleTheImmortalForm() {
	   const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
        return " <!DOCTYPE html> \n " + clone.outerHTML;
       }
       async function becomeImmortal() {
        const encryptEnabled = document.getElementById("encrypt-toggle").checked;
        let stateData = JSON.stringify(captureTheQuickening(), null, 2);
        if (encryptEnabled) {
         const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
         if (!password) {
          alert("Encryption cancelled. File not saved.");
          return;
         }
         const confirmPassword = prompt("Confirm your password:");
         if (password !== confirmPassword) {
          alert("Passwords do not match. File not saved.");
          return;
         }
         try {
          stateData = await encryptData(stateData, password);
         } catch (e) {
          alert("Encryption failed: " + e.message);
          return;
         }
        }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       clone.querySelectorAll(".ping-indicator").forEach(el => el.remove());
       const nodeScript = clone.querySelector("#nodes-json");
        if (nodeScript) {
         if (encryptEnabled) {
          nodeScript.textContent = JSON.stringify({}, null, 2);
         } else {
          nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
         }
        }
        let stateScript = clone.querySelector("#topology-state");
        if (!stateScript) {
         stateScript = document.createElement("script");
         stateScript.id = "topology-state";
         stateScript.type = "application/json";
         const body = clone.querySelector("body") || clone;
         body.appendChild(stateScript);
        }
        stateScript.textContent = stateData;
        const html = "<!DOCTYPE html> \n " + clone.outerHTML;
        const blob = new Blob([html], {
         type: "text/html"
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
        a.download = safeTitle + ".html";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
		if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
        saveRollbackVersion("Manual save");
		logAuditEvent("save", `File saved: ${safeTitle}.html`);
       }
      function captureState() {
		 const clone = typeof structuredClone === 'function' 
		   ? (o) => structuredClone(o)
		   : (o) => JSON.parse(JSON.stringify(o));
		 return {
		  nodes: clone(NODE_DATA),
		  edges: clone(EDGE_DATA),
		  positions: clone(savedPositions),
		  sizes: clone(savedSizes),
		  styles: clone(savedStyles),
		  legend: clone(EDGE_LEGEND),
		  rects: clone(RECT_DATA),
		  texts: clone(TEXT_DATA)
		 };
		}
      let lastUndoPush = 0;
	   let pendingUndoState = null;
	   function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	    return;
	   }
	   lastUndoPush = now;
	   const state = captureState();
	   undoStack.push(state);
       if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
          "create node": "node",
          "delete node": "node",
          "add node": "node",
          "edit": "node",
          "clone node": "node",
          "paste node": "node",
          "move nodes": "node",
          "nudge": "node",
          "nudge nodes": "node",
          "align nodes": "node",
          "distribute nodes": "node",
          "snap to grid": "node",
          "toggle group": "node",
          "toggle lock": "node",
          "create rack": "rack",
          "add rack": "rack",
          "edit rack": "rack",
          "edit mac": "rack",
          "edit U height": "rack",
          "change rack capacity": "rack",
          "change assigned rack": "rack",
          "add connection": "connection",
          "delete connection": "connection",
          "delete edge": "connection",
          "clone edge": "connection",
          "paste edge": "connection",
          "style change": "style",
          "change layer": "layer",
          "add text": "text",
          "edit text": "text",
          "delete text": "text",
          "clone text": "text",
          "paste text": "text",
          "draw zone": "zone",
          "delete zone": "zone",
          "delete rect": "zone",
          "clone rect": "zone",
          "paste rect": "zone",
          "change zone line style": "zone",
          "delete selected": "bulk",
          "clone selected": "bulk",
        };
        const type = actionTypeMap[action] || "edit";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      NODE_DATA = state.nodes;
       EDGE_DATA = state.edges;
       savedPositions = state.positions;
       savedSizes = state.sizes;
       savedStyles = state.styles;
       EDGE_LEGEND = state.legend;
       RECT_DATA = state.rects || { list: [] };
       TEXT_DATA = state.texts || { list: [] };
       forgeTheTopology();
       if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
       } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      clearSearchHighlight();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n‚Ä¢ ${nodesInsideRacks.join('\n‚Ä¢ ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       isSelecting = true;
       selectionStart = { x: svgP.x, y: svgP.y };
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        selectionRect.style.pointerEvents = "none";
        svgEl.appendChild(selectionRect);
       }
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svgEl = document.getElementById("map");
       const pt = svgEl.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       selectionRect.style.display = "block";
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
       EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       selectionStart = null;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       const source = NODE_DATA[sourceId];
       if (!source) return;
       if (!skipUndo) pushUndo("clone node");
       let baseName = source.name;
       let copyNum = 0;
       let newName = baseName + " copy";
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        copyNum++;
        newName = baseName + " copy " + copyNum;
       }
       const newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        ping: source.ping ? JSON.parse(JSON.stringify(source.ping)) : {
         enabled: false,
         protocol: 'http',
         customUrl: '',
         timeout: 3000,
         status: 'unknown',
         lastCheck: null
        },
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         let childBaseName = childNode.name;
         let c = 0;
         let childNewName = childBaseName + " copy";
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          c++;
          childNewName = childBaseName + " copy " + c;
         }
         const childNewId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
      if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       switch(direction) {
        case "left":
         const minX = Math.min(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...positions.map(p => p.pos.x));
         positions.forEach(p => savedPositions[p.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...positions.map(p => p.pos.y));
         positions.forEach(p => savedPositions[p.id].y = maxY);
         break;
        case "center-h":
         const avgX = positions.reduce((sum, p) => sum + p.pos.x, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].x = avgX);
         break;
        case "center-v":
         const avgY = positions.reduce((sum, p) => sum + p.pos.y, 0) / positions.length;
         positions.forEach(p => savedPositions[p.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodeIds = Array.from(selectedNodes);
       const positions = nodeIds.map(id => ({ id, pos: savedPositions[id] }));
       if (direction === "horizontal") {
        positions.sort((a, b) => a.pos.x - b.pos.x);
        const minX = positions[0].pos.x;
        const maxX = positions[positions.length - 1].pos.x;
        const gap = (maxX - minX) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].x = minX + (gap * i);
        });
       } else if (direction === "vertical") {
        positions.sort((a, b) => a.pos.y - b.pos.y);
        const minY = positions[0].pos.y;
        const maxY = positions[positions.length - 1].pos.y;
        const gap = (maxY - minY) / (positions.length - 1);
        positions.forEach((p, i) => {
         savedPositions[p.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        if (nodesToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        if (unlockedNodes.length === 0) {
          return;
        }
        pushUndo("nudge nodes");
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) {
            savedPositions[id] = { x: 0, y: 0 };
          }
          switch(direction) {
            case "ArrowUp":
              savedPositions[id].y -= distance;
              break;
            case "ArrowDown":
              savedPositions[id].y += distance;
              break;
            case "ArrowLeft":
              savedPositions[id].x -= distance;
              break;
            case "ArrowRight":
              savedPositions[id].x += distance;
              break;
          }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack") {
           const node = NODE_DATA[id];
           return node && node.assignedRack === currentView.rackId;
          }
          return isNodeVisible(id);
         });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
        updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z" && !event.shiftKey) {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
       if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const svgEl = document.getElementById("map");
        const rect = svgEl.getBoundingClientRect();
        const pt = svgEl.createSVGPoint();
        pt.x = rect.left + rect.width / 2;
        pt.y = rect.top + rect.height / 2;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const centerX = svgP.x;
        const centerY = svgP.y;
        if (clipboard.type === "node") {
         let newName = clipboard.data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = clipboard.data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...JSON.parse(JSON.stringify(clipboard.data)), name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
       }
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
			focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = true) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group, .edge").forEach(edge => {
			if (hasQuery) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
		   document.querySelectorAll(".search-highlight").forEach(node => {
			node.classList.remove("search-highlight");
		   });
		   document.querySelectorAll(".search-faded").forEach(el => {
			el.classList.remove("search-faded");
		   });
		}
      function editNodeMac(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit MAC Address";
       document.getElementById("modal-input").value = node.mac || "";
       document.getElementById("edit-modal").style.display = "";
	   document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
       const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit mac");
        const value = document.getElementById("modal-input").value.trim();
        node.mac = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge) return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       edge.fromPort = fromPortInput ? fromPortInput.value.trim() : "";
       edge.toPort = toPortInput ? toPortInput.value.trim() : "";
       forgeTheTopology();
      }
      document.addEventListener("keydown", handleKeyDown);
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
       nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
		 });
		}
       document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
       document.getElementById("check-all-ping-btn").addEventListener("click", checkAllNodesStatus);
       const addNodeBtn = document.getElementById("add-node-btn");
       const addNodeModal = document.getElementById("add-node-modal");
       const addNodeCancel = document.getElementById("add-node-cancel");
       const addNodeSave = document.getElementById("add-node-save");
       addNodeBtn.addEventListener("click", () => {
	    if (isViewOnly()) return;
        document.getElementById("new-node-name").value = "";
        document.getElementById("new-node-ip").value = "";
        document.getElementById("new-node-tags").value = "";
        document.getElementById("new-node-shape").value = "circle";
        document.getElementById("new-node-pingable").checked = false;
        document.getElementById("new-node-ping-protocol").value = "http";
        document.getElementById("new-node-custom-url").value = "";
        document.getElementById("new-node-ping-timeout").value = "3000";
        document.getElementById("new-node-ping-options").style.display = "none";
        document.getElementById("new-node-custom-url-container").style.display = "none";
        newNodeIconTags = [];
        document.getElementById("new-node-icon-tags").style.display = "none";
        document.getElementById("new-node-icon-tags-list").innerHTML = "";
        addNodeModal.classList.add("active");
        document.getElementById("new-node-name").focus();
       });
       const canvasViewport = document.getElementById("canvas-viewport");
       if (canvasViewport) {
        canvasViewport.addEventListener("dblclick", (e) => {
         if (currentView.mode === "rack" && e.target.id === "map") {
          exitRack();
         }
        });
       }
       const layersBtn = document.getElementById("layers-btn");
       const layerModal = document.getElementById("layer-modal");
       const layerModalClose = document.getElementById("layer-modal-close");
       if (layersBtn && layerModal) {
        layersBtn.addEventListener("click", () => {
         layerModal.classList.add("active");
        });
       }
       if (layerModalClose && layerModal) {
        layerModalClose.addEventListener("click", () => {
         layerModal.classList.remove("active");
        });
       }
       if (layerModal) {
        layerModal.addEventListener("click", (e) => {
         if (e.target === layerModal) {
          layerModal.classList.remove("active");
         }
        });
       }
       const tabsBtn = document.getElementById("tabs-btn");
       const tabsModal = document.getElementById("tabs-modal");
       const tabsModalClose = document.getElementById("tabs-modal-close");
       if (tabsBtn && tabsModal) {
         tabsBtn.addEventListener("click", () => {
           displayTabs();
           tabsModal.classList.add("active");
         });
       }
       if (tabsModalClose && tabsModal) {
         tabsModalClose.addEventListener("click", () => {
           tabsModal.classList.remove("active");
         });
       }
       if (tabsModal) {
         tabsModal.addEventListener("click", (e) => {
           if (e.target === tabsModal) {
             tabsModal.classList.remove("active");
           }
         });
       }
       const rollbackBtn = document.getElementById("rollback-btn");
       const rollbackModal = document.getElementById("rollback-modal");
       const rollbackModalClose = document.getElementById("rollback-modal-close");
       if (rollbackBtn && rollbackModal) {
         rollbackBtn.addEventListener("click", () => {
           loadRollbackVersions();
           rollbackModal.classList.add("active");
         });
       }
       if (rollbackModalClose && rollbackModal) {
         rollbackModalClose.addEventListener("click", () => {
           rollbackModal.classList.remove("active");
         });
       }
       if (rollbackModal) {
         rollbackModal.addEventListener("click", (e) => {
           if (e.target === rollbackModal) {
             rollbackModal.classList.remove("active");
           }
         });
       }
       const auditLogBtn = document.getElementById("audit-log-btn");
       const auditLogModal = document.getElementById("audit-log-modal");
       const auditLogModalClose = document.getElementById("audit-log-modal-close");
       if (auditLogBtn && auditLogModal) {
         auditLogBtn.addEventListener("click", () => {
           loadAuditLog();
           displayAuditLog();
           auditLogModal.classList.add("active");
         });
       }
       if (auditLogModalClose && auditLogModal) {
         auditLogModalClose.addEventListener("click", () => {
           auditLogModal.classList.remove("active");
         });
       }
	   const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">‚Üó</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
       if (auditLogModal) {
         auditLogModal.addEventListener("click", (e) => {
           if (e.target === auditLogModal) {
             auditLogModal.classList.remove("active");
           }
         });
       }
       const auditFilter = document.getElementById("audit-filter");
       if (auditFilter) {
         auditFilter.addEventListener("change", (e) => {
           displayAuditLog(e.target.value);
         });
       }
       const secretsBtn = document.getElementById("secrets-btn");
       const secretsModal = document.getElementById("secrets-modal");
       const secretsModalClose = document.getElementById("secrets-modal-close");
       if (secretsBtn && secretsModal) {
         secretsBtn.addEventListener("click", () => {
           displaySecrets();
           secretsModal.classList.add("active");
         });
       }
       if (secretsModalClose && secretsModal) {
         secretsModalClose.addEventListener("click", () => {
           secretsModal.classList.remove("active");
         });
       }
       if (secretsModal) {
         secretsModal.addEventListener("click", (e) => {
           if (e.target === secretsModal) {
             secretsModal.classList.remove("active");
           }
         });
       }
       const secretEditorModal = document.getElementById("secret-editor-modal");
       if (secretEditorModal) {
         secretEditorModal.addEventListener("click", (e) => {
           if (e.target === secretEditorModal) {
             closeSecretEditor();
           }
         });
       }
       ["physical", "logical", "security", "application"].forEach(layer => {
        const checkbox = document.getElementById(`layer-${layer}`);
        if (checkbox) {
         checkbox.addEventListener("change", applyLayerFilter);
        }
       });
       const layerSelect = document.getElementById("node-layer");
       if (layerSelect) {
        layerSelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change layer");
          NODE_DATA[currentNodeId].layer = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.addEventListener("change", (e) => {
         if (currentNodeId) {
          pushUndo("change rack capacity");
          NODE_DATA[currentNodeId].rackCapacity = e.target.value;
          forgeTheTopology();
         }
        });
       }
       const addRackBtn = document.getElementById("add-rack-btn");
       const addRackModal = document.getElementById("add-rack-modal");
       const addRackCancel = document.getElementById("add-rack-cancel");
       const addRackSave = document.getElementById("add-rack-save");
       if (addRackBtn && addRackModal) {
        addRackBtn.addEventListener("click", () => {
		if (isViewOnly()) return;
         document.getElementById("new-rack-name").value = "";
         document.getElementById("new-rack-ip").value = "";
         document.getElementById("new-rack-tags").value = "";
         document.getElementById("new-rack-shape").value = "server";
         document.getElementById("new-rack-capacity").value = "42";
         selectedRackIconData = null;
         document.getElementById('selected-rack-icon').style.display = 'none';
         addRackModal.classList.add("active");
         document.getElementById("new-rack-name").focus();
        });
       }
       if (addRackCancel && addRackModal) {
        addRackCancel.addEventListener("click", () => {
         addRackModal.classList.remove("active");
        });
       }
       if (addRackModal) {
        addRackModal.addEventListener("click", (e) => {
         if (e.target === addRackModal) {
          addRackModal.classList.remove("active");
         }
        });
       }
       if (addRackSave && addRackModal) {
        addRackSave.addEventListener("click", () => {
         const name = document.getElementById("new-rack-name").value.trim();
         const ip = document.getElementById("new-rack-ip").value.trim();
         const tagsStr = document.getElementById("new-rack-tags").value.trim();
         const shape = document.getElementById("new-rack-shape").value;
         const capacity = document.getElementById("new-rack-capacity").value;
         if (!name) {
          alert("Please enter a rack name.");
          return;
         }
         const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
         let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
         if (!baseId) baseId = "rack";
         let nodeId = baseId;
         let counter = 1;
         while (NODE_DATA[nodeId]) {
          nodeId = baseId + "-" + counter;
          counter++;
         }
         pushUndo("add rack");
         NODE_DATA[nodeId] = {
          shape: shape,
          name: name,
          ip: ip || "",
          role: "Rack",
          tags: tags,
          notes: [],
          mac: "",
          rackUnit: "",
          uHeight: "1",
          layer: "physical",
          assignedRack: "",
          rackCapacity: capacity,
          isRack: true,
          locked: false,
          groupId: null
         };
         const viewWidth = CANVAS_WIDTH / canvasState.zoom;
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerX = canvasState.panX + (viewWidth / 2);
         const centerY = canvasState.panY + (viewHeight / 2);
         savedPositions[nodeId] = {
          x: centerX,
          y: centerY
         };
         if (selectedRackIconData) {
          if (!savedStyles[nodeId]) {
           savedStyles[nodeId] = {};
          }
          if (!savedStyles[nodeId]['all']) {
           savedStyles[nodeId]['all'] = {};
          }
          savedStyles[nodeId]['all'].icon = {
           library: selectedRackIconData.library,
           name: selectedRackIconData.name
          };
          selectedRackIconData = null;
          document.getElementById('selected-rack-icon').style.display = 'none';
         }
         addRackModal.classList.remove("active");
         forgeTheTopology();
         claimTheImmortal(nodeId);
        });
        ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
         const input = document.getElementById(inputId);
         if (input) {
          input.addEventListener("keypress", (e) => {
           if (e.key === "Enter") {
            addRackSave.click();
           }
          });
         }
        });
       }
       addNodeCancel.addEventListener("click", () => {
        addNodeModal.classList.remove("active");
       });
       addNodeModal.addEventListener("click", (e) => {
        if (e.target === addNodeModal) {
         addNodeModal.classList.remove("active");
        }
       });
       addNodeSave.addEventListener("click", () => {
        const name = document.getElementById("new-node-name").value.trim();
        const ip = document.getElementById("new-node-ip").value.trim();
        const tagsStr = document.getElementById("new-node-tags").value.trim();
        const shape = document.getElementById("new-node-shape").value;
        const pingable = document.getElementById("new-node-pingable").checked;
        const pingProtocol = document.getElementById("new-node-ping-protocol").value;
        const pingCustomUrl = document.getElementById("new-node-custom-url").value.trim();
        const pingTimeout = parseInt(document.getElementById("new-node-ping-timeout").value) || 3000;
        if (!name) {
         alert("Please enter a node name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        if (newNodeIconTags.length > 0) {
         tags.push(...newNodeIconTags);
        }
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "node";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
		pushUndo("add node");
        NODE_DATA[nodeId] = {
         shape: shape || "circle",
         name: name,
         ip: ip || "0.0.0.0",
         role: "",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         ping: {
          enabled: pingable,
          protocol: pingProtocol,
          customUrl: pingCustomUrl,
          timeout: pingTimeout,
          status: 'unknown',
          lastCheck: null
         },
         locked: false,
         groupId: null
        };
        if (currentView.mode === "rack" && currentView.rackId) {
         NODE_DATA[nodeId].assignedRack = currentView.rackId;
         NODE_DATA[nodeId].layer = "physical";
         const rackCapacity = getRackCapacity(currentView.rackId);
         const rackUHeight = getRackUHeight(currentView.rackId);
         const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
         const centerY = canvasState.panY + (viewHeight / 2);
         let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
         unit = Math.max(1, Math.min(rackCapacity, unit));
         NODE_DATA[nodeId].rackUnit = String(unit);
        }
        if (selectedNodeIconData) {
         if (!savedStyles[nodeId]) savedStyles[nodeId] = {};
         if (!savedStyles[nodeId]['all']) savedStyles[nodeId]['all'] = {};
         savedStyles[nodeId]['all'].icon = {
          library: selectedNodeIconData.library,
          name: selectedNodeIconData.name
         };
         selectedNodeIconData = null;
         document.getElementById('selected-node-icon').style.display = 'none';
        }
        newNodeIconTags = [];
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
        addNodeModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
        (inputId) => {
         document.getElementById(inputId).addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addNodeSave.click();
          }
         });
        }, );
       document.getElementById('new-node-pingable').addEventListener('change', (e) => {
        const pingOptions = document.getElementById('new-node-ping-options');
        pingOptions.style.display = e.target.checked ? 'block' : 'none';
       });
       document.getElementById('new-node-ping-protocol').addEventListener('change', (e) => {
        const customUrlContainer = document.getElementById('new-node-custom-url-container');
        customUrlContainer.style.display = e.target.value === 'custom' ? 'block' : 'none';
       });
       document.getElementById('pick-rack-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedRackIconData = iconData;
         const preview = document.getElementById('selected-rack-icon-preview');
         const container = document.getElementById('selected-rack-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-node-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         selectedNodeIconData = iconData;
         const preview = document.getElementById('selected-node-icon-preview');
         const container = document.getElementById('selected-node-icon');
         const parser = new DOMParser();
         const doc = parser.parseFromString(iconData.svg, 'image/svg+xml');
         const svgEl = doc.querySelector('svg');
         preview.innerHTML = '';
         if (svgEl) {
          preview.appendChild(svgEl.cloneNode(true));
         }
         const nameSpan = document.createElement('span');
         nameSpan.textContent = iconData.name;
         preview.appendChild(nameSpan);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-tag-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!currentNodeId || !NODE_DATA[currentNodeId]) return;
         if (!NODE_DATA[currentNodeId].tags) {
          NODE_DATA[currentNodeId].tags = [];
         }
         NODE_DATA[currentNodeId].tags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         forgeTheTopology();
         claimTheImmortal(currentNodeId);
        });
       });
       document.getElementById('pick-new-node-tag-icon-btn').addEventListener('click', () => {
        openIconPicker((iconData) => {
         newNodeIconTags.push({
          type: 'icon',
          library: iconData.library,
          name: iconData.name
         });
         const container = document.getElementById('new-node-icon-tags');
         const list = document.getElementById('new-node-icon-tags-list');
         const badge = document.createElement('div');
         badge.className = 'icon-badge';
         badge.style.cssText = 'display: inline-flex; align-items: center; gap: 6px; padding: 6px 10px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; font-size: 13px;';
         const iconPreview = document.createElement('div');
         iconPreview.style.cssText = 'width: 16px; height: 16px; display: flex; align-items: center; justify-content: center;';
         IconLibrary.getIcon(iconData.library, iconData.name).then(svg => {
          if (svg) {
           const parser = new DOMParser();
           const doc = parser.parseFromString(svg, 'image/svg+xml');
           const svgEl = doc.querySelector('svg');
           if (svgEl) {
            svgEl.setAttribute('width', '16');
            svgEl.setAttribute('height', '16');
            svgEl.style.fill = 'var(--text-main)';
            iconPreview.appendChild(svgEl);
           }
          }
         });
         const name = document.createElement('span');
         name.textContent = iconData.name;
         name.style.color = 'var(--text-soft)';
         const removeBtn = document.createElement('button');
         removeBtn.textContent = '√ó';
         removeBtn.style.cssText = 'background: none; border: none; color: var(--danger); cursor: pointer; font-size: 18px; line-height: 1; padding: 0 4px;';
         removeBtn.addEventListener('click', () => {
          const index = newNodeIconTags.findIndex(t => t.type === 'icon' && t.library === iconData.library && t.name === iconData.name);
          if (index > -1) {
           newNodeIconTags.splice(index, 1);
          }
          badge.remove();
          if (list.children.length === 0) {
           container.style.display = 'none';
          }
         });
         badge.appendChild(iconPreview);
         badge.appendChild(name);
         badge.appendChild(removeBtn);
         list.appendChild(badge);
         container.style.display = 'block';
        });
       });
       document.getElementById('pick-shape-icon-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        openIconPicker((iconData) => {
         if (!savedStyles[currentNodeId]) {
          savedStyles[currentNodeId] = {};
         }
         if (!savedStyles[currentNodeId][currentStyleScope]) {
          savedStyles[currentNodeId][currentStyleScope] = {};
         }
         savedStyles[currentNodeId][currentStyleScope].icon = {
          library: iconData.library,
          name: iconData.name
         };
		 delete savedStyles[currentNodeId][currentStyleScope].circleColor;
         delete savedStyles[currentNodeId][currentStyleScope].circleBorder;
         const shapeSelect = document.getElementById('shape-select');
         if (!shapeSelect.querySelector('option[value="custom-icon"]')) {
          const opt = document.createElement('option');
          opt.value = 'custom-icon';
          opt.textContent = 'Custom Icon';
          shapeSelect.insertBefore(opt, shapeSelect.firstChild);
         }
         shapeSelect.value = 'custom-icon';
         forgeTheTopology();
        });
       });
       document.getElementById('add-tag-btn').addEventListener('click', () => {
        if (!currentNodeId) return;
        if (!NODE_DATA[currentNodeId]) return;
        const input = document.getElementById('new-tag-input');
        const tagText = input.value.trim();
        if (!tagText) return;
        if (!NODE_DATA[currentNodeId].tags) {
         NODE_DATA[currentNodeId].tags = [];
        }
        NODE_DATA[currentNodeId].tags.push(tagText);
        input.value = '';
        forgeTheTopology();
        claimTheImmortal(currentNodeId);
       });
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} ‚Ä¢ ${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes ‚Ä¢ ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">‚úèÔ∏è</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">üóëÔ∏è</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit Secret: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note section: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "üîí Encrypted" : "üîì Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">‚úèÔ∏è</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">üóëÔ∏è</button>
              </div>
            </div>
          `;
        }).join('');
      }
       const clearAllBtn = document.getElementById("clear-all-btn");
       const clearAllModal = document.getElementById("clear-all-modal");
       const clearAllCancel = document.getElementById("clear-all-cancel");
       const clearAllConfirm = document.getElementById("clear-all-confirm");
       clearAllBtn.addEventListener("click", () => {
        clearAllModal.classList.add("active");
       });
       clearAllCancel.addEventListener("click", () => {
        clearAllModal.classList.remove("active");
       });
       clearAllModal.addEventListener("click", (e) => {
        if (e.target === clearAllModal) {
         clearAllModal.classList.remove("active");
        }
       });
       clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        clipboard = null;
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
       (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n‚Ä¢ ${nodesInsideRack.join('\n‚Ä¢ ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
       function screenshotCanvas() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        function inlineStyles(original, clone) {
         const elements = original.querySelectorAll("*");
         const clonedElements = clone.querySelectorAll("*");
         const rootStyles = getComputedStyle(document.documentElement);
         const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
         const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
         bgRect.setAttribute("x", x);
         bgRect.setAttribute("y", y);
         bgRect.setAttribute("width", width);
         bgRect.setAttribute("height", height);
         bgRect.setAttribute("fill", bgColor);
         clone.insertBefore(bgRect, clone.firstChild);
         elements.forEach((el, index) => {
          const clonedEl = clonedElements[index];
          if (!clonedEl) return;
          const computedStyle = getComputedStyle(el);
          const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
          svgProps.forEach((prop) => {
           const value = computedStyle.getPropertyValue(prop);
           if (value && value !== "none" && value !== "normal") {
            clonedEl.style[prop] = value;
           }
          });
          clonedEl.removeAttribute("class");
         });
        }
        inlineStyles(svg, svgClone);
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const svgBlob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();
        img.onload = function() {
         const canvas = document.createElement("canvas");
         canvas.width = width;
         canvas.height = height;
         const ctx = canvas.getContext("2d");
         ctx.drawImage(img, 0, 0);
         canvas.toBlob(function(blob) {
          const link = document.createElement("a");
          const timestamp = new Date().toISOString().slice(0, 10);
          link.download = `topology-${timestamp}.png`;
          link.href = URL.createObjectURL(blob);
          link.click();
          URL.revokeObjectURL(url);
          URL.revokeObjectURL(link.href);
         }, "image/png");
        };
        img.onerror = function() {
         console.error("Failed to load SVG image");
         alert("Screenshot failed. Please try again.");
         URL.revokeObjectURL(url);
        };
        img.src = url;
       }
       function exportCanvasSVG() {
        const svg = document.getElementById("map");
        const svgClone = svg.cloneNode(true);
        const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
        const [x, y, width, height] = viewBox;
        svgClone.setAttribute("width", width);
        svgClone.setAttribute("height", height);
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        svgClone.insertBefore(bgRect, svgClone.firstChild);
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "-9999px";
        wrapper.appendChild(svgClone);
        document.body.appendChild(wrapper);
        const elements = svg.querySelectorAll("*");
        const clonedElements = svgClone.querySelectorAll("*");
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.setAttribute(prop, value);
          }
         });
         clonedEl.removeAttribute("class");
        });
        const svgData = new XMLSerializer().serializeToString(svgClone);
        document.body.removeChild(wrapper);
        const blob = new Blob([svgData], {
         type: "image/svg+xml;charset=utf-8",
        });
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        const timestamp = new Date().toISOString().slice(0, 10);
        link.download = `topology-${timestamp}.svg`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
       }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
    </script>
</body></html>