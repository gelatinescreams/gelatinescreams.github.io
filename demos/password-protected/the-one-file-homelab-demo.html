<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self-contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block;
      background: linear-gradient(rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.1) 1px,
      transparent 1px),
      linear-gradient(rgba(71, 85, 105, 0.05) 1px, transparent 1px),
      linear-gradient(90deg,
      rgba(71, 85, 105, 0.05) 1px,
      transparent 1px);
      background-size:
      100px 100px,
      100px 100px,
      20px 20px,
      20px 20px;
      background-position:
      -1px -1px,
      -1px -1px,
      -1px -1px,
      -1px -1px;
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
      .style-content {
      margin-top: 10px;
      }
      .style-row {
      display: flex;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
      }
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }
	  #map circle[class*="node"],
	  #map .node-shape,
	  #map .node-group circle,
	  #map .node-group rect,
	  #map .node-group path,
	  #map .node-group polygon {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }
	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

  #map .rect-group rect {
    stroke: #333 !important;
  }
	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90°)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
              <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Sidebar / Mobile Footer</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
        </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">105 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">11 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">🔒</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-json-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
            <option value="solid">Solid</option>
            <option value="dashed">Dashed</option>
            <option value="dotted">Dotted</option>
          </select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="162.25942846156744 -131.59941950312611 4069.861183597212 3052.395887697909" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="162.25942846156744" y="-131.59941950312611" width="4069.861183597212" height="3052.395887697909"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">98%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
          <details id="node-connections-section" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90°)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
              <option value="solid">Solid</option>
              <option value="dashed">Dashed</option>
              <option value="dotted">Dotted</option>
            </select>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent, );
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
       rackFrameFill: "#0f172a",
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
const frag = document.createDocumentFragment();

EDGE_DATA.list.forEach((edge) => {
  if (edge.type === "custom") return;
  const fromNode = NODE_DATA[edge.from];
  const toNode = NODE_DATA[edge.to];
  if (!fromNode || !toNode) return;
  if (currentView.mode === "rack") {
    if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
  } else {
    if (fromNode.assignedRack || toNode.assignedRack) return;
  }
  const p1 = savedPositions[edge.from];
  const p2 = savedPositions[edge.to];
  if (!p1 || !p2) return;
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", p1.x);
  line.setAttribute("y1", p1.y);
  line.setAttribute("x2", p2.x);
  line.setAttribute("y2", p2.y);
  line.classList.add("minimap-edge");
  frag.appendChild(line);
});

Object.entries(savedPositions).forEach(([id, pos]) => {
  const node = NODE_DATA[id];
  if (!node) return;
  if (currentView.mode === "rack") {
    if (node.assignedRack !== currentView.rackId) return;
  } else {
    if (node.assignedRack) return;
  }
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", pos.x);
  circle.setAttribute("cy", pos.y);
  circle.setAttribute("r", 40);
  circle.classList.add("minimap-node");
  frag.appendChild(circle);
});

minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom), );
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX), );
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY), );
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.innerHTML = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh", );
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")", );
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.", );
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.", );
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page, );
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0], );
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p), );
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`, );
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45, );
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45, );
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `, );
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
       defs.appendChild(markerBackward);
       svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack") {
 const gridGroup = document.createElementNS(ns, "g");
 gridGroup.id = "canvas-grid";
 const gridSize = PAGE_STATE.canvasGridSize || 50;
 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", x);
  line.setAttribute("y1", CANVAS_PADDING);
  line.setAttribute("x2", x);
  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", CANVAS_PADDING);
  line.setAttribute("y1", y);
  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
  line.setAttribute("y2", y);
  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 svg.appendChild(gridGroup);
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
         const y = RACK_START_Y + u * rackUHeight;
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
         if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      handle.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x), );
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y), );
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
         if (lineStyle === "dashed") {
          poly.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          poly.style.strokeDasharray = "2,4";
         } else {
          poly.style.strokeDasharray = "none";
         }
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        let pathD;
        if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g", );
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        g.setAttribute("transform", `translate(${pos.x},${pos.y})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text", );
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         }, );
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX), );
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY), );
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId, );
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`, );
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
           else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         }, );
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`, );
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p), );
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         }, );
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          }, );
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        }, );
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        }, );
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY, );
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        }, );
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point');
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
          if (isEmptySpace && e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        }, );
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        }, );
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value), );
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value), );
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value), );
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value), );
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)), );
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value), );
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value), );
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)), );
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`, );
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`, );
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId, );
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        }, );
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler, );
           document.removeEventListener("touchend", touchUpHandler, );
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         }, );
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse(), );
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       }, );
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.style.background = "var(--accent)";
       textToggleBtn.style.color = "var(--bg)";
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.style.background = "";
       textToggleBtn.style.color = "";
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-opacity").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.opacity = parseFloat(e.target.value);
        document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
        forgeTheTopology();
       }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
	   document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page, );
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2, );
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)", );
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  let pendingUndoState = null;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
       };
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
       NODE_DATA[newId] = {
        shape: source.shape,
        name: newName,
        ip: source.ip,
        role: source.role,
        tags: [...source.tags],
        notes: [...source.notes],
        mac: source.mac || "",
        rackUnit: source.rackUnit || "",
        uHeight: source.uHeight || "1",
        layer: source.layer || "physical",
        assignedRack: source.assignedRack || "",
        rackCapacity: source.rackCapacity || "42",
        isRack: source.isRack || false
       };
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 10px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 8px;"></span><span style="cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()">${escapeHtml(fromName)}</span></td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.fromPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')">${fromPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; cursor: pointer; text-decoration: underline;" onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()">${escapeHtml(toName)}</td><td style="padding: 10px; font-family: monospace;"><span style="color: ${e.toPort ? 'var(--accent)' : 'var(--text-soft)'}; cursor: pointer;" onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')">${toPortDisplay}</span> <span style="cursor: pointer; opacity: 0.6; font-size: 11px;" onclick="${goToEdge}" title="Go to connection">↗</span></td><td style="padding: 10px; color: var(--text-soft); font-size: 12px;">${escapeHtml(notes) || "-"}</td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = (NODE_DATA[e.from]?.name || e.from || "").replace(/,/g, ";");
          const toName = (NODE_DATA[e.to]?.name || e.to || "").replace(/,/g, ";");
          const notes = (e.notes || []).join("; ").replace(/,/g, ";");
          csv += `"${fromName}","${e.fromPort || ""}","${toName}","${e.toPort || ""}","${notes}"\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       }, );
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect", );
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `• ${nodes.length} nodes in CSV data\n` +
        `• ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `• ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState);
		  if (config.canvasView) {
			canvasState.zoom = config.canvasView.zoom || 1;
			canvasState.panX = config.canvasView.panX || 0;
			canvasState.panY = config.canvasView.panY || 0;
		  }
		  if (config.legend) Object.assign(EDGE_LEGEND, config.legend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		alert(`Successfully imported ${nodes.length} nodes`);
	  } catch (err) {
		console.error('CSV import error:', err);
		alert('Failed to import CSV: ' + err.message);
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    edges.forEach(edge => {
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
     } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});
    </script>
  
</body></html>