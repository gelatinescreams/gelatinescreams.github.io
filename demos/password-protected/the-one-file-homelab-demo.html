<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
	  .toggle-switch{position:relative;display:inline-block;min-width:44px !important;height:24px;flex-shrink:0;vertical-align:middle;}
		.toggle-switch input{opacity:0;width:0;height:0;position:absolute;}
		.toggle-slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:#475569;transition:.25s;border-radius:24px;}
		.toggle-slider:before{position:absolute;content:"";height:18px;width:18px;left:3px;bottom:3px;background:#e2e8f0;transition:.25s;border-radius:50%;}
		.toggle-switch input:checked+.toggle-slider{background:var(--accent);}
		.toggle-switch input:checked+.toggle-slider:before{transform:translateX(20px);}
		.anim-zone-row{display:flex;justify-content:space-between;align-items:center;padding:6px 0;}
		.anim-zone-row label{color:var(--text-main);font-size:14px;}
		.anim-zone-section{font-size:11px;color:var(--text-soft);margin:12px 0 6px;text-transform:uppercase;letter-spacing:0.05em;border-bottom:1px solid var(--edge-main);padding-bottom:4px;}
		.anim-zone-header{font-size:12px;color:var(--accent);margin-bottom:10px;text-transform:uppercase;letter-spacing:0.05em;font-weight:600;}
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
	  .fov-group {
        transition: opacity 0.3s ease;
      }
      g[data-node-id]:not(:hover) .fov-group {
        opacity: 0.7;
      }
      g[data-node-id]:hover .fov-group {
        opacity: 1;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
	  .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 8px;
      fill: none;
      }
	  .minimap-wall {
      pointer-events: none;
      }
      .minimap-rect {
      pointer-events: none;
      }	  
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      pointer-events: auto;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
.style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
.style-row {
  display: contents;
}
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
	  .fov-group {
  transition: opacity 0.3s ease;
}
g[data-node-id]:not(:hover) .fov-group {
  opacity: 0.6;
}
g[data-node-id]:hover .fov-group {
  opacity: 1;
}
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }

	  #map .node-hit-area,
	  #map .group-indicator,
	  #map .lock-indicator,
	  #map .fov-group,
	  #map .edge-arrow-forward,
	  #map .edge-arrow-backward {
		display: none !important;
	  }

	  #map .node-circle,
	  #map .node-shape {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }

	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

  #map .rect-group rect {
    stroke: #333 !important;
  }
	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message"> Are you sure you want to delete this line? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                 <option value="defaulted">Default</option>
                 <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
              </div>
            </div>
			<div class="style-row">
			 <label>  
			  <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save Custom Theme</button>
			 </label>
			  <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding: 4px 8px; background: var(--danger); color: rgb(255, 255, 255); border: none; border-radius: 4px; cursor: pointer; font-size: 12px; display: block;" disabled="">Delete Custom Theme</button>
			</div>	
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
			<div class="style-row">
              <label>Tag(s) Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Tag(s) Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Tag(s) Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>			
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
			<label>Show Grid</label>
			<input type="checkbox" id="canvas-grid-enabled" checked="">
			</div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
			<div class="style-row">
			  <label>Show Grid</label>
			  <input type="checkbox" id="rack-grid-enabled" checked="">
			</div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90°)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Animations &amp; Zones</summary>
          <div class="style-content">
            <div class="style-row"><label>All Animations</label><label class="toggle-switch"><input type="checkbox" id="anim-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Type</div>
            <div class="style-row"><label>Sweep (Pan)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-sweep" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Pulse (Breathe)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-pulse" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Rings (Emanate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-rings" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Spin (Rotate)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-spin" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections (Flow)</label><label class="toggle-switch"><input type="checkbox" id="anim-type-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Connections</label><label class="toggle-switch"><input type="checkbox" id="anim-cat-connections" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:12px;color:var(--accent);text-transform:uppercase;letter-spacing:0.05em;font-weight:600;margin-top:16px;padding-top:12px;border-top:1px solid var(--edge-main);">Zone (Animation Cone) Setings</div>
            <div class="style-row"><label>All Zones</label><label class="toggle-switch"><input type="checkbox" id="zone-master" checked=""><span class="toggle-slider"></span></label></div>
            <div style="grid-column:1/-1;font-size:11px;color:var(--text-soft);text-transform:uppercase;border-bottom:1px solid var(--edge-main);padding-bottom:4px;margin-top:8px;">By Category</div>
            <div class="style-row"><label>Cameras</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-camera" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Doorbells</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-doorbell" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Motion Sensors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-motion" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Smoke Detectors</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-smoke" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>WiFi/AP/Router</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-wifi" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sensors/IoT</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sensor" checked=""><span class="toggle-slider"></span></label></div>
            <div class="style-row"><label>Sprinklers</label><label class="toggle-switch"><input type="checkbox" id="zone-cat-sprinkler" checked=""><span class="toggle-slider"></span></label></div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">16 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">🔒</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-json-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text">T</button>
          <span style="border-left: 1px solid var(--edge-main); height: 20px; margin: 0 4px;"></span>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-zone-copy" title="Copy zone style">📡 Copy Zone</button>
          <button id="bulk-zone-paste" title="Paste zone style">📡 Paste Zone</button>
          <button id="bulk-zone-toggle" title="Toggle zones on selected">📡 Toggle Zones</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <div style="margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--edge-main);">
            <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 12px; text-transform: uppercase; letter-spacing: 0.05em;">Coverage Zones</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px;">
              <button id="bulk-zone-copy-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Copy Zone</span></button>
              <button id="bulk-zone-paste-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Paste Zone</span></button>
              <button id="bulk-zone-toggle-mobile" class="bulk-action-btn">📡<br><span style="font-size: 12px;">Toggle Zones</span></button>
            </div>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint" style="cursor: pointer;">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-191.26917538063572 -261.51832729948296 4570.339735330435 3427.7548014978265" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-191.26917538063572" y="-261.51832729948296" width="4570.339735330435" height="3427.7548014978265"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">88%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Connection &amp; Zone Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Connection</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Core Router 1</div>
          <div class="details-ip editable-text" id="node-ip">10.0.0.1</div>
          <div class="details-role" id="node-role">Core Routing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">00:1A:2B:3C:4D:01</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">2U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"></div>
          </details>
		  
          <details id="fov-section" style="display: block; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Coverage Zone</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px; gap: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Preset:</label>
                <select id="fov-preset" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                  <option value="">-- Apply Preset --</option>
                  <option value="security-cam">Security Camera</option>
                  <option value="ptz-cam">PTZ Camera</option>
                  <option value="motion-detect">Motion Detector</option>
                  <option value="wifi-strong">WiFi</option>
                  <option value="wifi-extended">WiFi Extender</option>
                  <option value="smoke-alarm">Smoke Alarm</option>
                  <option value="sprinkler-arc">Sprinkler Arc</option>
                </select>
                <button id="fov-save-preset" title="Save as preset" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">💾</button>
                <button id="fov-copy-style" title="Copy zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📋</button>
                <button id="fov-paste-style" title="Paste zone style" style="padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); cursor: pointer;">📥</button>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Show Zone:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">360°</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">200</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Inner Radius:</label>
                <input type="range" id="fov-inner-radius" min="0" max="200" value="0" style="flex: 1;">
                <span id="fov-inner-radius-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0°</span>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Fill</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-opacity" min="5" max="80" value="20" style="flex: 1;">
                  <span id="fov-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">20%</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Gradient:</label>
                  <input type="checkbox" id="fov-gradient" style="width: 18px; height: 18px; cursor: pointer;">
                  <span style="color: var(--text-soft); font-size: 12px; margin-left: 8px;">Fade toward edge</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Border</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Color:</label>
                  <input type="color" id="fov-border-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Width:</label>
                  <input type="range" id="fov-border-width" min="0" max="10" value="2" style="flex: 1;">
                  <span id="fov-border-width-value" style="min-width: 40px; text-align: right; color: var(--text-main);">2</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Style:</label>
                  <select id="fov-border-style" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Opacity:</label>
                  <input type="range" id="fov-border-opacity" min="0" max="100" value="100" style="flex: 1;">
                  <span id="fov-border-opacity-value" style="min-width: 40px; text-align: right; color: var(--text-main);">100%</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Label</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Text:</label>
                  <input type="text" id="fov-label" placeholder="e.g. Detection Zone" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Position:</label>
                  <select id="fov-label-position" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="center">Center</option>
                    <option value="edge">Edge</option>
                    <option value="outside">Outside</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Size:</label>
                  <input type="range" id="fov-label-size" min="8" max="32" value="14" style="flex: 1;">
                  <span id="fov-label-size-value" style="min-width: 40px; text-align: right; color: var(--text-main);">14px</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Font Color:</label>
                  <input type="color" id="fov-label-color" value="#ffffff" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Bold:</label>
                  <input type="checkbox" id="fov-label-bold" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Background:</label>
                  <input type="checkbox" id="fov-label-bg" style="width: 18px; height: 18px; cursor: pointer;">
                  <input type="color" id="fov-label-bg-color" value="#000000" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; margin-left: 8px;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset X:</label>
                  <input type="range" id="fov-label-offset-x" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-x-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Offset Y:</label>
                  <input type="range" id="fov-label-offset-y" min="-200" max="200" value="0" style="flex: 1;">
                  <span id="fov-label-offset-y-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0</span>
                </div>
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div style="font-size: 12px; color: var(--text-soft); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Animation</div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Type:</label>
                  <select id="fov-animation-type" style="flex: 1; padding: 4px 8px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main);">
                    <option value="sweep">Sweep (Pan)</option>
                    <option value="pulse">Pulse (Breathe)</option>
                    <option value="rings">Rings (Emanate)</option>
                    <option value="spin">Spin (Rotate)</option>
                  </select>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120°</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 100px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" ...="" <details="" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">9</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/1</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">ISP Primary</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi0/0)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to view connection" style="color: var(--accent); font-family: monospace; cursor: pointer;">Gi1/0/24</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Core Router 2</span><span title="Click to view connection" style="color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;">(Gi1/0/24)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">External FW 1</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">NYC Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">LA Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Chicago Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">London Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Tokyo Branch Router</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">AWS Cloud</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">55</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90°)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         zoneLegend: ZONE_LEGEND,
         zonePresets: ZONE_PRESETS,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
			ZONE_LEGEND = saved.zoneLegend || {};
            ZONE_PRESETS = saved.zonePresets || {};
            loadCustomPresets();
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
canvasGridEnabled: true,
rackFrameFill: "#0f172a",
rackGridEnabled: true,
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  let ZONES_VISIBLE = true;
const ANIM_SETTINGS = {
  masterAnim: true,
  masterZones: true,
  animTypes: { sweep: true, pulse: true, rings: true, spin: true, connections: true },
  animCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true, connections: true },
  zoneCategories: { camera: true, doorbell: true, motion: true, smoke: true, wifi: true, sensor: true, sprinkler: true }
};
function getShapeCategory(shape) {
  const map = {
    "camera": "camera", "cctv": "camera", "ptz-cam": "camera",
    "doorbell": "doorbell",
    "motion-sensor": "motion", "motion-detect": "motion",
    "smoke-detector": "smoke", "smoke-alarm": "smoke",
    "access-point": "wifi", "wifi": "wifi", "router": "wifi", "wifi-strong": "wifi", "wifi-weak": "wifi",
    "sensor": "sensor", "iot": "sensor",
    "sprinkler": "sprinkler", "sprinkler-arc": "sprinkler"
  };
  return map[shape] || null;
}
function isAnimationAllowed(shape, animType) {
  if (!ANIM_SETTINGS.masterAnim) return false;
  if (!ANIM_SETTINGS.animTypes[animType]) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.animCategories[cat]) return false;
  return true;
}
function isZoneAllowed(shape) {
  if (!ANIM_SETTINGS.masterZones) return false;
  const cat = getShapeCategory(shape);
  if (cat && !ANIM_SETTINGS.zoneCategories[cat]) return false;
  return true;
}
function applyAnimZoneSettings() {
  document.querySelectorAll(".fov-group").forEach(g => {
    const nodeEl = g.closest("g[data-node-id]");
    if (!nodeEl) return;
    const nodeId = nodeEl.dataset.nodeId;
    const node = NODE_DATA[nodeId];
    if (!node) return;
    const cat = getShapeCategory(node.shape);
    const zoneVisible = ANIM_SETTINGS.masterZones && (!cat || ANIM_SETTINGS.zoneCategories[cat]);
    g.style.display = zoneVisible ? "" : "none";
    if (zoneVisible && node.fovAnimate) {
      const animType = node.fovAnimationType || "sweep";
      const animAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes[animType] && (!cat || ANIM_SETTINGS.animCategories[cat]);
      g.style.animationPlayState = animAllowed ? "running" : "paused";
      g.querySelectorAll("circle").forEach(c => c.style.animationPlayState = animAllowed ? "running" : "paused");
    }
  });
  const connAnimAllowed = ANIM_SETTINGS.masterAnim && ANIM_SETTINGS.animTypes.connections && ANIM_SETTINGS.animCategories.connections;
  document.querySelectorAll(".edge-arrow-forward, .edge-arrow-backward").forEach(a => {
    a.style.animationPlayState = connAnimAllowed ? "running" : "paused";
  });
}
let ZONE_LEGEND = {};
let ZONE_PRESETS = {};
let copiedZoneStyle = null;
	  function hasCoverageZone(shape) {
		  const supportedShapes = [
			"camera", "cctv", "doorbell",
			"motion-sensor", "smoke-detector",
			"access-point", "wifi", "router",
			"sensor", "iot", "sprinkler"
		  ];
		  return supportedShapes.includes(shape);
		}

		function getCoverageDefaults(shape) {
		  const defaults = {
			"camera": { angle: 90, distance: 150, animationType: "sweep" },
			"cctv": { angle: 90, distance: 150, animationType: "sweep" },
			"doorbell": { angle: 120, distance: 100, animationType: "sweep" },
			"motion-sensor": { angle: 120, distance: 100, animationType: "pulse" },
			"smoke-detector": { angle: 360, distance: 80, animationType: "pulse" },
			"access-point": { angle: 360, distance: 200, animationType: "rings" },
			"wifi": { angle: 360, distance: 200, animationType: "rings" },
			"router": { angle: 360, distance: 200, animationType: "rings" },
			"sensor": { angle: 90, distance: 100, animationType: "pulse" },
			"iot": { angle: 90, distance: 100, animationType: "pulse" },
			"sprinkler": { angle: 90, distance: 120, animationType: "spin" }
		  };
		  return defaults[shape] || { angle: 90, distance: 150, animationType: "sweep" };
		}
		function toggleAllZones() {
  ANIM_SETTINGS.masterZones = !ANIM_SETTINGS.masterZones;
  const masterCheckbox = document.getElementById("zone-master");
  if (masterCheckbox) masterCheckbox.checked = ANIM_SETTINGS.masterZones;
  applyAnimZoneSettings();
}

function copyZoneStyle(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  copiedZoneStyle = {
    fovEnabled: node.fovEnabled,
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovRotation: node.fovRotation,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovLabel: node.fovLabel,
    fovLabelPosition: node.fovLabelPosition,
    fovLabelSize: node.fovLabelSize,
    fovLabelColor: node.fovLabelColor,
    fovLabelBold: node.fovLabelBold,
    fovLabelBg: node.fovLabelBg,
    fovLabelBgColor: node.fovLabelBgColor,
    fovLabelOffsetX: node.fovLabelOffsetX,
    fovLabelOffsetY: node.fovLabelOffsetY,
    fovAnimate: node.fovAnimate,
    fovAnimationType: node.fovAnimationType,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
}

function pasteZoneStyle(nodeId) {
  if (!copiedZoneStyle) return;
  const node = NODE_DATA[nodeId];
  if (!node || !hasCoverageZone(node.shape)) return;
  pushUndo("paste zone style");
  Object.assign(node, copiedZoneStyle);
  updateFovCone(nodeId);
  if (currentNodeId === nodeId) {
    claimTheImmortal(nodeId);
  }
}

function applyZonePreset(preset) {
  if (!currentNodeId) return;
  const presets = {
    "security-cam": { fovAngle: 90, fovDistance: 150, fovColor: "#f59e0b", fovOpacity: 20, fovAnimationType: "sweep", fovAnimate: false },
    "ptz-cam": { fovAngle: 60, fovDistance: 200, fovColor: "#f59e0b", fovOpacity: 25, fovAnimationType: "sweep", fovAnimate: true, fovSweep: 180, fovSpeed: 8 },
    "motion-detect": { fovAngle: 120, fovDistance: 100, fovColor: "#10b981", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: true, fovSpeed: 3 },
    "wifi-strong": { fovAngle: 360, fovDistance: 150, fovColor: "#3b82f6", fovOpacity: 10, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 4 },
    "wifi-weak": { fovAngle: 360, fovDistance: 250, fovColor: "#3b82f6", fovOpacity: 8, fovGradient: true, fovAnimationType: "rings", fovAnimate: true, fovSpeed: 5 },
    "smoke-alarm": { fovAngle: 360, fovDistance: 80, fovColor: "#ef4444", fovOpacity: 15, fovAnimationType: "pulse", fovAnimate: false },
    "sprinkler-arc": { fovAngle: 90, fovDistance: 120, fovColor: "#06b6d4", fovOpacity: 20, fovAnimationType: "spin", fovAnimate: true, fovSpeed: 6 }
  };
  const allPresets = { ...presets, ...ZONE_PRESETS };
  const settings = allPresets[preset];
  if (!settings) return;
  
  pushUndo("apply zone preset");
  const node = NODE_DATA[currentNodeId];
  node.fovEnabled = true;
  Object.assign(node, settings);
  updateFovCone(currentNodeId);
  claimTheImmortal(currentNodeId);
}

function saveCustomZonePreset() {
  if (!currentNodeId) return;
  const node = NODE_DATA[currentNodeId];
  if (!node.fovEnabled) {
    alert("Enable the zone first before saving as preset");
    return;
  }
  const name = prompt("Enter preset name:");
  if (!name || !name.trim()) return;
  
  const presetId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
  ZONE_PRESETS[presetId] = {
    fovAngle: node.fovAngle,
    fovDistance: node.fovDistance,
    fovInnerRadius: node.fovInnerRadius,
    fovColor: node.fovColor,
    fovOpacity: node.fovOpacity,
    fovGradient: node.fovGradient,
    fovBorderColor: node.fovBorderColor,
    fovBorderWidth: node.fovBorderWidth,
    fovBorderStyle: node.fovBorderStyle,
    fovBorderOpacity: node.fovBorderOpacity,
    fovAnimationType: node.fovAnimationType,
    fovAnimate: node.fovAnimate,
    fovSweep: node.fovSweep,
    fovSpeed: node.fovSpeed
  };
  const select = document.getElementById("fov-preset");
  if (select && !select.querySelector(`option[value="${presetId}"]`)) {
    const opt = document.createElement("option");
    opt.value = presetId;
    opt.textContent = name.trim() + " (Custom)";
    select.appendChild(opt);
  }
  alert("Preset saved: " + name.trim());
}

function bulkCopyZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select at least one node first");
    return;
  }
  const firstId = [...selectedNodes][0];
  if (copyZoneStyle(firstId)) {
    alert("Zone style copied from first selected node");
  }
}

function bulkPasteZoneStyle() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  if (!copiedZoneStyle) {
    alert("Copy a zone style first");
    return;
  }
  pushUndo("bulk paste zone style");
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      Object.assign(node, copiedZoneStyle);
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Zone style pasted to ${count} node(s)`);
}

function bulkToggleZones() {
  if (selectedNodes.size === 0) {
    alert("Select nodes first");
    return;
  }
  pushUndo("bulk toggle zones");
  const firstNode = NODE_DATA[[...selectedNodes][0]];
  const newState = !(firstNode?.fovEnabled);
  let count = 0;
  selectedNodes.forEach(id => {
    const node = NODE_DATA[id];
    if (node && hasCoverageZone(node.shape)) {
      node.fovEnabled = newState;
      updateFovCone(id);
      count++;
    }
  });
  forgeTheTopology();
  alert(`Toggled zones on ${count} node(s) to ${newState ? 'ON' : 'OFF'}`);
}

function loadCustomPresets() {
  const select = document.getElementById("fov-preset");
  if (!select) return;
  Object.keys(ZONE_PRESETS).forEach(id => {
    if (!select.querySelector(`option[value="${id}"]`)) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id.replace(/-/g, " ") + " ★";
      select.appendChild(opt);
    }
  });
}

function updateZoneLegend() {
  const container = document.getElementById("edge-legend");
  if (!container) return;
  container.querySelectorAll(".zone-legend-item").forEach(el => el.remove());
  container.querySelectorAll(".zone-legend-title").forEach(el => el.remove());
  const zoneColors = new Set();
  Object.values(NODE_DATA).forEach(node => {
    if (hasCoverageZone(node.shape) && node.fovEnabled && node.fovColor) {
      zoneColors.add(node.fovColor);
    }
  });
  
  if (zoneColors.size === 0) return;
  const zoneTitle = document.createElement("div");
  zoneTitle.className = "legend-title zone-legend-title";
  zoneTitle.textContent = "Zone Legend";
  zoneTitle.style.marginTop = "12px";
  zoneTitle.style.paddingTop = "8px";
  zoneTitle.style.borderTop = "1px solid var(--edge-main)";
  container.appendChild(zoneTitle);
  zoneColors.forEach(color => {
    if (!ZONE_LEGEND[color]) {
      ZONE_LEGEND[color] = "Coverage Zone";
    }
    const item = document.createElement("div");
    item.className = "legend-item zone-legend-item";
    item.addEventListener("mousedown", (e) => e.stopPropagation());
    item.addEventListener("click", (e) => e.stopPropagation());
    
    const swatch = document.createElement("span");
    swatch.className = "legend-swatch";
    swatch.style.backgroundColor = color;
    swatch.style.opacity = "0.5";
    swatch.style.cursor = "pointer";
    swatch.addEventListener("click", (e) => {
      e.stopPropagation();
      const nodeWithColor = Object.entries(NODE_DATA).find(([id, n]) => 
        hasCoverageZone(n.shape) && n.fovEnabled && n.fovColor === color
      );
      if (nodeWithColor) {
        claimTheImmortal(nodeWithColor[0]);
      }
    });
    
    const label = document.createElement("span");
    label.className = "legend-label";
    label.textContent = ZONE_LEGEND[color];
    label.contentEditable = true;
    label.addEventListener("focus", () => label.classList.add("editing"));
    label.addEventListener("blur", () => {
      label.classList.remove("editing");
      ZONE_LEGEND[color] = label.textContent.trim() || "Coverage Zone";
    });
    label.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        label.blur();
      }
    });
    
    item.append(swatch, label);
    container.appendChild(item);
  });
  
  updateLegendVisibility();
}
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
			const fovSection = document.getElementById("fov-section");
			if (fovSection) {
			  if (hasCoverageZone(data.shape)) {
				const defaults = getCoverageDefaults(data.shape);
				fovSection.style.display = "block";
				document.getElementById("fov-enabled").checked = data.fovEnabled || false;
				document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
				document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
				document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
				document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
				document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
				document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
				document.getElementById("fov-rotation").value = data.fovRotation || 0;
				document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
				document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
				document.getElementById("fov-gradient").checked = data.fovGradient || false;
				document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
				document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
				document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
				document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
				document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
				document.getElementById("fov-label").value = data.fovLabel || "";
				document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
				document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
				document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
				document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
				document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
				document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
				document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
				document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
				document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
				document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
				document.getElementById("fov-animate").checked = data.fovAnimate || false;
				document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
				document.getElementById("fov-sweep").value = data.fovSweep || 120;
				document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
				document.getElementById("fov-speed").value = data.fovSpeed || 4;
				document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
				document.getElementById("fov-opacity").value = data.fovOpacity || 20;
				document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
			  } else {
				fovSection.style.display = "none";
			  }
			}
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
  minimapSvg.querySelectorAll(".minimap-node, .minimap-edge, .minimap-wall, .minimap-rect").forEach(el => el.remove());
  const frag = document.createDocumentFragment();
  const ns = "http://www.w3.org/2000/svg";
  const dotColor = PAGE_STATE.minimapDots || "#94a3b8";

  if (RECT_DATA && RECT_DATA.list && currentView.mode !== "rack") {
    RECT_DATA.list.forEach((rect) => {
      if (rect.lineStyle === "wall") {
        const wallRect = document.createElementNS(ns, "rect");
        wallRect.setAttribute("x", rect.x);
        wallRect.setAttribute("y", rect.y);
        wallRect.setAttribute("width", rect.width);
        wallRect.setAttribute("height", rect.height);
        wallRect.style.fill = rect.color || "#666";
        wallRect.style.fillOpacity = "0.6";
        wallRect.style.stroke = rect.borderColor || rect.color || "#666";
        wallRect.style.strokeWidth = "4";
        wallRect.classList.add("minimap-wall");
        frag.appendChild(wallRect);
      }
    });
  }

  EDGE_DATA.list.forEach((edge) => {
    if (edge.type === "custom") {
      if (Array.isArray(edge.points) && edge.points.length >= 2) {
        const polyline = document.createElementNS(ns, "polyline");
        polyline.setAttribute("points", edge.points.map(p => `${p.x},${p.y}`).join(" "));
        polyline.classList.add("minimap-edge");
        frag.appendChild(polyline);
      }
      return;
    }
    const fromNode = NODE_DATA[edge.from];
    const toNode = NODE_DATA[edge.to];
    if (!fromNode || !toNode) return;
    if (currentView.mode === "rack") {
      if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
    } else {
      if (fromNode.assignedRack || toNode.assignedRack) return;
    }
    const p1 = savedPositions[edge.from];
    const p2 = savedPositions[edge.to];
    if (!p1 || !p2) return;
    const routing = edge.routing || PAGE_STATE.defaultEdgeRouting || "curved";
    
    if (routing === "orthogonal") {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const polyline = document.createElementNS(ns, "polyline");
      let points;
      if (Math.abs(dx) > Math.abs(dy)) {
        const midX = p1.x + dx / 2;
        points = `${p1.x},${p1.y} ${midX},${p1.y} ${midX},${p2.y} ${p2.x},${p2.y}`;
      } else {
        const midY = p1.y + dy / 2;
        points = `${p1.x},${p1.y} ${p1.x},${midY} ${p2.x},${midY} ${p2.x},${p2.y}`;
      }
      polyline.setAttribute("points", points);
      polyline.classList.add("minimap-edge");
      frag.appendChild(polyline);
    } else {
      const line = document.createElementNS(ns, "line");
      line.setAttribute("x1", p1.x);
      line.setAttribute("y1", p1.y);
      line.setAttribute("x2", p2.x);
      line.setAttribute("y2", p2.y);
      line.classList.add("minimap-edge");
      frag.appendChild(line);
    }
  });

  Object.entries(savedPositions).forEach(([id, pos]) => {
    const node = NODE_DATA[id];
    if (!node) return;
    if (currentView.mode === "rack") {
      if (node.assignedRack !== currentView.rackId) return;
    } else {
      if (node.assignedRack) return;
    }
    const nodeSize = savedSizes[id] || 55;
    const s = nodeSize * 0.5;
    
    if (node.isRack) {
      const rect = document.createElementNS(ns, "rect");
      rect.setAttribute("x", pos.x - s);
      rect.setAttribute("y", pos.y - s);
      rect.setAttribute("width", s * 2);
      rect.setAttribute("height", s * 2);
      rect.style.fill = dotColor;
      rect.classList.add("minimap-node");
      frag.appendChild(rect);
    } else if (hasCoverageZone(node.shape)) {
      const diamond = document.createElementNS(ns, "polygon");
      const points = `${pos.x},${pos.y - s} ${pos.x + s},${pos.y} ${pos.x},${pos.y + s} ${pos.x - s},${pos.y}`;
      diamond.setAttribute("points", points);
      diamond.style.fill = "none";
      diamond.style.stroke = dotColor;
      diamond.style.strokeWidth = "6";
      diamond.classList.add("minimap-node");
      frag.appendChild(diamond);
    } else {
      const circle = document.createElementNS(ns, "circle");
      circle.setAttribute("cx", pos.x);
      circle.setAttribute("cy", pos.y);
      circle.setAttribute("r", s);
      circle.style.fill = dotColor;
      circle.classList.add("minimap-node");
      frag.appendChild(circle);
    }
  });

  minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }

       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72°";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size * 0.15);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 1);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.3);
        g.appendChild(body);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("r", size);
        g.appendChild(body);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
function updateFovCone(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return;
  
  const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
  if (!nodeGroup) return;
  const existingFov = nodeGroup.querySelector(".fov-group");
  if (existingFov) existingFov.remove();
  if (!hasCoverageZone(node.shape) || !node.fovEnabled) return;
  
  const ns = "http://www.w3.org/2000/svg";
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${nodeId}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${nodeId})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const fovLabelOffsetX = node.fovLabelOffsetX || 0;
    const fovLabelOffsetY = node.fovLabelOffsetY || 0;
    const labelX = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance) + fovLabelOffsetX;
    const labelY = (fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance) + fovLabelOffsetY;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${nodeId}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {

      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
}
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const flowArrowBig = document.createElementNS(ns, "path");
       flowArrowBig.id = "flow-arrow-big";
       flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
       defs.appendChild(flowArrowBig);
       const flowArrowSmall = document.createElementNS(ns, "path");
       flowArrowSmall.id = "flow-arrow-small";
       flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
       defs.appendChild(flowArrowSmall);
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
defs.appendChild(markerBackward);
const wallPattern = document.createElementNS(ns, "pattern");
wallPattern.id = "wall-hatch";
wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
wallPattern.setAttribute("width", "8");
wallPattern.setAttribute("height", "8");
wallPattern.setAttribute("patternTransform", "rotate(45)");
const wallLine = document.createElementNS(ns, "line");
wallLine.setAttribute("x1", "0");
wallLine.setAttribute("y1", "0");
wallLine.setAttribute("x2", "0");
wallLine.setAttribute("y2", "8");
wallLine.setAttribute("stroke", "#666");
wallLine.setAttribute("stroke-width", "2");
wallPattern.appendChild(wallLine);
defs.appendChild(wallPattern);

svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
const gridGroup = document.createElementNS(ns, "g");
 gridGroup.id = "canvas-grid";
 const gridSize = PAGE_STATE.canvasGridSize || 50;
 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", x);
  line.setAttribute("y1", CANVAS_PADDING);
  line.setAttribute("x2", x);
  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", CANVAS_PADDING);
  line.setAttribute("y1", y);
  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
  line.setAttribute("y2", y);
  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 svg.appendChild(gridGroup);
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
 const y = RACK_START_Y + u * rackUHeight;
 if (PAGE_STATE.rackGridEnabled !== false) {
 const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
 }
 if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
if (lineStyle === "dashed") {
 poly.style.strokeDasharray = "10,5";
} else if (lineStyle === "dotted") {
 poly.style.strokeDasharray = "2,4";
} else if (lineStyle === "wall") {
 poly.style.stroke = "url(#wall-hatch)";
 poly.style.strokeWidth = (edge.width || 4) * 3;
 poly.style.strokeDasharray = "none";
} else {
 poly.style.strokeDasharray = "none";
}
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
         if (shouldAnimate) {
          poly.style.opacity = "0.25";
          const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (direction === "forward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (direction === "backward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        let pathD;
        if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const edgeDirection = edge.direction || "none";
        const edgeLineStyle = edge.lineStyle || "solid";
        if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
        else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
        if (edgeDirection === "forward") {
         path.setAttribute("marker-end", "url(#arrow-forward)");
        } else if (edgeDirection === "backward") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
        } else if (edgeDirection === "both") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
         path.setAttribute("marker-end", "url(#arrow-forward)");
        }
        const animDir = PAGE_STATE.animationDirection || "all";
        const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
        if (shouldAnimate) {
         path.style.opacity = "0.25";
         const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
         const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
         const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
         const arrowCount = 3;
         const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
         if (edgeDirection === "forward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
           arrow.classList.add("edge-arrow-forward");
           svg.appendChild(arrow);
          }
         }
         if (edgeDirection === "backward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
           arrow.classList.add("edge-arrow-backward");
           svg.appendChild(arrow);
          }
         }
        }
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        const nodeRotation = NODE_DATA[id].rotation || 0;
        g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
if (hasCoverageZone(node.shape) && node.fovEnabled) {
  const defaults = getCoverageDefaults(node.shape);
  const fovAngle = node.fovAngle || defaults.angle;
  const fovDistance = node.fovDistance || defaults.distance;
  const fovInnerRadius = node.fovInnerRadius || 0;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovOpacity = node.fovOpacity || 20;
  const fovGradient = node.fovGradient || false;
  const fovBorderColor = node.fovBorderColor || "#f59e0b";
  const fovBorderWidth = node.fovBorderWidth ?? 2;
  const fovBorderStyle = node.fovBorderStyle || "solid";
  const fovBorderOpacity = node.fovBorderOpacity ?? 100;
  const fovLabel = node.fovLabel || "";
  const fovAnimate = node.fovAnimate || false;
  const fovAnimationType = node.fovAnimationType || defaults.animationType;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  if (fovGradient) {
    const gradientId = `fov-gradient-${id}`;
    const defs = document.createElementNS(ns, "defs");
    const gradient = document.createElementNS(ns, "radialGradient");
    gradient.id = gradientId;
    gradient.setAttribute("cx", "0");
    gradient.setAttribute("cy", "0");
    gradient.setAttribute("r", fovDistance);
    gradient.setAttribute("gradientUnits", "userSpaceOnUse");
    const stop1 = document.createElementNS(ns, "stop");
    stop1.setAttribute("offset", fovInnerRadius / fovDistance);
    stop1.setAttribute("stop-color", fovColor);
    stop1.setAttribute("stop-opacity", fovOpacity / 100);
    const stop2 = document.createElementNS(ns, "stop");
    stop2.setAttribute("offset", "1");
    stop2.setAttribute("stop-color", fovColor);
    stop2.setAttribute("stop-opacity", "0");
    gradient.appendChild(stop1);
    gradient.appendChild(stop2);
    defs.appendChild(gradient);
    fovGroup.appendChild(defs);
  }
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    if (fovInnerRadius > 0) {
      fovPath.setAttribute("d", `M ${fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${-fovDistance},0 A ${fovDistance},${fovDistance} 0 1,1 ${fovDistance},0 M ${fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${-fovInnerRadius},0 A ${fovInnerRadius},${fovInnerRadius} 0 1,0 ${fovInnerRadius},0`);
      fovPath.setAttribute("fill-rule", "evenodd");
    } else {
      fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
    }
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    if (fovInnerRadius > 0) {
      const ix1 = Math.cos(startAngle) * fovInnerRadius;
      const iy1 = Math.sin(startAngle) * fovInnerRadius;
      const ix2 = Math.cos(endAngle) * fovInnerRadius;
      const iy2 = Math.sin(endAngle) * fovInnerRadius;
      fovPath.setAttribute("d", `M ${ix1},${iy1} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} L ${ix2},${iy2} A ${fovInnerRadius},${fovInnerRadius} 0 ${largeArc},0 ${ix1},${iy1} Z`);
    } else {
      fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
    }
  }
  
  if (fovGradient) {
    fovPath.style.fill = `url(#fov-gradient-${id})`;
  } else {
    const opacityHex = Math.round((fovOpacity / 100) * 255).toString(16).padStart(2, '0');
    fovPath.style.fill = fovColor + opacityHex;
  }
  
  const borderOpacityHex = Math.round((fovBorderOpacity / 100) * 255).toString(16).padStart(2, '0');
  fovPath.style.stroke = fovBorderColor + borderOpacityHex;
  fovPath.style.strokeWidth = fovBorderWidth;
  if (fovBorderStyle === "dashed") {
    fovPath.style.strokeDasharray = "10,5";
  } else if (fovBorderStyle === "dotted") {
    fovPath.style.strokeDasharray = "3,3";
  }
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovLabel) {
    const fovLabelPosition = node.fovLabelPosition || "center";
    const fovLabelSize = node.fovLabelSize || 14;
    const fovLabelColor = node.fovLabelColor || "#ffffff";
    const fovLabelBold = node.fovLabelBold || false;
    const fovLabelBg = node.fovLabelBg || false;
    const fovLabelBgColor = node.fovLabelBgColor || "#000000";
    
    let labelDistance;
    if (fovLabelPosition === "center") {
      labelDistance = fovAngle >= 360 ? 0 : fovDistance * 0.4;
    } else if (fovLabelPosition === "edge") {
      labelDistance = fovDistance * 0.75;
    } else {
      labelDistance = fovDistance + fovLabelSize + 8;
    }
    
    const labelAngle = ((fovRotation - 90) * Math.PI) / 180;
    const labelX = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.cos(labelAngle) * labelDistance;
    const labelY = fovAngle >= 360 && fovLabelPosition === "center" ? 0 : Math.sin(labelAngle) * labelDistance;
    
    if (fovLabelBg) {
      const bgRect = document.createElementNS(ns, "rect");
      const textWidth = fovLabel.length * fovLabelSize * 0.6;
      const textHeight = fovLabelSize * 1.4;
      bgRect.setAttribute("x", labelX - textWidth / 2 - 6);
      bgRect.setAttribute("y", labelY - textHeight / 2);
      bgRect.setAttribute("width", textWidth + 12);
      bgRect.setAttribute("height", textHeight);
      bgRect.setAttribute("rx", "4");
      bgRect.style.fill = fovLabelBgColor;
      bgRect.style.opacity = "0.8";
      bgRect.style.pointerEvents = "none";
      fovGroup.appendChild(bgRect);
    }
    
    const labelEl = document.createElementNS(ns, "text");
    labelEl.setAttribute("x", labelX);
    labelEl.setAttribute("y", labelY);
    labelEl.setAttribute("text-anchor", "middle");
    labelEl.setAttribute("dominant-baseline", "middle");
    labelEl.style.fill = fovLabelColor;
    labelEl.style.fontSize = fovLabelSize + "px";
    labelEl.style.fontWeight = fovLabelBold ? "bold" : "normal";
    labelEl.style.fontFamily = "system-ui, sans-serif";
    labelEl.style.pointerEvents = "none";
    labelEl.textContent = fovLabel;
    fovGroup.appendChild(labelEl);
  }
  
  if (fovAnimate) {
    const animationName = `fov-anim-${id}`;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    
    if (fovAnimationType === "sweep" && fovAngle < 360) {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: rotate(0deg); }
          50% { transform: rotate(${fovSweep}deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "pulse") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.1); opacity: 0.7; }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
      fovGroup.style.transformOrigin = "0 0";
    } else if (fovAnimationType === "rings") {
      for (let i = 1; i <= 3; i++) {
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", "0");
        ring.setAttribute("cy", "0");
        ring.setAttribute("r", fovDistance * 0.3 * i);
        ring.style.fill = "none";
        ring.style.stroke = fovBorderColor;
        ring.style.strokeWidth = "2";
        ring.style.opacity = "0";
        const ringAnimName = `${animationName}-ring-${i}`;
        const ringStyle = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        ringStyle.textContent = `
          @keyframes ${ringAnimName} {
            0% { r: ${fovInnerRadius || 10}; opacity: 0.8; }
            100% { r: ${fovDistance}; opacity: 0; }
          }
        `;
        ring.style.animation = `${ringAnimName} ${fovSpeed}s ease-out infinite`;
        ring.style.animationDelay = `${(i - 1) * (fovSpeed / 3)}s`;
        fovGroup.appendChild(ringStyle);
        fovGroup.appendChild(ring);
      }
    } else if (fovAnimationType === "spin") {
      styleEl.textContent = `
        @keyframes ${animationName} {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      fovGroup.style.animation = `${animationName} ${fovSpeed}s linear infinite`;
      fovGroup.style.transformOrigin = "0 0";
    }
    
    if (fovAnimationType !== "rings") {
      fovGroup.appendChild(styleEl);
      const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
      const animationOffset = elapsedSeconds % fovSpeed;
      fovGroup.style.animationDelay = `-${animationOffset}s`;
    }
  }
  
  g.appendChild(fovGroup);
}
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         });
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner, idx) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
                 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateZoneLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         });
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (hasCoverageZone(data.shape)) {
    const defaults = getCoverageDefaults(data.shape);
    fovSection.style.display = "block";
    document.getElementById("fov-enabled").checked = data.fovEnabled || false;
    document.getElementById("fov-angle").value = data.fovAngle || defaults.angle;
    document.getElementById("fov-angle-value").textContent = (data.fovAngle || defaults.angle) + "°";
    document.getElementById("fov-distance").value = data.fovDistance || defaults.distance;
    document.getElementById("fov-distance-value").textContent = data.fovDistance || defaults.distance;
    document.getElementById("fov-inner-radius").value = data.fovInnerRadius || 0;
    document.getElementById("fov-inner-radius-value").textContent = data.fovInnerRadius || 0;
    document.getElementById("fov-rotation").value = data.fovRotation || 0;
    document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
    document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
    document.getElementById("fov-opacity").value = data.fovOpacity || 20;
    document.getElementById("fov-opacity-value").textContent = (data.fovOpacity || 20) + "%";
    document.getElementById("fov-gradient").checked = data.fovGradient || false;
    document.getElementById("fov-border-color").value = data.fovBorderColor || "#f59e0b";
    document.getElementById("fov-border-width").value = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-width-value").textContent = data.fovBorderWidth ?? 2;
    document.getElementById("fov-border-style").value = data.fovBorderStyle || "solid";
    document.getElementById("fov-border-opacity").value = data.fovBorderOpacity ?? 100;
    document.getElementById("fov-border-opacity-value").textContent = (data.fovBorderOpacity ?? 100) + "%";
    document.getElementById("fov-label").value = data.fovLabel || "";
    document.getElementById("fov-label-position").value = data.fovLabelPosition || "center";
    document.getElementById("fov-label-size").value = data.fovLabelSize || 14;
    document.getElementById("fov-label-size-value").textContent = (data.fovLabelSize || 14) + "px";
    document.getElementById("fov-label-color").value = data.fovLabelColor || "#ffffff";
    document.getElementById("fov-label-bold").checked = data.fovLabelBold || false;
    document.getElementById("fov-label-bg").checked = data.fovLabelBg || false;
    document.getElementById("fov-label-bg-color").value = data.fovLabelBgColor || "#000000";
    document.getElementById("fov-label-offset-x").value = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-x-value").textContent = data.fovLabelOffsetX || 0;
    document.getElementById("fov-label-offset-y").value = data.fovLabelOffsetY || 0;
    document.getElementById("fov-label-offset-y-value").textContent = data.fovLabelOffsetY || 0;
    document.getElementById("fov-animate").checked = data.fovAnimate || false;
    document.getElementById("fov-animation-type").value = data.fovAnimationType || defaults.animationType;
    document.getElementById("fov-sweep").value = data.fovSweep || 120;
    document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
    document.getElementById("fov-speed").value = data.fovSpeed || 4;
    document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
  } else {
    fovSection.style.display = "none";
  }
}
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage zone");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-angle").oninput = function() {
  document.getElementById("fov-angle-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-distance").oninput = function() {
  document.getElementById("fov-distance-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-inner-radius").oninput = function() {
  document.getElementById("fov-inner-radius-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovInnerRadius = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-rotation").oninput = function() {
  document.getElementById("fov-rotation-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage color");
  NODE_DATA[currentNodeId].fovColor = this.value;
  updateFovCone(currentNodeId);
  updateZoneLegend();
};
document.getElementById("fov-opacity").oninput = function() {
  document.getElementById("fov-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-gradient").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage gradient");
  NODE_DATA[currentNodeId].fovGradient = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border color");
  NODE_DATA[currentNodeId].fovBorderColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-width").oninput = function() {
  document.getElementById("fov-border-width-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderWidth = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-style").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change coverage border style");
  NODE_DATA[currentNodeId].fovBorderStyle = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-border-opacity").oninput = function() {
  document.getElementById("fov-border-opacity-value").textContent = this.value + "%";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovBorderOpacity = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabel = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-position").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelPosition = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-size").oninput = function() {
  document.getElementById("fov-label-size-value").textContent = this.value + "px";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelSize = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bold").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBold = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg").onchange = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBg = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-bg-color").oninput = function() {
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelBgColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-x").oninput = function() {
  document.getElementById("fov-label-offset-x-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetX = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-label-offset-y").oninput = function() {
  document.getElementById("fov-label-offset-y-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovLabelOffsetY = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-preset").addEventListener("change", function() {
  if (this.value) {
    applyZonePreset(this.value);
    this.value = "";
  }
});
document.getElementById("fov-save-preset").addEventListener("click", saveCustomZonePreset);
document.getElementById("fov-copy-style").addEventListener("click", function() {
  if (currentNodeId && copyZoneStyle(currentNodeId)) {
    alert("Zone style copied!");
  }
});
document.getElementById("fov-paste-style").addEventListener("click", function() {
  if (currentNodeId && pasteZoneStyle(currentNodeId)) {
    claimTheImmortal(currentNodeId);
  }
});
document.getElementById("bulk-zone-copy").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle").addEventListener("click", bulkToggleZones);
document.getElementById("bulk-zone-copy-mobile").addEventListener("click", bulkCopyZoneStyle);
document.getElementById("bulk-zone-paste-mobile").addEventListener("click", bulkPasteZoneStyle);
document.getElementById("bulk-zone-toggle-mobile").addEventListener("click", bulkToggleZones);
document.getElementById("fov-animate").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle coverage animation");
  NODE_DATA[currentNodeId].fovAnimate = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-animation-type").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("change animation type");
  NODE_DATA[currentNodeId].fovAnimationType = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-sweep").oninput = function() {
  document.getElementById("fov-sweep-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-speed").oninput = function() {
  document.getElementById("fov-speed-value").textContent = this.value + "s";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
  updateFovCone(currentNodeId);
};
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const currentRotation = NODE_DATA[id].rotation || 0;
       document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
       document.getElementById("rotation-value").value = currentRotation;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         });
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          });
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       document.getElementById("edge-animate").checked = edge.animate === true;
       document.getElementById("edge-animation-style").value = edge.animationStyle || "";
       document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       hint.style.cursor = "pointer";
       let hintDismissed = false;
       const dismissHint = () => { hintDismissed = true; hint.classList.remove("visible"); };
       hint.addEventListener("click", dismissHint);
       hint.addEventListener("touchend", (e) => { e.preventDefault(); dismissHint(); });
       setTimeout(() => {
        if (hintDismissed) return;
        hint.classList.add("visible");
        setTimeout(() => { if (!hintDismissed) hint.classList.remove("visible"); }, 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        });
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        });
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        });
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        });
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        });
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
       updateMinimap();
      });
      const rotationSlider = document.getElementById("rotation-slider");
      const rotationInput = document.getElementById("rotation-value");
      const resetRotationBtn = document.getElementById("reset-rotation");
      rotationSlider.addEventListener("input", () => {
        const newRotation = parseInt(rotationSlider.value, 10);
        rotationInput.value = newRotation;
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      rotationInput.addEventListener("input", () => {
        const newRotation = parseInt(rotationInput.value, 10) || 0;
        rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      resetRotationBtn.addEventListener("click", () => {
        pushUndo("reset rotation");
        NODE_DATA[currentNodeId].rotation = 0;
        rotationSlider.value = 0;
        rotationInput.value = 0;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
        }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (hasCoverageZone(shape)) {
    const defaults = getCoverageDefaults(shape);
    fovSection.style.display = "block";
    document.getElementById("fov-angle").value = defaults.angle;
    document.getElementById("fov-angle-value").textContent = defaults.angle + "°";
    document.getElementById("fov-distance").value = defaults.distance;
    document.getElementById("fov-distance-value").textContent = defaults.distance;
    document.getElementById("fov-animation-type").value = defaults.animationType;
  } else {
    fovSection.style.display = "none";
  }
}
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animate").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animate");
       edge.animate = e.target.checked;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animation speed");
       edge.animationSpeed = e.target.value || "";
       if (PAGE_STATE.animateConnections && edge.animate !== false) forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
	  document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId);
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        });
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else if (lineStyle === "wall") {
  freeDrawPolylineEl.style.stroke = "url(#wall-hatch)";
  freeDrawPolylineEl.style.strokeWidth = "12";
  freeDrawPolylineEl.style.strokeDasharray = "none"; 
  } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler);
           document.removeEventListener("touchend", touchUpHandler);
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         });
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawToggleBtn.classList.add("done-btn-active");
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       drawToggleBtn.classList.remove("done-btn-active");
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       });
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.classList.add("done-btn-active");
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.classList.remove("done-btn-active");
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
       document.getElementById("text-rotation-val").value = textItem.rotation || 0;
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-rotation").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          textItem.rotation = parseInt(e.target.value) || 0;
          document.getElementById("text-rotation-val").value = textItem.rotation;
          forgeTheTopology();
        }
      });
      document.getElementById("text-rotation-val").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          const val = parseInt(e.target.value) || 0;
          textItem.rotation = val;
          document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
          forgeTheTopology();
        }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("add-line-color").value = PAGE_STATE.defaultEdge || "#475569";
       document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
	   document.getElementById("anim-master").addEventListener("change", e => { ANIM_SETTINGS.masterAnim = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-sweep").addEventListener("change", e => { ANIM_SETTINGS.animTypes.sweep = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-pulse").addEventListener("change", e => { ANIM_SETTINGS.animTypes.pulse = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-rings").addEventListener("change", e => { ANIM_SETTINGS.animTypes.rings = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-spin").addEventListener("change", e => { ANIM_SETTINGS.animTypes.spin = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-type-connections").addEventListener("change", e => { ANIM_SETTINGS.animTypes.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.animCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.animCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.animCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.animCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.animCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.animCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("anim-cat-connections").addEventListener("change", e => { ANIM_SETTINGS.animCategories.connections = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-master").addEventListener("change", e => { ANIM_SETTINGS.masterZones = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-camera").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.camera = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-doorbell").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.doorbell = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-motion").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.motion = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-smoke").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.smoke = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-wifi").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.wifi = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sensor").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sensor = e.target.checked; applyAnimZoneSettings(); });
document.getElementById("zone-cat-sprinkler").addEventListener("change", e => { ANIM_SETTINGS.zoneCategories.sprinkler = e.target.checked; applyAnimZoneSettings(); });

      document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
      document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
      document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;

      document.getElementById("animation-style-select").addEventListener("change", (e) => {
       PAGE_STATE.animationStyle = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-direction-select").addEventListener("change", (e) => {
       PAGE_STATE.animationDirection = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-speed-select").addEventListener("change", (e) => {
       PAGE_STATE.animationSpeed = parseFloat(e.target.value);
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
	   document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
	   document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       rebuildThemeDropdown();
       updateDeleteButton();
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       document.getElementById("add-line-color").value = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
	  document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.canvasGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.rackGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
		pushUndo('import json');
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
		savedStyleSets: savedStyleSets,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
		NODE_DATA[newId] = {
		 shape: source.shape,
		 name: newName,
		 ip: source.ip,
		 role: source.role,
		 tags: [...source.tags],
		 notes: [...source.notes],
		 mac: source.mac || "",
		 rackUnit: source.rackUnit || "",
		 uHeight: source.uHeight || "1",
		 layer: source.layer || "physical",
		 assignedRack: source.assignedRack || "",
		 rackCapacity: source.rackCapacity || "42",
		 isRack: source.isRack || false,
fovEnabled: source.fovEnabled || false,
 fovAngle: source.fovAngle || 90,
 fovDistance: source.fovDistance || 150,
 fovInnerRadius: source.fovInnerRadius || 0,
 fovRotation: source.fovRotation || 0,
 fovColor: source.fovColor || "#f59e0b",
 fovOpacity: source.fovOpacity || 20,
 fovGradient: source.fovGradient || false,
 fovBorderColor: source.fovBorderColor || "#f59e0b",
 fovBorderWidth: source.fovBorderWidth ?? 2,
 fovBorderStyle: source.fovBorderStyle || "solid",
 fovBorderOpacity: source.fovBorderOpacity ?? 100,
 fovLabel: source.fovLabel || "",
 fovLabelPosition: source.fovLabelPosition || "center",
 fovLabelSize: source.fovLabelSize || 14,
 fovLabelColor: source.fovLabelColor || "#ffffff",
 fovLabelBold: source.fovLabelBold || false,
 fovLabelBg: source.fovLabelBg || false,
 fovLabelBgColor: source.fovLabelBgColor || "#000000",
 fovLabelOffsetX: source.fovLabelOffsetX || 0,
 fovLabelOffsetY: source.fovLabelOffsetY || 0,
 fovAnimate: source.fovAnimate || false,
 fovAnimationType: source.fovAnimationType || "sweep",
 fovSweep: source.fovSweep || 120,
 fovSpeed: source.fovSpeed || 4
		};
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
		btn.style.display = "block";
		btn.disabled = !select.value.startsWith("mytheme-");
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       });
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `• ${nodes.length} nodes in CSV data\n` +
        `• ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `• ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState || config.page);
		  if (config.canvasView || config.canvas) {
			canvasState.zoom = (config.canvasView || config.canvas).zoom || 1;
			canvasState.panX = (config.canvasView || config.canvas).panX || 0;
			canvasState.panY = (config.canvasView || config.canvas).panY || 0;
		  }
		  if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		alert(`Successfully imported ${nodes.length} nodes`);
	  } catch (err) {
		console.error('CSV import error:', err);
		alert('Failed to import CSV: ' + err.message);
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
		document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
		  const file = e.target.files[0];
		  if (!file) return;
		  e.target.value = '';
		  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
     } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});
    </script>
  
</body></html>