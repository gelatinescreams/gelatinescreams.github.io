<!DOCTYPE html> 
 <html lang="en" style="--panel: #2f0e0e; --panel-alt: #10141b; --sidebar-bg: #10141b; --btn-bg: #0b0e13; --accent: #a75252; --danger: #f56565; --text-main: #e2e8f0; --text-soft: #94a3b8; --topbar-bg: rgba(9, 12, 20, 0.9); --topbar-border: #1f2533; --topbar-height: 112px; --sidebar-width: 350px; --mobile-footer-height: 40vh; --draw-toolbar-height: 0px; --btn-text: #e2e8f0; --tag-fill: #1e293b; --tag-text: #e2e8f0; --tag-border: #475569; --input-bg: #0b0e13; --input-text: #e2e8f0; --input-border: #1f2937; --input-font: Inter, system-ui, sans-serif; --input-font-size: 14px; --toolbar-bg: #441215; --toolbar-border: #1f2937; --toolbar-text: #94a3b8; --toolbar-btn-bg: #0b0e13; --toolbar-btn-text: #e2e8f0; --minimap-dots: #94a3b8; --canvas-hint-bg: #0f172a; --canvas-hint-color: #94a3b8; --node-fill: #1e293b; --node-stroke: #475569; --node-title: #e2e8f0; --node-sub: #94a3b8; --node-title-size: 18px; --node-sub-size: 13px; --node-font: Inter, system-ui, sans-serif; --default-edge: #475569; --selection-handle: #f59e0b; --selection-handle-size: 8px; --group-indicator: #4fd1c5;"><head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>The One File</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--
      * ====================================================================================
      * THE ONE FILE
      * "There can be only one". A all in one file topology maker for enterprise or homelab
      *
      * This is your last backup when all others fail. A completely self contained
      * network topology visualization tool that works as a single HTML file.
      * Open it anywhere, anytime and the idea lives forever.
      * ====================================================================================
      -->
<style>
      :root {
      color-scheme: dark;
      --bg: #050608;
      --panel: #0b0e13;
      --panel-alt: #10141b;
      --accent: #4fd1c5;
      --danger: #f56565;
      --text-main: #e2e8f0;
      --text-soft: #94a3b8;
      --edge-main: #475569;
      --node-min: 35px;
      --node-max: 70px;
      --topbar-bg: rgba(9, 12, 20, 0.9);
      --topbar-border: #1f2533;
      }
	  html, body, svg, .map-container {
      touch-action: none;
      }
      * {
      box-sizing: border-box;
      user-select: none;
      }
      input,
      textarea,
      [contenteditable="true"] {
      user-select: text;
      -webkit-user-select: text;
      }
      body {
      margin: 0;
      font-family: system-ui, sans-serif;
      background: radial-gradient(circle at top, #1e2532 0, #050608 70%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      }
      header {
      padding: 0 20px;
      height: var(--topbar-height, 52px);
      min-height: var(--topbar-height, 52px);
      background: var(--topbar-bg);
      backdrop-filter: blur(6px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--topbar-border);
      gap: 16px;
      }
      .title-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      }
      header h1 {
      font-size: clamp(22px, 3vw, 32px);
      margin: 0;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      }
      .editable-page-title {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-page-title:hover {
      opacity: 0.7;
      }
      .save-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      }
      .save-btn {
      padding: 6px 12px;
      background: var(--accent);
      color: var(--bg);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      white-space: nowrap;
      }
      .save-btn:hover {
      opacity: 0.9;
      }
      .help-icon {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 1px solid var(--edge-main);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
      color: var(--text-soft);
      background: rgba(15, 23, 42, 0.9);
      flex-shrink: 0;
      }
      .help-icon:hover {
      color: var(--accent);
      border-color: var(--accent);
      }
      #settings-btn {
      background: var(--btn-bg, var(--panel));
      color: var(--btn-text, var(--text-main));
      border: 1px solid var(--edge-main);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
      flex-shrink: 0;
      }
      #settings-btn:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .header-resizer {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .header-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .header-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .sidebar-resizer {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 6px;
      background: transparent;
      cursor: col-resize;
      z-index: 1000;
      transition: background 0.2s;
      }
      .sidebar-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .sidebar-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      .mobile-footer-resizer {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: transparent;
      cursor: row-resize;
      z-index: 1000;
      transition: background 0.2s;
      display: none;
      }
      .mobile-footer-resizer:hover {
      background: rgba(79, 209, 197, 0.3);
      }
      .mobile-footer-resizer.resizing {
      background: rgba(79, 209, 197, 0.5);
      }
      @media (max-width: 900px) {
      .mobile-footer-resizer {
      display: block;
      height: 12px;
      }
      .sidebar-resizer {
      display: none;
      }
      .header-resizer {
      height: 12px;
      }
      }
      @media (pointer: coarse) {
      .header-resizer {
      height: 16px;
      }
      .mobile-footer-resizer {
      height: 16px;
      }
      .sidebar-resizer {
      width: 16px;
      }
      }
      .resizer-icon {
      position: absolute;
      opacity: 0.5;
      transition: opacity 0.2s, transform 0.2s;
      pointer-events: none;
      fill: var(--accent);
      }
      .header-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .sidebar-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .mobile-footer-resizer .resizer-icon {
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      }
      .header-resizer:hover .resizer-icon,
      .sidebar-resizer:hover .resizer-icon,
      .mobile-footer-resizer:hover .resizer-icon {
      opacity: 1;
      }
      .header-resizer.resizing .resizer-icon,
      .sidebar-resizer.resizing .resizer-icon,
      .mobile-footer-resizer.resizing .resizer-icon {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1.2);
      }
      body.resizing {
      user-select: none;
      }
      body.resizing * {
      cursor: inherit !important;
      pointer-events: none;
      }
      header {
      position: relative;
      }
      .details-panel {
      position: relative;
      }
      main {
      display: grid;
      grid-template-columns: 1fr var(--sidebar-width, 350px);
      flex: 1;
      }
      main.sidebar-collapsed {
      grid-template-columns: 1fr 0;
      }
      @media (max-width: 900px) {
      main {
      grid-template-columns: 1fr;
      grid-template-rows: calc(100vh - var(--topbar-height, 52px) - var(--mobile-footer-height, 40vh)) var(--mobile-footer-height, 40vh);
      }
      main.sidebar-collapsed {
      grid-template-rows: 1fr 0;
      }
      .details-panel {
      max-height: var(--mobile-footer-height, 40vh);
      height: 100%;
      }
      }
      .topology-panel {
      background: var(--panel);
      border-right: 1px solid #111827;
      position: relative;
      overflow: hidden;
      }
      .topology-toolbar {
      position: absolute;
      top: 10px;
      right: 10px;
      display: none;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      color: var(--toolbar-text, #94a3b8);
      }
      .topology-toolbar label {
      color: var(--toolbar-text, var(--text-soft));
      }
      .topology-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .topology-toolbar button {
      padding: 4px 10px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      }
      .topology-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .bulk-toolbar-desktop,
      .bulk-toolbar-mobile {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      }
      .bulk-toolbar-desktop {
      position: absolute;
      top: 10px;
      right: 10px;
      bottom: auto;
      left: auto;
      transform: none;
      }
      @media (min-width: 768px) {
      .bulk-toolbar-mobile {
      display: none !important;
      }
      }
      .bulk-action-btn {
      padding: 16px;
      background: var(--panel-main);
      border: 1px solid var(--edge-main);
      border-radius: 8px;
      color: var(--text-main);
      font-size: 24px;
      cursor: pointer;
      text-align: center;
      line-height: 1.2;
      }
      .bulk-action-btn:active {
      transform: scale(0.95);
      background: var(--accent);
      }
      .draw-toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      z-index: 99;
      font-size: 13px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .draw-toolbar button {
      padding: 4px 8px;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 13px;
      }
      .draw-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .draw-toolbar input[type="color"] {
      width: 30px;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--edge-main);
      padding: 0;
      background: transparent;
      cursor: pointer;
      }
      .draw-toolbar select {
      padding: 4px 6px;
      background: var(--toolbar-btn-bg, var(--panel));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 13px;
      cursor: pointer;
      }
      .legend-container {
      position: absolute;
      left: 10px;
      bottom: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 10px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      font-size: 12px;
      z-index: 20;
      max-width: 260px;
      pointer-events: auto;
      color: var(--toolbar-text, #94a3b8);
      }
      .legend-container {
      padding-right: 22px;
      }
      @media (max-width: 900px) {
      .legend-container {
      height:250px;
      overflow-y: auto;
      z-index:99;
      }
      }
      @media (max-width: 900px) {
      .bulk-toolbar-desktop,
      .topology-toolbar {
      display: none !important;
      }
      }
      .legend-close-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 18px;
      height: 18px;
      border-radius: 999px;
      border: 1px solid var(--edge-main);
      background: var(--panel-alt);
      color: var(--text-soft);
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      }
      .legend-close-btn:hover {
      background: var(--danger);
      color: #fff;
      }
      .legend-mini-btn {
      position: absolute;
      left: 10px;
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--toolbar-border, #1f2937);
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      color: var(--toolbar-btn-text, var(--text-main));
      font-size: 11px;
      cursor: pointer;
      z-index: 20;
      display: none;
      transition: all 0.2s;
      }
      .legend-mini-btn:hover,
      .legend-mini-btn:active {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
      }
      .legend-title {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--toolbar-text, var(--text-soft));
      margin-bottom: 2px;
      }
      .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      }
      .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #020617;
      flex-shrink: 0;
      }
      .legend-label {
      outline: none;
      cursor: text;
      flex: 1;
      min-width: 60px;
      user-select: text;
      -webkit-user-select: text;
      }
      .legend-label.editing {
      border-bottom: 1px dashed var(--accent);
      }
      .canvas-viewport {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      overflow: hidden;
      }
      .canvas-viewport.panning {
      cursor: grabbing !important;
      }
      .canvas-viewport.panning * {
      cursor: grabbing !important;
      }
      .canvas-viewport svg {
      width: 100%;
      height: 100%;
      display: block; 
      }
      .zoom-toolbar {
      display: flex;
      gap: 4px;
      padding: 6px;
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      }
      .zoom-toolbar button {
      width: 32px;
      height: 32px;
      padding: 0;
      background: var(--toolbar-btn-bg, var(--panel));
      color: var(--toolbar-btn-text, var(--text-main));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      cursor: pointer;
      font-size: 18px;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      }
      .zoom-toolbar button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .zoom-toolbar .zoom-level {
      font-size: 11px;
      color: var(--toolbar-text, var(--text-soft));
      text-align: center;
      padding: 2px 0;
      min-width: 32px;
      }
      .zoom-toolbar .divider {
      height: 1px;
      background: var(--toolbar-border, var(--edge-main));
      margin: 2px 0;
      }
      .minimap-zoom-wrapper {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 99;
      }
      .minimap-container {
      background: var(--toolbar-bg, rgba(15, 23, 42, 0.92));
      border: 1px solid var(--toolbar-border, #1f2937);
      border-radius: 6px;
      overflow: hidden;
      margin-bottom: 4px;
      }
      .minimap-container svg {
      width: 100%;
      height: 100%;
      }
	.minimap-container,
	.node-panel,
	.edge-panel,
	#canvas-viewport {
	  contain: layout paint;
	}	  
	.low-zoom .node-group .node-circle,
	.low-zoom .node-group.active .node-circle,
	.low-zoom .node-group.selected .node-circle {
	  filter: none !important;
	  animation: none !important;
	}	
      .minimap-viewport {
      fill: rgba(79, 209, 197, 0.2);
      stroke: var(--accent);
      stroke-width: 2;
      cursor: move;
      }
      .minimap-node {
      fill: var(--minimap-dots, var(--text-soft));
      }
      .minimap-edge {
      stroke: var(--edge-main);
      stroke-width: 1;
      }
      .minimap-close-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 3px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 11px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      padding: 0;
      line-height: 1;
      }
      .minimap-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .toolbar-close-btn {
      width: 24px;
      height: 24px;
      background: var(--toolbar-btn-bg, rgba(15, 23, 42, 0.9));
      border: 1px solid var(--toolbar-border, var(--edge-main));
      border-radius: 4px;
      color: var(--toolbar-text, var(--text-soft));
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      line-height: 1;
      flex-shrink: 0;
      }
      .toolbar-close-btn:hover {
      background: var(--danger);
      color: white;
      border-color: var(--danger);
      }
      .canvas-hint {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 16px;
      background: rgba(15, 23, 42, 0.92);
      border: 1px solid #1f2937;
      border-radius: 6px;
      font-size: 12px;
      color: var(--text-soft);
      z-index: 18;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      }
      .canvas-hint.visible {
      opacity: 1;
      }
      .edge {
      stroke: var(--edge-main);
      stroke-width: 4;
      opacity: 0.75;
      transition: 0.25s ease-in-out;
      cursor: pointer;
      }
      .edge.backup {
      stroke: var(--danger);
      stroke-width: 5;
      }
      .edge.active {
      opacity: 1;
      stroke-width: 7;
      filter: drop-shadow(0 0 8px var(--accent, #4fd1c5));
      }
      .rect-group.active .rect-shape {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .text-element.active {
      filter: drop-shadow(0 0 10px var(--accent, #4fd1c5));
      animation: pulse 1.2s infinite ease-in-out;
      }
      .free-preview {
      fill: none;
      stroke-dasharray: 4 4;
      pointer-events: none;
      }
@keyframes edge-flow-arrow {
  0% { offset-distance: 0%; }
  100% { offset-distance: 100%; }
}
@keyframes edge-flow-arrow-reverse {
  0% { offset-distance: 100%; }
  100% { offset-distance: 0%; }
}
.edge-arrow-forward {
  offset-rotate: auto;
  animation: edge-flow-arrow 1.5s linear infinite;
}
.edge-arrow-backward {
  offset-rotate: auto 180deg;
  animation: edge-flow-arrow-reverse 1.5s linear infinite;
}
      .free-point {
      fill: #e5e7eb;
      stroke: #0f172a;
      stroke-width: 1.5;
      cursor: grab;
      }
      .node-circle {
      fill: var(--node-fill, #1e293b);
      stroke: var(--node-stroke, #475569);
      stroke-width: 2;
      transition: 0.25s ease;
      transform-origin: center center;
      }
      .node-hit-area {
      cursor: grab;
      pointer-events: all;
      }
      .node-group:hover .node-circle {
      filter: drop-shadow(0 0 10px rgba(79, 209, 197, 0.45));
      }
      .node-group.active .node-circle {
      stroke: var(--accent);
      animation: pulse 1.2s infinite ease-in-out;
      }
      .node-group.selected .node-circle {
      stroke: var(--selection-handle, #f59e0b);
      stroke-width: 3;
      }
      .node-group.search-highlight .node-circle {
      stroke: #10b981;
      stroke-width: 3;
      filter: drop-shadow(0 0 8px #10b981);
      }
	  .node-group.search-faded {
		opacity: 0.15;
		pointer-events: none;
		}
		.edge-group.search-faded {
		opacity: 0.1;
		}
	  .node-group.search-faded {
      opacity: 0.15;
      pointer-events: none;
      }
      .edge-group.search-faded {
      opacity: 0.1;
      }
      @keyframes pulse {
      0% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      50% {
      filter: drop-shadow(0 0 14px #4fd1c5);
      }
      100% {
      filter: drop-shadow(0 0 4px #4fd1c5);
      }
      }
      @keyframes done-pulse {
        0%, 100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(79, 209, 197, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 8px rgba(79, 209, 197, 0);
        }
      }
      .done-btn-active {
        animation: done-pulse 1.5s ease-in-out infinite;
        background: var(--accent) !important;
        color: var(--bg) !important;
      }
      .node-label {
      fill: var(--text-main);
      font-size: 18px;
      text-anchor: middle;
      font-weight: 600;
      }
      .node-sub {
      fill: var(--text-soft);
      font-size: 13px;
      text-anchor: middle;
      }
      @media (max-width: 1024px) {
      .node-label {
      font-size: 28px;
      }
      .node-sub {
      font-size: 20px;
      }
      }
      @media (max-width: 768px) {
      .node-label {
      font-size: 70px;
      }
      .node-sub {
      font-size: 50px;
      }
      }
      @media (max-width: 380px) {
      .node-label {
      font-size: 60px;
      }
      .node-sub {
      font-size: 42px;
      }
      }
      .details-panel {
      background: var(--sidebar-bg, var(--panel-alt));
      padding: 22px;
      padding-bottom: 80px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 15px;
      position: relative;
      transition:
      width 0.3s ease,
      min-width 0.3s ease,
      padding 0.3s ease,
      opacity 0.3s ease;
      }
      .details-panel {
      min-width: 260px !important;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      width: 0 !important;
      min-width: 0 !important;
      padding: 0 !important;
      overflow: hidden;
      opacity: 0;
      }
      body {
      overflow-x: hidden;
      overflow-y: hidden;
      }
      main {
      overflow-x: hidden;
      overflow-y: visible;
      }
      .details-panel {
      overflow-y: auto !important;
      overflow-x: hidden;
      }
      .details-panel.collapsed {
      min-width: 0 !important;
      }
      .sidebar-toggle {
      position: absolute;
      left: -16px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 60px;
      background: var(--sidebar-bg, var(--panel-alt));
      border: 1px solid var(--edge-main);
      border-right: none;
      border-radius: 8px 0 0 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-soft);
      font-size: 10px;
      z-index: 25;
      transition:
      background 0.2s,
      color 0.2s;
      }
      .sidebar-toggle:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .sidebar-toggle.collapsed {
      left: 0;
      border-right: 1px solid var(--edge-main);
      border-radius: 0 8px 8px 0;
      position: fixed;
      right: 0;
      left: auto;
      }
      .details-name {
      font-size: clamp(22px, 2.5vw, 30px);
      font-weight: 700;
      }
      .details-ip {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--text-soft);
      }
      .details-role {
      font-size: clamp(16px, 2vw, 22px);
      color: var(--accent);
      }
      .details-info-row {
      display: flex;
      align-items: center;
      margin: 6px 0;
      }
      .size-controls {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
      }
      .size-controls label {
      font-size: clamp(14px, 1.6vw, 18px);
      color: var(--text-soft);
      }
      .size-controls input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
      }
      .size-controls button {
      padding: 6px 12px;
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .size-controls button:hover {
      background: var(--accent);
      color: var(--bg);
      }
      .style-section {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid var(--edge-main);
      }
      .style-section summary {
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
      }
      .style-section summary::-webkit-details-marker {
      display: none;
      }
      .password-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 9999;
      }
      .style-section summary::after {
      content: "▼";
      transition: transform 0.2s;
      }
      .style-section[open] summary::after {
      transform: rotate(180deg);
      }
.style-content {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px 12px;
  align-items: center;
  justify-items: end;
}
.style-content label {
  justify-self: start;
}
.style-row {
  display: contents;
}
#edge-panel .style-row,
#rect-panel .style-row,
#text-panel .style-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
#edge-panel .style-row label,
#rect-panel .style-row label,
#text-panel .style-row label {
  min-width: 80px;
}
      .style-row label {
      font-size: clamp(13px, 1.5vw, 17px);
      color: var(--text-soft);
      min-width: 80px;
      }
      .style-row input[type="color"] {
      width: 50px;
      height: 30px;
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      cursor: pointer;
      background: transparent;
      }
      .style-row input[type="number"] {
      width: 70px;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      }
      .style-row select {
      flex: 1;
      padding: 4px 8px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(12px, 1.4vw, 16px);
      cursor: pointer;
      }
      .editable-text {
      cursor: pointer;
      transition: opacity 0.2s;
      }
      .editable-text:hover {
      opacity: 0.7;
      }
      .modal {
	  display: none;
	  position: fixed;
	  top: 0;
	  left: 0;
	  width: 100%;
	  height: 100%;
	  z-index: 999999;
	  justify-content: center;
	  align-items: center;
	  overflow: auto;
	  }
	  .modal.active {
	  display: inline-grid;
	  }
	  .modal-content {
	  background: var(--panel-alt);
	  padding: 25px;
	  border-radius: 8px;
	  border: 1px solid var(--edge-main);
	  min-width: 300px;
	  max-width: 90%;
	  }
      .modal-content h3 {
      margin: 0 0 15px 0;
      color: var(--text-main);
      font-size: clamp(18px, 2vw, 24px);
      }
      .modal-content p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .modal-content input:not([type="color"]),
      .modal-content select {
      width: 100%;
      padding: 10px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 4px;
      color: var(--text-main);
      font-size: clamp(14px, 1.6vw, 18px);
      margin-bottom: 15px;
      user-select: text;
      -webkit-user-select: text;
      }
      .modal-content input[type="color"] {
      width: 60px;
      height: 36px;
      padding: 2px;
      border: 2px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      background: none;
      -webkit-appearance: none;
      appearance: none;
      }
      .modal-content input[type="color"]::-webkit-color-swatch-wrapper {
      padding: 0;
      }
      .modal-content input[type="color"]::-webkit-color-swatch {
      border: none;
      border-radius: 4px;
      }
      .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      margin-top: 10px;
      }
      .modal-buttons button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: clamp(14px, 1.6vw, 18px);
      font-weight: 600;
      }
      .modal-buttons .btn-cancel {
      background: var(--panel);
      color: var(--text-main);
      border: 1px solid var(--edge-main);
      }
      .modal-buttons .btn-save {
      background: var(--accent);
      color: var(--bg);
      }
      .modal-buttons .btn-delete {
      background: var(--danger);
      color: white;
      }
      .confirm-modal p {
      color: var(--text-soft);
      font-size: clamp(14px, 1.6vw, 18px);
      margin: 0 0 20px 0;
      }
      .context-menu-item {
      transition: background 0.15s;
      }
      .context-menu-item:hover {
      background: var(--panel);
      }
      .badge-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      }
      .badge {
      background: var(--tag-fill, #1e293b);
      color: var(--tag-text, #e2e8f0);
      border: 1px solid var(--tag-border, var(--edge-main));
      padding: 5px 12px;
      border-radius: 22px;
      font-size: clamp(12px, 1.4vw, 18px);
      }
      .badge.wg {
      color: var(--accent);
      border-color: var(--accent);
      }
      input[type="text"],
      input[type="number"],
      input[type="password"],
      textarea,
      select {
      background: var(--input-bg, #0b0e13) !important;
      color: var(--input-text, #e2e8f0) !important;
      border-color: var(--input-border, #1f2937) !important;
      font-family: var(--input-font, Inter, system-ui, sans-serif) !important;
      font-size: var(--input-font-size, 14px) !important;
      }
      .section-label {
      margin-top: 8px;
      font-size: clamp(14px, 1.6vw, 20px);
      text-transform: uppercase;
      color: var(--text-soft);
      }
      .list li {
      margin: 6px 0;
      font-size: clamp(14px, 1.6vw, 20px);
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      }
      .list li:hover {
      color: var(--accent);
      }
      .delete-note {
      color: var(--danger);
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s;
      flex-shrink: 0;
      }
      .list li:hover .delete-note {
      opacity: 1;
      }
      .editing {
      outline: 2px solid var(--accent);
      background: #0d141f;
      padding: 4px;
      border-radius: 6px;
      user-select: text;
      -webkit-user-select: text;
      }
      .version-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .version-item:hover {
      background: var(--panel-alt);
      border-color: var(--accent);
      }
      .version-item.current {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .version-info {
      flex: 1;
      }
      .version-info .timestamp {
      font-size: 13px;
      color: var(--text-main);
      font-weight: 600;
      }
      .version-info .details {
      font-size: 11px;
      color: var(--text-soft);
      margin-top: 4px;
      }
      .version-actions {
      display: flex;
      gap: 6px;
      }
      .audit-entry {
      padding: 8px 12px;
      background: var(--panel);
      border-left: 3px solid var(--edge-main);
      border-radius: 4px;
      font-size: 12px;
      }
      .audit-entry.node { border-left-color: #4fd1c5; }
      .audit-entry.connection { border-left-color: #9f7aea; }
      .audit-entry.style { border-left-color: #ed8936; }
      .audit-entry.rack { border-left-color: #48bb78; }
      .audit-entry.layer { border-left-color: #4299e1; }
      .audit-entry .time {
      color: var(--text-soft);
      font-size: 10px;
      }
      .audit-entry .action {
      color: var(--text-main);
      font-weight: 500;
      }
      .tab-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      }
      .tab-item:hover {
      background: var(--panel-alt);
      }
      .tab-item.active {
      border-color: var(--accent);
      background: rgba(79, 209, 197, 0.1);
      }
      .tab-item .tab-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .tab-item .tab-stats {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .tab-actions {
      display: flex;
      gap: 6px;
      }
      .secret-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      border-radius: 6px;
      border-left: 3px solid var(--danger);
      }
      .secret-item .secret-name {
      font-weight: 600;
      color: var(--text-main);
      flex: 1;
      }
      .secret-item .secret-status {
      font-size: 11px;
      color: var(--text-soft);
      margin-right: 10px;
      }
      .mobile-menu-btn {
      display: none;
      background: var(--panel);
      border: 1px solid var(--edge-main);
      color: var(--text-main);
      font-size: 22px;
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      }
      #topbar-menu {
      gap: 8px;
      }
      @media (min-width: 721px) {
      #topbar-menu {
      display: flex !important;
      }
      }
      @media (max-width: 720px) {
      #topbar-menu {
      display: none;
      }
      #topbar-menu.open {
      display: flex;
      }
      }
      @media (max-width: 720px) {
      .mobile-menu-btn {
      display: block;
      }
      #topbar-menu {
      position: absolute;
      top: var(--topbar-height);
      right: 0;
      background: var(--panel-alt);
      border-left: 1px solid var(--topbar-border);
      border-bottom: 1px solid var(--topbar-border);
      padding: 12px;
      display: none;
      flex-direction: column;
      width: 180px;
      z-index: 999;
      }
      #topbar-menu.open {
      display: flex;
      }
      header {
      position: relative;
      z-index: 9999;
      }
      }
      @media (max-width: 720px) {
      .draw-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      left: 10px !important;
      right: auto !important;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .topology-toolbar {
      position: absolute;
      top: auto;
      bottom: auto;
      width: auto;
      gap: 6px;
      padding: 8px;
      }
      .draw-toolbar {
      top: 10px !important;
      z-index:99;
      }
      .topology-toolbar {
      z-index:99;
      top: calc(10px + var(--draw-toolbar-height, 50px)) !important;
      }
      .canvas-hint {
      top: calc(10px + 120px);
      }
      #search-input {
      width: 100%;
      }
      }
	  body.view-only-mode:not(.view-only-inspect) #node-panel,
      body.view-only-mode:not(.view-only-inspect) #edge-panel,
      body.view-only-mode:not(.view-only-inspect) #text-panel,
      body.view-only-mode:not(.view-only-inspect) #rect-panel {
        display: none !important;
      }
      body.view-only-mode .node-group,
      body.view-only-mode .edge,
      body.view-only-mode .rect-group,
      body.view-only-mode .text-element {
        cursor: default !important;
      }
      body.view-only-mode #bulk-toolbar,
      body.view-only-mode #bulk-toolbar-mobile,
      body.view-only-mode #bulk-actions-modal {
        display: none !important;
      }
      body.view-only-mode::after {
        content: "VIEW ONLY • tap 5× to inspect";
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(245, 101, 101, 0.9);
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 1px;
        z-index: 9999;
        pointer-events: none;
      }
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-btn {
  padding: 6px 12px;
  background: var(--btn-bg, var(--panel));
  color: var(--btn-text, var(--text-main));
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
}
.dropdown-btn:hover {
  background: var(--accent);
  color: var(--bg);
}
.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  min-width: 180px;
  background: var(--panel);
  border: 1px solid var(--edge-main);
  border-radius: 6px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.4);
  z-index: 100000;
  margin-top: 4px;
  overflow: hidden;
}
header {
  z-index: 99999;
  position: relative;
}
.dropdown-menu.open {
  display: block;
}
.dropdown-menu button {
  display: block;
  width: 100%;
  padding: 10px 14px;
  background: none;
  border: none;
  color: var(--text-main);
  text-align: left;
  cursor: pointer;
  font-size: 14px;
}
.dropdown-menu button:hover {
  background: var(--panel-alt);
  color: var(--accent);
}
.dropdown-divider {
  height: 1px;
  background: var(--edge-main);
  margin: 4px 0;
}
@media (max-width: 900px) {
  .save-row .dropdown {
    display: none !important;
  }
}
	@media print {
	  @page {
		size: landscape;
		margin: 0.5cm;
	  }
	  html, body {
		width: 100%;
		height: 100%;
		margin: 0;
		padding: 0;
		overflow: visible !important;
	  }
	  body * {
		visibility: hidden;
	  }
	  #canvas-viewport,
	  #canvas-viewport *,
	  #map,
	  #map * {
		visibility: visible;
	  }
	  #canvas-viewport {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		right: 0 !important;
		bottom: 0 !important;
		width: 100vw !important;
		height: 100vh !important;
		overflow: visible !important;
	  }
	  #map {
		position: absolute !important;
		left: 0 !important;
		top: 0 !important;
		width: 100% !important;
		height: 100% !important;
		background: white !important;
		background-image: none !important;
	  }
	  #canvas-grid {
		display: none !important;
	  }
	  main, .topology-panel {
		display: block !important;
		position: static !important;
		overflow: visible !important;
	  }
	  #map circle[class*="node"],
	  #map .node-shape,
	  #map .node-group circle,
	  #map .node-group rect,
	  #map .node-group path,
	  #map .node-group polygon {
		fill: white !important;
		stroke: #000 !important;
		stroke-width: 2px !important;
	  }
	  #map text {
		fill: #000 !important;
		stroke: none !important;
	  }

	  #map .edge,
	  #map polyline,
	  #map line:not([class*="grid"]) {
		stroke: #333 !important;
	  }

  #map .rect-group rect {
    stroke: #333 !important;
  }
	  header, .sidebar, .mobile-footer, .minimap-zoom-wrapper,
	  .draw-toolbar, .topology-toolbar, .legend-container,
	  .bulk-toolbar, #bulk-toolbar-mobile, .dropdown-menu,
	  #canvas-hint, .node-panel, .edge-panel, .text-panel, .rect-panel {
		display: none !important;
	  }
	}
	#mobile-export-btn,
#mobile-import-btn {
  display: none;
}
@media (max-width: 900px) {
  #mobile-export-btn,
  #mobile-import-btn {
    display: inline-block;
  }
}
    </style>
  </head>
  <body style="background: radial-gradient(circle at center top, rgb(30, 37, 50) 0px, rgb(5, 6, 8) 70%);" class="">
    <div class="modal" id="edit-modal">
      <div class="modal-content">
        <h3 id="modal-title">Edit Title</h3>
        <input type="text" id="modal-input">
        <div class="modal-buttons">
          <button class="btn-cancel" id="modal-cancel">Cancel</button>
          <button class="btn-save" id="modal-save">Save</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="confirm-modal">
      <div class="modal-content">
        <h3>Confirm</h3>
        <p id="confirm-message">Are you sure you want to delete this line?</p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="confirm-cancel">Cancel</button>
          <button class="btn-delete" id="confirm-delete">Delete</button>
        </div>
      </div>
    </div>
    <div class="modal" id="save-info-modal">
      <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
        <h3 style="margin-bottom: 16px;">Help</h3>
        <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
          <button class="help-tab active" data-tab="general" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--accent); color: var(--bg); border-radius: 6px; cursor: pointer; font-weight: 600;">General</button>
          <button class="help-tab" data-tab="desktop" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Desktop</button>
          <button class="help-tab" data-tab="mobile" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Mobile</button>
		  <button class="help-tab" data-tab="formats" style="padding: 8px 16px; border: 1px solid var(--edge-main); background: var(--panel); color: var(--text-main); border-radius: 6px; cursor: pointer; font-weight: 600;">Import/Export</button>
        </div>
        <div id="help-tab-general" class="help-tab-content" style="display: block;">
          <ul style="margin-left: 20px; margin-bottom: 12px; line-height: 1.8;">
            <li><strong>Add Nodes:</strong> Click "+ Node" or "+ Rack" in the top menu</li>
            <li><strong>Connect Nodes:</strong> Select a node, then use "Add Connection" in the panel</li>
            <li><strong>Move Nodes:</strong> Drag nodes to reposition them</li>
            <li><strong>Enter Rack View:</strong> Double click on desktop or Long press on mobile</li>
            <li><strong>Multi Select:</strong> Right click (desktop) or double tap (mobile)</li>
            <li><strong>Pan Canvas:</strong> Drag empty space or hold Space + drag</li>
            <li><strong>Zoom:</strong> Scroll wheel or pinch gesture</li>
            <li><strong>Free Draw:</strong> Use draw toolbar for drawing lines, boxes/zones , and text</li>
          </ul>
          <h4 style="color: var(--accent); margin-bottom: 8px;">Saving &amp; Encryption</h4>
          <p style="margin-bottom: 8px;">Browsers cannot overwrite local files. Click <strong>Save File</strong> to download an updated HTML with all changes. Replace your old file to keep edits.</p>
          <p style="margin-bottom: 8px;"><strong>Encryption of data:</strong> Check "Encrypt" before saving to password protect your data. Beware! No recovery possible without password!!</p>
          <p><strong>Decryption of data:</strong> Export via JSON in top settings menu after successful password validation to decrypt your data. You can then reimport back into the same file and save!</p>
        </div>
        <div id="help-tab-desktop" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Navigation</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Arrow Keys</code></td>
              <td style="padding: 8px;">Move selected 1px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Shift + Arrows</code></td>
              <td style="padding: 8px;">Move selected 10px</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Tab / Shift+Tab</code></td>
              <td style="padding: 8px;">Cycle through nodes</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">F</code></td>
              <td style="padding: 8px;">Focus on selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Space + Drag</code></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Management</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">L</code></td>
              <td style="padding: 8px;">Lock/unlock selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">G</code></td>
              <td style="padding: 8px;">Group/ungroup selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+C / Ctrl+V</code></td>
              <td style="padding: 8px;">Copy / Paste</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+D</code></td>
              <td style="padding: 8px;">Duplicate</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+A</code></td>
              <td style="padding: 8px;">Select all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Delete</code></td>
              <td style="padding: 8px;">Delete selected</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Escape</code></td>
              <td style="padding: 8px;">Clear selection</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Ctrl+Z / Ctrl+Y</code></td>
              <td style="padding: 8px;">Undo / Redo</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><code style="background: var(--panel-alt); padding: 2px 6px; border-radius: 4px;">Right Click</code></td>
              <td style="padding: 8px;">Multi select toggle</td>
            </tr>
          </tbody></table>
        </div>
        <div id="help-tab-mobile" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Basic Gestures</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap node</strong></td>
              <td style="padding: 8px;">Select &amp; open properties</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Tap empty</strong></td>
              <td style="padding: 8px;">Deselect all</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag node</strong></td>
              <td style="padding: 8px;">Move node</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Drag empty</strong></td>
              <td style="padding: 8px;">Pan canvas</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Pinch</strong></td>
              <td style="padding: 8px;">Zoom in/out</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap node</strong></td>
              <td style="padding: 8px;">Add/remove from selection</td>
            </tr>
          </tbody></table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Rack View</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody><tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Long press rack</strong></td>
              <td style="padding: 8px;">Enter rack view</td>
            </tr>
            <tr style="border-bottom: 1px solid var(--edge-main);">
              <td style="padding: 8px;"><strong>Double tap empty</strong></td>
              <td style="padding: 8px;">Exit rack view</td>
            </tr>
          </tbody></table>
        </div>
		<div id="help-tab-formats" class="help-tab-content" style="display: none;">
          <h4 style="color: var(--accent); margin-bottom: 12px;">Export Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>HTML</strong></td>
                <td style="padding: 8px;">Complete self contained file and the default save method. When in doubt, choose this. Use the Save HTML button for this</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Full backup. Editable in your favorite text editor</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Full backup in header, nodes in spreadsheet rows</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>PNG</strong></td>
                <td style="padding: 8px;">Standard image of current canvas tab</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>SVG</strong></td>
                <td style="padding: 8px;">Vector image, scalable and editable image of current canvas tab</td>
              </tr>
            </tbody>
          </table>
          <h4 style="color: var(--accent); margin-bottom: 12px;">Import Help</h4>
          <table style="width: 100%; border-collapse: collapse; margin-bottom: 16px; font-size: 14px;">
            <tbody>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>JSON</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>Markdown</strong></td>
                <td style="padding: 8px;">Replaces all data</td>
              </tr>
              <tr style="border-bottom: 1px solid var(--edge-main);">
                <td style="padding: 8px;"><strong>CSV</strong></td>
                <td style="padding: 8px;">Choose full restore or add nodes only. Allows quickly creating nodes with a spreadsheet and importing into an existing save.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <div class="modal-buttons" style="margin-top: 16px;">
          <button class="btn-cancel" id="save-info-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="settings-modal">
      <div class="modal-content">
        <h2>Settings</h2>
		<details class="style-section">
          <summary>View Only Mode</summary>
          <div class="style-content">
            <div class="style-row">
              <label>View Only (disable editing)</label>
              <input type="checkbox" id="view-only-mode" style="width:auto;">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">When enabled, all editing of the canvas is disabled. Pan and zoom still work.</p>
          </div>
        </details>
        <details class="style-section">
          <summary>General Theme</summary>
          <div class="style-content">
		    <div class="style-row">
              <label>Theme Preset</label>
              <div style="display:flex;gap:6px;flex:1;">
                <select id="theme-preset" style="flex:1;padding:4px 8px;background:var(--input-bg);color:var(--input-text);border:1px solid var(--input-border);border-radius:4px;">
                 <option value="defaulted">Default</option>
                 <option value="">Custom</option>
                  <optgroup label="Corporate">
                    <option value="slate">Slate</option>
                    <option value="graphite">Graphite</option>
                    <option value="frost">Frost (Light)</option>
                  </optgroup>
                  <optgroup label="Homelab">
                    <option value="synthwave">Synthwave</option>
                    <option value="terminal">Terminal</option>
                  </optgroup>
                  <optgroup label="Dev">
                    <option value="dracula">Dracula</option>
                    <option value="cobalt">Cobalt</option>
                    <option value="solarized">Solarized</option>
                  </optgroup>
                  <optgroup id="my-themes-group" label="My Themes"></optgroup>
                </select>
                <button onclick="saveCurrentTheme()" style="padding:4px 8px;background:var(--accent);color:var(--bg);border:none;border-radius:4px;cursor:pointer;font-size:12px;white-space:nowrap;">Save</button>
                <button id="delete-theme-btn" onclick="deleteCurrentTheme()" style="padding:4px 8px;background:var(--danger);color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:12px;display:none;">Del</button>
              </div>
            </div>
            <div class="style-row">
              <label>Main Background</label>
              <input type="color" id="panel-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Sidebar / Mobile Footer</label>
              <input type="color" id="sidebar-bg-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Modal Window (popup) Background</label>
              <input type="color" id="panel-alt-color" value="#10141b">
            </div>
            <div class="style-row">
              <label>Accent Buttons</label>
              <input type="color" id="accent-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Danger Buttons</label>
              <input type="color" id="danger-color" value="#f56565">
            </div>
            <div class="style-row">
              <label>Primary Text</label>
              <input type="color" id="text-main-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Secondary Text</label>
              <input type="color" id="text-soft-color" value="#94a3b8">
            </div>
          </div>
        </details>
		<details class="style-section">
          <summary>Top Bar</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="topbar-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="topbar-border-color" value="#1f2533">
            </div>
          </div>
		  <div class="style-content">
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="btn-text-color" value="#e2e8f0">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Main Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="canvas-border-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="canvas-grid-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Grid Size</label>
              <input type="number" id="canvas-grid-size" value="50" min="20" max="200" style="width:60px;">
            </div>
			<div class="style-row">
  <label>Show Grid</label>
  <input type="checkbox" id="canvas-grid-enabled" checked="">
</div>
			<div class="style-row">
              <label>Background Top</label>
              <input type="color" id="canvas-gradient-top" value="#1e2532">
            </div>
            <div class="style-row">
              <label>Background Bottom</label>
              <input type="color" id="canvas-gradient-bottom" value="#050608">
            </div>
            <div class="style-row">
              <label>Solid Background</label>
              <input type="color" id="page-bg-color" value="#050608">
            </div>
            <p style="margin-top:4px;font-size:12px;color:var(--text-soft);">Set solid background to override gradient.</p>
          </div>
			</details>
		  <details class="style-section">
          <summary>Rack Canvas</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Frame Fill</label>
              <input type="color" id="rack-frame-fill" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Frame Border</label>
              <input type="color" id="rack-frame-stroke" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Grid Lines</label>
              <input type="color" id="rack-line-color" value="#475569">
            </div>
			<div class="style-row">
  <label>Show Grid</label>
  <input type="checkbox" id="rack-grid-enabled" checked="">
</div>
            <div class="style-row">
              <label>U Labels</label>
              <input type="color" id="rack-text-color" value="#4fd1c5">
            </div>
          </div>
        </details>
		        <details class="style-section">
          <summary>Canvas Toolbars</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="toolbar-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="toolbar-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="toolbar-text-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Button Fill</label>
              <input type="color" id="toolbar-btn-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Button Text</label>
              <input type="color" id="toolbar-btn-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Minimap Dots</label>
              <input type="color" id="minimap-dots-color" value="#94a3b8">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Nodes</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="node-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="node-stroke-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Title Color</label>
              <input type="color" id="node-title-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Title Size</label>
              <input type="number" id="node-title-size" value="18" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Subtitle Color</label>
              <input type="color" id="node-sub-color" value="#94a3b8">
            </div>
            <div class="style-row">
              <label>Subtitle Size</label>
              <input type="number" id="node-sub-size" value="13" min="8" max="48" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="node-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Connections</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Default Color</label>
              <input type="color" id="default-edge-color" value="#475569">
            </div>
            <div class="style-row">
              <label>Default Routing</label>
              <select id="default-edge-routing">
                <option value="orthogonal">Orthogonal (90°)</option>
                <option value="curved">Curved</option>
                <option value="straight">Straight</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Connections</label>
              <input type="checkbox" id="animate-connections-toggle">
            </div>
            <div class="style-row">
              <label>Animation Style</label>
              <select id="animation-style-select">
                <option value="arrows">Flowing Arrows</option>
                <option value="dots">Dot Arrows</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animate Directions</label>
              <select id="animation-direction-select">
                <option value="all">All Directions</option>
                <option value="forward">Forward Only</option>
                <option value="backward">Backward Only</option>
                <option value="both">Bidirectional Only</option>
              </select>
            </div>
            <div class="style-row">
              <label>Animation Speed</label>
              <select id="animation-speed-select">
                <option value="0.5">Very Fast</option>
                <option value="1">Fast</option>
                <option value="1.5">Normal</option>
                <option value="2.5">Slow</option>
                <option value="4">Very Slow</option>
              </select>
            </div>
            <div class="style-row" style="grid-column: 1 / -1;">
              <button id="apply-routing-all" style="width:100%;padding:8px;background:var(--accent);color:var(--bg);border:none;border-radius:6px;cursor:pointer;font-weight:600;">Apply Routing to All Connections</button>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Groups &amp; Editing</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Resize handle Color</label>
              <input type="color" id="selection-handle-color" value="#f59e0b">
            </div>
            <div class="style-row">
              <label>Resize Handle Size</label>
              <input type="number" id="selection-handle-size" value="8" min="4" max="16" style="width:60px;">
            </div>
            <div class="style-row">
              <label>Grouped Icon Outline</label>
              <input type="color" id="group-indicator-color" value="#4fd1c5">
            </div>
          </div>
		   <div class="style-content">
            <div class="style-row">
              <label>Multiselect Fill Color (Desktop)</label>
              <input type="color" id="selection-fill-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Fill Opacity (Desktop)</label>
              <div style="display:flex;align-items:center;gap:8px;">
                <input type="range" id="selection-fill-opacity" min="0" max="1" step="0.05" value="0.1">
                <span id="selection-fill-opacity-val" style="min-width:35px;text-align:right;">10%</span>
              </div>
            </div>
            <div class="style-row">
              <label>Multiselect Border Color (Desktop)</label>
              <input type="color" id="selection-stroke-color" value="#4fd1c5">
            </div>
            <div class="style-row">
              <label>Multiselect Border Width (Desktop)</label>
              <input type="number" id="selection-stroke-width" min="1" max="10" value="2">
            </div>
            <div class="style-row">
              <label>Multiselect Border Style (Desktop)</label>
              <select id="selection-stroke-style">
                <option value="5,5">Dashed</option>
                <option value="2,4">Dotted</option>
                <option value="none">Solid</option>
              </select>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Inputs &amp; Dropdowns</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="input-bg-color" value="#0b0e13">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="input-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="input-border-color" value="#1f2937">
            </div>
            <div class="style-row">
              <label>Font</label>
              <select id="input-font-family" style="flex:1;padding:4px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;">
                <option value="Inter, system-ui, sans-serif">Inter</option>
                <option value="Arial, sans-serif">Arial</option>
                <option value="Helvetica, sans-serif">Helvetica</option>
                <option value="Georgia, serif">Georgia</option>
                <option value="monospace">Monospace</option>
              </select>
            </div>
            <div class="style-row">
              <label>Font Size</label>
              <input type="number" id="input-font-size" value="14" min="10" max="24" style="width:60px;">
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Welcome Message</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Enabled</label>
              <input type="checkbox" id="canvas-hint-enabled" checked="" style="width:auto;">
            </div>
            <div class="style-row">
              <label>Background</label>
              <input type="color" id="canvas-hint-bg-color" value="#0f172a">
            </div>
            <div class="style-row">
              <label>Text Color</label>
              <input type="color" id="canvas-hint-text-color" value="#94a3b8">
            </div>
            <div class="style-row" style="flex-direction:column;align-items:stretch;">
              <label>Custom Text (HTML)</label>
              <textarea id="canvas-hint-text" rows="4" style="width:100%;margin-top:4px;padding:6px;background:var(--panel);color:var(--text-main);border:1px solid var(--topbar-border);border-radius:4px;font-size:12px;resize:vertical;" placeholder="Leave empty for default"></textarea>
            </div>
          </div>
        </details>
        <details class="style-section">
          <summary>Tags</summary>
          <div class="style-content">
            <div class="style-row">
              <label>Fill</label>
              <input type="color" id="tag-fill-color" value="#1e293b">
            </div>
            <div class="style-row">
              <label>Text</label>
              <input type="color" id="tag-text-color" value="#e2e8f0">
            </div>
            <div class="style-row">
              <label>Border</label>
              <input type="color" id="tag-border-color" value="#475569">
            </div>
          </div>
        </details>
        <details class="style-section" open="">
          <summary>Danger Zone</summary>
          <div class="style-content">
            <p style="margin-bottom:12px;font-size:13px;color:var(--text-soft);">Permanently delete everything on the canvas.</p>
            <button id="clear-all-btn" title="Clear all nodes" style="padding:6px 12px;background:var(--danger);color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:14px;font-weight:600;">Clear All</button>
            <input type="file" id="import-data-file" accept=".json" style="display:none">
          </div>
        </details>
        <div class="modal-buttons">
          <button class="btn-cancel" id="settings-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-node-modal">
      <div class="modal-content">
        <h3>Add New Node</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Name</label>
        <input type="text" id="new-node-name" placeholder="e.g. web-server">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Subtitle</label>
        <input type="text" id="new-node-ip" placeholder="e.g. 192.168.1.100">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-node-tags" placeholder="e.g. Docker, nginx, WG: vpn">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Shape</label>
        <select id="new-node-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-node-cancel">Cancel</button>
          <button class="btn-save" id="add-node-save">Add Node</button>
        </div>
      </div>
    </div>
    <div class="modal" id="add-rack-modal">
      <div class="modal-content">
        <h3>Add New Rack</h3>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Name</label>
        <input type="text" id="new-rack-name" placeholder="e.g. Rack-A, DC1-R01">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">IP / Network Range (optional)</label>
        <input type="text" id="new-rack-ip" placeholder="e.g. 192.168.1.0/24">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Tags (comma separated)</label>
        <input type="text" id="new-rack-tags" placeholder="e.g. Production, Data Center 1">
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Icon / Shape</label>
        <select id="new-rack-shape">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
        <label style="display: block;margin-bottom: 4px;color: var(--text-soft);font-size: 13px;">Rack Capacity</label>
        <select id="new-rack-capacity">
          <option value="42" selected="">42U (Standard Full Rack)</option>
          <option value="48">48U (Large Rack)</option>
          <option value="24">24U (Half Rack)</option>
          <option value="12">12U (Small/Wall Mount)</option>
          <option value="6">6U (Mini Rack)</option>
        </select>
        <div class="modal-buttons">
          <button class="btn-cancel" id="add-rack-cancel">Cancel</button>
          <button class="btn-save" id="add-rack-save">Add Rack</button>
        </div>
      </div>
    </div>
    <div class="modal confirm-modal" id="clear-all-modal">
      <div class="modal-content">
        <h3>Clear All Nodes</h3>
        <p> This will remove ALL nodes and connections. This cannot be undone until you reload without saving. Are you sure? </p>
        <div class="modal-buttons">
          <button class="btn-cancel" id="clear-all-cancel">Cancel</button>
          <button class="btn-delete" id="clear-all-confirm">Clear Everything</button>
        </div>
      </div>
    </div>
    <div class="modal" id="layer-modal">
      <div class="modal-content" style="max-width: 400px;">
        <h3>Layer Visibility</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Toggle which layers are visible on the canvas</p>
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-physical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Physical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-logical" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Logical Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-security" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Security Layer</span>
          </label>
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; background: var(--panel-alt); border-radius: 6px;">
          <input type="checkbox" id="layer-application" checked="" style="cursor: pointer; width: 18px; height: 18px;">
          <span style="flex: 1; font-weight: 500;">Application Layer</span>
          </label>
        </div>
        <div style="margin-top: 15px; display: flex; gap: 8px;">
          <button class="btn-cancel" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = false); applyLayerFilter();">Hide All</button>
          <button class="btn-save" style="flex: 1;" onclick="document.querySelectorAll('#layer-modal input[type=checkbox]').forEach(cb =&gt; cb.checked = true); applyLayerFilter();">Show All</button>
        </div>
        <div class="modal-buttons" style="margin-top: 10px;">
          <button class="btn-cancel" id="layer-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="tabs-modal">
      <div class="modal-content" style="max-width: 600px;">
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Manage multiple topologies</p>
        <div id="tabs-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto; margin-bottom: 15px;">
            <div class="tab-item " onclick="switchTab(0)">
              <div class="tab-name">Corporate Site B</div>
              <div class="tab-stats">107 nodes • 64 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(0)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(0)" title="Delete tab">🗑️</button>
              </div>
            </div>
          
            <div class="tab-item active" onclick="switchTab(1)">
              <div class="tab-name">Homelab 2</div>
              <div class="tab-stats">16 nodes • 10 connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(1)" title="Rename tab">✏️</button>
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(1)" title="Delete tab">🗑️</button>
              </div>
            </div>
          </div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-tab-name" placeholder="New tab name..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewTab()">+ Add Tab</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="tabs-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="rollback-modal">
      <div class="modal-content" style="max-width: 700px;">
        <h3>Version History</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Limit: Snapshots</p>
        <div id="rollback-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 450px; overflow-y: auto; margin-bottom: 15px;"></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <button class="btn-cancel" onclick="clearRollbackHistory()">Clear History</button>
          <button class="btn-save" onclick="createManualSnapshot()">Create Snapshot</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="rollback-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="audit-log-modal">
      <div class="modal-content" style="max-width: 800px;">
        <h3>Audit Log</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Track all changes made to your topology</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <select id="audit-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Events</option>
            <option value="node">Node Operations</option>
            <option value="connection">Connections</option>
            <option value="style">Style Changes</option>
            <option value="rack">Rack Operations</option>
            <option value="layer">Layer Changes</option>
          </select>
          <button class="btn-save" onclick="exportAuditLog()">Export</button>
        </div>
        <div id="audit-log-list" style="display: flex; flex-direction: column; gap: 4px; max-height: 450px; overflow-y: auto; margin-bottom: 15px; font-family: monospace; font-size: 12px;"></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-cancel" onclick="clearAuditLog()">Clear Log</button>
          <button class="btn-cancel" id="audit-log-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="port-map-modal">
      <div class="modal-content" style="max-width: 900px;">
        <h3>Port Map</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">All connections with port assignments</p>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="port-map-search" placeholder="Search devices or ports..." style="flex: 1; min-width: 200px; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <select id="port-map-filter" style="padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
            <option value="all">All Connections</option>
            <option value="with-ports">With Ports Only</option>
            <option value="without-ports">Missing Ports</option>
          </select>
        </div>
        <div id="port-map-table" style="max-height: 450px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div></div>
        <div style="display: flex; gap: 8px;">
          <button class="btn-save" onclick="exportPortMap()">Export CSV</button>
          <button class="btn-cancel" id="port-map-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secrets-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3>Notes</h3>
        <p style="font-size: 13px; color: var(--text-soft); margin-bottom: 15px;">Notes can also be stored with AES 256 encryption</p>
        <div id="secrets-list" style="display: flex; flex-direction: column; gap: 8px; max-height: 350px; overflow-y: auto; margin-bottom: 15px;"><div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div></div>
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
          <input type="text" id="new-secret-name" placeholder="Note name (e.g., 'Root Passwords')..." style="flex: 1; padding: 8px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main);">
          <button class="btn-save" onclick="createNewSecret()">+ Add Note</button>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" id="secrets-modal-close">Close</button>
        </div>
      </div>
    </div>
    <div class="modal" id="secret-editor-modal">
      <div class="modal-content" style="max-width: 600px;">
        <h3 id="secret-editor-title">Edit Note</h3>
        <textarea id="secret-editor-content" placeholder="Enter sensitive information here..." style="width: 100%; height: 200px; padding: 12px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 6px; color: var(--text-main); font-family: monospace; resize: vertical; margin-bottom: 15px;"></textarea>
        <div style="margin-bottom: 15px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
          <input type="checkbox" id="secret-auto-encrypt" checked="" style="cursor: pointer;">
          <span>Encrypt Note</span>
          </label>
        </div>
        <div class="modal-buttons">
          <button class="btn-cancel" onclick="closeSecretEditor()">Cancel</button>
          <button class="btn-save" onclick="saveSecret()">Save</button>
        </div>
      </div>
    </div>
	
	<div class="modal" id="mobile-export-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Export</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="screenshotCanvas(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">PNG Image</button>
          <button onclick="exportCanvasSVG(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">SVG Vector</button>
          <button onclick="exportJSONFile(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON (Full Backup)</button>
          <button onclick="exportMarkdown(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="exportCSV(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="printTopology(); document.getElementById('mobile-export-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Print...</button>
		  <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Export Help</button>
        </div>
        <button onclick="document.getElementById('mobile-export-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div class="modal" id="mobile-import-modal">
      <div class="modal-content" style="max-width: 320px;">
        <h3 style="margin: 0 0 20px 0;">Import</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
          <button onclick="document.getElementById('import-json-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">JSON</button>
          <button onclick="document.getElementById('import-markdown-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Markdown</button>
          <button onclick="document.getElementById('import-csv-file').click(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">CSV</button>
          <button onclick="showFormatHelp(); document.getElementById('mobile-import-modal').classList.remove('active');" style="padding: 14px; background: var(--panel-alt); border: 1px solid var(--edge-main); border-radius: 8px; color: var(--text-main); font-size: 16px; cursor: pointer;">Import Help</button>
        </div>
        <button onclick="document.getElementById('mobile-import-modal').classList.remove('active');" style="margin-top: 20px; padding: 12px; background: var(--danger); border: none; border-radius: 8px; color: white; font-size: 16px; cursor: pointer; width: 100%;">Cancel</button>
      </div>
    </div>
    <div id="context-menu" style="display: none !important;">
    </div>
    <header>
      <div class="title-block">
        <h1 id="page-title" class="editable-page-title">The One File</h1>
        <div class="save-row">
          <button id="save-file-btn" class="save-btn" type="button">Save HTML</button>
          <label style="display: flex;align-items: center;gap: 4px;font-size: 12px;color: var(--text-soft);cursor: pointer;user-select: none;">
            <input type="checkbox" id="encrypt-toggle" style="cursor: pointer">
            <span title="Encrypt data with password">🔒</span>
          </label>
          <div class="dropdown" id="export-dropdown">
            <button class="dropdown-btn" type="button">Export ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="screenshotCanvas()">PNG Image</button>
              <button type="button" onclick="exportCanvasSVG()">SVG Vector</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="exportJSONFile()">JSON</button>
              <button type="button" onclick="exportMarkdown()">Markdown</button>
              <button type="button" onclick="exportCSV()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="printTopology()">Print...</button>
			  <div class="dropdown-divider"></div>
			  <button type="button" onclick="showFormatHelp()">Export Help</button>
            </div>
          </div>
          <div class="dropdown" id="import-dropdown">
            <button class="dropdown-btn" type="button">Import ▾</button>
            <div class="dropdown-menu">
              <button type="button" onclick="document.getElementById('import-json-file').click()">JSON</button>
              <button type="button" onclick="document.getElementById('import-markdown-file').click()">Markdown</button>
              <button type="button" onclick="document.getElementById('import-csv-file').click()">CSV</button>
              <div class="dropdown-divider"></div>
              <button type="button" onclick="showFormatHelp()">Import Help</button>
            </div>
          </div>
          <input type="file" id="import-json-file" accept=".json" style="display:none">
          <input type="file" id="import-markdown-file" accept=".md,.markdown,.txt" style="display:none">
          <input type="file" id="import-csv-file" accept=".csv,.txt" style="display:none">
          <span id="save-help-btn" class="help-icon" title="Why save?">?</span>
        </div>
      </div>
      <div id="topbar-menu">
        <button id="back-to-topology-btn" title="Exit rack view and return to topology" style="padding: 6px 12px; background: var(--accent); color: var(--bg); border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; display: none;">← Back to Topology</button>
        <button id="add-node-btn" class="save-btn" title="Add new node" style="background: var(--accent)" draggable="true">+ Node</button>
        <button id="add-rack-btn" class="save-btn" title="Add new rack" style="background: var(--accent); margin-left: 8px;" draggable="true">+ Rack</button>
        <button id="undo-btn" title="Undo (Ctrl+Z)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 1;">↶</button>
        <button id="redo-btn" title="Redo (Ctrl+Y)" style="padding: 6px 12px; background: var(--btn-bg); color: var(--btn-text); border: 1px solid var(--edge-main); border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; opacity: 0.5;" disabled="">↷</button>
        <input type="text" id="search-nodes" placeholder="Search nodes..." title="Search by name, IP, MAC, role, or tag" style="padding: 6px 12px;background: var(--input-bg);color: var(--input-text);border: 1px solid var(--input-border);border-radius: 6px;font-family: var(--input-font);font-size: var(--input-font-size);width: 180px;">
        <button id="layers-btn" title="Toggle layer visibility" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Layers</button>
        <button id="tabs-btn" title="Manage document tabs" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Tabs</button>
        <button id="rollback-btn" title="View version history" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Snapshots</button>
        <button id="audit-log-btn" title="View audit log" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Audit</button>
        <button id="port-map-btn" title="View all port connections" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Ports</button>
        <button id="secrets-btn" title="Manage encrypted notes" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Notes</button>
		<button id="mobile-export-btn" title="Export topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Export</button>
        <button id="mobile-import-btn" title="Import topology" style="padding: 6px 12px;background: var(--btn-bg);color: var(--btn-text);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: 14px;font-weight: 600;">Import</button>
        <button id="settings-btn" title="Page settings">⚙️</button>
      </div>
      <button id="mobile-menu-toggle" class="mobile-menu-btn">☰</button>
      <div class="header-resizer" id="header-resizer">
        <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
          <circle cx="14" cy="3" r="2"></circle>
          <circle cx="20" cy="3" r="2"></circle>
          <circle cx="26" cy="3" r="2"></circle>
        </svg>
      </div>
    </header>
    <main>
      <section class="topology-panel">
        <div class="draw-toolbar" id="draw-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="draw-toolbar-close-btn" title="Hide draw toolbar">✕</button>
          <button id="draw-toggle" title="Draw custom line">✏️</button>
          <button id="rect-toggle" title="Draw zone">▭</button>
          <button id="text-toggle" title="Add text" class="">T</button>
          <select id="rect-style" title="zone style">
            <option value="filled">Filled</option>
            <option value="outlined">Outlined</option>
          </select>
          <input type="color" id="draw-color" value="#f97316" title="Line color">
          <select id="draw-style" title="Line style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          <select id="draw-arrow" title="Arrow direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Right</option>
            <option value="backward">← Left</option>
            <option value="both">↔ Both</option>
          </select>
          <button id="draw-undo" style="display: none" title="Undo last point">Undo</button>
        </div>
        <div class="topology-toolbar" id="topology-toolbar" style="display: flex !important;">
          <button type="button" class="toolbar-close-btn" id="topology-toolbar-close-btn" title="Hide add line toolbar">✕</button>
          <label for="add-line-select">Add line to:</label>
          <select id="add-line-select"></select>
          <input type="color" id="add-line-color" value="#475569" title="Line color" style="width: 30px;height: 24px;border: 1px solid var(--toolbar-border);border-radius: 4px;cursor: pointer;background: transparent;padding: 0;">
          <select id="add-line-direction" title="Line direction">
            <option value="none">No arrows</option>
            <option value="forward">→ Forward</option>
            <option value="backward">← Backward</option>
            <option value="both">↔ Both</option>
          </select>
          <select id="add-line-routing" title="Line routing">
            <option value="orthogonal">Orthogonal</option>
            <option value="curved">Curved</option>
            <option value="straight">Straight</option>
          </select>
          <button id="add-line-btn">Add</button>
        </div>
        <div class="topology-toolbar bulk-toolbar-desktop" id="bulk-toolbar" style="display: none">
          <button type="button" class="toolbar-close-btn" id="bulk-toolbar-close" title="Clear selection">✕</button>
          <label style="font-weight: 600; color: var(--accent)">Selected: <span id="bulk-count">0</span></label>
          <button id="bulk-align-left" title="Align left">⬅ Left</button>
          <button id="bulk-align-right" title="Align right">➡ Right</button>
          <button id="bulk-align-top" title="Align top">⬆ Top</button>
          <button id="bulk-align-bottom" title="Align bottom">⬇ Bottom</button>
          <button id="bulk-distribute-h" title="Distribute horizontally">↔ Distribute H</button>
          <button id="bulk-distribute-v" title="Distribute vertically">↕ Distribute V</button>
          <button id="bulk-clone" title="Clone selected">📋 Clone</button>
          <button id="bulk-delete" title="Delete selected" style="background: var(--danger); color: white;">Delete</button>
        </div>
        <div class="bulk-toolbar-mobile" id="bulk-toolbar-mobile" style="">
          <button type="button" id="bulk-mobile-btn" style="background: var(--accent);color: white;padding: 12px 20px;border-radius: 25px;font-weight: 600;font-size: 16px;box-shadow: 0 4px 12px rgba(0,0,0,0.3);border: none;cursor: pointer;display: flex;align-items: center;gap: 8px;">
          <span id="bulk-count-mobile">0</span>Selected</button>
        </div>
        <div id="bulk-actions-modal" style="display: none;position: fixed;bottom: 0;left: 0;right: 0;background: var(--panel-alt);border-top-left-radius: 20px;border-top-right-radius: 20px;padding: 20px;padding-bottom: env(safe-area-inset-bottom, 20px);box-shadow: 0 -4px 20px rgba(0,0,0,0.5);z-index: 10000;max-height: calc(100vh - 80px);overflow-y: auto;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--accent); font-size: 20px;">
              <span id="bulk-count-modal">0</span> Nodes Selected
            </h3>
            <button id="bulk-modal-close" style="background: none;border: none;font-size: 24px;cursor: pointer;color: var(--text-main);padding: 0;width: 32px;height: 32px;">✕</button>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
            <button id="bulk-align-left-mobile" class="bulk-action-btn">⬅<br><span style="font-size: 12px;">Align Left</span></button>
            <button id="bulk-align-right-mobile" class="bulk-action-btn">➡<br><span style="font-size: 12px;">Align Right</span></button>
            <button id="bulk-align-top-mobile" class="bulk-action-btn">⬆<br><span style="font-size: 12px;">Align Top</span></button>
            <button id="bulk-align-bottom-mobile" class="bulk-action-btn">⬇<br><span style="font-size: 12px;">Align Bottom</span></button>
            <button id="bulk-distribute-h-mobile" class="bulk-action-btn">↔<br><span style="font-size: 12px;">Distribute H</span></button>
            <button id="bulk-distribute-v-mobile" class="bulk-action-btn">↕<br><span style="font-size: 12px;">Distribute V</span></button>
            <button id="bulk-lock-mobile" class="bulk-action-btn">🔒<br><span style="font-size: 12px;">Lock Toggle</span></button>
            <button id="bulk-group-mobile" class="bulk-action-btn">⭕<br><span style="font-size: 12px;">Group Toggle</span></button>
            <button id="bulk-clone-mobile" class="bulk-action-btn">📋<br><span style="font-size: 12px;">Clone All</span></button>
            <button id="bulk-delete-mobile" class="bulk-action-btn" style="background: var(--danger); color: white;">🗑<br><span style="font-size: 12px;">Delete All</span></button>
          </div>
          <button id="bulk-clear-mobile" style="width: 100%;margin-top: 16px;padding: 14px;background: var(--panel-main);border: 1px solid var(--edge-main);border-radius: 8px;color: var(--text-main);font-size: 16px;cursor: pointer;">Clear Selection</button>
        </div>
        <div class="canvas-hint" id="canvas-hint">
          <ul>
            <li>Scroll to zoom</li>
            <li>Drag to pan</li>
            <li>Right click to clone and align</li>
            <li>Right click to select multiple</li>
			<li>Hold Shift + drag mouse for marquee selection</li>
            <li>You have the power</li>
            <li>Your time is NOW!</li>
          </ul>
        </div>
        <div class="legend-container" id="edge-legend" style="display: flex;"><div class="legend-title">Line Legend</div><button type="button" class="legend-close-btn">✕</button><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(85, 226, 8); cursor: pointer;"></span><span class="legend-label" contenteditable="true">ISP LINE</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(76, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">MY Guest NETWORK</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(128, 255, 0); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(251, 0, 255); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(255, 0, 208); cursor: pointer;"></span><span class="legend-label" contenteditable="true">iPhone (always guest iPhone)</span></div><div class="legend-item"><span class="legend-swatch" style="background-color: rgb(249, 115, 22); cursor: pointer;"></span><span class="legend-label" contenteditable="true">you can edit me too</span></div></div>
        <div class="canvas-viewport" id="canvas-viewport">
          <svg id="map" viewBox="-191.26917538063572 -261.51832729948296 4570.339735330435 3427.7548014978265" style=""></svg>
        </div>
        <div class="minimap-zoom-wrapper" id="minimap-zoom-wrapper" style="display: block;">
          <button type="button" class="minimap-close-btn" id="minimap-close-btn" title="Hide map &amp; zoom">✕</button>
          <div class="minimap-container" id="minimap-container">
            <svg id="minimap" viewBox="0 0 4000 3000">
              <rect class="minimap-viewport" id="minimap-viewport" x="-191.26917538063572" y="-261.51832729948296" width="4570.339735330435" height="3427.7548014978265"></rect>
            </svg>
          </div>
          <div class="zoom-toolbar" id="zoom-toolbar">
            <button id="zoom-in-btn" title="Zoom in">+</button>
            <div class="zoom-level" id="zoom-level">88%</div>
            <button id="zoom-out-btn" title="Zoom out">-</button>
            <div class="divider"></div>
            <button id="zoom-fit-btn" title="Fit to view">[ ]</button>
            <button id="zoom-reset-btn" title="Reset view">R</button>
          </div>
        </div>
        <button type="button" id="edge-legend-mini" class="legend-mini-btn" style="bottom: 10px; display: none;">Line Legend</button>
        <button type="button" id="minimap-mini" class="legend-mini-btn" style="right: 10px; left: auto; bottom: 10px; display: none;">Map</button>
        <button type="button" id="draw-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: 10px; right: auto;">Draw</button>
        <button type="button" id="topology-toolbar-mini" class="legend-mini-btn" style="top: 10px; left: auto; right: 40px;">Add Line</button></section>
      <aside class="details-panel" id="details-panel">
        <div class="sidebar-resizer" id="sidebar-resizer">
          <svg class="resizer-icon" width="6" height="40" viewBox="0 0 6 40" xmlns="http://www.w3.org/2000/svg">
            <circle cx="3" cy="14" r="2"></circle>
            <circle cx="3" cy="20" r="2"></circle>
            <circle cx="3" cy="26" r="2"></circle>
          </svg>
        </div>
        <div class="mobile-footer-resizer" id="mobile-footer-resizer">
          <svg class="resizer-icon" width="40" height="6" viewBox="0 0 40 6" xmlns="http://www.w3.org/2000/svg">
            <circle cx="14" cy="3" r="2"></circle>
            <circle cx="20" cy="3" r="2"></circle>
            <circle cx="26" cy="3" r="2"></circle>
          </svg>
        </div>
        <div id="node-panel" style="display: none;">
          <div class="details-name editable-text" id="node-name">Test Environment</div>
          <div class="details-ip editable-text" id="node-ip">10.81.0.0/24</div>
          <div class="details-role" id="node-role">QA/Testing</div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">MAC:</span>
            <span class="editable-text" id="node-mac" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Unit:</span>
            <span class="editable-text" id="node-rack" style="margin-left: 8px; font-size: 14px;">--</span>
          </div>
          <div class="details-info-row" id="uheight-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">U Height:</span>
            <span class="editable-text" id="node-uheight" style="margin-left: 8px; font-size: 14px;">1U</span>
          </div>
          <div class="details-info-row">
            <span style="color: var(--text-soft); font-size: 14px;">Layer:</span>
            <select id="node-layer" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="physical">Physical</option>
              <option value="logical">Logical</option>
              <option value="security">Security</option>
              <option value="application">Application</option>
            </select>
          </div>
          <div class="details-info-row" id="assigned-rack-row" style="display: flex;">
            <span style="color: var(--text-soft); font-size: 14px;">Assigned Rack:</span>
            <select id="node-assigned-rack" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;"><option value="">None</option><option value="racked">Racked</option></select>
          </div>
          <div class="details-info-row" id="rack-capacity-row" style="display: none;">
            <span style="color: var(--text-soft); font-size: 14px;">Rack Capacity:</span>
            <select id="node-rack-capacity" style="margin-left: 8px; padding: 4px 8px; background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer; font-size: 14px;">
              <option value="42">42U</option>
              <option value="48">48U</option>
              <option value="24">24U</option>
              <option value="12">12U</option>
			  <option value="6">6U</option>
            </select>
          </div>
		  <details id="rack-contents-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;" open="">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Nodes in Rack (<span id="rack-contents-count">0</span>)</summary>
            <div id="rack-contents-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">SAN Primary</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">san</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">netapp</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">SAN Secondary</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">san</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">netapp</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">FC Switch 1</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fc</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fabric-a</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">FC Switch 2</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">storage</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fc</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">fabric-b</span></div><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); cursor: pointer;"><span style="color: var(--text-main);">ToR Switch B1</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">tor</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">access</span><span style="background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;">rack-b1</span></div></div>
          </details>
		  
          <details id="fov-section" style="display: none; margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Field of View</summary>
            <div style="padding: 10px 0;">
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Show FOV:</label>
                <input type="checkbox" id="fov-enabled" style="width: 18px; height: 18px; cursor: pointer;">
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Angle:</label>
                <input type="range" id="fov-angle" min="10" max="360" value="90" style="flex: 1;">
                <span id="fov-angle-value" style="min-width: 40px; text-align: right; color: var(--text-main);">90°</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Distance:</label>
                <input type="range" id="fov-distance" min="50" max="500" value="150" style="flex: 1;">
                <span id="fov-distance-value" style="min-width: 40px; text-align: right; color: var(--text-main);">150</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Rotation:</label>
                <input type="range" id="fov-rotation" min="0" max="360" value="0" style="flex: 1;">
                <span id="fov-rotation-value" style="min-width: 40px; text-align: right; color: var(--text-main);">0°</span>
              </div>
              <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Color:</label>
                <input type="color" id="fov-color" value="#f59e0b" style="width: 50px; height: 30px; border: 1px solid var(--edge-main); border-radius: 4px; cursor: pointer;">
              </div>
              <div style="border-top: 1px solid var(--edge-main); margin-top: 10px; padding-top: 10px;">
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Animate:</label>
                  <input type="checkbox" id="fov-animate" style="width: 18px; height: 18px; cursor: pointer;">
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Sweep:</label>
                  <input type="range" id="fov-sweep" min="30" max="360" value="120" style="flex: 1;">
                  <span id="fov-sweep-value" style="min-width: 40px; text-align: right; color: var(--text-main);">120°</span>
                </div>
                <div class="style-row" style="display: flex; align-items: center; margin-bottom: 8px;">
                  <label style="color: var(--text-soft); font-size: 14px; min-width: 80px;">Speed:</label>
                  <input type="range" id="fov-speed" min="1" max="60" value="4" style="flex: 1;">
                  <span id="fov-speed-value" style="min-width: 40px; text-align: right; color: var(--text-main);">4s</span>
                </div>
              </div>
            </div>
          </details>
          <details id="node-connections-section" ...="" <details="" style="margin-top: 12px; margin-bottom: 12px; padding: 10px; background: var(--panel-alt); border-radius: 6px; display: block;">
            <summary style="color: var(--accent); font-weight: 600; font-size: 14px; cursor: pointer;">Connections (<span id="node-connections-count">1</span>)</summary>
            <div id="node-connections-list" style="max-height: 200px; overflow-y: auto; margin-top: 8px;"><div style="padding: 6px 0px; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;"><span title="Click to set port" style="color: var(--text-soft); cursor: pointer;">-</span><span style="color: var(--text-soft); margin: 0px 8px;">↔</span><span title="Click to view connection" style="color: var(--text-main); cursor: pointer;">Internal FW</span><span title="Click to set port" style="color: var(--text-soft); margin-left: 6px; cursor: pointer;">(-)</span></div></div>
          </details>
          <div class="badge-row" id="node-tags"></div>
          <div class="size-controls">
            <label>Size:</label>
            <input type="range" id="size-slider" min="20" max="200" value="55">
            <span id="size-value">121</span>
            <button id="reset-size">Reset</button>
          </div>
          <div class="size-controls">
            <label>Rotation:</label>
            <input type="range" id="rotation-slider" min="-360" max="360" value="0">
            <input type="number" id="rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
            <button id="reset-rotation">Reset</button>
          </div>
          <details class="style-section" open="">
            <summary>Styling</summary>
            <div class="style-content">
              <div class="style-row">
                <label>Screen:</label>
                <select id="style-scope">
                  <option value="all">All</option>
                  <option value="desktop">Desktop</option>
                  <option value="tablet">Tablet</option>
                  <option value="mobile">Mobile</option>
                  <option value="fold">Fold</option>
                </select>
              </div>
              <div class="style-row">
                <label>Shape:</label>
                <select id="shape-select">
                  <optgroup label="Basic Shapes">
				  <option value="circle">Circle</option>
				  <option value="square">Square</option>
				  <option value="rectangle">Rectangle</option>
				  <option value="triangle">Triangle</option>
				  <option value="hexagon">Hexagon</option>
				  <option value="diamond">Diamond</option>
				  <option value="star">Star</option>
				  <option value="stop-sign">Stop Sign</option>
				  <option value="octagon">Octagon</option>
				  <option value="pentagon">Pentagon</option>
				  <option value="cross">Cross</option>
				  <option value="rounded-square">Rounded Square</option>
				  <option value="pill">Pill</option>
				  <option value="parallelogram">Parallelogram</option>
				  <option value="trapezoid">Trapezoid</option>
				</optgroup>
			  <optgroup label="Computers &amp; Devices">
			      <option value="server">Server</option>
				  <option value="pc">PC / Desktop</option>
				  <option value="laptop">Laptop</option>
				  <option value="phone">Phone / Mobile</option>
				  <option value="printer">Printer</option>
				  <option value="pi">Raspberry Pi</option>
				  <option value="sensor">Sensor / IoT</option>
			  </optgroup>
			  <optgroup label="Network Equipment">
				  <option value="router">Router</option>
				  <option value="switch">Switch</option>
				  <option value="firewall">Firewall</option>
				  <option value="access-point">Access Point</option>
				  <option value="load-balancer">Load Balancer</option>
				  <option value="gateway">Gateway</option>
				  <option value="vpn">VPN / Tunnel</option>
				  <option value="nas">NAS / Storage</option>
			  </optgroup>
			  <optgroup label="Cloud &amp; Services">
			      <option value="cloud">Cloud</option>
				  <option value="database">Database</option>
				  <option value="docker">Docker</option>
				  <option value="container">Container</option>
				  <option value="vm">Virtual Machine</option>
				  <option value="kubernetes">Kubernetes</option>
				  <option value="api">API / Endpoint</option>
				  <option value="queue">Queue / Message</option>
				  <option value="lambda">Lambda / Function</option>
				  <option value="bucket">Bucket / S3</option>
			  </optgroup>
			  <optgroup label="Security &amp; Monitoring">
				  <option value="shield">Shield</option>
				  <option value="camera">Camera / CCTV</option>
				  <option value="monitor">Monitor / Dashboard</option>
			  </optgroup>
			  <optgroup label="Smart Home">
				  <option value="thermostat">Thermostat</option>
				  <option value="doorbell">Video Doorbell</option>
				  <option value="smart-lock">Smart Lock</option>
				  <option value="smart-bulb">Smart Bulb</option>
				  <option value="smart-plug">Smart Plug</option>
				  <option value="smart-speaker">Smart Speaker</option>
				  <option value="smart-tv">Smart TV</option>
				  <option value="hub">Smart Hub</option>
				  <option value="smoke-detector">Smoke Detector</option>
				  <option value="motion-sensor">Motion Sensor</option>
				  <option value="garage">Garage Door</option>
				  <option value="sprinkler">Sprinkler</option>
				  <option value="vacuum">Robot Vacuum</option>
			  </optgroup>
             </select>
              </div>
              <div class="style-row">
                <label>Fill Color:</label>
                <input type="color" id="circle-color" value="#1e293b">
              </div>
              <div class="style-row">
                <label>Border Color:</label>
                <input type="color" id="circle-border" value="#475569">
              </div>
              <div class="style-row">
                <label>Title Color:</label>
                <input type="color" id="title-color" value="#e2e8f0">
              </div>
              <div class="style-row">
                <label>Title Font:</label>
                <select id="title-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Title Size:</label>
                <input type="number" id="title-size" min="8" max="100" value="18">
              </div>
              <div class="style-row">
                <label>Sub Color:</label>
                <input type="color" id="sub-color" value="#94a3b8">
              </div>
              <div class="style-row">
                <label>Sub Font:</label>
                <select id="sub-font">
                  <option value="system-ui, sans-serif"> System UI </option>
                  <option value="monospace">Monospace</option>
                  <option value="serif">Serif</option>
                  <option value="cursive">Cursive</option>
                  <option value="'Courier New', monospace"> Courier </option>
                  <option value="Arial, sans-serif">Arial</option>
                  <option value="'Times New Roman', serif"> Times </option>
                </select>
              </div>
              <div class="style-row">
                <label>Sub Size:</label>
                <input type="number" id="sub-size" min="6" max="80" value="13">
              </div>
              <div style="margin-top: 12px;padding-top: 10px;border-top: 1px solid var(--edge-main);">
                <div style="
                  font-size: 12px;
                  color: var(--text-soft);
                  margin-bottom: 8px;
                  text-transform: uppercase;
                  "> Text Position </div>
                <div class="style-row">
                  <label>Name Y:</label>
                  <input type="number" id="title-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>Name X:</label>
                  <input type="number" id="title-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP Y:</label>
                  <input type="number" id="sub-offset-y" min="-100" max="100" value="0" style="width: 60px">
                </div>
                <div class="style-row">
                  <label>IP X:</label>
                  <input type="number" id="sub-offset-x" min="-100" max="100" value="0" style="width: 60px">
                </div>
              </div>
              <button id="reset-styles" style="width: 100%;margin-top: 10px;padding: 8px;background: var(--panel);color: var(--text-main);border: 1px solid var(--edge-main);border-radius: 6px;cursor: pointer;font-size: clamp(13px, 1.5vw, 17px);">Reset Styles</button>
            </div>
          </details>
          <div class="section-label">Notes</div>
          <ul class="list" id="node-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-note-input" placeholder="Type new note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-note-btn" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-node-btn" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: rgb(255, 255, 255);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;">Delete Node</button>
        </div>
        <div id="edge-panel" style="display: none;">
          <div class="details-name" id="edge-title">Custom line</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Width:</label>
            <input type="number" id="edge-width" min="1" max="20" value="4">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="edge-color" value="#475569">
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="edge-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Routing:</label>
            <select id="edge-routing">
              <option value="orthogonal">Orthogonal (90°)</option>
              <option value="curved">Curved</option>
              <option value="straight">Straight</option>
            </select>
          </div>
          <div class="style-row">
            <label>Direction:</label>
            <select id="edge-direction">
              <option value="none">No arrows</option>
              <option value="forward">→ Forward</option>
              <option value="backward">← Backward</option>
              <option value="both">↔ Bidirectional</option>
            </select>
          </div>
          <div class="style-row">
            <label>Animate:</label>
            <input type="checkbox" id="edge-animate">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="edge-animation-style">
              <option value="">Default</option>
              <option value="arrows">Flowing Arrows</option>
              <option value="dots">Dot Arrows</option>
            </select>
          </div>
          <div class="style-row">
            <label>Speed:</label>
            <select id="edge-animation-speed">
              <option value="">Default</option>
              <option value="0.5">Very Fast</option>
              <option value="1">Fast</option>
              <option value="1.5">Normal</option>
              <option value="2.5">Slow</option>
              <option value="4">Very Slow</option>
            </select>
          </div>
          <div class="style-row" id="edge-from-port-row" style="display: none;">
            <label>From Port:</label>
            <input type="text" id="edge-from-port" placeholder="e.g. eth0, gi0/1" style="flex: 1;">
          </div>
          <div class="style-row" id="edge-to-port-row" style="display: none;">
            <label>To Port:</label>
            <input type="text" id="edge-to-port" placeholder="e.g. eth1, gi0/2" style="flex: 1;">
          </div>
          <div class="section-label">Line Notes</div>
          <ul class="list" id="edge-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-edge-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-edge-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-edge" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Line</button>
        </div>
        <div id="rect-panel" style="display: none">
          <div class="details-name" id="rect-title">Zone</div>
          <div class="style-row" id="rect-fill-row" style="margin-top: 10px">
            <label>Fill Color:</label>
            <input type="color" id="rect-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Color:</label>
            <input type="color" id="rect-border-color" value="#f97316">
          </div>
          <div class="style-row">
            <label>Border Width:</label>
            <input type="number" id="rect-border-width" min="0" max="20" value="2">
          </div>
          <div class="style-row">
            <label>Style:</label>
            <select id="rect-style-select">
              <option value="filled">Filled</option>
              <option value="outlined">Outlined</option>
            </select>
          </div>
          <div class="style-row">
            <label>Line Style:</label>
            <select id="rect-line-style">
  <option value="solid">Solid</option>
  <option value="dashed">Dashed</option>
  <option value="dotted">Dotted</option>
  <option value="wall">Wall</option>
</select>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="rect-rotation" min="-360" max="360" value="0" style="flex: 1;">
            <input type="number" id="rect-rotation-value" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <div class="section-label">Zone Notes</div>
          <ul class="list" id="rect-notes"></ul>
          <div style="margin-top: 10px; display: flex; gap: 8px">
            <input type="text" id="new-rect-note" placeholder="Add note..." style="flex: 1;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: clamp(14px, 1.6vw, 18px);">
            <button id="add-rect-note" style="padding: 8px 16px;background: var(--accent);color: var(--bg);border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Add</button>
          </div>
          <button id="delete-rect" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;">Delete Zone</button>
        </div>
        <div id="text-panel" style="display: none;">
          <div class="details-name" id="text-title">Text Element</div>
          <div class="style-row" style="margin-top: 10px">
            <label>Content:</label>
            <textarea id="text-content" placeholder="Enter text..." style="width: 100%;padding: 8px 12px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 6px;color: var(--text-main);font-size: 14px;min-height: 80px;resize: vertical;font-family: inherit;"></textarea>
          </div>
          <div class="style-row">
            <label>Font Size:</label>
            <input type="number" id="text-font-size" min="8" max="200" value="18" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);">
          </div>
          <div class="style-row">
            <label>Color:</label>
            <input type="color" id="text-color" value="#e2e8f0">
          </div>
          <div class="style-row">
            <label>Font Weight:</label>
            <select id="text-font-weight" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="bold">Bold</option>
              <option value="600">Semi-Bold</option>
              <option value="300">Light</option>
            </select>
          </div>
          <div class="style-row">
            <label>Font Style:</label>
            <select id="text-font-style" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="normal">Normal</option>
              <option value="italic">Italic</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Align:</label>
            <select id="text-align" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="start">Left</option>
              <option value="middle">Center</option>
              <option value="end">Right</option>
            </select>
          </div>
          <div class="style-row">
            <label>Text Decoration:</label>
            <select id="text-decoration" style="flex: 1;padding: 6px 10px;background: var(--panel);border: 1px solid var(--edge-main);border-radius: 4px;color: var(--text-main);cursor: pointer;">
              <option value="none">None</option>
              <option value="underline">Underline</option>
              <option value="line-through">Strike Through</option>
            </select>
          </div>
          <div class="style-row">
            <label>Background:</label>
            <input type="color" id="text-bg-color" value="#000000">
            <label style="margin-left: 10px; display: flex; align-items: center; gap: 6px;">
            <input type="checkbox" id="text-bg-enabled" style="cursor: pointer;">
            <span style="font-size: 13px;">Enable</span>
            </label>
          </div>
          <div class="style-row">
            <label>Opacity:</label>
            <input type="range" id="text-opacity" min="0" max="1" step="0.1" value="1" style="flex: 1">
            <span id="text-opacity-val" style="min-width: 35px; text-align: right">100%</span>
          </div>
          <div class="style-row">
            <label>Rotation:</label>
            <input type="range" id="text-rotation" min="-360" max="360" value="0" style="flex: 1">
            <input type="number" id="text-rotation-val" value="0" style="width: 60px; padding: 4px; background: var(--panel); border: 1px solid var(--edge-main); border-radius: 4px; color: var(--text-main); text-align: center;">
            <span style="color: var(--text-soft);">°</span>
          </div>
          <button id="delete-text" style="margin-top: 15px;padding: 10px 16px;background: var(--danger);color: #fff;border: none;border-radius: 6px;cursor: pointer;font-size: clamp(14px, 1.6vw, 18px);font-weight: 600;width: 100%;"> Delete Text </button>
        </div>
        <details class="style-section" open="">
          <summary>Page Layout</summary>
          <div class="style-content">
            <div style="padding: 12px; background: var(--panel-alt); border-radius: 6px; color: var(--text-soft); font-size: 13px; line-height: 1.6;">
              <strong style="color: var(--accent); display: block; margin-bottom: 8px;">Drag to Resize:</strong>
              • <strong>Header:</strong> Drag the bottom edge of the header bar<br>
              • <strong>Sidebar:</strong> Drag the left edge of the sidebar panel<br>
              • <strong>Mobile:</strong> Drag the top edge of the footer panel<br>
              <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--edge-main); font-size: 12px;">
                Hover over panel edges to see resize handles
              </div>
            </div>
          </div>
        </details>
      </aside>
    </main>
    <script id="nodes-json" type="application/json">{}</script>
    <script id="topology-state" type="application/json">ENCRYPTED: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</script>
    <script>
      const BASE_NODE_DATA = JSON.parse(document.getElementById("nodes-json").textContent);
      let currentNodeId = "host";
      let textDrawMode = false;
      let currentEdgeId = null;
      let currentStyleScope = "all";
      let NODE_DATA = {};
      let EDGE_DATA = {
       list: []
      };
      let currentRectId = null;
      let currentTextId = null;
      let rectDrawMode = false;
      let RECT_DATA = {
       list: []
      };
      let TEXT_DATA = {
       list: []
      };
      let EDGE_LEGEND = {};
      let freeDrawMode = false;
      let savedPositions = {};
      let savedSizes = {};
      let savedStyles = {};
      let legendCollapsed = false;
      let minimapCollapsed = false;
      let drawToolbarCollapsed = false;
      let activeLayers = new Set(["physical", "logical", "security", "application"]);
      let currentView = {
       mode: "topology",
       rackId: null
      };
      let savedTopologyView = null;
      let topologyToolbarCollapsed = false;
      let legendMiniBtn = null;
      let minimapMiniBtn = null;
      let drawToolbarMiniBtn = null;
      let topologyToolbarMiniBtn = null;
      let undoStack = [];
      let redoStack = [];
      const MAX_UNDO_STACK = 50;
      let forgeDebounceTimer = null;
      let forgeImmediate = false;
      let currentSearchQuery = "";
      let currentSearchResults = [];
      const AUTOSAVE_DB_NAME = "TheOneFileAutosave";
      const AUTOSAVE_STORE_NAME = "drafts";
      const AUTOSAVE_KEY = "currentDraft";
      const AUTOSAVE_INTERVAL = 30000;
      let autosaveTimer = null;
      let lastAutosaveTime = 0;
      let selectedNodes = new Set();
      let selectedEdges = new Set();
      let selectedRects = new Set();
      let selectedTexts = new Set();
      let isSelecting = false;
      let selectionStart = null;
      let preDragSelectedNodes = new Set();
      let preDragSelectedEdges = new Set();
      let preDragSelectedRects = new Set();
      let preDragSelectedTexts = new Set();
      let selectionRect = null;
      let selectionBoxStyle = {
       fillColor: "#4fd1c5",
       fillOpacity: 0.1,
       strokeColor: "#4fd1c5",
       strokeWidth: 2,
       strokeDasharray: "5,5"
      };
      let isDraggingSelection = false;
      let dragSelectionStart = null;
      let clipboard = null;
      const ROLLBACK_STORAGE_KEY = "theonefile_rollbacks";
      const MAX_ROLLBACK_VERSIONS = 50;
      let rollbackVersions = [];
      let currentRollbackIndex = -1;
      const AUDIT_STORAGE_KEY = "theonefile_audit_log";
      let auditLog = [];
      const MAX_AUDIT_ENTRIES = 1000;
      let savedStyleSets = [];
      let documentTabs = [{
        id: "main",
        name: "Main Topology",
        nodes: {},
        edges: { list: [] },
        positions: {},
        sizes: {},
        styles: {},
        legend: {},
        rects: { list: [] },
        texts: { list: [] },
      pageState: null
      }];
      let currentTabIndex = 0;
      let encryptedSections = {};
      let performanceMode = "auto";
      let cullOffscreenNodes = true;
      let minimapNeedsUpdate = true;
      let lastMinimapUpdate = 0;
      const MobileManager = {
        isMobile: false,
        detect() {
          if (navigator.userAgentData?.mobile === true) {
            this.isMobile = true;
            return true;
          }
          const coarse = matchMedia("(pointer: coarse)").matches;
          const width = window.innerWidth <= 900;
          const portrait = matchMedia("(orientation: portrait)").matches;
          this.isMobile = coarse;
          return this.isMobile;
        },
        applyInitialCollapse() {
          if (!this.isMobile) return;
          legendCollapsed = true;
          minimapCollapsed = true;
          drawToolbarCollapsed = true;
          topologyToolbarCollapsed = true;
          if (typeof updateLegendVisibility === "function") updateLegendVisibility();
          if (typeof updateMinimapVisibility === "function") updateMinimapVisibility();
          if (typeof updateDrawToolbarVisibility === "function") updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === "function") updateTopologyToolbarVisibility();
        },
        updateBulkToolbar() {
          const desktop = document.getElementById("bulk-toolbar");
          const mobile = document.getElementById("bulk-toolbar-mobile");
          if (!desktop || !mobile) return;
          if (typeof selectedNodes === 'undefined' || selectedNodes.size === 0) {
           desktop.style.display = "none";
           mobile.style.display = "none";
           return;
          }
          const isVisible = desktop.style.display !== "none" || mobile.style.display !== "none";
          if (this.isMobile) {
            desktop.style.display = "none";
            if (isVisible) {
              mobile.style.display = "flex";
            }
          } else {
            mobile.style.display = "none";
            if (isVisible) {
              desktop.style.display = "flex";
            }
          }
        },
        updateCanvasHint() {
      const hint = document.getElementById("canvas-hint");
      if (!hint) return;
      if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
        hint.textContent = PAGE_STATE.canvasHintText;
        return;
      }
      const items = this.isMobile
      ? [
        "Pinch to zoom",
        "Drag to pan",
        "Add node from top menu",
        "Double tap to clone and align",
        "Double tap to select multiple",
        "You have the power",
        "Your time is NOW!",
      ]
      : [
        "Scroll to zoom",
        "Drag to pan",
        "Right click to clone and align",
        "Right click to select multiple",
	    "Hold Shift + drag mouse for marquee selection",
        "You have the power",
        "Your time is NOW!",
      ];
      const list = document.createElement("ul");
      for (const item of items) {
      const li = document.createElement("li");
      li.textContent = item;
      list.appendChild(li);
      }
      hint.replaceChildren(list);
      },
        autoSelectStyleScope() {
          const scope = document.getElementById("style-scope");
          if (!scope) return;
          if (this.isMobile) scope.value = "mobile";
        },
        updateToolbarStack() {
          if (!this.isMobile) return;
          const draw = document.getElementById("draw-toolbar");
          const topo = document.getElementById("topology-toolbar");
          if (!draw || !topo) return;
          const h = draw.getBoundingClientRect().height;
          document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
        },
        updateLayoutControls() {
          const sidebarRow = document.getElementById("sidebar-width-row");
          const footerRow = document.getElementById("mobile-footer-row");
          if (sidebarRow && footerRow) {
            if (this.isMobile) {
              sidebarRow.style.display = "none";
              footerRow.style.display = "flex";
            } else {
              sidebarRow.style.display = "flex";
              footerRow.style.display = "none";
            }
          }
        },
        applyAll() {
          this.detect();
          this.applyInitialCollapse();
          this.updateBulkToolbar();
		  this.updateCanvasHint();
          this.autoSelectStyleScope();
          this.updateToolbarStack();
          this.updateLayoutControls();
        }
      };
      function isMobileDevice() {
        return MobileManager.isMobile;
      }
	  function escapeHtml(str) {
       if (!str) return '';
       return String(str).replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
       }[c]));
      }
      function u8ToBase64(u8) {
      let binary = "";
      for (let i = 0; i < u8.length; i++) binary += String.fromCharCode(u8[i]);
      return btoa(binary);
      }
      function base64ToU8(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
      }
      function openAutosaveDB() {
       return new Promise((resolve, reject) => {
        const request = indexedDB.open(AUTOSAVE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (e) => {
         const db = e.target.result;
         if (!db.objectStoreNames.contains(AUTOSAVE_STORE_NAME)) {
          db.createObjectStore(AUTOSAVE_STORE_NAME, { keyPath: "id" });
         }
        };
       });
      }
      async function saveToIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        const state = {
         id: AUTOSAVE_KEY,
         timestamp: Date.now(),
         pageTitle: document.getElementById("page-title")?.textContent || "The One File",
         nodeData: NODE_DATA,
         edgeData: EDGE_DATA,
         rectData: RECT_DATA,
         textData: TEXT_DATA,
         edgeLegend: EDGE_LEGEND,
         nodePositions: savedPositions,
         nodeSizes: savedSizes,
         nodeStyles: savedStyles,
         page: PAGE_STATE,
         canvas: {
          zoom: canvasState.zoom,
          panX: canvasState.panX,
          panY: canvasState.panY,
         },
         savedTopologyView: savedTopologyView,
         documentTabs: documentTabs,
         currentTabIndex: currentTabIndex,
         encryptedSections: encryptedSections,
         auditLog: auditLog,
		 savedStyleSets: savedStyleSets,
		 selectedTheme: document.getElementById("theme-preset")?.value || "defaulted",
        };
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.put(state);
        await new Promise((resolve, reject) => {
         tx.oncomplete = resolve;
         tx.onerror = () => reject(tx.error);
        });
        lastAutosaveTime = Date.now();
        console.log("Auto-saved to IndexedDB at", new Date().toLocaleTimeString());
       } catch (e) {
        console.warn("Auto-save failed:", e);
       }
      }
      async function loadFromIndexedDB() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readonly");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        const request = store.get(AUTOSAVE_KEY);
        return new Promise((resolve, reject) => {
         request.onsuccess = () => resolve(request.result);
         request.onerror = () => reject(request.error);
        });
       } catch (e) {
        console.warn("Load from IndexedDB failed:", e);
        return null;
       }
      }
      async function clearAutosave() {
       try {
        const db = await openAutosaveDB();
        const tx = db.transaction(AUTOSAVE_STORE_NAME, "readwrite");
        const store = tx.objectStore(AUTOSAVE_STORE_NAME);
        store.delete(AUTOSAVE_KEY);
       } catch (e) {
        console.warn("Clear autosave failed:", e);
       }
      }
      function startAutosave() {
       if (autosaveTimer) clearInterval(autosaveTimer);
       autosaveTimer = setInterval(() => {
        if (Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0 || documentTabs.length > 1) {
         saveToIndexedDB();
        }
       }, AUTOSAVE_INTERVAL);
      }
      async function checkForAutosaveRecovery() {
       try {
        const saved = await loadFromIndexedDB();
        if (saved && saved.timestamp) {
         const age = Date.now() - saved.timestamp;
         const hasCurrentData = Object.keys(NODE_DATA).length > 0 || EDGE_DATA.list.length > 0;
         const savedNodeCount = saved.nodeData ? Object.keys(saved.nodeData).length : 0;
         const savedTabCount = saved.documentTabs ? saved.documentTabs.length : 1;
         if (age < 300000 && (savedNodeCount > 0 || savedTabCount > 1)) {
          const savedDate = new Date(saved.timestamp).toLocaleString();
          const tabInfo = savedTabCount > 1 ? ` across ${savedTabCount} tabs` : "";
          if (!hasCurrentData || confirm(`Recover unsaved work from ${savedDate}?\n(${savedNodeCount} nodes${tabInfo})\n\nClick OK to recover, Cancel to start fresh.`)) {
           if (!hasCurrentData || confirm("This will replace current data. Continue?")) {
            NODE_DATA = saved.nodeData || {};
            EDGE_DATA = saved.edgeData || { list: [] };
            RECT_DATA = saved.rectData || { list: [] };
            TEXT_DATA = saved.textData || { list: [] };
            EDGE_LEGEND = saved.edgeLegend || {};
            savedPositions = saved.nodePositions || {};
            savedSizes = saved.nodeSizes || {};
            savedStyles = saved.nodeStyles || {};
            if (saved.page) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, saved.page);
            if (saved.canvas) {
             canvasState.zoom = saved.canvas.zoom || 1;
             canvasState.panX = saved.canvas.panX || 0;
             canvasState.panY = saved.canvas.panY || 0;
            }
            if (saved.savedTopologyView) savedTopologyView = saved.savedTopologyView;
            if (saved.savedStyleSets) savedStyleSets = saved.savedStyleSets;
            if (saved.selectedTheme) {
              rebuildThemeDropdown();
              document.getElementById("theme-preset").value = saved.selectedTheme;
              updateDeleteButton();
            }
            if (saved.documentTabs) documentTabs = saved.documentTabs;
            if (saved.currentTabIndex !== undefined) currentTabIndex = saved.currentTabIndex;
            if (saved.encryptedSections) encryptedSections = saved.encryptedSections;
            if (saved.auditLog) auditLog = saved.auditLog;
            if (saved.pageTitle) {
             const titleEl = document.getElementById("page-title");
             if (titleEl) titleEl.textContent = saved.pageTitle;
            }
            wieldThePower();
            forgeTheTopology();
            updateViewBox();
            console.log("Recovered from autosave:", savedNodeCount, "nodes,", savedTabCount, "tabs");
            return true;
           }
          }
         }
        }
       } catch (e) {
        console.warn("Autosave recovery check failed:", e);
       }
       return false;
      }
			  function ensureLegendMiniButton() {
		   if (legendMiniBtn) return legendMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			legendCollapsed = false;
			updateLegendVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("edge-legend-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			legendMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "edge-legend-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Legend";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   legendMiniBtn = btn;
		   return btn;
		}
			  function ensureMinimapMiniButton() {
		   if (minimapMiniBtn) return minimapMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			minimapCollapsed = false;
			updateMinimapVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("minimap-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			minimapMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "minimap-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Map";
		   btn.style.right = "10px";
		   btn.style.left = "auto";
		   btn.style.bottom = "10px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   minimapMiniBtn = btn;
		   return btn;
		}
			  function ensureDrawToolbarMiniButton() {
		   if (drawToolbarMiniBtn) return drawToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			drawToolbarCollapsed = false;
			updateDrawToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("draw-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			drawToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "draw-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Draw";
		   btn.style.top = "10px";
		   btn.style.left = "10px";
		   btn.style.right = "auto";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   drawToolbarMiniBtn = btn;
		   return btn;
		}
			  function ensureTopologyToolbarMiniButton() {
		   if (topologyToolbarMiniBtn) return topologyToolbarMiniBtn;
		   const handleClick = (e) => {
			e.stopPropagation();
			e.preventDefault();
			topologyToolbarCollapsed = false;
			updateTopologyToolbarVisibility();
		   };
		   const preventTouch = (e) => { e.preventDefault(); };
		   const existing = document.getElementById("topology-toolbar-mini");
		   if (existing) {
			existing.addEventListener("click", handleClick);
			existing.addEventListener("touchstart", preventTouch, { passive: false });
			existing.addEventListener("touchend", handleClick);
			topologyToolbarMiniBtn = existing;
			return existing;
		   }
		   const panel = document.querySelector(".topology-panel");
		   if (!panel) return null;
		   const btn = document.createElement("button");
		   btn.type = "button";
		   btn.id = "topology-toolbar-mini";
		   btn.className = "legend-mini-btn";
		   btn.textContent = "Add Line";
		   btn.style.top = "10px";
		   btn.style.left = "auto";
		   btn.style.right = "40px";
		   btn.addEventListener("click", handleClick);
		   btn.addEventListener("touchstart", preventTouch, { passive: false });
		   btn.addEventListener("touchend", handleClick);
		   panel.appendChild(btn);
		   topologyToolbarMiniBtn = btn;
		   return btn;
		}
      function updateToolbarStack() {
       if (!isMobileDevice()) return;
       const draw = document.getElementById("draw-toolbar");
       const topo = document.getElementById("topology-toolbar");
       if (!draw || !topo) return;
       const h = draw.getBoundingClientRect().height;
       document.documentElement.style.setProperty("--draw-toolbar-height", h + "px");
      }
      window.addEventListener("resize", updateToolbarStack);
      window.addEventListener("DOMContentLoaded", updateToolbarStack);
      updateToolbarStack();
      function updateLegendVisibility() {
       const legend = document.getElementById("edge-legend");
       const mini = ensureLegendMiniButton();
       if (!legend || !mini) return;
       const hasItems = legend.querySelectorAll(".legend-item").length > 0;
       if (!hasItems) {
        legend.style.display = "none";
        mini.style.display = "none";
        return;
       }
       if (legendCollapsed) {
        legend.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        legend.style.display = "flex";
        mini.style.display = "none";
       }
      }
      function updateMinimapVisibility() {
       const wrapper = document.getElementById("minimap-zoom-wrapper");
       const mini = ensureMinimapMiniButton();
       if (!wrapper || !mini) return;
       if (minimapCollapsed) {
        wrapper.style.display = "none";
        mini.style.display = "inline-flex";
       } else {
        wrapper.style.display = "block";
        mini.style.display = "none";
       }
      }
      function updateDrawToolbarVisibility() {
       const toolbar = document.getElementById("draw-toolbar");
       const mini = ensureDrawToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       if (drawToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
      } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      function updateTopologyToolbarVisibility() {
       const toolbar = document.getElementById("topology-toolbar");
       const mini = ensureTopologyToolbarMiniButton();
       if (isViewOnly()) {
        if (toolbar) toolbar.style.setProperty('display', 'none', 'important');
        if (mini) mini.style.display = "none";
        return;
       }
       if (!toolbar || !mini) return;
       const hasSelectedNode = currentNodeId !== null;
       if (!hasSelectedNode) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "none";
       } else if (topologyToolbarCollapsed) {
        toolbar.style.setProperty('display', 'none', 'important');
        mini.style.display = "inline-flex";
       } else {
      if (isMobileDevice()) {
        toolbar.style.setProperty('display', 'grid', 'important');
        mini.style.display = "none";
        } else {
        toolbar.style.setProperty('display', 'flex', 'important');
        mini.style.display = "none";
      }
       }
      }
      const DEFAULT_CANVAS_HINT = document.getElementById("canvas-hint")?.innerHTML || "";
      const DEFAULT_PAGE_STATE = {
       title: "The One File",
       background: "",
       topbarBg: "rgba(9, 12, 20, 0.9)",
       topbarBorder: "#1f2533",
       panel: "#0b0e13",
       panelAlt: "#10141b",
       accent: "#4fd1c5",
       sidebarBg: "#10141b",
       btnBg: "#0b0e13",
       btnText: "#e2e8f0",
       tagFill: "#1e293b",
       tagText: "#e2e8f0",
       tagBorder: "#475569",
       inputBg: "#0b0e13",
       inputText: "#e2e8f0",
       inputBorder: "#1f2937",
       inputFont: "Inter, system-ui, sans-serif",
       inputFontSize: 14,
       toolbarBg: "#0f172a",
       toolbarBorder: "#1f2937",
       toolbarText: "#94a3b8",
       toolbarBtnBg: "#0b0e13",
       toolbarBtnText: "#e2e8f0",
       minimapDots: "#94a3b8",
       canvasHintEnabled: true,
       canvasHintText: "",
       canvasHintBg: "#0f172a",
       canvasHintColor: "#94a3b8",
       danger: "#f56565",
       textMain: "#e2e8f0",
       textSoft: "#94a3b8",
       topbarHeight: 52,
       sidebarWidth: 350,
       mobileFooterHeight: 40,
       sidebarCollapsed: false,
       nodeFill: "#1e293b",
       nodeStroke: "#475569",
       nodeTitle: "#e2e8f0",
       nodeSub: "#94a3b8",
       nodeTitleSize: 18,
       nodeSubSize: 13,
       nodeFont: "Inter, system-ui, sans-serif",
       defaultEdge: "#475569",
       selectionHandle: "#f59e0b",
       selectionHandleSize: 8,
       groupIndicator: "#4fd1c5",
      canvasGradientTop: "#1e2532",
       canvasGradientBottom: "#050608",
       canvasBorder: "#475569",
       canvasGrid: "#475569",
       canvasGridSize: 50,
canvasGridEnabled: true,
rackFrameFill: "#0f172a",
rackGridEnabled: true,
       rackFrameStroke: "#4fd1c5",
       rackLineColor: "#475569",
       rackTextColor: "#4fd1c5",
	   viewOnly: false,
	   defaultEdgeRouting: "curved",
	   animateConnections: false,
	   animationStyle: "arrows",
	   animationDirection: "all",
	   animationSpeed: 1.5,
      };
      let PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE);
	  const FOV_ANIMATION_START = Date.now();
	  function isViewOnly() {
       return PAGE_STATE.viewOnly === true;
      }
	  let viewOnlyClickCount = 0;
      let viewOnlyClickTimer = null;
      let viewOnlyClickTarget = null;
      function handleViewOnlyClick(id, type) {
       if (!isViewOnly()) return false;
       if (viewOnlyClickTarget !== id) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = id;
       }
       viewOnlyClickCount++;
       clearTimeout(viewOnlyClickTimer);
       viewOnlyClickTimer = setTimeout(() => {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
       }, 2000);
       if (viewOnlyClickCount >= 5) {
        viewOnlyClickCount = 0;
        viewOnlyClickTarget = null;
        document.body.classList.add("view-only-inspect");
        if (type === 'node') {
         currentNodeId = id;
         const data = NODE_DATA[id];
         if (data) {
          document.querySelectorAll(".node-group").forEach((n) => {
           n.classList.toggle("active", n.dataset.nodeId === id);
          });
          document.getElementById("node-panel").style.display = "block";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("node-name").textContent = data.name;
          document.getElementById("node-ip").textContent = data.ip;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (data.shape === "camera" || data.shape === "cctv") {
    fovSection.style.display = "block";
    document.getElementById("fov-enabled").checked = data.fovEnabled || false;
    document.getElementById("fov-angle").value = data.fovAngle || 90;
    document.getElementById("fov-angle-value").textContent = (data.fovAngle || 90) + "°";
    document.getElementById("fov-distance").value = data.fovDistance || 150;
    document.getElementById("fov-distance-value").textContent = data.fovDistance || 150;
    document.getElementById("fov-rotation").value = data.fovRotation || 0;
    document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
    document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
  } else {
    fovSection.style.display = "none";
  }
}
          document.getElementById("node-role").textContent = data.role;
          document.getElementById("node-mac").textContent = data.mac || "--";
          document.getElementById("node-rack").textContent = data.rackUnit || "--";
          document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
          const tagList = document.getElementById("node-tags");
          if (tagList) {
           tagList.innerHTML = "";
           if (data.tags && data.tags.length > 0) {
            data.tags.forEach((tag) => {
             const li = document.createElement("li");
             li.textContent = tag;
             tagList.appendChild(li);
            });
           }
          }
          const noteList = document.getElementById("node-notes");
          if (noteList) {
           noteList.innerHTML = "";
           if (data.notes && data.notes.length > 0) {
            data.notes.forEach((note) => {
             const li = document.createElement("li");
             li.textContent = note;
             noteList.appendChild(li);
            });
           }
          }
         }
        } else if (type === 'edge') {
         currentEdgeId = id;
         const edge = EDGE_DATA.list.find(e => e.id === id);
         if (edge) {
          document.querySelectorAll(".edge").forEach((e) => {
           e.classList.toggle("active", e.dataset.edgeId === id);
          });
          document.getElementById("edge-panel").style.display = "block";
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-from").textContent = NODE_DATA[edge.from]?.name || edge.from;
          document.getElementById("edge-to").textContent = NODE_DATA[edge.to]?.name || edge.to;
          document.getElementById("edge-label").value = edge.label || "";
         }
        }
        return true;
       }
       return false;
      }
      const CANVAS_WIDTH = 4000;
      let CANVAS_HEIGHT = 3000;
      const BASE_CANVAS_HEIGHT = 3000;
      const CANVAS_PADDING = 100;
      const RACK_U_HEIGHT = 70;
      const RACK_WIDTH = 600;
      const RACK_START_X = CANVAS_WIDTH / 2;
      const RACK_START_Y = CANVAS_PADDING + 100;
      function getRackUHeight(rackId) {
      const capacity = getRackCapacity(rackId);
      const availableHeight = CANVAS_HEIGHT - RACK_START_Y - 200;
      return Math.floor(availableHeight / capacity);
      }
      let canvasState = {
       zoom: 1,
       panX: 0,
       panY: 0,
       minZoom: 0.25,
       maxZoom: 4,
       isPanning: false,
       panStartX: 0,
       panStartY: 0,
       spacePressed: false,
      };
      function getViewBox() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       return {
        x: canvasState.panX,
        y: canvasState.panY,
        width: viewWidth,
        height: viewHeight,
       };
      }
function updateViewBox() {
  const svg = document.getElementById("map");
  const vb = getViewBox();
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  const zoomLevel = document.getElementById("zoom-level");
  if (zoomLevel) {
    zoomLevel.textContent = Math.round(canvasState.zoom * 100) + "%";
  }
  if (canvasState.zoom < 0.5) {
    svg.classList.add("low-zoom");
  } else {
    svg.classList.remove("low-zoom");
  }
  updateMinimap();
  populateRackDropdown();
}
	  
let lastMinimapRender = 0;
const MINIMAP_THROTTLE = 100;

function updateMinimap() {
  const now = performance.now();
  if (now - lastMinimapRender < MINIMAP_THROTTLE) return;
  lastMinimapRender = now;
  
  const minimapViewport = document.getElementById("minimap-viewport");
  const minimapSvg = document.getElementById("minimap");
  if (!minimapViewport || !minimapSvg) return;
  const vb = getViewBox();
  minimapViewport.setAttribute("x", vb.x);
  minimapViewport.setAttribute("y", vb.y);
  minimapViewport.setAttribute("width", vb.width);
  minimapViewport.setAttribute("height", vb.height);
minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
const frag = document.createDocumentFragment();

EDGE_DATA.list.forEach((edge) => {
  if (edge.type === "custom") return;
  const fromNode = NODE_DATA[edge.from];
  const toNode = NODE_DATA[edge.to];
  if (!fromNode || !toNode) return;
  if (currentView.mode === "rack") {
    if (fromNode.assignedRack !== currentView.rackId || toNode.assignedRack !== currentView.rackId) return;
  } else {
    if (fromNode.assignedRack || toNode.assignedRack) return;
  }
  const p1 = savedPositions[edge.from];
  const p2 = savedPositions[edge.to];
  if (!p1 || !p2) return;
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("x1", p1.x);
  line.setAttribute("y1", p1.y);
  line.setAttribute("x2", p2.x);
  line.setAttribute("y2", p2.y);
  line.classList.add("minimap-edge");
  frag.appendChild(line);
});

Object.entries(savedPositions).forEach(([id, pos]) => {
  const node = NODE_DATA[id];
  if (!node) return;
  if (currentView.mode === "rack") {
    if (node.assignedRack !== currentView.rackId) return;
  } else {
    if (node.assignedRack) return;
  }
  
  if ((node.shape === "camera" || node.shape === "cctv") && node.fovEnabled) {
    const fovAngle = node.fovAngle || 90;
    const fovDistance = (node.fovDistance || 150) * 0.8; 
    const fovRotation = node.fovRotation || 0;
    const fovColor = node.fovColor || "#f59e0b";
    const fovAnimate = node.fovAnimate || false;
    const fovSweep = node.fovSweep || 120;
    const fovSpeed = node.fovSpeed || 4;
    
    if (fovAngle < 360) {
      const angleRad = (fovAngle * Math.PI) / 180;
      const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
      
      const startAngle = rotationRad - angleRad / 2;
      const endAngle = rotationRad + angleRad / 2;
      
      const x1 = pos.x + Math.cos(startAngle) * fovDistance;
      const y1 = pos.y + Math.sin(startAngle) * fovDistance;
      const x2 = pos.x + Math.cos(endAngle) * fovDistance;
      const y2 = pos.y + Math.sin(endAngle) * fovDistance;
      
      const largeArc = fovAngle > 180 ? 1 : 0;
      
      const fovGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      fovGroup.classList.add("minimap-node");
      
      const fovPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
      fovPath.setAttribute("d", `M ${pos.x},${pos.y} L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
      fovPath.style.fill = fovColor + "44";
      fovPath.style.stroke = fovColor;
      fovPath.style.strokeWidth = "2";
      fovGroup.appendChild(fovPath);
      
      if (fovAnimate) {
        const animationName = `minimap-fov-sweep-${id}`;
        const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
        styleEl.textContent = `
          @keyframes ${animationName} {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(${fovSweep}deg); }
          }
        `;
        fovGroup.appendChild(styleEl);
        
        const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
        const animationOffset = elapsedSeconds % fovSpeed;
        
        fovGroup.style.transformOrigin = `${pos.x}px ${pos.y}px`;
        fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
        fovGroup.style.animationDelay = `-${animationOffset}s`;
      }
      
      frag.appendChild(fovGroup);
    }
  }
  
  const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle.setAttribute("cx", pos.x);
  circle.setAttribute("cy", pos.y);
  circle.setAttribute("r", 40);
  circle.classList.add("minimap-node");
  frag.appendChild(circle);
});

minimapSvg.insertBefore(frag, minimapViewport);
}

      function zoomTo(newZoom, centerX, centerY) {
       const oldZoom = canvasState.zoom;
       newZoom = Math.max(canvasState.minZoom, Math.min(canvasState.maxZoom, newZoom));
       if (centerX !== undefined && centerY !== undefined) {
        const oldWidth = CANVAS_WIDTH / oldZoom;
        const oldHeight = CANVAS_HEIGHT / oldZoom;
        const newWidth = CANVAS_WIDTH / newZoom;
        const newHeight = CANVAS_HEIGHT / newZoom;
        const pointX = canvasState.panX + centerX * oldWidth;
        const pointY = canvasState.panY + centerY * oldHeight;
        canvasState.panX = pointX - centerX * newWidth;
        canvasState.panY = pointY - centerY * newHeight;
       }
       canvasState.zoom = newZoom;
       constrainPan();
       updateViewBox();
      }
      function constrainPan() {
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       const minVisiblePortion = 0.1;
       const maxPanX = CANVAS_WIDTH - viewWidth * minVisiblePortion;
       const maxPanY = CANVAS_HEIGHT - viewHeight * minVisiblePortion;
       const minPanX = -viewWidth * (1 - minVisiblePortion);
       const minPanY = -viewHeight * (1 - minVisiblePortion);
       canvasState.panX = Math.max(minPanX, Math.min(maxPanX, canvasState.panX));
       canvasState.panY = Math.max(minPanY, Math.min(maxPanY, canvasState.panY));
      }
      function fitToContent() {
       const positions = Object.values(savedPositions);
       if (positions.length === 0) {
        resetView();
        return;
       }
       let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
       positions.forEach((pos) => {
        minX = Math.min(minX, pos.x - 100);
        minY = Math.min(minY, pos.y - 100);
        maxX = Math.max(maxX, pos.x + 100);
        maxY = Math.max(maxY, pos.y + 100);
       });
       const contentWidth = maxX - minX + 200;
       const contentHeight = maxY - minY + 200;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(2, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = minX - 100 - (viewWidth - contentWidth) / 2;
       canvasState.panY = minY - 100 - (viewHeight - contentHeight) / 2;
       constrainPan();
       updateViewBox();
      }
      function resetView() {
       canvasState.zoom = 1;
       canvasState.panX = 0;
       canvasState.panY = 0;
       updateViewBox();
      }
      function focusOnNodes(nodeIds) {
       if (!nodeIds || nodeIds.length === 0) return;
       const positions = nodeIds.map(id => savedPositions[id]).filter(Boolean);
       if (positions.length === 0) return;
       let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
       positions.forEach(pos => {
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
       });
       const padding = 150;
       const contentWidth = Math.max(maxX - minX + padding * 2, 300);
       const contentHeight = Math.max(maxY - minY + padding * 2, 300);
       const centerX = (minX + maxX) / 2;
       const centerY = (minY + maxY) / 2;
       const viewport = document.getElementById("canvas-viewport");
       const vpRect = viewport.getBoundingClientRect();
       const aspectRatio = vpRect.width / vpRect.height;
       const contentAspect = contentWidth / contentHeight;
       let newZoom;
       if (contentAspect > aspectRatio) {
        newZoom = (vpRect.width / contentWidth) * (CANVAS_WIDTH / vpRect.width);
       } else {
        newZoom = (vpRect.height / contentHeight) * (CANVAS_HEIGHT / vpRect.height);
       }
       newZoom = Math.max(canvasState.minZoom, Math.min(1.5, newZoom));
       const viewWidth = CANVAS_WIDTH / newZoom;
       const viewHeight = CANVAS_HEIGHT / newZoom;
       canvasState.zoom = newZoom;
       canvasState.panX = centerX - viewWidth / 2;
       canvasState.panY = centerY - viewHeight / 2;
       constrainPan();
       updateViewBox();
      }
      window.addEventListener("DOMContentLoaded", () => {
       const toggle = document.getElementById("mobile-menu-toggle");
       const menu = document.getElementById("topbar-menu");
       if (!toggle || !menu) return;
       toggle.addEventListener("click", () => {
        menu.classList.toggle("open");
       });
       menu.addEventListener("click", (e) => {
        const target = e.target.closest("a, button");
        if (!target) return;
        if (isMobileDevice()) {
       menu.classList.remove("open");
      }
       });
       const minimapCloseBtn = document.getElementById("minimap-close-btn");
       if (minimapCloseBtn) {
        const handleMinimapClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         minimapCollapsed = true;
         updateMinimapVisibility();
        };
        minimapCloseBtn.addEventListener("click", handleMinimapClose);
        minimapCloseBtn.addEventListener("touchend", handleMinimapClose);
       }
       const drawToolbarCloseBtn = document.getElementById("draw-toolbar-close-btn");
       if (drawToolbarCloseBtn) {
        const handleDrawClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         drawToolbarCollapsed = true;
         updateDrawToolbarVisibility();
        };
        drawToolbarCloseBtn.addEventListener("click", handleDrawClose);
        drawToolbarCloseBtn.addEventListener("touchend", handleDrawClose);
       }
       const topologyToolbarCloseBtn = document.getElementById("topology-toolbar-close-btn");
       if (topologyToolbarCloseBtn) {
        const handleTopologyClose = (e) => {
         e.stopPropagation();
         e.preventDefault();
         topologyToolbarCollapsed = true;
         updateTopologyToolbarVisibility();
        };
        topologyToolbarCloseBtn.addEventListener("click", handleTopologyClose);
        topologyToolbarCloseBtn.addEventListener("touchstart", (e) => e.preventDefault(), {
         passive: false
        });
        topologyToolbarCloseBtn.addEventListener("touchend", handleTopologyClose);
       }
       updateMinimapVisibility();
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
      });
      function applyLayerFilter() {
       activeLayers.clear();
       if (document.getElementById("layer-physical").checked) activeLayers.add("physical");
       if (document.getElementById("layer-logical").checked) activeLayers.add("logical");
       if (document.getElementById("layer-security").checked) activeLayers.add("security");
       if (document.getElementById("layer-application").checked) activeLayers.add("application");
       forgeTheTopology();
      }
      function isNodeVisible(nodeId) {
       const node = NODE_DATA[nodeId];
       if (!node) return false;
       const nodeLayer = node.layer || "physical";
       return activeLayers.has(nodeLayer);
      }
      function enterRack(rackId) {
      if (!NODE_DATA[rackId] || !NODE_DATA[rackId].isRack) return;
      const rackCapacity = getRackCapacity(rackId);
      const neededHeight = RACK_START_Y + (rackCapacity * RACK_U_HEIGHT) + 200;
      if (neededHeight > BASE_CANVAS_HEIGHT) {
      CANVAS_HEIGHT = neededHeight;
      }
       savedTopologyView = {
        zoom: canvasState.zoom,
        panX: canvasState.panX,
        panY: canvasState.panY
       };
       currentView.mode = "rack";
       currentView.rackId = rackId;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "inline-block";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.textContent = `Viewing: ${NODE_DATA[rackId]?.name || 'Rack'} | Double click empty space to exit`;
        hint.classList.add("visible");
       }
      const rackUHeight = getRackUHeight(rackId);
      const rackHeight = rackCapacity * rackUHeight;
      const rackCenterX = RACK_START_X;
      const rackCenterY = RACK_START_Y + (rackHeight / 2);
       const viewWidth = CANVAS_WIDTH / canvasState.zoom;
       const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
       canvasState.panX = rackCenterX - (viewWidth / 2);
       canvasState.panY = rackCenterY - (viewHeight / 2);
       constrainPan();
       updateViewBox();
       forgeTheTopology();
      }
      function exitRack() {
      CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
      currentView.mode = "topology";
      currentView.rackId = null;
       const backBtn = document.getElementById("back-to-topology-btn");
       if (backBtn) backBtn.style.display = "none";
       const hint = document.getElementById("canvas-hint");
       if (hint) {
        hint.classList.remove("visible");
       }
       if (savedTopologyView) {
        canvasState.zoom = savedTopologyView.zoom;
        canvasState.panX = savedTopologyView.panX;
        canvasState.panY = savedTopologyView.panY;
        updateViewBox();
       }
       forgeTheTopology();
      }
      function getRackCapacity(rackId) {
       const node = NODE_DATA[rackId];
       return node && node.rackCapacity ? parseInt(node.rackCapacity) : 42;
      }
      function populateRackDropdown() {
       const dropdown = document.getElementById("node-assigned-rack");
       if (!dropdown) return;
       dropdown.innerHTML = '<option value="">None</option>';
       Object.keys(NODE_DATA).forEach(id => {
        if (NODE_DATA[id].isRack) {
         const option = document.createElement("option");
         option.value = id;
         option.textContent = NODE_DATA[id].name;
         dropdown.appendChild(option);
        }
       });
      }
      function wieldThePower() {
       const root = document.documentElement;
       root.style.setProperty("--panel", PAGE_STATE.panel);
       root.style.setProperty("--panel-alt", PAGE_STATE.panelAlt);
       root.style.setProperty("--sidebar-bg", PAGE_STATE.sidebarBg || PAGE_STATE.panelAlt);
       root.style.setProperty("--btn-bg", PAGE_STATE.btnBg || PAGE_STATE.panel);
       root.style.setProperty("--btn-text", PAGE_STATE.btnText || "#e2e8f0");
       root.style.setProperty("--tag-fill", PAGE_STATE.tagFill || "#1e293b");
       root.style.setProperty("--tag-text", PAGE_STATE.tagText || "#e2e8f0");
       root.style.setProperty("--tag-border", PAGE_STATE.tagBorder || "#475569");
       root.style.setProperty("--input-bg", PAGE_STATE.inputBg || "#0b0e13");
       root.style.setProperty("--input-text", PAGE_STATE.inputText || "#e2e8f0");
       root.style.setProperty("--input-border", PAGE_STATE.inputBorder || "#1f2937");
       root.style.setProperty("--input-font", PAGE_STATE.inputFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--input-font-size", (PAGE_STATE.inputFontSize || 14) + "px");
       root.style.setProperty("--toolbar-bg", PAGE_STATE.toolbarBg || "#0f172a");
       root.style.setProperty("--toolbar-border", PAGE_STATE.toolbarBorder || "#1f2937");
       root.style.setProperty("--toolbar-text", PAGE_STATE.toolbarText || "#94a3b8");
       root.style.setProperty("--toolbar-btn-bg", PAGE_STATE.toolbarBtnBg || "#0b0e13");
       root.style.setProperty("--toolbar-btn-text", PAGE_STATE.toolbarBtnText || "#e2e8f0");
       root.style.setProperty("--minimap-dots", PAGE_STATE.minimapDots || "#94a3b8");
       root.style.setProperty("--canvas-hint-bg", PAGE_STATE.canvasHintBg || "#0f172a");
       root.style.setProperty("--canvas-hint-color", PAGE_STATE.canvasHintColor || "#94a3b8");
       const canvasHint = document.getElementById("canvas-hint");
       if (canvasHint) {
        canvasHint.style.display = PAGE_STATE.canvasHintEnabled === false ? "none" : "";
        if (PAGE_STATE.canvasHintText !== undefined && PAGE_STATE.canvasHintText !== "") {
         canvasHint.textContent = PAGE_STATE.canvasHintText;
        } else {
         canvasHint.innerHTML = DEFAULT_CANVAS_HINT;
        }
       }
       root.style.setProperty("--accent", PAGE_STATE.accent);
       root.style.setProperty("--danger", PAGE_STATE.danger);
       root.style.setProperty("--text-main", PAGE_STATE.textMain);
       root.style.setProperty("--text-soft", PAGE_STATE.textSoft);
       root.style.setProperty("--topbar-bg", PAGE_STATE.topbarBg);
       root.style.setProperty("--topbar-border", PAGE_STATE.topbarBorder);
       root.style.setProperty("--node-fill", PAGE_STATE.nodeFill || "#1e293b");
       root.style.setProperty("--node-stroke", PAGE_STATE.nodeStroke || "#475569");
       root.style.setProperty("--node-title", PAGE_STATE.nodeTitle || "#e2e8f0");
       root.style.setProperty("--node-sub", PAGE_STATE.nodeSub || "#94a3b8");
       root.style.setProperty("--node-title-size", (PAGE_STATE.nodeTitleSize || 18) + "px");
       root.style.setProperty("--node-sub-size", (PAGE_STATE.nodeSubSize || 13) + "px");
       root.style.setProperty("--node-font", PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif");
       root.style.setProperty("--default-edge", PAGE_STATE.defaultEdge || "#475569");
       root.style.setProperty("--selection-handle", PAGE_STATE.selectionHandle || "#f59e0b");
       root.style.setProperty("--selection-handle-size", (PAGE_STATE.selectionHandleSize || 8) + "px");
       root.style.setProperty("--group-indicator", PAGE_STATE.groupIndicator || "#4fd1c5");
       const topbarHeight = PAGE_STATE.topbarHeight || 52;
       const sidebarWidth = PAGE_STATE.sidebarWidth || 350;
       const mobileFooterHeight = PAGE_STATE.mobileFooterHeight || 40;
       root.style.setProperty("--topbar-height", topbarHeight + "px");
       root.style.setProperty("--sidebar-width", sidebarWidth + "px");
       root.style.setProperty("--mobile-footer-height", mobileFooterHeight + "vh");
       const mainEl = document.querySelector("main");
       const detailsPanel = document.getElementById("details-panel");
       const sidebarToggle = document.getElementById("sidebar-toggle");
       if (PAGE_STATE.sidebarCollapsed) {
        if (mainEl) mainEl.classList.add("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.add("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.add("collapsed");
         sidebarToggle.textContent = "▶";
        }
       } else {
        if (mainEl) mainEl.classList.remove("sidebar-collapsed");
        if (detailsPanel) detailsPanel.classList.remove("collapsed");
        if (sidebarToggle) {
         sidebarToggle.classList.remove("collapsed");
         sidebarToggle.textContent = "◀";
        }
       }
       if (PAGE_STATE.background) {
        document.body.style.background = PAGE_STATE.background;
       } else {
        document.body.style.background = `radial-gradient(circle at top, ${PAGE_STATE.canvasGradientTop || "#1e2532"} 0, ${PAGE_STATE.canvasGradientBottom || "#050608"} 70%)`;
       }
       document.title = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       const titleEl = document.getElementById("page-title");
       if (titleEl) {
        titleEl.textContent = PAGE_STATE.title || DEFAULT_PAGE_STATE.title;
       }
       const sidebarToggleEl = document.getElementById("sidebar-toggle");
       const isMobile = isMobileDevice();
       if (sidebarToggleEl) {
        sidebarToggleEl.style.display = isMobile ? "none" : "flex";
       }
       const viewOnlyMode = PAGE_STATE.viewOnly === true;
       const addNodeBtn = document.getElementById("add-node-btn");
       const addRackBtn = document.getElementById("add-rack-btn");
       const drawToolbar = document.getElementById("draw-toolbar");
       const topologyToolbar = document.getElementById("topology-toolbar");
       const bulkToolbar = document.getElementById("bulk-toolbar");
       if (addNodeBtn) addNodeBtn.style.display = viewOnlyMode ? "none" : "";
       if (addRackBtn) addRackBtn.style.display = viewOnlyMode ? "none" : "";
       if (viewOnlyMode) {
        if (drawToolbar) drawToolbar.style.setProperty('display', 'none', 'important');
        if (topologyToolbar) topologyToolbar.style.setProperty('display', 'none', 'important');
        if (bulkToolbar) bulkToolbar.style.display = "none";
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       if (bulkToolbarMobile) bulkToolbarMobile.style.display = viewOnlyMode ? "none" : "";
       ["draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.style.display = viewOnlyMode ? "none" : "";
       });
       document.body.classList.toggle("view-only-mode", viewOnlyMode);
      }
      (async function awakeTheImmortal() {
       let initialState = {};
       let decryptionCancelled = false;
       const stateEl = document.getElementById("topology-state");
       if (stateEl && stateEl.textContent.trim()) {
        try {
         let stateText = stateEl.textContent.trim();
         if (isEncrypted(stateText)) {
          let decrypted = false;
          let attempts = 0;
          const maxAttempts = 3;
          while (!decrypted && attempts < maxAttempts) {
           const password = prompt("This file is encrypted. Enter password to decrypt:\n(Attempt " + (attempts + 1) + " of " + maxAttempts + ")");
           if (!password) {
            alert("Decryption cancelled. The file will not be loaded.");
            decryptionCancelled = true;
            break;
           }
           try {
            stateText = await decryptData(stateText, password);
            decrypted = true;
           } catch (e) {
            attempts++;
            if (attempts < maxAttempts) {
             alert("Incorrect password. Please try again.");
            } else {
             alert("Maximum attempts reached. The file will not be loaded.");
             decryptionCancelled = true;
            }
           }
          }
          if (!decrypted) {
           stateText = "{}";
          }
         }
         initialState = JSON.parse(stateText);
        } catch (e) {
         console.error("Failed to load state:", e);
         initialState = {};
        }
       }
       if (decryptionCancelled) {
        NODE_DATA = {};
        EDGE_DATA = {
         list: []
        };
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        EDGE_LEGEND = {};
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
       } else {
        NODE_DATA = initialState.nodeData ? initialState.nodeData : BASE_NODE_DATA;
        EDGE_DATA = initialState.edgeData ? initialState.edgeData : {
         list: [],
        };
        RECT_DATA = initialState.rectData ? initialState.rectData : { list: [] };
        TEXT_DATA = initialState.textData ? initialState.textData : { list: [] };
        EDGE_LEGEND = initialState.edgeLegend || {};
        savedPositions = initialState.nodePositions || {};
        savedSizes = initialState.nodeSizes || {};
        savedStyles = initialState.nodeStyles || {};
       }
       if (initialState.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, initialState.page);
       }
       if (initialState.canvas) {
        canvasState.zoom = initialState.canvas.zoom || 1;
        canvasState.panX = initialState.canvas.panX || 0;
        canvasState.panY = initialState.canvas.panY || 0;
       }
       if (initialState.savedTopologyView) {
        savedTopologyView = initialState.savedTopologyView;
       }
       if (initialState.documentTabs) {
        documentTabs = initialState.documentTabs;
        currentTabIndex = initialState.currentTabIndex || 0;
        const currentTab = documentTabs[currentTabIndex];
        if (currentTab) {
          NODE_DATA = currentTab.nodes || NODE_DATA;
          EDGE_DATA = currentTab.edges || EDGE_DATA;
          savedPositions = currentTab.positions || savedPositions;
          savedSizes = currentTab.sizes || savedSizes;
          savedStyles = currentTab.styles || savedStyles;
          EDGE_LEGEND = currentTab.legend || EDGE_LEGEND;
          RECT_DATA = currentTab.rects || RECT_DATA;
          TEXT_DATA = currentTab.texts || TEXT_DATA;
      if (currentTab.pageState) PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, currentTab.pageState);
        }
       }
       if (initialState.encryptedSections) {
        encryptedSections = initialState.encryptedSections;
       }
       wieldThePower();
       forgeTheTopology();
       updateViewBox();
       MobileManager.applyAll();
       const initialNodes = Object.keys(NODE_DATA);
       if (initialNodes.length > 0) {
        claimTheImmortal(initialNodes.includes("host") ? "host" : initialNodes[0]);
       } else {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
       }
       if (Object.keys(NODE_DATA).length === 0 && EDGE_DATA.list.length === 0) {
        checkForAutosaveRecovery();
       }
       startAutosave();
      })();
      let resizeDebounceTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeDebounceTimer);
        resizeDebounceTimer = setTimeout(() => {
          MobileManager.applyAll();
          if (typeof updateDrawToolbarVisibility === 'function') updateDrawToolbarVisibility();
          if (typeof updateTopologyToolbarVisibility === 'function') updateTopologyToolbarVisibility();
        }, 100);
      });
      function getBreakpointKey() {
       const w = window.innerWidth;
       if (w <= 380) return "fold";
       if (w <= 768) return "mobile";
       if (w <= 1024) return "tablet";
       return "desktop";
      }
      function resolveStylesEntry(styleEntry) {
       if (!styleEntry) return {};
       if (styleEntry.circleColor || styleEntry.titleColor || styleEntry.titleFont || styleEntry.titleSize || styleEntry.subColor || styleEntry.subFont || styleEntry.subSize) {
        return styleEntry;
       }
       const bp = getBreakpointKey();
       const base = styleEntry.all || {};
       const bpStyles = styleEntry[bp] || {};
       return Object.assign({}, base, bpStyles);
      }
      function resolveStylesForNode(id) {
       const styleEntry = savedStyles[id];
       if (!styleEntry) return {};
       return resolveStylesEntry(styleEntry);
      }
      function ensureStyleEntry(id) {
       if (!savedStyles[id]) savedStyles[id] = {};
       const entry = savedStyles[id];
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(entry, p));
       if (isFlat) {
        const all = entry.all || {};
        flatProps.forEach((p) => {
         if (entry[p] !== undefined) {
          all[p] = entry[p];
          delete entry[p];
         }
        });
        entry.all = all;
       }
       return entry;
      }
      function getDefaultSize() {
       if (window.innerWidth <= 380) return 120;
       if (window.innerWidth <= 768) return 140;
       if (window.innerWidth <= 1024) return 70;
       return 55;
      }
      function createShapeElement(shape, size) {
       const ns = "http://www.w3.org/2000/svg";
       if (shape === "circle") {
        const c = document.createElementNS(ns, "circle");
        c.setAttribute("r", size);
        return c;
       }
       if (shape === "square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 2;
        r.setAttribute("x", -size);
        r.setAttribute("y", -size);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", 4);
        return r;
       }
       if (shape === "rectangle") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.4);
        r.setAttribute("y", -size * 0.8);
        r.setAttribute("width", size * 2.8);
        r.setAttribute("height", size * 1.6);
        r.setAttribute("rx", 6);
        return r;
       }
       if (shape === "triangle") {
        const p = document.createElementNS(ns, "polygon");
        const h = size * 1.8;
        const w = size * 2;
        p.setAttribute("points", `0,${-h} ${w / 2},${h / 2} ${-w / 2},${h / 2}`);
        return p;
       }
       if (shape === "hexagon") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const pts = [
         [0, -s],
         [s * 0.86, -s * 0.5],
         [s * 0.86, s * 0.5],
         [0, s],
         [-s * 0.86, s * 0.5],
         [-s * 0.86, -s * 0.5],
        ].map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "stop-sign") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const ptsArr = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i + Math.PI / 8;
         ptsArr.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        const pts = ptsArr.map((pt) => pt.join(",")).join(" ");
        p.setAttribute("points", pts);
        return p;
       }
       if (shape === "star") {
        const p = document.createElementNS(ns, "polygon");
        const outer = size;
        const inner = size * 0.45;
        let pts = "";
        for (let i = 0; i < 10; i++) {
         const a = (Math.PI / 5) * i - Math.PI / 2;
         const r = i % 2 === 0 ? outer : inner;
         pts += `${Math.cos(a) * r},${Math.sin(a) * r} `;
        }
        p.setAttribute("points", pts.trim());
        return p;
       }
       if (shape === "diamond") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `0,${-s} ${s},0 0,${s} ${-s},0`);
        return p;
       }
       if (shape === "server") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.2);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 2.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y1", -size * 0.3);
         line.setAttribute("x2", -size * 0.9 + i * size * 0.5);
         line.setAttribute("y2", size * 0.3);
         line.style.stroke = "currentColor";
         line.style.strokeWidth = "2";
         line.style.opacity = "0.5";
         g.appendChild(line);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", size * 0.9);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "pc" || shape === "desktop") {
        const g = document.createElementNS(ns, "g");
        const monitor = document.createElementNS(ns, "rect");
        monitor.setAttribute("x", -size * 0.9);
        monitor.setAttribute("y", -size * 0.8);
        monitor.setAttribute("width", size * 1.8);
        monitor.setAttribute("height", size * 1.2);
        monitor.setAttribute("rx", 4);
        g.appendChild(monitor);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.75);
        screen.setAttribute("y", -size * 0.65);
        screen.setAttribute("width", size * 1.5);
        screen.setAttribute("height", size * 0.9);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const neck = document.createElementNS(ns, "rect");
        neck.setAttribute("x", -size * 0.15);
        neck.setAttribute("y", size * 0.4);
        neck.setAttribute("width", size * 0.3);
        neck.setAttribute("height", size * 0.3);
        g.appendChild(neck);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.5);
        base.setAttribute("y", size * 0.7);
        base.setAttribute("width", size * 1);
        base.setAttribute("height", size * 0.15);
        base.setAttribute("rx", 2);
        g.appendChild(base);
        return g;
       }
       if (shape === "laptop") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.8);
        screen.setAttribute("y", -size * 0.9);
        screen.setAttribute("width", size * 1.6);
        screen.setAttribute("height", size * 1.1);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.9);
        base.setAttribute("y", size * 0.25);
        base.setAttribute("width", size * 1.8);
        base.setAttribute("height", size * 0.6);
        base.setAttribute("rx", 4);
        g.appendChild(base);
        const pad = document.createElementNS(ns, "rect");
        pad.setAttribute("x", -size * 0.25);
        pad.setAttribute("y", size * 0.45);
        pad.setAttribute("width", size * 0.5);
        pad.setAttribute("height", size * 0.25);
        pad.setAttribute("rx", 2);
        pad.style.fill = "#1e293b";
        g.appendChild(pad);
        return g;
       }
       if (shape === "phone" || shape === "mobile") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 0.9);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.38);
        screen.setAttribute("y", -size * 0.85);
        screen.setAttribute("width", size * 0.76);
        screen.setAttribute("height", size * 1.6);
        screen.setAttribute("rx", 4);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const btn = document.createElementNS(ns, "rect");
        btn.setAttribute("x", -size * 0.15);
        btn.setAttribute("y", size * 0.82);
        btn.setAttribute("width", size * 0.3);
        btn.setAttribute("height", size * 0.06);
        btn.setAttribute("rx", 2);
        btn.style.fill = "#475569";
        g.appendChild(btn);
        return g;
       }
       if (shape === "router") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.1);
        body.setAttribute("y", -size * 0.3);
        body.setAttribute("width", size * 2.2);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        for (let i = -1; i <= 1; i++) {
         const ant = document.createElementNS(ns, "rect");
         ant.setAttribute("x", i * size * 0.6 - size * 0.05);
         ant.setAttribute("y", -size * 0.9);
         ant.setAttribute("width", size * 0.1);
         ant.setAttribute("height", size * 0.6);
         ant.setAttribute("rx", 2);
         g.appendChild(ant);
         const tip = document.createElementNS(ns, "circle");
         tip.setAttribute("cx", i * size * 0.6);
         tip.setAttribute("cy", -size * 0.95);
         tip.setAttribute("r", size * 0.08);
         g.appendChild(tip);
        }
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.7 + i * size * 0.35);
         led.setAttribute("cy", size * 0.1);
         led.setAttribute("r", size * 0.06);
         led.style.fill = i < 2 ? "#4ade80" : "#facc15";
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "switch") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 1.4);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2.8);
        body.setAttribute("height", size * 0.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 8; i++) {
         const port = document.createElementNS(ns, "rect");
         port.setAttribute("x", -size * 1.2 + i * size * 0.32);
         port.setAttribute("y", -size * 0.15);
         port.setAttribute("width", size * 0.22);
         port.setAttribute("height", size * 0.3);
         port.setAttribute("rx", 1);
         port.style.fill = "#1e293b";
         g.appendChild(port);
        }
        return g;
       }
       if (shape === "firewall") {
        const g = document.createElementNS(ns, "g");
        const wall = document.createElementNS(ns, "rect");
        wall.setAttribute("x", -size);
        wall.setAttribute("y", -size * 0.8);
        wall.setAttribute("width", size * 2);
        wall.setAttribute("height", size * 1.6);
        wall.setAttribute("rx", 4);
        g.appendChild(wall);
        for (let row = 0; row < 3; row++) {
         const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", -size * 0.85);
         line.setAttribute("y1", -size * 0.5 + row * size * 0.45);
         line.setAttribute("x2", size * 0.85);
         line.setAttribute("y2", -size * 0.5 + row * size * 0.45);
         line.style.stroke = "#475569";
         line.style.strokeWidth = "2";
         g.appendChild(line);
        }
        for (let row = 0; row < 4; row++) {
         const offset = row % 2 === 0 ? 0 : size * 0.35;
         for (let col = 0; col < 3; col++) {
          const line = document.createElementNS(ns, "line");
          const x = -size * 0.5 + col * size * 0.7 + offset;
          if (x > -size * 0.85 && x < size * 0.85) {
           line.setAttribute("x1", x);
           line.setAttribute("y1", -size * 0.8 + row * size * 0.45);
           line.setAttribute("x2", x);
           line.setAttribute("y2", -size * 0.8 + row * size * 0.45 + size * 0.45);
           line.style.stroke = "#475569";
           line.style.strokeWidth = "2";
           g.appendChild(line);
          }
         }
        }
        return g;
       }
       if (shape === "cloud") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `
             M ${-s * 0.8} ${s * 0.2}
             Q ${-s * 1.1} ${s * 0.2} ${-s * 1.1} ${-s * 0.1}
             Q ${-s * 1.1} ${-s * 0.5} ${-s * 0.7} ${-s * 0.5}
             Q ${-s * 0.7} ${-s * 0.9} ${-s * 0.2} ${-s * 0.9}
             Q ${s * 0.1} ${-s * 1.1} ${s * 0.5} ${-s * 0.8}
             Q ${s * 1} ${-s * 0.8} ${s * 1.1} ${-s * 0.3}
             Q ${s * 1.3} ${-s * 0.1} ${s * 1.1} ${s * 0.2}
             Q ${s * 1.1} ${s * 0.5} ${s * 0.7} ${s * 0.5}
             L ${-s * 0.5} ${s * 0.5}
             Q ${-s * 0.9} ${s * 0.5} ${-s * 0.9} ${s * 0.2}
             Z
            `);
        return p;
       }
       if (shape === "database") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.4);
        g.appendChild(body);
        const top = document.createElementNS(ns, "ellipse");
        top.setAttribute("cx", 0);
        top.setAttribute("cy", -size * 0.6);
        top.setAttribute("rx", size * 0.7);
        top.setAttribute("ry", size * 0.25);
        g.appendChild(top);
        const bottom = document.createElementNS(ns, "ellipse");
        bottom.setAttribute("cx", 0);
        bottom.setAttribute("cy", size * 0.8);
        bottom.setAttribute("rx", size * 0.7);
        bottom.setAttribute("ry", size * 0.25);
        g.appendChild(bottom);
        const mid1 = document.createElementNS(ns, "ellipse");
        mid1.setAttribute("cx", 0);
        mid1.setAttribute("cy", -size * 0.15);
        mid1.setAttribute("rx", size * 0.7);
        mid1.setAttribute("ry", size * 0.2);
        mid1.style.fill = "none";
        mid1.style.stroke = "#475569";
        mid1.style.strokeWidth = "2";
        g.appendChild(mid1);
        const mid2 = document.createElementNS(ns, "ellipse");
        mid2.setAttribute("cx", 0);
        mid2.setAttribute("cy", size * 0.35);
        mid2.setAttribute("rx", size * 0.7);
        mid2.setAttribute("ry", size * 0.2);
        mid2.style.fill = "none";
        mid2.style.stroke = "#475569";
        mid2.style.strokeWidth = "2";
        g.appendChild(mid2);
        return g;
       }
       if (shape === "printer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.4);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 0.9);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const trayTop = document.createElementNS(ns, "rect");
        trayTop.setAttribute("x", -size * 0.7);
        trayTop.setAttribute("y", -size * 0.8);
        trayTop.setAttribute("width", size * 1.4);
        trayTop.setAttribute("height", size * 0.4);
        trayTop.setAttribute("rx", 2);
        trayTop.style.fill = "#1e293b";
        g.appendChild(trayTop);
        const trayOut = document.createElementNS(ns, "rect");
        trayOut.setAttribute("x", -size * 0.6);
        trayOut.setAttribute("y", size * 0.5);
        trayOut.setAttribute("width", size * 1.2);
        trayOut.setAttribute("height", size * 0.35);
        trayOut.setAttribute("rx", 2);
        g.appendChild(trayOut);
        const paper = document.createElementNS(ns, "rect");
        paper.setAttribute("x", -size * 0.5);
        paper.setAttribute("y", size * 0.3);
        paper.setAttribute("width", size * 1);
        paper.setAttribute("height", size * 0.5);
        paper.style.fill = "#e2e8f0";
        g.appendChild(paper);
        return g;
       }
       if (shape === "access-point" || shape === "wifi") {
        const g = document.createElementNS(ns, "g");
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.3);
        base.setAttribute("y", size * 0.2);
        base.setAttribute("width", size * 0.6);
        base.setAttribute("height", size * 0.3);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        for (let i = 1; i <= 3; i++) {
         const arc = document.createElementNS(ns, "path");
         const r = size * 0.3 * i;
         arc.setAttribute("d", `M ${-r * 0.7} ${size * 0.1 - r * 0.5} A ${r} ${r} 0 0 1 ${r * 0.7} ${size * 0.1 - r * 0.5}`);
         arc.style.fill = "none";
         arc.style.stroke = "currentColor";
         arc.style.strokeWidth = "2";
         arc.style.opacity = 1 - (i * 0.2);
         g.appendChild(arc);
        }
        return g;
       }
       if (shape === "load-balancer") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const bar = document.createElementNS(ns, "line");
        bar.setAttribute("x1", -size * 0.6);
        bar.setAttribute("y1", 0);
        bar.setAttribute("x2", size * 0.6);
        bar.setAttribute("y2", 0);
        bar.style.stroke = "#4ade80";
        bar.style.strokeWidth = "3";
        g.appendChild(bar);
        [-1, 1].forEach(dir => {
         const arrow = document.createElementNS(ns, "path");
         arrow.setAttribute("d", `M ${dir * size * 0.3} ${-size * 0.2} L ${dir * size * 0.6} 0 L ${dir * size * 0.3} ${size * 0.2}`);
         arrow.style.fill = "none";
         arrow.style.stroke = "#4ade80";
         arrow.style.strokeWidth = "2";
         g.appendChild(arrow);
        });
        return g;
       }
       if (shape === "nas" || shape === "storage") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const bay = document.createElementNS(ns, "rect");
         bay.setAttribute("x", -size * 0.6);
         bay.setAttribute("y", -size * 0.7 + i * size * 0.4);
         bay.setAttribute("width", size * 1.2);
         bay.setAttribute("height", size * 0.3);
         bay.setAttribute("rx", 2);
         bay.style.fill = "#1e293b";
         g.appendChild(bay);
        }
        return g;
       }
       if (shape === "gateway" || shape === "modem") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size * 0.9);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 1.8);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", 0);
         led.setAttribute("cy", -size * 0.6 + i * size * 0.35);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#4ade80", "#facc15", "#60a5fa"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "vpn" || shape === "tunnel") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "ellipse");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("rx", size);
        outer.setAttribute("ry", size * 0.6);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "ellipse");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("rx", size * 0.5);
        inner.setAttribute("ry", size * 0.3);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const lock = document.createElementNS(ns, "rect");
        lock.setAttribute("x", -size * 0.15);
        lock.setAttribute("y", -size * 0.1);
        lock.setAttribute("width", size * 0.3);
        lock.setAttribute("height", size * 0.25);
        lock.setAttribute("rx", 2);
        lock.style.fill = "#4ade80";
        g.appendChild(lock);
        return g;
       }
       if (shape === "container") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 3; i++) {
         const block = document.createElementNS(ns, "rect");
         block.setAttribute("x", -size * 0.8 + i * size * 0.55);
         block.setAttribute("y", -size * 0.3);
         block.setAttribute("width", size * 0.45);
         block.setAttribute("height", size * 0.6);
         block.setAttribute("rx", 2);
         block.style.fill = "#1e293b";
         g.appendChild(block);
        }
        return g;
       }
       if (shape === "vm" || shape === "virtual") {
        const g = document.createElementNS(ns, "g");
        const shadow = document.createElementNS(ns, "rect");
        shadow.setAttribute("x", -size * 0.85 + 4);
        shadow.setAttribute("y", -size * 0.65 + 4);
        shadow.setAttribute("width", size * 1.7);
        shadow.setAttribute("height", size * 1.3);
        shadow.setAttribute("rx", 4);
        shadow.style.opacity = "0.3";
        g.appendChild(shadow);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.85);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 1.7);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 0.65);
        screen.setAttribute("y", -size * 0.45);
        screen.setAttribute("width", size * 1.3);
        screen.setAttribute("height", size * 0.7);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        return g;
       }
       if (shape === "kubernetes" || shape === "k8s") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("cx", 0);
        outer.setAttribute("cy", 0);
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("cx", 0);
        inner.setAttribute("cy", 0);
        inner.setAttribute("r", size * 0.4);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 7; i++) {
         const angle = (Math.PI * 2 / 7) * i - Math.PI / 2;
         const spoke = document.createElementNS(ns, "line");
         spoke.setAttribute("x1", Math.cos(angle) * size * 0.4);
         spoke.setAttribute("y1", Math.sin(angle) * size * 0.4);
         spoke.setAttribute("x2", Math.cos(angle) * size * 0.85);
         spoke.setAttribute("y2", Math.sin(angle) * size * 0.85);
         spoke.style.stroke = "#326ce5";
         spoke.style.strokeWidth = "3";
         g.appendChild(spoke);
        }
        return g;
       }
       if (shape === "shield" || shape === "security") {
        const p = document.createElementNS(ns, "path");
        const s = size;
        p.setAttribute("d", `M 0 ${-s} L ${s * 0.85} ${-s * 0.5} L ${s * 0.85} ${s * 0.2} Q ${s * 0.7} ${s * 0.9} 0 ${s} Q ${-s * 0.7} ${s * 0.9} ${-s * 0.85} ${s * 0.2} L ${-s * 0.85} ${-s * 0.5} Z`);
        return p;
       }
       if (shape === "camera" || shape === "cctv") {
        const g = document.createElementNS(ns, "g");
        const mount = document.createElementNS(ns, "rect");
        mount.setAttribute("x", -size * 1.1);
        mount.setAttribute("y", -size * 0.5);
        mount.setAttribute("width", size * 0.25);
        mount.setAttribute("height", size * 0.6);
        mount.setAttribute("rx", 2);
        g.appendChild(mount);
        const arm = document.createElementNS(ns, "rect");
        arm.setAttribute("x", -size * 0.9);
        arm.setAttribute("y", -size * 0.15);
        arm.setAttribute("width", size * 0.5);
        arm.setAttribute("height", size * 0.15);
        g.appendChild(arm);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.45);
        body.setAttribute("y", -size * 0.35);
        body.setAttribute("width", size * 1.1);
        body.setAttribute("height", size * 0.7);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lensHousing = document.createElementNS(ns, "circle");
        lensHousing.setAttribute("cx", size * 0.85);
        lensHousing.setAttribute("cy", 0);
        lensHousing.setAttribute("r", size * 0.4);
        g.appendChild(lensHousing);
        const lensOuter = document.createElementNS(ns, "circle");
        lensOuter.setAttribute("cx", size * 0.85);
        lensOuter.setAttribute("cy", 0);
        lensOuter.setAttribute("r", size * 0.28);
        lensOuter.style.fill = "#1e293b";
        g.appendChild(lensOuter);
        const lensInner = document.createElementNS(ns, "circle");
        lensInner.setAttribute("cx", size * 0.85);
        lensInner.setAttribute("cy", 0);
        lensInner.setAttribute("r", size * 0.15);
        lensInner.style.fill = "#3b82f6";
        g.appendChild(lensInner);
        const reflection = document.createElementNS(ns, "circle");
        reflection.setAttribute("cx", size * 0.8);
        reflection.setAttribute("cy", -size * 0.05);
        reflection.setAttribute("r", size * 0.05);
        reflection.style.fill = "#93c5fd";
        g.appendChild(reflection);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", -size * 0.2);
        led.setAttribute("cy", -size * 0.15);
        led.setAttribute("r", size * 0.06);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "monitor" || shape === "dashboard") {
        const g = document.createElementNS(ns, "g");
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size);
        screen.setAttribute("y", -size * 0.7);
        screen.setAttribute("width", size * 2);
        screen.setAttribute("height", size * 1.2);
        screen.setAttribute("rx", 4);
        g.appendChild(screen);
        const graph = document.createElementNS(ns, "polyline");
        graph.setAttribute("points", `${-size * 0.8},${size * 0.2} ${-size * 0.3},${-size * 0.2} ${size * 0.2},${size * 0.1} ${size * 0.7},${-size * 0.3}`);
        graph.style.fill = "none";
        graph.style.stroke = "#4ade80";
        graph.style.strokeWidth = "3";
        g.appendChild(graph);
        return g;
       }
       if (shape === "docker" || shape === "whale") {
        const g = document.createElementNS(ns, "g");
        const s = size;
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `
         M ${-s * 0.9} ${s * 0.2}
         Q ${-s * 1.1} ${s * 0.5} ${-s * 0.7} ${s * 0.7}
         Q ${-s * 0.3} ${s * 0.85} ${s * 0.3} ${s * 0.75}
         Q ${s * 0.8} ${s * 0.6} ${s * 1.0} ${s * 0.3}
         Q ${s * 1.1} ${s * 0.1} ${s * 1.0} ${-s * 0.1}
         L ${s * 0.85} ${-s * 0.1}
         Q ${s * 0.7} ${-s * 0.15} ${s * 0.4} ${-s * 0.2}
         L ${-s * 0.5} ${-s * 0.2}
         Q ${-s * 0.8} ${-s * 0.1} ${-s * 0.9} ${s * 0.2}
         Z
        `);
        body.style.fill = "#0db7ed";
        g.appendChild(body);
        const tail = document.createElementNS(ns, "path");
        tail.setAttribute("d", `
         M ${-s * 0.85} ${s * 0.1}
         Q ${-s * 1.2} ${-s * 0.2} ${-s * 1.0} ${-s * 0.55}
         Q ${-s * 0.95} ${-s * 0.35} ${-s * 0.8} ${-s * 0.15}
         Z
        `);
        tail.style.fill = "#0db7ed";
        g.appendChild(tail);
        const belly = document.createElementNS(ns, "path");
        belly.setAttribute("d", `
         M ${-s * 0.5} ${s * 0.65}
         Q ${s * 0.1} ${s * 0.75} ${s * 0.6} ${s * 0.55}
         Q ${s * 0.8} ${s * 0.45} ${s * 0.9} ${s * 0.25}
         Q ${s * 0.7} ${s * 0.5} ${s * 0.3} ${s * 0.6}
         Q ${-s * 0.1} ${s * 0.7} ${-s * 0.5} ${s * 0.65}
         Z
        `);
        belly.style.fill = "#ffffff";
        belly.style.opacity = "0.3";
        g.appendChild(belly);
        for (let row = 0; row < 2; row++) {
         for (let col = 0; col < 3; col++) {
          const container = document.createElementNS(ns, "rect");
          container.setAttribute("x", -s * 0.45 + col * s * 0.35);
          container.setAttribute("y", -s * 0.7 + row * s * 0.28);
          container.setAttribute("width", s * 0.3);
          container.setAttribute("height", s * 0.23);
          container.setAttribute("rx", 2);
          container.style.fill = "#0db7ed";
          container.style.stroke = "#0a9ed8";
          container.style.strokeWidth = "1.5";
          g.appendChild(container);
         }
        }
        const topContainer = document.createElementNS(ns, "rect");
        topContainer.setAttribute("x", -s * 0.1);
        topContainer.setAttribute("y", -s * 0.95);
        topContainer.setAttribute("width", s * 0.3);
        topContainer.setAttribute("height", s * 0.23);
        topContainer.setAttribute("rx", 2);
        topContainer.style.fill = "#0db7ed";
        topContainer.style.stroke = "#0a9ed8";
        topContainer.style.strokeWidth = "1.5";
        g.appendChild(topContainer);
        const eye = document.createElementNS(ns, "circle");
        eye.setAttribute("cx", s * 0.65);
        eye.setAttribute("cy", s * 0.25);
        eye.setAttribute("r", s * 0.08);
        eye.style.fill = "#0a5f7a";
        g.appendChild(eye);
        return g;
       }
       if (shape === "rounded-square") {
        const r = document.createElementNS(ns, "rect");
        const s = size * 1.6;
        r.setAttribute("x", -s / 2);
        r.setAttribute("y", -s / 2);
        r.setAttribute("width", s);
        r.setAttribute("height", s);
        r.setAttribute("rx", size * 0.4);
        return r;
       }
       if (shape === "pill" || shape === "capsule") {
        const r = document.createElementNS(ns, "rect");
        r.setAttribute("x", -size * 1.2);
        r.setAttribute("y", -size * 0.5);
        r.setAttribute("width", size * 2.4);
        r.setAttribute("height", size);
        r.setAttribute("rx", size * 0.5);
        return r;
       }
       if (shape === "octagon") {
        const p = document.createElementNS(ns, "polygon");
        const r = size;
        const pts = [];
        for (let i = 0; i < 8; i++) {
         const a = (Math.PI / 4) * i - Math.PI / 8;
         pts.push([Math.cos(a) * r, Math.sin(a) * r]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "pentagon") {
        const p = document.createElementNS(ns, "polygon");
        const pts = [];
        for (let i = 0; i < 5; i++) {
         const a = (Math.PI * 2 / 5) * i - Math.PI / 2;
         pts.push([Math.cos(a) * size, Math.sin(a) * size]);
        }
        p.setAttribute("points", pts.map(pt => pt.join(",")).join(" "));
        return p;
       }
       if (shape === "cross" || shape === "plus") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        const t = size * 0.35;
        p.setAttribute("points", `${-t},${-s} ${t},${-s} ${t},${-t} ${s},${-t} ${s},${t} ${t},${t} ${t},${s} ${-t},${s} ${-t},${t} ${-s},${t} ${-s},${-t} ${-t},${-t}`);
        return p;
       }
       if (shape === "parallelogram") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 1.2},${-s * 0.6} ${s * 0.6},${s * 0.6} ${-s * 1.2},${s * 0.6}`);
        return p;
       }
       if (shape === "trapezoid") {
        const p = document.createElementNS(ns, "polygon");
        const s = size;
        p.setAttribute("points", `${-s * 0.6},${-s * 0.6} ${s * 0.6},${-s * 0.6} ${s},${s * 0.6} ${-s},${s * 0.6}`);
        return p;
       }
       if (shape === "sensor" || shape === "iot") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("cx", 0);
        body.setAttribute("cy", 0);
        body.setAttribute("r", size * 0.7);
        g.appendChild(body);
        const ant = document.createElementNS(ns, "line");
        ant.setAttribute("x1", 0);
        ant.setAttribute("y1", -size * 0.7);
        ant.setAttribute("x2", 0);
        ant.setAttribute("y2", -size);
        ant.style.stroke = "currentColor";
        ant.style.strokeWidth = "2";
        g.appendChild(ant);
        const tip = document.createElementNS(ns, "circle");
        tip.setAttribute("cx", 0);
        tip.setAttribute("cy", -size);
        tip.setAttribute("r", size * 0.1);
        tip.style.fill = "#4ade80";
        g.appendChild(tip);
        return g;
       }
       if (shape === "pi" || shape === "sbc" || shape === "raspberry") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size);
        body.setAttribute("y", -size * 0.65);
        body.setAttribute("width", size * 2);
        body.setAttribute("height", size * 1.3);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        for (let i = 0; i < 10; i++) {
         const pin = document.createElementNS(ns, "rect");
         pin.setAttribute("x", -size * 0.85 + i * size * 0.19);
         pin.setAttribute("y", -size * 0.8);
         pin.setAttribute("width", size * 0.08);
         pin.setAttribute("height", size * 0.15);
         pin.style.fill = "#facc15";
         g.appendChild(pin);
        }
        const port = document.createElementNS(ns, "rect");
        port.setAttribute("x", size * 0.6);
        port.setAttribute("y", -size * 0.2);
        port.setAttribute("width", size * 0.35);
        port.setAttribute("height", size * 0.4);
        port.style.fill = "#1e293b";
        g.appendChild(port);
        return g;
       }
       if (shape === "api" || shape === "endpoint") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.7);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size * 1.4);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const left = document.createElementNS(ns, "text");
        left.setAttribute("x", -size * 0.5);
        left.setAttribute("y", size * 0.15);
        left.setAttribute("font-size", size * 0.9);
        left.setAttribute("fill", "#4ade80");
        left.setAttribute("font-family", "monospace");
        left.textContent = "{";
        g.appendChild(left);
        const right = document.createElementNS(ns, "text");
        right.setAttribute("x", size * 0.15);
        right.setAttribute("y", size * 0.15);
        right.setAttribute("font-size", size * 0.9);
        right.setAttribute("fill", "#4ade80");
        right.setAttribute("font-family", "monospace");
        right.textContent = "}";
        g.appendChild(right);
        return g;
       }
       if (shape === "queue" || shape === "message") {
        const g = document.createElementNS(ns, "g");
        for (let i = 2; i >= 0; i--) {
         const card = document.createElementNS(ns, "rect");
         card.setAttribute("x", -size * 0.7 + i * 4);
         card.setAttribute("y", -size * 0.5 + i * 4);
         card.setAttribute("width", size * 1.4);
         card.setAttribute("height", size * 0.8);
         card.setAttribute("rx", 3);
         card.style.opacity = 1 - i * 0.25;
         g.appendChild(card);
        }
        return g;
       }
       if (shape === "lambda" || shape === "function") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.8);
        body.setAttribute("y", -size * 0.8);
        body.setAttribute("width", size * 1.6);
        body.setAttribute("height", size * 1.6);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const lambda = document.createElementNS(ns, "text");
        lambda.setAttribute("x", 0);
        lambda.setAttribute("y", size * 0.2);
        lambda.setAttribute("font-size", size * 1.2);
        lambda.setAttribute("fill", "#f59e0b");
        lambda.setAttribute("text-anchor", "middle");
        lambda.setAttribute("font-family", "serif");
        lambda.textContent = "λ";
        g.appendChild(lambda);
        return g;
       }
       if (shape === "bucket" || shape === "s3") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "path");
        body.setAttribute("d", `M ${-size * 0.8} ${-size * 0.7} L ${-size * 0.6} ${size * 0.8} Q ${-size * 0.5} ${size} 0 ${size} Q ${size * 0.5} ${size} ${size * 0.6} ${size * 0.8} L ${size * 0.8} ${-size * 0.7} Z`);
        g.appendChild(body);
        const rim = document.createElementNS(ns, "ellipse");
        rim.setAttribute("cx", 0);
        rim.setAttribute("cy", -size * 0.7);
        rim.setAttribute("rx", size * 0.8);
        rim.setAttribute("ry", size * 0.25);
        g.appendChild(rim);
        return g;
       }

       if (shape === "thermostat") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.75);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        const temp = document.createElementNS(ns, "text");
        temp.setAttribute("x", 0);
        temp.setAttribute("y", size * 0.15);
        temp.setAttribute("font-size", size * 0.5);
        temp.setAttribute("fill", "#4ade80");
        temp.setAttribute("text-anchor", "middle");
        temp.setAttribute("font-family", "monospace");
        temp.textContent = "72°";
        g.appendChild(temp);
        return g;
       }
       if (shape === "doorbell") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.5);
        body.setAttribute("y", -size);
        body.setAttribute("width", size);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.25);
        g.appendChild(body);
        const lens = document.createElementNS(ns, "circle");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.35);
        lens.setAttribute("r", size * 0.3);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const lensDot = document.createElementNS(ns, "circle");
        lensDot.setAttribute("cx", 0);
        lensDot.setAttribute("cy", -size * 0.35);
        lensDot.setAttribute("r", size * 0.12);
        lensDot.style.fill = "#3b82f6";
        g.appendChild(lensDot);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.5);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#f59e0b";
        g.appendChild(btn);
        return g;
       }
       if (shape === "smart-lock") {
        const g = document.createElementNS(ns, "g");
        const shackle = document.createElementNS(ns, "path");
        shackle.setAttribute("d", `M ${-size * 0.4} ${-size * 0.1} L ${-size * 0.4} ${-size * 0.6} A ${size * 0.4} ${size * 0.4} 0 1 1 ${size * 0.4} ${-size * 0.6} L ${size * 0.4} ${-size * 0.1}`);
        shackle.style.fill = "none";
        shackle.style.strokeWidth = size * 0.2;
        g.appendChild(shackle);
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size * 0.15);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 1);
        body.setAttribute("rx", 4);
        g.appendChild(body);
        const keyhole = document.createElementNS(ns, "circle");
        keyhole.setAttribute("cx", 0);
        keyhole.setAttribute("cy", size * 0.3);
        keyhole.setAttribute("r", size * 0.15);
        keyhole.style.fill = "#4ade80";
        g.appendChild(keyhole);
        return g;
       }
       if (shape === "smart-bulb") {
        const g = document.createElementNS(ns, "g");
        const bulb = document.createElementNS(ns, "path");
        bulb.setAttribute("d", `M ${-size * 0.5} ${size * 0.2} Q ${-size * 0.8} ${-size * 0.3} ${-size * 0.5} ${-size * 0.7} Q 0 ${-size * 1.1} ${size * 0.5} ${-size * 0.7} Q ${size * 0.8} ${-size * 0.3} ${size * 0.5} ${size * 0.2} Z`);
        g.appendChild(bulb);
        const base1 = document.createElementNS(ns, "rect");
        base1.setAttribute("x", -size * 0.35);
        base1.setAttribute("y", size * 0.2);
        base1.setAttribute("width", size * 0.7);
        base1.setAttribute("height", size * 0.15);
        base1.style.fill = "#94a3b8";
        g.appendChild(base1);
        const base2 = document.createElementNS(ns, "rect");
        base2.setAttribute("x", -size * 0.3);
        base2.setAttribute("y", size * 0.35);
        base2.setAttribute("width", size * 0.6);
        base2.setAttribute("height", size * 0.15);
        base2.style.fill = "#64748b";
        g.appendChild(base2);
        const base3 = document.createElementNS(ns, "rect");
        base3.setAttribute("x", -size * 0.25);
        base3.setAttribute("y", size * 0.5);
        base3.setAttribute("width", size * 0.5);
        base3.setAttribute("height", size * 0.2);
        base3.setAttribute("rx", 2);
        base3.style.fill = "#475569";
        g.appendChild(base3);
        return g;
       }
       if (shape === "smart-plug") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.7);
        body.setAttribute("y", -size * 0.6);
        body.setAttribute("width", size * 1.4);
        body.setAttribute("height", size * 1.2);
        body.setAttribute("rx", 6);
        g.appendChild(body);
        const hole1 = document.createElementNS(ns, "rect");
        hole1.setAttribute("x", -size * 0.35);
        hole1.setAttribute("y", -size * 0.3);
        hole1.setAttribute("width", size * 0.15);
        hole1.setAttribute("height", size * 0.4);
        hole1.setAttribute("rx", 2);
        hole1.style.fill = "#1e293b";
        g.appendChild(hole1);
        const hole2 = document.createElementNS(ns, "rect");
        hole2.setAttribute("x", size * 0.2);
        hole2.setAttribute("y", -size * 0.3);
        hole2.setAttribute("width", size * 0.15);
        hole2.setAttribute("height", size * 0.4);
        hole2.setAttribute("rx", 2);
        hole2.style.fill = "#1e293b";
        g.appendChild(hole2);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.35);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "smart-speaker") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.6);
        body.setAttribute("y", -size);
        body.setAttribute("width", size * 1.2);
        body.setAttribute("height", size * 2);
        body.setAttribute("rx", size * 0.3);
        g.appendChild(body);
        const mesh = document.createElementNS(ns, "rect");
        mesh.setAttribute("x", -size * 0.5);
        mesh.setAttribute("y", -size * 0.3);
        mesh.setAttribute("width", size);
        mesh.setAttribute("height", size * 1.1);
        mesh.setAttribute("rx", 4);
        mesh.style.fill = "#1e293b";
        g.appendChild(mesh);
        const ring = document.createElementNS(ns, "circle");
        ring.setAttribute("cx", 0);
        ring.setAttribute("cy", -size * 0.65);
        ring.setAttribute("r", size * 0.2);
        ring.style.fill = "#3b82f6";
        g.appendChild(ring);
        return g;
       }
       if (shape === "smart-tv") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size * 1.4);
        frame.setAttribute("y", -size * 0.85);
        frame.setAttribute("width", size * 2.8);
        frame.setAttribute("height", size * 1.6);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        const screen = document.createElementNS(ns, "rect");
        screen.setAttribute("x", -size * 1.3);
        screen.setAttribute("y", -size * 0.75);
        screen.setAttribute("width", size * 2.6);
        screen.setAttribute("height", size * 1.4);
        screen.setAttribute("rx", 2);
        screen.style.fill = "#1e293b";
        g.appendChild(screen);
        const stand = document.createElementNS(ns, "rect");
        stand.setAttribute("x", -size * 0.8);
        stand.setAttribute("y", size * 0.75);
        stand.setAttribute("width", size * 1.6);
        stand.setAttribute("height", size * 0.12);
        stand.setAttribute("rx", 2);
        g.appendChild(stand);
        return g;
       }
       if (shape === "hub") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "rect");
        body.setAttribute("x", -size * 0.9);
        body.setAttribute("y", -size * 0.5);
        body.setAttribute("width", size * 1.8);
        body.setAttribute("height", size);
        body.setAttribute("rx", 8);
        g.appendChild(body);
        for (let i = 0; i < 4; i++) {
         const led = document.createElementNS(ns, "circle");
         led.setAttribute("cx", -size * 0.5 + i * size * 0.35);
         led.setAttribute("cy", 0);
         led.setAttribute("r", size * 0.08);
         led.style.fill = ["#4ade80", "#3b82f6", "#f59e0b", "#ef4444"][i];
         g.appendChild(led);
        }
        return g;
       }
       if (shape === "smoke-detector") {
        const g = document.createElementNS(ns, "g");
        const outer = document.createElementNS(ns, "circle");
        outer.setAttribute("r", size);
        g.appendChild(outer);
        const inner = document.createElementNS(ns, "circle");
        inner.setAttribute("r", size * 0.6);
        inner.style.fill = "#1e293b";
        g.appendChild(inner);
        for (let i = 0; i < 6; i++) {
         const slot = document.createElementNS(ns, "rect");
         const angle = (i * 60 - 90) * Math.PI / 180;
         slot.setAttribute("x", Math.cos(angle) * size * 0.35 - size * 0.08);
         slot.setAttribute("y", Math.sin(angle) * size * 0.35 - size * 0.03);
         slot.setAttribute("width", size * 0.16);
         slot.setAttribute("height", size * 0.06);
         slot.setAttribute("rx", 1);
         slot.style.fill = "#475569";
         slot.setAttribute("transform", `rotate(${i * 60}, ${Math.cos(angle) * size * 0.35}, ${Math.sin(angle) * size * 0.35})`);
         g.appendChild(slot);
        }
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", 0);
        led.setAttribute("r", size * 0.1);
        led.style.fill = "#ef4444";
        g.appendChild(led);
        return g;
       }
       if (shape === "motion-sensor") {
        const g = document.createElementNS(ns, "g");
        const dome = document.createElementNS(ns, "path");
        dome.setAttribute("d", `M ${-size * 0.8} ${size * 0.3} Q ${-size * 0.8} ${-size * 0.8} 0 ${-size * 0.8} Q ${size * 0.8} ${-size * 0.8} ${size * 0.8} ${size * 0.3} Z`);
        g.appendChild(dome);
        const base = document.createElementNS(ns, "rect");
        base.setAttribute("x", -size * 0.8);
        base.setAttribute("y", size * 0.3);
        base.setAttribute("width", size * 1.6);
        base.setAttribute("height", size * 0.35);
        base.setAttribute("rx", 3);
        g.appendChild(base);
        const lens = document.createElementNS(ns, "ellipse");
        lens.setAttribute("cx", 0);
        lens.setAttribute("cy", -size * 0.15);
        lens.setAttribute("rx", size * 0.35);
        lens.setAttribute("ry", size * 0.25);
        lens.style.fill = "#1e293b";
        g.appendChild(lens);
        const led = document.createElementNS(ns, "circle");
        led.setAttribute("cx", 0);
        led.setAttribute("cy", size * 0.45);
        led.setAttribute("r", size * 0.08);
        led.style.fill = "#4ade80";
        g.appendChild(led);
        return g;
       }
       if (shape === "garage") {
        const g = document.createElementNS(ns, "g");
        const frame = document.createElementNS(ns, "rect");
        frame.setAttribute("x", -size);
        frame.setAttribute("y", -size * 0.9);
        frame.setAttribute("width", size * 2);
        frame.setAttribute("height", size * 1.8);
        frame.setAttribute("rx", 4);
        g.appendChild(frame);
        for (let i = 0; i < 4; i++) {
         const panel = document.createElementNS(ns, "rect");
         panel.setAttribute("x", -size * 0.9);
         panel.setAttribute("y", -size * 0.8 + i * size * 0.42);
         panel.setAttribute("width", size * 1.8);
         panel.setAttribute("height", size * 0.35);
         panel.setAttribute("rx", 2);
         panel.style.fill = "#1e293b";
         g.appendChild(panel);
        }
        return g;
       }
       if (shape === "sprinkler") {
        const g = document.createElementNS(ns, "g");
        const head = document.createElementNS(ns, "circle");
        head.setAttribute("r", size * 0.5);
        g.appendChild(head);
        const nozzle = document.createElementNS(ns, "rect");
        nozzle.setAttribute("x", -size * 0.15);
        nozzle.setAttribute("y", size * 0.3);
        nozzle.setAttribute("width", size * 0.3);
        nozzle.setAttribute("height", size * 0.5);
        g.appendChild(nozzle);
        for (let i = 0; i < 5; i++) {
         const spray = document.createElementNS(ns, "line");
         const angle = (-60 + i * 30) * Math.PI / 180;
         spray.setAttribute("x1", 0);
         spray.setAttribute("y1", -size * 0.3);
         spray.setAttribute("x2", Math.cos(angle) * size * 0.8);
         spray.setAttribute("y2", Math.sin(angle) * size * 0.8 - size * 0.3);
         spray.style.stroke = "#3b82f6";
         spray.style.strokeWidth = "2";
         spray.style.strokeDasharray = "3,3";
         g.appendChild(spray);
        }
        return g;
       }
       if (shape === "vacuum") {
        const g = document.createElementNS(ns, "g");
        const body = document.createElementNS(ns, "circle");
        body.setAttribute("r", size);
        g.appendChild(body);
        const top = document.createElementNS(ns, "circle");
        top.setAttribute("r", size * 0.7);
        top.style.fill = "#1e293b";
        g.appendChild(top);
        const bumper = document.createElementNS(ns, "path");
        bumper.setAttribute("d", `M ${-size * 0.7} ${-size * 0.4} A ${size * 0.8} ${size * 0.8} 0 0 1 ${size * 0.7} ${-size * 0.4}`);
        bumper.style.fill = "none";
        bumper.style.strokeWidth = size * 0.15;
        g.appendChild(bumper);
        const btn = document.createElementNS(ns, "circle");
        btn.setAttribute("cx", 0);
        btn.setAttribute("cy", size * 0.1);
        btn.setAttribute("r", size * 0.2);
        btn.style.fill = "#4ade80";
        g.appendChild(btn);
        return g;
       }
       const c = document.createElementNS(ns, "circle");
       c.setAttribute("r", size);
       return c;
      }
      function createNodeShape(id, size) {
       const shapeType = (NODE_DATA[id] && NODE_DATA[id].shape) || "circle";
       const shapeEl = createShapeElement(shapeType, size);
       shapeEl.classList.add("node-circle");
       const styles = resolveStylesForNode(id);
       shapeEl.style.fill = styles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       shapeEl.style.stroke = styles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
       return shapeEl;
      }
      function forgeTheLegend() {
       const container = document.getElementById("edge-legend");
       if (!container) return;
       container.innerHTML = "";
       const title = document.createElement("div");
       title.className = "legend-title";
       title.textContent = "Line Legend";
       container.appendChild(title);
       const closeBtn = document.createElement("button");
       closeBtn.type = "button";
       closeBtn.className = "legend-close-btn";
       closeBtn.textContent = "✕";
       closeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        legendCollapsed = true;
        updateLegendVisibility();
       });
       container.appendChild(closeBtn);
       const colors = [...new Set(EDGE_DATA.list.map((e) => e.color).filter(Boolean))];
       if (colors.length === 0) {
        updateLegendVisibility();
        return;
       }
       colors.forEach((color) => {
        if (!EDGE_LEGEND[color]) {
         EDGE_LEGEND[color] = "you can edit me too";
        }
        const item = document.createElement("div");
        item.className = "legend-item";
        item.addEventListener("mousedown", (e) => e.stopPropagation());
        item.addEventListener("click", (e) => e.stopPropagation());
        const swatch = document.createElement("span");
        swatch.className = "legend-swatch";
        swatch.style.backgroundColor = color;
        swatch.style.cursor = "pointer";
        swatch.addEventListener("click", (e) => {
         e.stopPropagation();
         const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
         if (edgeWithColor) {
          selectTheConnection(edgeWithColor.id);
         }
        });
        let swatchTouchStart = null;
        let swatchTouchMoved = false;
        swatch.addEventListener("touchstart", (e) => {
         swatchTouchStart = Date.now();
         swatchTouchMoved = false;
         if (e.touches[0]) {
          swatchTouchStartX = e.touches[0].clientX;
          swatchTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let swatchTouchStartX = 0, swatchTouchStartY = 0;
        swatch.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - swatchTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - swatchTouchStartY);
          if (dx > 10 || dy > 10) swatchTouchMoved = true;
         }
        }, {
         passive: false
        });
        swatch.addEventListener("touchend", (e) => {
         if (swatchTouchStart && !swatchTouchMoved && Date.now() - swatchTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          const edgeWithColor = EDGE_DATA.list.find(edge => edge.color === color);
          if (edgeWithColor) {
           selectTheConnection(edgeWithColor.id);
          }
         }
         swatchTouchStart = null;
         swatchTouchMoved = false;
        }, {
         passive: false
        });
        const label = document.createElement("span");
        label.className = "legend-label";
        label.textContent = EDGE_LEGEND[color];
        if (isMobileDevice()) {
         label.style.cursor = "pointer";
         let labelTapStart = null;
         let labelTapMoved = false;
         label.addEventListener("touchstart", (e) => {
          labelTapStart = Date.now();
          labelTapMoved = false;
          if (e.touches[0]) {
           labelTapStartX = e.touches[0].clientX;
           labelTapStartY = e.touches[0].clientY;
          }
          e.stopPropagation();
         });
         let labelTapStartX = 0, labelTapStartY = 0;
         label.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - labelTapStartX);
           const dy = Math.abs(e.touches[0].clientY - labelTapStartY);
           if (dx > 10 || dy > 10) labelTapMoved = true;
          }
         });
         label.addEventListener("touchend", (e) => {
          if (labelTapStart && !labelTapMoved && Date.now() - labelTapStart < 400) {
           e.preventDefault();
           e.stopPropagation();
           const currentText = label.textContent;
           const newText = prompt("Edit legend label:", currentText);
           if (newText !== null && newText.trim()) {
            label.textContent = newText.trim();
            EDGE_LEGEND[color] = newText.trim();
           }
          }
          labelTapStart = null;
          labelTapMoved = false;
         });
        } else {
         label.contentEditable = true;
         label.addEventListener("focus", () => {
          label.classList.add("editing");
         });
         label.addEventListener("blur", () => {
          label.classList.remove("editing");
          const text = label.textContent.trim() || "you can edit me too";
          EDGE_LEGEND[color] = text;
         });
         label.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
           e.preventDefault();
           label.blur();
          }
         });
        }
        item.append(swatch, label);
        container.appendChild(item);
       });
       updateLegendVisibility();
      }
       function deleteRectangle(rectId) {
      pushUndo("delete zone");
        RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        forgeTheTopology();
       }
       function updateRectangleDeleteButtons() {
        const deleteButtons = document.querySelectorAll('.rect-delete-btn');
        deleteButtons.forEach(btn => {
         btn.style.display = rectDrawMode ? 'block' : 'none';
        });
       }
	   function updateFovCone(nodeId) {
  const node = NODE_DATA[nodeId];
  if (!node) return;
  
  const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
  if (!nodeGroup) return;
  const existingFov = nodeGroup.querySelector(".fov-group");
  if (existingFov) existingFov.remove();
  if ((node.shape !== "camera" && node.shape !== "cctv") || !node.fovEnabled) return;
  
  const ns = "http://www.w3.org/2000/svg";
  const fovAngle = node.fovAngle || 90;
  const fovDistance = node.fovDistance || 150;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovAnimate = node.fovAnimate || false;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
  }
  
  fovPath.style.fill = fovColor + "33";
  fovPath.style.stroke = fovColor;
  fovPath.style.strokeWidth = "2";
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  
  if (fovAnimate && fovAngle < 360) {
    const animationName = `fov-sweep-${nodeId}`;
    
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    styleEl.textContent = `
      @keyframes ${animationName} {
        0%, 100% { transform: rotate(0deg); }
        50% { transform: rotate(${fovSweep}deg); }
      }
    `;
    fovGroup.appendChild(styleEl);
    const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
    const animationOffset = elapsedSeconds % fovSpeed;
    
    fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
    fovGroup.style.animationDelay = `-${animationOffset}s`;
    fovGroup.style.transformOrigin = "0 0";
  }
  nodeGroup.insertBefore(fovGroup, nodeGroup.firstChild);
}
      function forgeTheTopology() {
       if (!NODE_DATA || !EDGE_DATA) {
        console.warn("forgeTheTopology called before data initialized");
        return;
       }
       const svg = document.getElementById("map");
       svg.innerHTML = "";
       const ns = "http://www.w3.org/2000/svg";
       const defs = document.createElementNS(ns, "defs");
       const flowArrowBig = document.createElementNS(ns, "path");
       flowArrowBig.id = "flow-arrow-big";
       flowArrowBig.setAttribute("d", "M-6,-4 L6,0 L-6,4 L-3,0 Z");
       defs.appendChild(flowArrowBig);
       const flowArrowSmall = document.createElementNS(ns, "path");
       flowArrowSmall.id = "flow-arrow-small";
       flowArrowSmall.setAttribute("d", "M-4,-3 L4,0 L-4,3 Z");
       defs.appendChild(flowArrowSmall);
       const markerForward = document.createElementNS(ns, "marker");
       markerForward.id = "arrow-forward";
       markerForward.setAttribute("markerWidth", "10");
       markerForward.setAttribute("markerHeight", "10");
       markerForward.setAttribute("refX", "9");
       markerForward.setAttribute("refY", "3");
       markerForward.setAttribute("orient", "auto");
       markerForward.setAttribute("markerUnits", "strokeWidth");
       const pathForward = document.createElementNS(ns, "path");
       pathForward.setAttribute("d", "M0,0 L0,6 L9,3 z");
       pathForward.setAttribute("fill", "context-stroke");
       markerForward.appendChild(pathForward);
       defs.appendChild(markerForward);
       const markerBackward = document.createElementNS(ns, "marker");
       markerBackward.id = "arrow-backward";
       markerBackward.setAttribute("markerWidth", "10");
       markerBackward.setAttribute("markerHeight", "10");
       markerBackward.setAttribute("refX", "0");
       markerBackward.setAttribute("refY", "3");
       markerBackward.setAttribute("orient", "auto");
       markerBackward.setAttribute("markerUnits", "strokeWidth");
       const pathBackward = document.createElementNS(ns, "path");
       pathBackward.setAttribute("d", "M9,0 L9,6 L0,3 z");
       pathBackward.setAttribute("fill", "context-stroke");
       markerBackward.appendChild(pathBackward);
defs.appendChild(markerBackward);
const wallPattern = document.createElementNS(ns, "pattern");
wallPattern.id = "wall-hatch";
wallPattern.setAttribute("patternUnits", "userSpaceOnUse");
wallPattern.setAttribute("width", "8");
wallPattern.setAttribute("height", "8");
wallPattern.setAttribute("patternTransform", "rotate(45)");
const wallLine = document.createElementNS(ns, "line");
wallLine.setAttribute("x1", "0");
wallLine.setAttribute("y1", "0");
wallLine.setAttribute("x2", "0");
wallLine.setAttribute("y2", "8");
wallLine.setAttribute("stroke", "#666");
wallLine.setAttribute("stroke-width", "2");
wallPattern.appendChild(wallLine);
defs.appendChild(wallPattern);

svg.appendChild(defs);
       const boundary = document.createElementNS(ns, "rect");
       boundary.setAttribute("x", CANVAS_PADDING);
       boundary.setAttribute("y", CANVAS_PADDING);
       boundary.setAttribute("width", CANVAS_WIDTH - CANVAS_PADDING * 2);
       boundary.setAttribute("height", CANVAS_HEIGHT - CANVAS_PADDING * 2);
       boundary.setAttribute("fill", "none");
       boundary.setAttribute("stroke", (PAGE_STATE.canvasBorder || "#475569") + "4D");
       boundary.setAttribute("stroke-width", "20");
       boundary.setAttribute("stroke-dasharray", "10 5");
       boundary.setAttribute("rx", "8");
       svg.appendChild(boundary);
       if (currentView.mode !== "rack" && PAGE_STATE.canvasGridEnabled !== false) {
const gridGroup = document.createElementNS(ns, "g");
 gridGroup.id = "canvas-grid";
 const gridSize = PAGE_STATE.canvasGridSize || 50;
 const gridColor = (PAGE_STATE.canvasGrid || "#475569") + "33";
 const majorGridColor = (PAGE_STATE.canvasGrid || "#475569") + "66";
 for (let x = CANVAS_PADDING; x <= CANVAS_WIDTH - CANVAS_PADDING; x += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", x);
  line.setAttribute("y1", CANVAS_PADDING);
  line.setAttribute("x2", x);
  line.setAttribute("y2", CANVAS_HEIGHT - CANVAS_PADDING);
  line.setAttribute("stroke", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (x - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 for (let y = CANVAS_PADDING; y <= CANVAS_HEIGHT - CANVAS_PADDING; y += gridSize) {
  const line = document.createElementNS(ns, "line");
  line.setAttribute("x1", CANVAS_PADDING);
  line.setAttribute("y1", y);
  line.setAttribute("x2", CANVAS_WIDTH - CANVAS_PADDING);
  line.setAttribute("y2", y);
  line.setAttribute("stroke", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? majorGridColor : gridColor);
  line.setAttribute("stroke-width", (y - CANVAS_PADDING) % (gridSize * 5) === 0 ? "2" : "1");
  gridGroup.appendChild(line);
 }
 svg.appendChild(gridGroup);
}
       if (currentView.mode === "rack" && currentView.rackId) {
        const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
        const rackGroup = document.createElementNS(ns, "g");
        rackGroup.id = "rack-visualization";
        const rackFrame = document.createElementNS(ns, "rect");
        rackFrame.setAttribute("x", RACK_START_X - RACK_WIDTH / 2);
        rackFrame.setAttribute("y", RACK_START_Y);
        rackFrame.setAttribute("width", RACK_WIDTH);
      rackFrame.setAttribute("height", rackCapacity * rackUHeight);
        rackFrame.setAttribute("fill", (PAGE_STATE.rackFrameFill || "#0f172a") + "4D");
        rackFrame.setAttribute("stroke", PAGE_STATE.rackFrameStroke || "#4fd1c5");
        rackFrame.setAttribute("stroke-width", "3");
        rackFrame.setAttribute("rx", "4");
        rackGroup.appendChild(rackFrame);
        for (let u = 0; u <= rackCapacity; u++) {
 const y = RACK_START_Y + u * rackUHeight;
 if (PAGE_STATE.rackGridEnabled !== false) {
 const line = document.createElementNS(ns, "line");
         line.setAttribute("x1", RACK_START_X - RACK_WIDTH / 2);
         line.setAttribute("y1", y);
         line.setAttribute("x2", RACK_START_X + RACK_WIDTH / 2);
         line.setAttribute("y2", y);
         line.setAttribute("stroke", (PAGE_STATE.rackLineColor || "#475569") + "66");
         line.setAttribute("stroke-width", u % 5 === 0 ? "2" : "1");
         line.setAttribute("stroke-dasharray", u % 5 === 0 ? "none" : "5,5");
         rackGroup.appendChild(line);
 }
 if (u < rackCapacity) {
          const uNumber = rackCapacity - u;
          const text = document.createElementNS(ns, "text");
          text.setAttribute("x", RACK_START_X - RACK_WIDTH / 2 - 30);
          text.setAttribute("y", y + rackUHeight / 2);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("dominant-baseline", "middle");
          text.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          text.style.fontSize = "14px";
          text.style.fontWeight = "bold";
          text.textContent = `U${uNumber}`;
          rackGroup.appendChild(text);
          const textRight = document.createElementNS(ns, "text");
          textRight.setAttribute("x", RACK_START_X + RACK_WIDTH / 2 + 30);
          textRight.setAttribute("y", y + rackUHeight / 2);
          textRight.setAttribute("text-anchor", "middle");
          textRight.setAttribute("dominant-baseline", "middle");
          textRight.style.fill = PAGE_STATE.rackTextColor || "#4fd1c5";
          textRight.style.fontSize = "14px";
          textRight.style.fontWeight = "bold";
          textRight.textContent = `U${uNumber}`;
          rackGroup.appendChild(textRight);
         }
        }
        svg.appendChild(rackGroup);
       }
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "filled") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = rect.color;
           rectEl.style.fillOpacity = "0.3";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
          rectEl.addEventListener("click", (e) => {
		  if (isViewOnly()) return;
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           deleteBtn.addEventListener("touchend", (e) => {
      e.stopPropagation();
           e.preventDefault();
           deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
         rectEl.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
            if (currentRectId === rect.id) {
      const corners = [
      { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
      { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
      { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
      { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
      ];
      corners.forEach((corner, idx) => {
      const handle = document.createElementNS(ns, "circle");
      handle.setAttribute("cx", corner.cx);
      handle.setAttribute("cy", corner.cy);
      const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
      handle.setAttribute("r", handleSize);
      handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
      handle.style.stroke = "#fff";
      handle.style.strokeWidth = "2";
      handle.style.cursor = corner.cursor;
      handle.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      e.preventDefault();
      e.stopPropagation();
	  pushUndo("resize zone");
      let dragging = true;
      const startX = e.clientX, startY = e.clientY;
      const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
      const moveHandler = (ev) => {
        if (!dragging) return;
        const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
        const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
        const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
        const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
        const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
        if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
        else { rect.width = origW + dx; }
        if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
        else { rect.height = origH + dy; }
        if (rect.width < 20) rect.width = 20;
        if (rect.height < 20) rect.height = 20;
        forgeTheTopology();
      };
      const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
      document.addEventListener("mousemove", moveHandler);
      document.addEventListener("mouseup", upHandler);
      });
      g.appendChild(handle);
      });
      }
          if (rect.groupId) {
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", rect.x - 4);
      groupIndicator.setAttribute("y", rect.y - 4);
      groupIndicator.setAttribute("width", rect.width + 8);
      groupIndicator.setAttribute("height", rect.height + 8);
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      g.insertBefore(groupIndicator, g.firstChild);
      }
      g.appendChild(rectEl);
      g.appendChild(deleteBtn);
      svg.appendChild(g);
          }
         });
        }
       const centerX = CANVAS_WIDTH / 2;
       const centerY = CANVAS_HEIGHT / 2;
       let positions = {};
              Object.keys(NODE_DATA).forEach((id) => {
        if (currentView.mode === "rack") {
         const node = NODE_DATA[id];
         if (!node || node.assignedRack !== currentView.rackId) {
          return;
         }
        }
        positions[id] = savedPositions[id] || {
         x: centerX,
         y: centerY
        };
       });
       if (Object.keys(savedPositions).length === 0) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
         if (currentView.mode === "rack") {
          const node = NODE_DATA[id];
          return node && node.assignedRack === currentView.rackId;
         }
         return true;
        });
        const baseY = centerY - 300;
        if (nodeIds.length > 0) {
         positions[nodeIds[0]] = {
          x: centerX,
          y: baseY
         };
         const remaining = nodeIds.slice(1);
         const radius = 350;
         const startAngle = Math.PI * 0.3;
         const endAngle = Math.PI * 0.7;
         remaining.forEach((id, i) => {
          const angle = startAngle + (endAngle - startAngle) * (i / Math.max(1, remaining.length - 1));
          positions[id] = {
           x: centerX + Math.cos(angle) * radius * (i % 2 === 0 ? 1 : 1.3),
           y: baseY + 200 + Math.sin(angle) * radius * 0.8 + i * 80,
          };
         });
        }
       }
       Object.keys(positions).forEach((id) => {
        let pos = savedPositions[id] || positions[id];
        const nodeSize = savedSizes[id] || 55;
        pos.x = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, pos.x));
        pos.y = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, pos.y));
        positions[id] = {
         x: pos.x,
         y: pos.y
        };
        savedPositions[id] = {
         x: pos.x,
         y: pos.y
        };
       });
       const edgePairCount = {};
       const edgePairIndex = {};
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        edgePairCount[key] = (edgePairCount[key] || 0) + 1;
       });
       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom") return;
        const key = [edge.from, edge.to].sort().join("||");
        if (!edgePairIndex[key]) edgePairIndex[key] = 0;
        edge._pairIndex = edgePairIndex[key];
        edge._pairTotal = edgePairCount[key];
        edgePairIndex[key]++;
       });
       
       const orthoGaps = (function() {
         const segments = [];
         const GAP_SIZE = 12;
         EDGE_DATA.list.forEach((edge, edgeIndex) => {
           if ((edge.routing || PAGE_STATE.defaultEdgeRouting || "curved") !== "orthogonal") return;
           if (edge.type === "custom") return;
           const p1 = positions[edge.from];
           const p2 = positions[edge.to];
           if (!p1 || !p2) return;
           const dx = p2.x - p1.x;
           const dy = p2.y - p1.y;
           const pairIndex = edge._pairIndex || 0;
           const pairTotal = edge._pairTotal || 1;
           const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
           if (Math.abs(dx) > Math.abs(dy)) {
             const midX = p1.x + dx / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: midX, y2: p1.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p1.y, x2: midX, y2: p2.y, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: midX, y1: p2.y, x2: p2.x, y2: p2.y, idx: edgeIndex });
           } else {
             const midY = p1.y + dy / 2 + offset;
             segments.push({ edgeId: edge.id, x1: p1.x, y1: p1.y, x2: p1.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p1.x, y1: midY, x2: p2.x, y2: midY, idx: edgeIndex });
             segments.push({ edgeId: edge.id, x1: p2.x, y1: midY, x2: p2.x, y2: p2.y, idx: edgeIndex });
           }
         });
         const gaps = {};
         for (let i = 0; i < segments.length; i++) {
           for (let j = i + 1; j < segments.length; j++) {
             const s1 = segments[i];
             const s2 = segments[j];
             if (s1.edgeId === s2.edgeId) continue;
             const s1Horiz = Math.abs(s1.y1 - s1.y2) < 1;
             const s2Horiz = Math.abs(s2.y1 - s2.y2) < 1;
             if (s1Horiz === s2Horiz) continue;
             const horiz = s1Horiz ? s1 : s2;
             const vert = s1Horiz ? s2 : s1;
             const hY = horiz.y1;
             const vX = vert.x1;
             const hMinX = Math.min(horiz.x1, horiz.x2);
             const hMaxX = Math.max(horiz.x1, horiz.x2);
             const vMinY = Math.min(vert.y1, vert.y2);
             const vMaxY = Math.max(vert.y1, vert.y2);
             if (vX > hMinX && vX < hMaxX && hY > vMinY && hY < vMaxY) {
               const gapEdge = s1.idx > s2.idx ? s1.edgeId : s2.edgeId;
               if (!gaps[gapEdge]) gaps[gapEdge] = [];
               gaps[gapEdge].push({ x: vX, y: hY });
             }
           }
         }
         return gaps;
       })();

       EDGE_DATA.list.forEach((edge) => {
        if (edge.type === "custom" && Array.isArray(edge.points) && edge.points.length >= 2) {
         const poly = document.createElementNS(ns, "polyline");
         poly.classList.add("edge");
         poly.dataset.edgeId = edge.id;
         poly.style.stroke = edge.color || PAGE_STATE.defaultEdge || "#475569";
         poly.style.strokeWidth = edge.width || 4;
         poly.setAttribute("fill", "none");
         const lineStyle = edge.lineStyle || "solid";
if (lineStyle === "dashed") {
 poly.style.strokeDasharray = "10,5";
} else if (lineStyle === "dotted") {
 poly.style.strokeDasharray = "2,4";
} else if (lineStyle === "wall") {
 poly.style.stroke = "url(#wall-hatch)";
 poly.style.strokeWidth = (edge.width || 4) * 3;
 poly.style.strokeDasharray = "none";
} else {
 poly.style.strokeDasharray = "none";
}
         const direction = edge.direction || "none";
         if (direction === "forward") {
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         } else if (direction === "backward") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
         } else if (direction === "both") {
          poly.setAttribute("marker-start", "url(#arrow-backward)");
          poly.setAttribute("marker-end", "url(#arrow-forward)");
         }
         const ptsStr = edge.points.map((p) => `${p.x},${p.y}`).join(" ");
         poly.setAttribute("points", ptsStr);
         const animDir = PAGE_STATE.animationDirection || "all";
         const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && direction !== "none" && edge.points.length >= 2 && (animDir === "all" || animDir === direction);
         if (shouldAnimate) {
          poly.style.opacity = "0.25";
          const polyPathD = "M " + edge.points.map(p => `${p.x} ${p.y}`).join(" L ");
          const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
          const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
          const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
          const arrowCount = 3;
          const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
          if (direction === "forward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
            arrow.classList.add("edge-arrow-forward");
            svg.appendChild(arrow);
           }
          }
          if (direction === "backward" || direction === "both") {
           for (let i = 0; i < arrowCount; i++) {
            const arrow = document.createElementNS(ns, "use");
            arrow.setAttribute("href", arrowId);
            arrow.style.fill = arrowColor;
            arrow.style.offsetPath = `path('${polyPathD}')`;
            arrow.style.animationDuration = animDuration + "s";
            arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (direction === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
            arrow.classList.add("edge-arrow-backward");
            svg.appendChild(arrow);
           }
          }
         }
         const polyHit = document.createElementNS(ns, "polyline");
         polyHit.setAttribute("points", ptsStr);
         polyHit.style.fill = "none";
         polyHit.style.stroke = "transparent";
         polyHit.style.strokeWidth = "20";
         polyHit.style.cursor = "pointer";
         polyHit.dataset.edgeId = edge.id;
         polyHit.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         let edgeTouchStart = null;
         let edgeTouchMoved = false;
         polyHit.addEventListener("touchstart", (e) => {
          edgeTouchStart = Date.now();
          edgeTouchMoved = false;
          if (e.touches[0]) {
           edgeTouchStartX = e.touches[0].clientX;
           edgeTouchStartY = e.touches[0].clientY;
          }
         }, {
          passive: false
         });
         let edgeTouchStartX = 0, edgeTouchStartY = 0;
         polyHit.addEventListener("touchmove", (e) => {
          if (e.touches[0]) {
           const dx = Math.abs(e.touches[0].clientX - edgeTouchStartX);
           const dy = Math.abs(e.touches[0].clientY - edgeTouchStartY);
           if (dx > 10 || dy > 10) edgeTouchMoved = true;
          }
         }, {
          passive: false
         });
         polyHit.addEventListener("touchend", (e) => {
          if (edgeTouchStart && !edgeTouchMoved && Date.now() - edgeTouchStart < 400) {
           e.stopPropagation();
           e.preventDefault();
           selectTheConnection(edge.id);
          }
          edgeTouchStart = null;
          edgeTouchMoved = false;
         }, {
          passive: false
         });
         poly.addEventListener("click", (e) => {
          e.stopPropagation();
          selectTheConnection(edge.id);
         });
         polyHit.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let customEdgeLastTap = 0;
         polyHit.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - customEdgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           customEdgeLastTap = 0;
          } else {
           customEdgeLastTap = now;
          }
         }, { passive: false });
         poly.addEventListener("contextmenu", (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (selectedEdges.has(edge.id)) {
           selectedEdges.delete(edge.id);
          } else {
           selectedEdges.add(edge.id);
          }
          updateAllSelections();
         });
         let edgeLastTap = 0;
         poly.addEventListener("touchend", (e) => {
          const now = Date.now();
          if (now - edgeLastTap < 300) {
           e.preventDefault();
           if (selectedEdges.has(edge.id)) {
            selectedEdges.delete(edge.id);
           } else {
            selectedEdges.add(edge.id);
           }
           updateAllSelections();
           if (navigator.vibrate) navigator.vibrate(50);
           edgeLastTap = 0;
          } else {
           edgeLastTap = now;
          }
         });
         if (currentView.mode === "rack") {
          return;
         }
         if (edge.groupId) {
      const bounds = edge.points.reduce((acc, p) => ({ minX: Math.min(acc.minX, p.x), minY: Math.min(acc.minY, p.y), maxX: Math.max(acc.maxX, p.x), maxY: Math.max(acc.maxY, p.y) }), { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity });
      const groupIndicator = document.createElementNS(ns, "rect");
      groupIndicator.setAttribute("x", bounds.minX - 8);
      groupIndicator.setAttribute("y", bounds.minY - 8);
      groupIndicator.setAttribute("width", bounds.maxX - bounds.minX + 16);
      groupIndicator.setAttribute("height", bounds.maxY - bounds.minY + 16);
      groupIndicator.setAttribute("rx", "4");
      groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = "#4fd1c5";
      groupIndicator.style.strokeWidth = "3";
      groupIndicator.style.strokeDasharray = "5,5";
      groupIndicator.style.pointerEvents = "none";
      svg.appendChild(groupIndicator);
      }
         let lineDragging = false;
      let lineDragStartX, lineDragStartY;
      let linePointsStart = [];
      polyHit.addEventListener("mousedown", (e) => {
	  if (isViewOnly()) return;
      if (freeDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      lineDragging = true;
      lineDragStartX = e.clientX;
      lineDragStartY = e.clientY;
      linePointsStart = edge.points.map(p => ({x: p.x, y: p.y}));
      if (selectedEdges.has(edge.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
      const lineMoveHandler = (e) => {
      if (!lineDragging || freeDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = lineDragStartX;
      pt1.y = lineDragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      edge.points.forEach((p, i) => { p.x = linePointsStart[i].x + dx; p.y = linePointsStart[i].y + dy; });
      if (selectedEdges.has(edge.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       savedPositions[nodeId] = { x: initialPositions[nodeId].x + dx, y: initialPositions[nodeId].y + dy };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      if (edgeId === edge.id) return;
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
      const lineUpHandler = () => {
        lineDragging = false;
        document.removeEventListener("mousemove", lineMoveHandler);
        document.removeEventListener("mouseup", lineUpHandler);
      };
      document.addEventListener("mousemove", lineMoveHandler);
      document.addEventListener("mouseup", lineUpHandler);
      svg.appendChild(poly);
      svg.appendChild(polyHit);
         if (currentEdgeId === edge.id) {
          edge.points.forEach((p, idx) => {
           const c = document.createElementNS(ns, "circle");
           c.classList.add("edge-edit-point");
           c.setAttribute("cx", p.x);
           c.setAttribute("cy", p.y);
      c.setAttribute("r", PAGE_STATE.selectionHandleSize || 8);
           c.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
           c.style.stroke = "#fff";
           c.style.strokeWidth = "2";
           c.style.cursor = "move";
           c.dataset.edgeId = edge.id;
           c.dataset.pointIndex = String(idx);
           c.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const moveHandler = (ev) => {
             if (!dragging) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.clientX;
             pt.y = ev.clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const upHandler = () => {
             dragging = false;
             document.removeEventListener("mousemove", moveHandler);
             document.removeEventListener("mouseup", upHandler);
            };
            document.addEventListener("mousemove", moveHandler);
            document.addEventListener("mouseup", upHandler);
           });
           c.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            e.preventDefault();
            e.stopPropagation();
            pushUndo("edit edge point");
            let dragging = true;
            const svgEl = svg;
            const touchMoveHandler = (ev) => {
             if (!dragging || !ev.touches[0]) return;
             const pt = svgEl.createSVGPoint();
             pt.x = ev.touches[0].clientX;
             pt.y = ev.touches[0].clientY;
             const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
             edge.points[idx].x = svgP.x;
             edge.points[idx].y = svgP.y;
             forgeTheTopology();
            };
            const touchUpHandler = () => {
             dragging = false;
             document.removeEventListener("touchmove", touchMoveHandler);
             document.removeEventListener("touchend", touchUpHandler);
            };
            document.addEventListener("touchmove", touchMoveHandler);
            document.addEventListener("touchend", touchUpHandler);
           }, { passive: false });
           svg.appendChild(c);
          });
         }
         return;
        }
        const p1 = positions[edge.from];
        const p2 = positions[edge.to];
        if (!p1 || !p2) return;
        const pairTotal = edge._pairTotal || 1;
        const pairIndex = edge._pairIndex || 0;
        const routing = edge.routing || "curved";
        let pathD;
        if (routing === "straight") {
         pathD = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        } else if (routing === "orthogonal") {
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const offset = (pairIndex - (pairTotal - 1) / 2) * 40;
         const GAP = 10;
         const edgeGaps = orthoGaps[edge.id] || [];
         
         if (Math.abs(dx) > Math.abs(dy)) {
          const midX = p1.x + dx / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: midX, y2: p1.y },
           { x1: midX, y1: p1.y, x2: midX, y2: p2.y },
           { x1: midX, y1: p2.y, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         } else {
          const midY = p1.y + dy / 2 + offset;
          const segs = [
           { x1: p1.x, y1: p1.y, x2: p1.x, y2: midY },
           { x1: p1.x, y1: midY, x2: p2.x, y2: midY },
           { x1: p2.x, y1: midY, x2: p2.x, y2: p2.y }
          ];
          pathD = `M ${p1.x} ${p1.y}`;
          segs.forEach(seg => {
           const isHoriz = Math.abs(seg.y1 - seg.y2) < 1;
           const segGaps = edgeGaps.filter(g => {
            if (isHoriz) {
             const minX = Math.min(seg.x1, seg.x2), maxX = Math.max(seg.x1, seg.x2);
             return Math.abs(g.y - seg.y1) < 1 && g.x > minX + GAP && g.x < maxX - GAP;
            } else {
             const minY = Math.min(seg.y1, seg.y2), maxY = Math.max(seg.y1, seg.y2);
             return Math.abs(g.x - seg.x1) < 1 && g.y > minY + GAP && g.y < maxY - GAP;
            }
           }).sort((a, b) => isHoriz ? (seg.x2 > seg.x1 ? a.x - b.x : b.x - a.x) : (seg.y2 > seg.y1 ? a.y - b.y : b.y - a.y));
           let cx = seg.x1, cy = seg.y1;
           segGaps.forEach(g => {
            if (isHoriz) {
             const gx = g.x;
             pathD += ` L ${gx - GAP} ${cy} M ${gx + GAP} ${cy}`;
             cx = gx + GAP;
            } else {
             const gy = g.y;
             pathD += ` L ${cx} ${gy - GAP} M ${cx} ${gy + GAP}`;
             cy = gy + GAP;
            }
           });
           pathD += ` L ${seg.x2} ${seg.y2}`;
          });
         }
        } else {
         const midX = (p1.x + p2.x) / 2;
         const midY = (p1.y + p2.y) / 2;
         const dx = p2.x - p1.x;
         const dy = p2.y - p1.y;
         const len = Math.sqrt(dx * dx + dy * dy) || 1;
         const perpX = -dy / len;
         const perpY = dx / len;
         let offsetAmount = 0;
         if (pairTotal > 1) {
          offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
         }
         const ctrlX = midX + perpX * offsetAmount;
         const ctrlY = midY + perpY * offsetAmount;
         pathD = `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`;
        }
        const path = document.createElementNS(ns, "path");
        path.setAttribute("d", pathD);
        path.setAttribute("fill", "none");
        path.classList.add("edge");
        if (edge.type === "backup") path.classList.add("backup");
        path.dataset.edgeId = edge.id;
        path.dataset.from = edge.from;
        path.dataset.to = edge.to;
        path.style.stroke = edge.color;
        path.style.strokeWidth = edge.width;
        const edgeDirection = edge.direction || "none";
        const edgeLineStyle = edge.lineStyle || "solid";
        if (edgeLineStyle === "dashed") { path.style.strokeDasharray = "10,5"; }
        else if (edgeLineStyle === "dotted") { path.style.strokeDasharray = "2,4"; }
        if (edgeDirection === "forward") {
         path.setAttribute("marker-end", "url(#arrow-forward)");
        } else if (edgeDirection === "backward") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
        } else if (edgeDirection === "both") {
         path.setAttribute("marker-start", "url(#arrow-backward)");
         path.setAttribute("marker-end", "url(#arrow-forward)");
        }
        const animDir = PAGE_STATE.animationDirection || "all";
        const shouldAnimate = (PAGE_STATE.animateConnections && edge.animate !== false || edge.animate === true) && edgeDirection !== "none" && (animDir === "all" || animDir === edgeDirection);
        if (shouldAnimate) {
         path.style.opacity = "0.25";
         const edgeStyle = edge.animationStyle || PAGE_STATE.animationStyle || "arrows";
         const arrowId = edgeStyle === "dots" ? "#flow-arrow-small" : "#flow-arrow-big";
         const arrowColor = edge.color || PAGE_STATE.defaultEdge || "#475569";
         const arrowCount = 3;
         const animDuration = edge.animationSpeed ? parseFloat(edge.animationSpeed) : (PAGE_STATE.animationSpeed || 1.5);
         if (edgeDirection === "forward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = (i * (animDuration / arrowCount)) + "s";
           arrow.classList.add("edge-arrow-forward");
           svg.appendChild(arrow);
          }
         }
         if (edgeDirection === "backward" || edgeDirection === "both") {
          for (let i = 0; i < arrowCount; i++) {
           const arrow = document.createElementNS(ns, "use");
           arrow.setAttribute("href", arrowId);
           arrow.style.fill = arrowColor;
           arrow.style.offsetPath = `path('${pathD}')`;
           arrow.style.animationDuration = animDuration + "s";
           arrow.style.animationDelay = ((i * (animDuration / arrowCount)) + (edgeDirection === "both" ? animDuration / (arrowCount * 2) : 0)) + "s";
           arrow.classList.add("edge-arrow-backward");
           svg.appendChild(arrow);
          }
         }
        }
        const pathHit = document.createElementNS(ns, "path");
        pathHit.setAttribute("d", pathD);
        pathHit.setAttribute("fill", "none");
        pathHit.style.stroke = "transparent";
        pathHit.style.strokeWidth = "20";
        pathHit.style.cursor = "pointer";
        pathHit.dataset.edgeId = edge.id;
        pathHit.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        let pathTouchStart = null;
        let pathTouchMoved = false;
        pathHit.addEventListener("touchstart", (e) => {
         pathTouchStart = Date.now();
         pathTouchMoved = false;
         if (e.touches[0]) {
          pathTouchStartX = e.touches[0].clientX;
          pathTouchStartY = e.touches[0].clientY;
         }
        }, {
         passive: false
        });
        let pathTouchStartX = 0, pathTouchStartY = 0;
        pathHit.addEventListener("touchmove", (e) => {
         if (e.touches[0]) {
          const dx = Math.abs(e.touches[0].clientX - pathTouchStartX);
          const dy = Math.abs(e.touches[0].clientY - pathTouchStartY);
          if (dx > 10 || dy > 10) pathTouchMoved = true;
         }
        }, {
         passive: false
        });
        pathHit.addEventListener("touchend", (e) => {
         if (pathTouchStart && !pathTouchMoved && Date.now() - pathTouchStart < 400) {
          e.stopPropagation();
          e.preventDefault();
          selectTheConnection(edge.id);
         }
         pathTouchStart = null;
         pathTouchMoved = false;
        }, {
         passive: false
        });
        path.addEventListener("click", (e) => {
         e.stopPropagation();
         selectTheConnection(edge.id);
        });
        if (currentView.mode === "rack") {
         const fromNode = NODE_DATA[edge.from];
         const toNode = NODE_DATA[edge.to];
         if (!fromNode || !toNode ||
             fromNode.assignedRack !== currentView.rackId ||
             toNode.assignedRack !== currentView.rackId) {
          return;
         }
        }
        const fromVisible = isNodeVisible(edge.from);
        const toVisible = isNodeVisible(edge.to);
        if (!fromVisible || !toVisible) {
         path.style.opacity = "0.1";
         path.style.pointerEvents = "none";
         pathHit.style.pointerEvents = "none";
        }
        svg.appendChild(path);
        svg.appendChild(pathHit);
        if (edge.fromPort || edge.toPort) {
         const ns = "http://www.w3.org/2000/svg";
         if (edge.fromPort) {
          const fromLabel = document.createElementNS(ns, "text");
          fromLabel.textContent = edge.fromPort;
          fromLabel.setAttribute("x", p1.x);
          fromLabel.setAttribute("y", p1.y - 10);
          fromLabel.setAttribute("text-anchor", "middle");
          fromLabel.style.fill = "#94a3b8";
          fromLabel.style.fontSize = "12px";
          fromLabel.style.fontWeight = "600";
          fromLabel.style.pointerEvents = "none";
          fromLabel.classList.add("port-label");
          svg.appendChild(fromLabel);
         }
         if (edge.toPort) {
          const toLabel = document.createElementNS(ns, "text");
          toLabel.textContent = edge.toPort;
          toLabel.setAttribute("x", p2.x);
          toLabel.setAttribute("y", p2.y - 10);
          toLabel.setAttribute("text-anchor", "middle");
          toLabel.style.fill = "#94a3b8";
          toLabel.style.fontSize = "12px";
          toLabel.style.fontWeight = "600";
          toLabel.style.pointerEvents = "none";
          toLabel.classList.add("port-label");
          svg.appendChild(toLabel);
         }
        }
       });
       Object.entries(positions).forEach(([id, pos]) => {
        const node = NODE_DATA[id];
        if (!node) return;
        if (currentView.mode === "rack") {
         if (node.assignedRack !== currentView.rackId) return;
         const rackUnit = parseInt(node.rackUnit) || 1;
      const uHeight = parseInt(node.uHeight) || 1;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      pos.x = RACK_START_X;
      pos.y = RACK_START_Y + (rackCapacity - rackUnit - uHeight + 1) * rackUHeight + (uHeight * rackUHeight) / 2;
        } else {
         if (node.assignedRack) return;
        }
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.classList.add("node-group");
        g.dataset.nodeId = id;
        const nodeRotation = NODE_DATA[id].rotation || 0;
        g.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${nodeRotation})`);
		let r = savedSizes[id] || 55;
		if (!savedSizes[id]) {
		 if (window.innerWidth <= 480) r = 45;
		 else if (window.innerWidth <= 768) r = 50;
		}
        const styles = resolveStylesForNode(id);
        const ns = "http://www.w3.org/2000/svg";
        const hitArea = document.createElementNS(ns, "circle");
        hitArea.setAttribute("r", r * 1.5);
        hitArea.style.fill = "transparent";
        hitArea.style.stroke = "none";
        hitArea.style.cursor = "grab";
        hitArea.classList.add("node-hit-area");
        const shapeEl = createNodeShape(id, r);
        const titleOffsetX = styles.titleOffsetX || 0;
        const titleOffsetY = styles.titleOffsetY || 0;
        const subOffsetX = styles.subOffsetX || 0;
        const subOffsetY = styles.subOffsetY || 0;
        const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
        label.classList.add("node-label");
        label.setAttribute("x", titleOffsetX);
        label.setAttribute("y", -r * 0.28 + titleOffsetY);
      const labelFontSize = styles.titleSize || PAGE_STATE.nodeTitleSize || r * 0.33;
        label.style.fontSize = labelFontSize + "px";
        label.textContent = NODE_DATA[id].name;
      label.style.fill = styles.titleColor || PAGE_STATE.nodeTitle || "#e2e8f0";
        label.style.fontFamily = styles.titleFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        label.style.pointerEvents = "none";
        const sub = document.createElementNS("http://www.w3.org/2000/svg", "text");
        sub.classList.add("node-sub");
        sub.setAttribute("x", subOffsetX);
        sub.setAttribute("y", r * 0.4 + subOffsetY);
      const subFontSize = styles.subSize || PAGE_STATE.nodeSubSize || r * 0.24;
        sub.style.fontSize = subFontSize + "px";
        sub.textContent = NODE_DATA[id].ip;
      sub.style.fill = styles.subColor || PAGE_STATE.nodeSub || "#94a3b8";
        sub.style.fontFamily = styles.subFont || PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
        sub.style.pointerEvents = "none";
if ((node.shape === "camera" || node.shape === "cctv") && node.fovEnabled) {
  const fovAngle = node.fovAngle || 90;
  const fovDistance = node.fovDistance || 150;
  const fovRotation = node.fovRotation || 0;
  const fovColor = node.fovColor || "#f59e0b";
  const fovAnimate = node.fovAnimate || false;
  const fovSweep = node.fovSweep || 120;
  const fovSpeed = node.fovSpeed || 4;
  const fovGroup = document.createElementNS(ns, "g");
  fovGroup.classList.add("fov-group");
  
  const fovPath = document.createElementNS(ns, "path");
  
  if (fovAngle >= 360) {
    fovPath.setAttribute("d", `M 0,0 m -${fovDistance},0 a ${fovDistance},${fovDistance} 0 1,0 ${fovDistance * 2},0 a ${fovDistance},${fovDistance} 0 1,0 -${fovDistance * 2},0`);
  } else {
    const angleRad = (fovAngle * Math.PI) / 180;
    const rotationRad = ((fovRotation - 90) * Math.PI) / 180;
    
    const startAngle = rotationRad - angleRad / 2;
    const endAngle = rotationRad + angleRad / 2;
    
    const x1 = Math.cos(startAngle) * fovDistance;
    const y1 = Math.sin(startAngle) * fovDistance;
    const x2 = Math.cos(endAngle) * fovDistance;
    const y2 = Math.sin(endAngle) * fovDistance;
    
    const largeArc = fovAngle > 180 ? 1 : 0;
    
    fovPath.setAttribute("d", `M 0,0 L ${x1},${y1} A ${fovDistance},${fovDistance} 0 ${largeArc},1 ${x2},${y2} Z`);
  }
  
  fovPath.style.fill = fovColor + "33";
  fovPath.style.stroke = fovColor;
  fovPath.style.strokeWidth = "2";
  fovPath.style.pointerEvents = "none";
  fovPath.classList.add("fov-cone");
  
  fovGroup.appendChild(fovPath);
  if (fovAnimate && fovAngle < 360) {
    const animationName = `fov-sweep-${id}`;
    const halfSweep = fovSweep / 2;
    const styleEl = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
    styleEl.textContent = `
      @keyframes ${animationName} {
        0%, 100% { transform: rotate(0deg); }
        50% { transform: rotate(${fovSweep}deg); }
      }
    `;
    fovGroup.appendChild(styleEl);
    const elapsedSeconds = (Date.now() - FOV_ANIMATION_START) / 1000;
    const animationOffset = elapsedSeconds % fovSpeed;
    
    fovGroup.style.animation = `${animationName} ${fovSpeed}s ease-in-out infinite`;
    fovGroup.style.animationDelay = `-${animationOffset}s`;
    fovGroup.style.transformOrigin = "0 0";
  }
  
  g.appendChild(fovGroup);
}
        g.append(hitArea, shapeEl, label, sub);
        if (NODE_DATA[id]?.locked) {
          const lockIcon = document.createElementNS(ns, "text");
          lockIcon.textContent = "🔒";
          lockIcon.setAttribute("x", r * 0.6);
          lockIcon.setAttribute("y", -r * 0.6);
          lockIcon.style.fontSize = (r * 0.4) + "px";
          lockIcon.style.pointerEvents = "none";
          lockIcon.style.userSelect = "none";
          lockIcon.classList.add("lock-indicator");
          g.appendChild(lockIcon);
        }
        if (NODE_DATA[id]?.groupId) {
          const groupIndicator = document.createElementNS(ns, "circle");
          groupIndicator.setAttribute("r", r + 4);
          groupIndicator.style.fill = "none";
      groupIndicator.style.stroke = PAGE_STATE.groupIndicator || "#4fd1c5";
          groupIndicator.style.strokeWidth = "3";
          groupIndicator.style.strokeDasharray = "5,5";
          groupIndicator.style.pointerEvents = "none";
          groupIndicator.classList.add("group-indicator");
          g.insertBefore(groupIndicator, g.firstChild);
        }
        let isDragging = false;
        let startX, startY;
        let initialPositions = {};
        let longPressTimer = null;
        let longPressTriggered = false;
        g.addEventListener("contextmenu", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (isViewOnly()) return;
         if (selectedNodes.has(id)) {
          selectedNodes.delete(id);
         } else {
          selectedNodes.add(id);
         }
         updateNodeSelection();
         return false;
        });
        g.addEventListener("touchstart", (e) => {
         if (NODE_DATA[id].isRack) {
          const touch = e.touches[0];
          longPressStartX = touch.clientX;
          longPressStartY = touch.clientY;
          longPressTimer = setTimeout(() => {
           longPressTriggered = true;
           if (navigator.vibrate) {
            navigator.vibrate(100);
           }
           enterRack(id);
          }, 500);
         }
        }, { passive: true });
        let lastTapTime = 0;
        let lastTapNode = null;
        g.addEventListener("touchend", (e) => {
         const currentTime = new Date().getTime();
         const tapLength = currentTime - lastTapTime;
         if (tapLength < 300 && tapLength > 0 && lastTapNode === id) {
          e.preventDefault();
          e.stopPropagation();
          if (isViewOnly()) return;
          if (selectedNodes.has(id)) {
           selectedNodes.delete(id);
          } else {
           selectedNodes.add(id);
          }
          updateNodeSelection();
          if (navigator.vibrate) {
           navigator.vibrate(50);
          }
          lastTapTime = 0;
          lastTapNode = null;
         } else {
          lastTapTime = currentTime;
          lastTapNode = id;
         }
        });
        g.addEventListener("touchend", (e) => {
         if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
         }
         if (longPressTriggered) {
          e.preventDefault();
          e.stopPropagation();
          longPressTriggered = false;
         }
        });
        let longPressStartX = 0;
        let longPressStartY = 0;
        g.addEventListener("touchmove", (e) => {
         if (longPressTimer) {
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - longPressStartX);
          const dy = Math.abs(touch.clientY - longPressStartY);
          if (dx > 15 || dy > 15) {
           clearTimeout(longPressTimer);
           longPressTimer = null;
           longPressTriggered = false;
          }
         }
        }, { passive: true });
        g.addEventListener("mousedown", (e) => {
		 if (isViewOnly()) return;
         if (e.button === 2) {
          return;
         }
         if (NODE_DATA[id]?.locked) {
          return;
         }
         e.preventDefault();
         isDragging = true;
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         startX = svgP.x;
         startY = svgP.y;
      if (selectedNodes.has(id)) {
      initialPositions = {};
      const allSelectedRects = Array.from(selectedRects);
      const allSelectedTexts = Array.from(selectedTexts);
      const allSelectedEdges = Array.from(selectedEdges).map(eid => EDGE_DATA.list.find(e => e.id === eid)).filter(Boolean);
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) {
      initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      }
      });
      Array.from(selectedRects).forEach(rectId => {
        const rect = RECT_DATA.list.find(r => r.id === rectId);
        if (rect) { rect._dragStartX = rect.x; rect._dragStartY = rect.y; }
      });
      Array.from(selectedTexts).forEach(textId => {
        const text = TEXT_DATA.list.find(t => t.id === textId);
        if (text) { text._dragStartX = text.x; text._dragStartY = text.y; }
      });
      Array.from(selectedEdges).forEach(edgeId => {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (edge && edge.points) { edge._dragStartPoints = edge.points.map(p => ({x: p.x, y: p.y})); }
      });
      } else {
      initialPositions = { [id]: { x: pos.x, y: pos.y } };
      }
      if (currentView.mode === "rack") {
      initialPositions[id] = { x: pos.x, y: pos.y };
      }
         g.style.cursor = "grabbing";
         hitArea.style.cursor = "grabbing";
         e.stopPropagation();
        });
        const handleMouseMove = (e) => {
         if (!isDragging) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         pt.x = e.clientX;
         pt.y = e.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = svgP.x - startX;
         const dy = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + dx;
          let newY = initialPos.y + dy;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         Array.from(selectedRects).forEach(rectId => {
           const rect = RECT_DATA.list.find(r => r.id === rectId);
           if (rect && rect._dragStartX !== undefined) {
             rect.x = rect._dragStartX + dx;
             rect.y = rect._dragStartY + dy;
           }
         });
         Array.from(selectedTexts).forEach(textId => {
           const text = TEXT_DATA.list.find(t => t.id === textId);
           if (text && text._dragStartX !== undefined) {
             text.x = text._dragStartX + dx;
             text.y = text._dragStartY + dy;
           }
         });
         Array.from(selectedEdges).forEach(edgeId => {
           const edge = EDGE_DATA.list.find(e => e.id === edgeId);
           if (edge && edge._dragStartPoints) {
             edge.points.forEach((p, i) => {
               p.x = edge._dragStartPoints[i].x + dx;
               p.y = edge._dragStartPoints[i].y + dy;
             });
           }
         });
         forgeTheTopology();
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        };
      const handleMouseUp = () => {
      if (isDragging) {
      isDragging = false;
      g.style.cursor = "grab";
      hitArea.style.cursor = "grab";
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const draggedY = savedPositions[id]?.y || pos.y;
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
        let touchStartTime = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        let touchMoved = false;
        g.addEventListener("touchstart",
         (e) => {
          if (isViewOnly()) {
           touchStartTime = Date.now();
           touchMoved = false;
           e.stopPropagation();
           return;
          }
          if (NODE_DATA[id]?.locked) {
           return;
          }
          e.preventDefault();
          touchStartTime = Date.now();
          touchMoved = false;
          const svgEl = document.getElementById("map");
          const pt = svgEl.createSVGPoint();
          const touch = e.touches[0];
          pt.x = touch.clientX;
          pt.y = touch.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          touchStartX = svgP.x;
          touchStartY = svgP.y;
          startX = svgP.x;
          startY = svgP.y;
          if (selectedNodes.has(id)) {
           initialPositions = {};
           selectedNodes.forEach(nodeId => {
            const nodePos = savedPositions[nodeId];
            if (nodePos) {
             initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
            }
           });
          } else {
           initialPositions = { [id]: { x: pos.x, y: pos.y } };
          }
          e.stopPropagation();
         }, {
          passive: false
         });
        g.addEventListener("touchmove", (e) => {
		if (isViewOnly()) return;
         e.preventDefault();
         const svgEl = document.getElementById("map");
         const pt = svgEl.createSVGPoint();
         const touch = e.touches[0];
         pt.x = touch.clientX;
         pt.y = touch.clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         const dx = Math.abs(svgP.x - touchStartX);
         const dy = Math.abs(svgP.y - touchStartY);
         if (dx > (isMobileDevice() ? 4 : 10) || dy > (isMobileDevice() ? 4 : 10)) {
      touchMoved = true;
      isDragging = true;
      }
         if (!isDragging) return;
         const deltaX = svgP.x - startX;
         const deltaY = svgP.y - startY;
         let nodesToMove = selectedNodes.has(id) ? Array.from(selectedNodes) : [id];
         const groupIds = new Set();
         nodesToMove.forEach(nodeId => {
          const groupId = NODE_DATA[nodeId]?.groupId;
          if (groupId) {
            groupIds.add(groupId);
          }
         });
         if (groupIds.size > 0) {
          Object.keys(NODE_DATA).forEach(nodeId => {
            const nodeGroupId = NODE_DATA[nodeId]?.groupId;
            if (nodeGroupId && groupIds.has(nodeGroupId)) {
              if (!nodesToMove.includes(nodeId)) {
                nodesToMove.push(nodeId);
                if (!initialPositions[nodeId]) {
                  const nodePos = savedPositions[nodeId];
                  if (nodePos) {
                    initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
                  }
                }
              }
            }
          });
         }
         nodesToMove = nodesToMove.filter(nodeId => !NODE_DATA[nodeId]?.locked);
         nodesToMove.forEach(nodeId => {
          if (!initialPositions[nodeId]) return;
          const initialPos = initialPositions[nodeId];
          let newX = initialPos.x + deltaX;
          let newY = initialPos.y + deltaY;
          const nodeSize = savedSizes[nodeId] || 55;
          newX = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_WIDTH - nodeSize - CANVAS_PADDING, newX));
          newY = Math.max(nodeSize + CANVAS_PADDING, Math.min(CANVAS_HEIGHT - nodeSize - CANVAS_PADDING, newY));
          savedPositions[nodeId] = { x: newX, y: newY };
          positions[nodeId] = { x: newX, y: newY };
          if (nodeId === id) {
           pos.x = newX;
           pos.y = newY;
          }
          const nodeGroup = document.querySelector(`g[data-node-id="${nodeId}"]`);
          if (nodeGroup) {
           nodeGroup.setAttribute("transform", `translate(${newX},${newY})`);
          }
         });
         updateMinimap();
         document.querySelectorAll(".edge").forEach((edgeEl) => {
          const fromId = edgeEl.dataset.from;
          const toId = edgeEl.dataset.to;
          if (nodesToMove.includes(fromId) || nodesToMove.includes(toId)) {
           const p1 = savedPositions[fromId] || positions[fromId] || {
            x: 600,
            y: 350
           };
           const p2 = savedPositions[toId] || positions[toId] || {
            x: 600,
            y: 350
           };
           if (edgeEl.tagName === "line") {
            edgeEl.setAttribute("x1", p1.x);
            edgeEl.setAttribute("y1", p1.y);
            edgeEl.setAttribute("x2", p2.x);
            edgeEl.setAttribute("y2", p2.y);
           } else if (edgeEl.tagName === "path") {
            const edgeId = edgeEl.dataset.edgeId;
            const edge = EDGE_DATA.list.find(
             (e) => e.id === edgeId);
            if (edge) {
             const pairTotal = edge._pairTotal || 1;
             const pairIndex = edge._pairIndex || 0;
             const midX = (p1.x + p2.x) / 2;
             const midY = (p1.y + p2.y) / 2;
             const dx = p2.x - p1.x;
             const dy = p2.y - p1.y;
             const len = Math.sqrt(dx * dx + dy * dy) || 1;
             const perpX = -dy / len;
             const perpY = dx / len;
             let offsetAmount = 0;
             if (pairTotal > 1) {
              offsetAmount = (pairIndex - (pairTotal - 1) / 2) * 40;
             }
             const ctrlX = midX + perpX * offsetAmount;
             const ctrlY = midY + perpY * offsetAmount;
             edgeEl.setAttribute("d", `M ${p1.x} ${p1.y} Q ${ctrlX} ${ctrlY} ${p2.x} ${p2.y}`);
            }
           }
          }
         });
        }, {
         passive: false
        });
      g.addEventListener("touchend", (e) => {
      const touchDuration = Date.now() - touchStartTime;
      if (!touchMoved && touchDuration < 400) {
       if (isViewOnly()) {
        handleViewOnlyClick(id, 'node');
        return;
       }
       claimTheImmortal(id);
      }
      if (isDragging) {
      const draggedY = pos.y;
      isDragging = false;
      savedPositions[id] = {
      x: pos.x,
      y: pos.y
      };
      if (currentView.mode === "rack" && NODE_DATA[id]?.assignedRack === currentView.rackId) {
      const rackCapacity = getRackCapacity(currentView.rackId);
      const rackUHeight = getRackUHeight(currentView.rackId);
      let newUnit = rackCapacity - Math.round((draggedY - RACK_START_Y) / rackUHeight);
      newUnit = Math.max(1, Math.min(newUnit, rackCapacity));
      NODE_DATA[id].rackUnit = newUnit;
      forgeTheTopology();
      claimTheImmortal(id);
      }
      }
      touchMoved = false;
      });
        g.style.cursor = "grab";
        g.addEventListener("click", (e) => {
         if (!isDragging) {
          if (isViewOnly()) {
           handleViewOnlyClick(id, 'node');
           return;
          }
          claimTheImmortal(id);
         }
        });
        g.addEventListener("dblclick", (e) => {
         e.preventDefault();
         e.stopPropagation();
         if (NODE_DATA[id].isRack) {
          enterRack(id);
         }
        });
        if (!isNodeVisible(id)) {
         g.style.opacity = "0.1";
         g.style.pointerEvents = "none";
        }
        svg.appendChild(g);
       });
        if (RECT_DATA && RECT_DATA.list) {
         RECT_DATA.list.forEach((rect) => {
          if (currentView.mode === "rack") return;
          if (rect.style === "outlined") {
           const g = document.createElementNS(ns, "g");
           g.classList.add("rect-group");
           g.dataset.rectId = rect.id;
           const rectCenterX = rect.x + rect.width / 2;
           const rectCenterY = rect.y + rect.height / 2;
           const rectRotation = rect.rotation || 0;
           if (rectRotation !== 0) {
             g.setAttribute("transform", `rotate(${rectRotation}, ${rectCenterX}, ${rectCenterY})`);
           }
           const rectEl = document.createElementNS(ns, "rect");
           rectEl.classList.add("rect-shape");
           rectEl.setAttribute("x", rect.x);
           rectEl.setAttribute("y", rect.y);
           rectEl.setAttribute("width", rect.width);
           rectEl.setAttribute("height", rect.height);
           rectEl.style.fill = "none";
           rectEl.style.stroke = rect.borderColor || rect.color;
           rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 3) + "px";
           if (rect.lineStyle === "dashed") { rectEl.style.strokeDasharray = "10,5"; }
else if (rect.lineStyle === "dotted") { rectEl.style.strokeDasharray = "2,4"; }
else if (rect.lineStyle === "wall") {
  rectEl.style.fill = rect.color;
  rectEl.style.fillOpacity = "0.5";
  rectEl.style.stroke = rect.borderColor || rect.color;
  rectEl.style.strokeWidth = (rect.borderWidth !== undefined ? rect.borderWidth : 2) + "px";
  const hatchGroup = document.createElementNS(ns, "g");
  hatchGroup.classList.add("wall-hatch-lines");
  hatchGroup.style.pointerEvents = "none";
  const spacing = 12;
  const hatchColor = rect.borderColor || rect.color;
  for (let i = -rect.height; i < rect.width + rect.height; i += spacing) {
    const line = document.createElementNS(ns, "line");
    line.setAttribute("x1", rect.x + i);
    line.setAttribute("y1", rect.y);
    line.setAttribute("x2", rect.x + i - rect.height);
    line.setAttribute("y2", rect.y + rect.height);
    line.style.stroke = hatchColor;
    line.style.strokeWidth = "2";
    hatchGroup.appendChild(line);
  }
  const clipId = "clip-" + rect.id;
  const clipPath = document.createElementNS(ns, "clipPath");
  clipPath.id = clipId;
  const clipRect = document.createElementNS(ns, "rect");
  clipRect.setAttribute("x", rect.x);
  clipRect.setAttribute("y", rect.y);
  clipRect.setAttribute("width", rect.width);
  clipRect.setAttribute("height", rect.height);
  clipPath.appendChild(clipRect);
  defs.appendChild(clipPath);
  hatchGroup.setAttribute("clip-path", "url(#" + clipId + ")");
  g.appendChild(hatchGroup);
}
           else { rectEl.style.strokeDasharray = "none"; }
           rectEl.style.cursor = "move";
           rectEl.addEventListener("click", (e) => {
             if (rectDrawMode) return;
             e.stopPropagation();
             currentRectId = rect.id;
             selectTheRect(rect.id);
           });
           rectEl.addEventListener("contextmenu", (e) => {
		   if (isViewOnly()) return;
             e.preventDefault();
             e.stopPropagation();
             if (selectedRects.has(rect.id)) {
               selectedRects.delete(rect.id);
             } else {
               selectedRects.add(rect.id);
             }
             updateAllSelections();
           });
           let rectLastTap = 0;
           rectEl.addEventListener("touchend", (e) => {
             const now = Date.now();
             if (now - rectLastTap < 300) {
               e.preventDefault();
               if (selectedRects.has(rect.id)) {
                 selectedRects.delete(rect.id);
               } else {
                 selectedRects.add(rect.id);
               }
               updateAllSelections();
               if (navigator.vibrate) navigator.vibrate(50);
               rectLastTap = 0;
             } else {
               rectLastTap = now;
             }
           }, { passive: false });
           const deleteBtn = document.createElementNS(ns, "g");
           deleteBtn.classList.add("rect-delete-btn");
           deleteBtn.style.cursor = "pointer";
           deleteBtn.style.display = rectDrawMode ? "block" : "none";
           const deleteBg = document.createElementNS(ns, "circle");
           deleteBg.setAttribute("cx", rect.x + rect.width - 10);
           deleteBg.setAttribute("cy", rect.y + 10);
           deleteBg.setAttribute("r", 12);
           deleteBg.style.fill = "#f56565";
           deleteBg.style.stroke = "white";
           deleteBg.style.strokeWidth = "2";
           const deleteX = document.createElementNS(ns, "text");
           deleteX.setAttribute("x", rect.x + rect.width - 10);
           deleteX.setAttribute("y", rect.y + 10);
           deleteX.setAttribute("text-anchor", "middle");
           deleteX.setAttribute("dominant-baseline", "middle");
           deleteX.style.fill = "white";
           deleteX.style.fontSize = "16px";
           deleteX.style.fontWeight = "bold";
           deleteX.style.pointerEvents = "none";
           deleteX.textContent = "×";
           deleteBtn.appendChild(deleteBg);
           deleteBtn.appendChild(deleteX);
           deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            e.preventDefault();
            deleteRectangle(rect.id);
           });
           let isDragging = false;
           let dragStartX, dragStartY;
           let rectStartX, rectStartY;
           rectEl.addEventListener("mousedown", (e) => {
		   if (isViewOnly()) return;
      if (rectDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      rectStartX = rect.x;
      rectStartY = rect.y;
      rectEl.style.cursor = "grabbing";
      if (selectedRects.has(rect.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
           const moveHandler = (e) => {
      if (!isDragging || rectDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      rect.x = rectStartX + dx;
      rect.y = rectStartY + dy;
      if (selectedRects.has(rect.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      if (rectId === rect.id) return;
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
           const upHandler = () => {
            if (isDragging) {
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           };
           document.addEventListener("mousemove", moveHandler);
           document.addEventListener("mouseup", upHandler);
           let touchStartX, touchStartY;
           let touchRectStartX, touchRectStartY;
           rectEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
            if (rectDrawMode) return;
            e.preventDefault();
            e.stopPropagation();
            isDragging = true;
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchRectStartX = rect.x;
            touchRectStartY = rect.y;
            rectEl.style.cursor = "grabbing";
           }, { passive: false });
           rectEl.addEventListener("touchmove", (e) => {
		    if (isViewOnly()) return;
            if (!isDragging || rectDrawMode) return;
            if (!e.touches[0]) return;
            e.preventDefault();
            e.stopPropagation();
            const svgEl = svg;
            const pt1 = svgEl.createSVGPoint();
            pt1.x = touchStartX;
            pt1.y = touchStartY;
            const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
            const touch = e.touches[0];
            const pt2 = svgEl.createSVGPoint();
            pt2.x = touch.clientX;
            pt2.y = touch.clientY;
            const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
            const dx = svgP2.x - svgP1.x;
            const dy = svgP2.y - svgP1.y;
            rect.x = touchRectStartX + dx;
            rect.y = touchRectStartY + dy;
            forgeTheTopology();
           }, { passive: false });
           rectEl.addEventListener("touchend", (e) => {
            if (isDragging) {
             e.preventDefault();
             isDragging = false;
             rectEl.style.cursor = "move";
            }
           }, { passive: false });
           if (currentRectId === rect.id) {
             const corners = [
               { cx: rect.x, cy: rect.y, cursor: 'nwse-resize', dx: -1, dy: -1 },
               { cx: rect.x + rect.width, cy: rect.y, cursor: 'nesw-resize', dx: 1, dy: -1 },
               { cx: rect.x, cy: rect.y + rect.height, cursor: 'nesw-resize', dx: -1, dy: 1 },
               { cx: rect.x + rect.width, cy: rect.y + rect.height, cursor: 'nwse-resize', dx: 1, dy: 1 }
             ];
             corners.forEach((corner, idx) => {
               const handle = document.createElementNS(ns, "circle");
               handle.setAttribute("cx", corner.cx);
               handle.setAttribute("cy", corner.cy);
               const borderW = rect.borderWidth !== undefined ? rect.borderWidth : 3;
               const handleSize = Math.max(PAGE_STATE.selectionHandleSize || 8, borderW + 4);
               handle.setAttribute("r", handleSize);
               handle.style.fill = PAGE_STATE.selectionHandle || "#f59e0b";
               handle.style.stroke = "#fff";
               handle.style.strokeWidth = "2";
               handle.style.cursor = corner.cursor;
               handle.addEventListener("mousedown", (e) => {
                 if (isViewOnly()) return;
                 e.preventDefault();
                 e.stopPropagation();
                 pushUndo("resize zone");
                 let dragging = true;
                 const startX = e.clientX, startY = e.clientY;
                 const origX = rect.x, origY = rect.y, origW = rect.width, origH = rect.height;
                 const moveHandler = (ev) => {
                   if (!dragging) return;
                   const pt1 = svg.createSVGPoint(); pt1.x = startX; pt1.y = startY;
                   const pt2 = svg.createSVGPoint(); pt2.x = ev.clientX; pt2.y = ev.clientY;
                   const svgP1 = pt1.matrixTransform(svg.getScreenCTM().inverse());
                   const svgP2 = pt2.matrixTransform(svg.getScreenCTM().inverse());
                   const dx = svgP2.x - svgP1.x, dy = svgP2.y - svgP1.y;
                   if (corner.dx < 0) { rect.x = origX + dx; rect.width = origW - dx; }
                   else { rect.width = origW + dx; }
                   if (corner.dy < 0) { rect.y = origY + dy; rect.height = origH - dy; }
                   else { rect.height = origH + dy; }
                   if (rect.width < 20) rect.width = 20;
                   if (rect.height < 20) rect.height = 20;
                   forgeTheTopology();
                 };
                 const upHandler = () => { dragging = false; document.removeEventListener("mousemove", moveHandler); document.removeEventListener("mouseup", upHandler); };
                 document.addEventListener("mousemove", moveHandler);
                 document.addEventListener("mouseup", upHandler);
               });
               g.appendChild(handle);
             });
           }
           if (rect.groupId) {
             const groupIndicator = document.createElementNS(ns, "rect");
             groupIndicator.setAttribute("x", rect.x - 4);
             groupIndicator.setAttribute("y", rect.y - 4);
             groupIndicator.setAttribute("width", rect.width + 8);
             groupIndicator.setAttribute("height", rect.height + 8);
             groupIndicator.style.fill = "none";
             groupIndicator.style.stroke = "#4fd1c5";
             groupIndicator.style.strokeWidth = "3";
             groupIndicator.style.strokeDasharray = "5,5";
             groupIndicator.style.pointerEvents = "none";
             g.insertBefore(groupIndicator, g.firstChild);
           }
           g.appendChild(rectEl);
           g.appendChild(deleteBtn);
           svg.appendChild(g);
          }
         });
        }
        if (TEXT_DATA && TEXT_DATA.list) {
         TEXT_DATA.list.forEach((textItem) => {
          if (currentView.mode === "rack") return;
          const g = document.createElementNS(ns, "g");
          g.classList.add("text-group");
          g.dataset.textId = textItem.id;
          const textRotation = textItem.rotation || 0;
          if (textRotation !== 0) {
            g.setAttribute("transform", `rotate(${textRotation}, ${textItem.x}, ${textItem.y})`);
          }
          if (textItem.bgEnabled) {
           const bgRect = document.createElementNS(ns, "rect");
           bgRect.classList.add("text-bg");
           bgRect.setAttribute("x", textItem.x - 5);
           bgRect.setAttribute("y", textItem.y - textItem.fontSize - 2);
           bgRect.setAttribute("width", 100);
           bgRect.setAttribute("height", textItem.fontSize + 10);
           bgRect.style.fill = textItem.bgColor;
           bgRect.style.opacity = "0.7";
           bgRect.style.rx = "4";
           g.appendChild(bgRect);
          }
          const textEl = document.createElementNS(ns, "text");
          textEl.classList.add("text-element");
          textEl.setAttribute("x", textItem.x);
          textEl.setAttribute("y", textItem.y);
          textEl.style.fill = textItem.color;
          textEl.style.fontSize = textItem.fontSize + "px";
          textEl.style.fontWeight = textItem.fontWeight;
          textEl.style.fontStyle = textItem.fontStyle;
          textEl.style.textAnchor = textItem.textAlign;
          textEl.style.textDecoration = textItem.textDecoration;
          textEl.style.opacity = textItem.opacity;
          textEl.style.cursor = "move";
          textEl.style.userSelect = "none";
          textEl.setAttribute("dominant-baseline", "middle");
          const lines = textItem.content.split('\n');
          if (lines.length === 1) {
           textEl.textContent = textItem.content;
          } else {
           lines.forEach((line, i) => {
            const tspan = document.createElementNS(ns, "tspan");
            tspan.textContent = line;
            tspan.setAttribute("x", textItem.x);
            tspan.setAttribute("dy", i === 0 ? 0 : textItem.fontSize * 1.2);
            textEl.appendChild(tspan);
           });
          }
          g.appendChild(textEl);
          if (textItem.bgEnabled) {
           setTimeout(() => {
            try {
             const bbox = textEl.getBBox();
             const bgRect = g.querySelector('.text-bg');
             if (bgRect && bbox) {
              bgRect.setAttribute("x", bbox.x - 5);
              bgRect.setAttribute("y", bbox.y - 2);
              bgRect.setAttribute("width", bbox.width + 10);
              bgRect.setAttribute("height", bbox.height + 4);
             }
            } catch (e) {
            }
           }, 0);
          }
          const deleteBtn = document.createElementNS(ns, "g");
          deleteBtn.classList.add("text-delete-btn");
          deleteBtn.style.cursor = "pointer";
          deleteBtn.style.display = textDrawMode ? "block" : "none";
          const deleteBg = document.createElementNS(ns, "circle");
          deleteBg.setAttribute("cx", textItem.x + 20);
          deleteBg.setAttribute("cy", textItem.y - textItem.fontSize);
          deleteBg.setAttribute("r", 12);
          deleteBg.style.fill = "#f56565";
          deleteBg.style.stroke = "white";
          deleteBg.style.strokeWidth = "2";
          const deleteX = document.createElementNS(ns, "text");
          deleteX.setAttribute("x", textItem.x + 20);
          deleteX.setAttribute("y", textItem.y - textItem.fontSize);
          deleteX.setAttribute("text-anchor", "middle");
          deleteX.setAttribute("dominant-baseline", "middle");
          deleteX.style.fill = "white";
          deleteX.style.fontSize = "16px";
          deleteX.style.fontWeight = "bold";
          deleteX.style.pointerEvents = "none";
          deleteX.textContent = "×";
          deleteBtn.appendChild(deleteBg);
          deleteBtn.appendChild(deleteX);
          deleteBtn.addEventListener("click", (e) => {
           e.stopPropagation();
           e.preventDefault();
           deleteText(textItem.id);
          });
          let isDragging = false;
          let dragStartX, dragStartY;
          let textStartX, textStartY;
          textEl.addEventListener("mousedown", (e) => {
		  if (isViewOnly()) return;
      if (textDrawMode) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      textStartX = textItem.x;
      textStartY = textItem.y;
      textEl.style.cursor = "grabbing";
      showTextPanel(textItem.id);
      if (selectedTexts.has(textItem.id)) {
      initialPositions = {};
      selectedNodes.forEach(nodeId => {
      const nodePos = savedPositions[nodeId];
      if (nodePos) initialPositions[nodeId] = { x: nodePos.x, y: nodePos.y };
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r) { r._dragStartX = r.x; r._dragStartY = r.y; }
      });
      selectedTexts.forEach(textId => {
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t) { t._dragStartX = t.x; t._dragStartY = t.y; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed.points) { ed._dragStartPoints = ed.points.map(p => ({x: p.x, y: p.y})); }
      });
      }
      });
          const moveHandler = (e) => {
      if (!isDragging || textDrawMode) return;
      const svgEl = svg;
      const pt1 = svgEl.createSVGPoint();
      pt1.x = dragStartX;
      pt1.y = dragStartY;
      const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
      const pt2 = svgEl.createSVGPoint();
      pt2.x = e.clientX;
      pt2.y = e.clientY;
      const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
      const dx = svgP2.x - svgP1.x;
      const dy = svgP2.y - svgP1.y;
      textItem.x = textStartX + dx;
      textItem.y = textStartY + dy;
      if (selectedTexts.has(textItem.id)) {
      selectedNodes.forEach(nodeId => {
      if (initialPositions[nodeId]) {
       const newX = initialPositions[nodeId].x + dx;
       const newY = initialPositions[nodeId].y + dy;
       savedPositions[nodeId] = { x: newX, y: newY };
      }
      });
      selectedRects.forEach(rectId => {
      const r = RECT_DATA.list.find(x => x.id === rectId);
      if (r && r._dragStartX !== undefined) { r.x = r._dragStartX + dx; r.y = r._dragStartY + dy; }
      });
      selectedTexts.forEach(textId => {
      if (textId === textItem.id) return;
      const t = TEXT_DATA.list.find(x => x.id === textId);
      if (t && t._dragStartX !== undefined) { t.x = t._dragStartX + dx; t.y = t._dragStartY + dy; }
      });
      selectedEdges.forEach(edgeId => {
      const ed = EDGE_DATA.list.find(x => x.id === edgeId);
      if (ed && ed._dragStartPoints) { ed.points.forEach((p, i) => { p.x = ed._dragStartPoints[i].x + dx; p.y = ed._dragStartPoints[i].y + dy; }); }
      });
      }
      forgeTheTopology();
      };
          const upHandler = () => {
           if (isDragging) {
            isDragging = false;
            textEl.style.cursor = "move";
           }
          };
          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
          let touchStartX = 0, touchStartY = 0;
          let textTouchStartX = 0, textTouchStartY = 0;
          textEl.addEventListener("touchstart", (e) => {
		   if (isViewOnly()) return;
           if (textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           e.stopPropagation();
           const touch = e.touches[0];
           isDragging = true;
           touchStartX = touch.clientX;
           touchStartY = touch.clientY;
           textTouchStartX = textItem.x;
           textTouchStartY = textItem.y;
           showTextPanel(textItem.id);
          }, { passive: false });
          textEl.addEventListener("touchmove", (e) => {
           if (!isDragging || textDrawMode) return;
           if (e.touches.length !== 1) return;
           e.preventDefault();
           const touch = e.touches[0];
           const svgEl = svg;
           const pt1 = svgEl.createSVGPoint();
           pt1.x = touchStartX;
           pt1.y = touchStartY;
           const svgP1 = pt1.matrixTransform(svgEl.getScreenCTM().inverse());
           const pt2 = svgEl.createSVGPoint();
           pt2.x = touch.clientX;
           pt2.y = touch.clientY;
           const svgP2 = pt2.matrixTransform(svgEl.getScreenCTM().inverse());
           const dx = svgP2.x - svgP1.x;
           const dy = svgP2.y - svgP1.y;
           textItem.x = textTouchStartX + dx;
           textItem.y = textTouchStartY + dy;
           forgeTheTopology();
          }, { passive: false });
          textEl.addEventListener("touchend", () => {
           if (isDragging) {
            isDragging = false;
           }
          }, { passive: false });
          textEl.addEventListener("contextmenu", (e) => {
		  if (isViewOnly()) return;
           e.preventDefault();
           e.stopPropagation();
           if (selectedTexts.has(textItem.id)) {
            selectedTexts.delete(textItem.id);
           } else {
            selectedTexts.add(textItem.id);
           }
           updateAllSelections();
          });
          let textLastTap = 0;
          g.addEventListener("touchend", (e) => {
           const now = Date.now();
           if (now - textLastTap < 300) {
            e.preventDefault();
            if (selectedTexts.has(textItem.id)) {
             selectedTexts.delete(textItem.id);
            } else {
             selectedTexts.add(textItem.id);
            }
            updateAllSelections();
            if (navigator.vibrate) navigator.vibrate(50);
            textLastTap = 0;
           } else {
            textLastTap = now;
           }
          }, { passive: false });
          if (textItem.groupId) {
            const groupIndicator = document.createElementNS(ns, "rect");
            groupIndicator.setAttribute("x", textItem.x - 54);
            groupIndicator.setAttribute("y", textItem.y - 24);
            groupIndicator.setAttribute("width", 108);
            groupIndicator.setAttribute("height", 48);
            groupIndicator.setAttribute("rx", "8");
            groupIndicator.style.fill = "none";
            groupIndicator.style.stroke = "#4fd1c5";
            groupIndicator.style.strokeWidth = "3";
            groupIndicator.style.strokeDasharray = "5,5";
            groupIndicator.style.pointerEvents = "none";
            g.insertBefore(groupIndicator, g.firstChild);
          }
          g.appendChild(deleteBtn);
          svg.appendChild(g);
         });
        }
       forgeTheLegend();
       updateMinimap();
       populateRackDropdown();
       if (currentSearchQuery && currentSearchResults.length > 0) {
        highlightSearchResults(currentSearchResults, true);
       }
      }
      const _forgeTheTopologyImpl = forgeTheTopology;
      forgeTheTopology = function(immediate = false) {
       if (immediate || forgeImmediate) {
        forgeImmediate = false;
        clearTimeout(forgeDebounceTimer);
        _forgeTheTopologyImpl();
        return;
       }
       clearTimeout(forgeDebounceTimer);
       forgeDebounceTimer = setTimeout(() => {
        _forgeTheTopologyImpl();
       }, 16);
      };
      function forgeTheTopologyImmediate() {
       forgeImmediate = true;
       forgeTheTopology();
      }
      function showEditModal(title, currentValue, onSave) {
       const modal = document.getElementById("edit-modal");
       const input = document.getElementById("modal-input");
       const titleEl = document.getElementById("modal-title");
       const saveBtn = document.getElementById("modal-save");
       const cancelBtn = document.getElementById("modal-cancel");
       titleEl.textContent = title;
       input.value = currentValue;
       modal.classList.add("active");
       input.focus();
       input.select();
       const cleanup = () => {
        modal.classList.remove("active");
        saveBtn.removeEventListener("click", handleSave);
        cancelBtn.removeEventListener("click", handleCancel);
        input.removeEventListener("keypress", handleEnter);
        modal.removeEventListener("click", bgHandler);
       };
       const handleSave = () => {
        if (input.value.trim()) {
         onSave(input.value.trim());
        }
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const handleEnter = (e) => {
        if (e.key === "Enter") handleSave();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       saveBtn.addEventListener("click", handleSave);
       cancelBtn.addEventListener("click", handleCancel);
       input.addEventListener("keypress", handleEnter);
       modal.addEventListener("click", bgHandler);
      }
      function challengeTheImmortal(message, onConfirm) {
       const modal = document.getElementById("confirm-modal");
       const messageEl = document.getElementById("confirm-message");
       const deleteBtn = document.getElementById("confirm-delete");
       const cancelBtn = document.getElementById("confirm-cancel");
       messageEl.textContent = message;
       modal.classList.add("active");
	   const cleanup = () => {
        modal.classList.remove("active");
        deleteBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.removeEventListener("click", bgHandler);
       };
       const handleConfirm = () => {
        onConfirm();
        cleanup();
       };
       const handleCancel = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) handleCancel();
       };
       deleteBtn.addEventListener("click", handleConfirm);
       cancelBtn.addEventListener("click", handleCancel);
       modal.addEventListener("click", bgHandler);
      }
      const pageTitleEl = document.getElementById("page-title");
      if (pageTitleEl) {
       pageTitleEl.addEventListener("click", () => {
        showEditModal("Edit Title", PAGE_STATE.title || DEFAULT_PAGE_STATE.title,
         (newTitle) => {
          PAGE_STATE.title = newTitle;
          wieldThePower();
         });
       });
      }
      function editNodeName(id) {
       showEditModal("Edit Name", NODE_DATA[id].name, (newName) => {
        pushUndo("edit node name");
        NODE_DATA[id].name = newName;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const label = nodeGroup.querySelector(".node-label");
         if (label) label.textContent = newName;
        }
        if (currentNodeId === id) {
         document.getElementById("node-name").textContent = newName;
        }
       });
      }
      function editNodeIp(id) {
       showEditModal("Edit IP/Subtitle", NODE_DATA[id].ip, (newIp) => {
        pushUndo("edit node ip");
        NODE_DATA[id].ip = newIp;
        const nodeGroup = document.querySelector(`g[data-node-id="${id}"]`);
        if (nodeGroup) {
         const sub = nodeGroup.querySelector(".node-sub");
         if (sub) sub.textContent = newIp;
        }
        if (currentNodeId === id) {
         document.getElementById("node-ip").textContent = newIp;
        }
       });
      }
      function claimTheImmortal(id) {
	   if (isViewOnly()) return;
	   if (!NODE_DATA[id]) return;
       currentNodeId = id;
       currentEdgeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       const data = NODE_DATA[id];
       document.querySelectorAll(".node-group").forEach((n) => {
        n.classList.toggle("active", n.dataset.nodeId === id);
       });
       document.querySelectorAll(".edge").forEach((e) => {
        const active = e.dataset.from === id || e.dataset.to === id;
        e.classList.toggle("active", active);
       });
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.getElementById("node-panel").style.display = "block";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("text-panel").style.display = "none";
       const toolbar = document.getElementById("topology-toolbar");
       if (!topologyToolbarCollapsed) {
        toolbar.style.display = "flex";
       }
       updateTopologyToolbarVisibility();
       document.getElementById("node-name").textContent = data.name;
       document.getElementById("node-ip").textContent = data.ip;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (data.shape === "camera" || data.shape === "cctv") {
    fovSection.style.display = "block";
    document.getElementById("fov-enabled").checked = data.fovEnabled || false;
    document.getElementById("fov-angle").value = data.fovAngle || 90;
    document.getElementById("fov-angle-value").textContent = (data.fovAngle || 90) + "°";
    document.getElementById("fov-distance").value = data.fovDistance || 150;
    document.getElementById("fov-distance-value").textContent = data.fovDistance || 150;
    document.getElementById("fov-rotation").value = data.fovRotation || 0;
    document.getElementById("fov-rotation-value").textContent = (data.fovRotation || 0) + "°";
    document.getElementById("fov-color").value = data.fovColor || "#f59e0b";
    document.getElementById("fov-animate").checked = data.fovAnimate || false;
    document.getElementById("fov-sweep").value = data.fovSweep || 120;
    document.getElementById("fov-sweep-value").textContent = (data.fovSweep || 120) + "°";
    document.getElementById("fov-speed").value = data.fovSpeed || 4;
    document.getElementById("fov-speed-value").textContent = (data.fovSpeed || 4) + "s";
  } else {
    fovSection.style.display = "none";
  }
}
       document.getElementById("node-role").textContent = data.role;
       document.getElementById("node-mac").textContent = data.mac || "--";
       document.getElementById("node-rack").textContent = data.rackUnit || "--";
       document.getElementById("node-uheight").textContent = (data.uHeight || "1") + "U";
       document.getElementById("node-layer").value = data.layer || "physical";
       populateRackDropdown();
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
        assignedRackSelect.value = data.assignedRack || "";
       }
       const rackCapacitySelect = document.getElementById("node-rack-capacity");
       if (rackCapacitySelect) {
        rackCapacitySelect.value = data.rackCapacity || "42";
       }
       const isRack = data.isRack === true;
       const isAssignedToRack = !!data.assignedRack;
       const assignedRackRow = document.getElementById("assigned-rack-row");
       const rackCapacityRow = document.getElementById("rack-capacity-row");
       const uheightRow = document.getElementById("uheight-row");
       if (assignedRackRow) assignedRackRow.style.display = isRack ? "none" : "flex";
       if (rackCapacityRow) rackCapacityRow.style.display = isRack ? "flex" : "none";
       if (uheightRow) uheightRow.style.display = isAssignedToRack ? "flex" : "none";
       const rackContentsSection = document.getElementById("rack-contents-section");
       const rackContentsList = document.getElementById("rack-contents-list");
       if (rackContentsSection && rackContentsList) {
        if (isRack) {
         const nodesInRack = Object.entries(NODE_DATA).filter(([nid, n]) => n.assignedRack === id);
         if (nodesInRack.length > 0) {
          rackContentsList.innerHTML = '';
          nodesInRack.forEach(([nid, n]) => {
           const div = document.createElement('div');
           div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); cursor: pointer;';
           div.onclick = () => claimTheImmortal(nid);
           const nameSpan = document.createElement('span');
           nameSpan.style.color = 'var(--text-main)';
           nameSpan.textContent = n.name;
           div.appendChild(nameSpan);
           (n.tags || []).forEach(t => {
            const tagSpan = document.createElement('span');
            tagSpan.style.cssText = 'background: var(--accent); color: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 4px;';
            tagSpan.textContent = t;
            div.appendChild(tagSpan);
           });
           rackContentsList.appendChild(div);
          });
          rackContentsSection.style.display = "block";
         } else {
          rackContentsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No nodes assigned</div>';
          rackContentsSection.style.display = "block";
         }
        } else {
         rackContentsSection.style.display = "none";
        }
       }
       const connectionsSection = document.getElementById("node-connections-section");
       const connectionsList = document.getElementById("node-connections-list");
       const connectionsCount = document.getElementById("node-connections-count");
       if (connectionsSection && connectionsList) {
        const connectedEdges = (EDGE_DATA.list || []).filter(e => e.from === id || e.to === id);
        connectionsCount.textContent = connectedEdges.length;
        if (connectedEdges.length > 0) {
         connectionsList.innerHTML = '';
         connectedEdges.forEach(e => {
          const isFrom = e.from === id;
          const localPort = isFrom ? e.fromPort : e.toPort;
          const remoteNodeId = isFrom ? e.to : e.from;
          const remotePort = isFrom ? e.toPort : e.fromPort;
          const remoteName = NODE_DATA[remoteNodeId]?.name || remoteNodeId;
          const div = document.createElement('div');
          div.style.cssText = 'padding: 6px 0; border-bottom: 1px solid var(--edge-main); display: flex; align-items: center; font-size: 13px;';
          const localSpan = document.createElement('span');
          localSpan.style.cssText = localPort ? 'color: var(--accent); font-family: monospace; cursor: pointer;' : 'color: var(--text-soft); cursor: pointer;';
          localSpan.textContent = localPort || '-';
          localSpan.title = localPort ? 'Click to view connection' : 'Click to set port';
          localSpan.onclick = () => { if (localPort) { selectTheConnection(e.id); } else { const label = `Port on ${NODE_DATA[id]?.name || id}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === id && x.fromPort === newVal) || (x.to === id && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${NODE_DATA[id]?.name || id}. Use anyway?`)) return; if (isFrom) e.fromPort = newVal; else e.toPort = newVal; claimTheImmortal(id); } } };
          const arrow = document.createElement('span');
          arrow.style.cssText = 'color: var(--text-soft); margin: 0 8px;';
          arrow.textContent = '↔';
          const remoteSpan = document.createElement('span');
          remoteSpan.style.cssText = 'color: var(--text-main); cursor: pointer;';
          remoteSpan.textContent = remoteName;
          remoteSpan.title = 'Click to view connection';
          remoteSpan.onclick = () => { claimTheImmortal(remoteNodeId); focusOnSelected(); };
          const remotePortSpan = document.createElement('span');
          remotePortSpan.style.cssText = remotePort ? 'color: var(--accent); font-family: monospace; margin-left: 6px; cursor: pointer;' : 'color: var(--text-soft); margin-left: 6px; cursor: pointer;';
          remotePortSpan.textContent = '(' + (remotePort || '-') + ')';
          remotePortSpan.title = remotePort ? 'Click to view connection' : 'Click to set port';
          remotePortSpan.onclick = () => { if (remotePort) { selectTheConnection(e.id); } else { const label = `Port on ${remoteName}:`; const newVal = prompt(label, ''); if (newVal !== null && newVal !== '') { const isDupe = (EDGE_DATA.list || []).some(x => x.id !== e.id && ((x.from === remoteNodeId && x.fromPort === newVal) || (x.to === remoteNodeId && x.toPort === newVal))); if (isDupe && !confirm(`Warning: Port "${newVal}" is already used on ${remoteName}. Use anyway?`)) return; if (isFrom) e.toPort = newVal; else e.fromPort = newVal; claimTheImmortal(id); } } };
          div.appendChild(localSpan);
          div.appendChild(arrow);
          div.appendChild(remoteSpan);
          div.appendChild(remotePortSpan);
          connectionsList.appendChild(div);
         });
         connectionsSection.style.display = "block";
        } else {
         connectionsList.innerHTML = '<div style="color: var(--text-soft); font-style: italic;">No connections</div>';
         connectionsSection.style.display = "block";
        }
       }
       document.getElementById("node-name").onclick = () => editNodeName(id);
       document.getElementById("node-ip").onclick = () => editNodeIp(id);
document.getElementById("fov-enabled").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle fov");
  NODE_DATA[currentNodeId].fovEnabled = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-angle").oninput = function() {
  document.getElementById("fov-angle-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovAngle = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-distance").oninput = function() {
  document.getElementById("fov-distance-value").textContent = this.value;
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovDistance = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-rotation").oninput = function() {
  document.getElementById("fov-rotation-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovRotation = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-color").oninput = function() {
  if (!currentNodeId) return;
  pushUndo("change fov color");
  NODE_DATA[currentNodeId].fovColor = this.value;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-animate").onchange = function() {
  if (!currentNodeId) return;
  pushUndo("toggle fov animation");
  NODE_DATA[currentNodeId].fovAnimate = this.checked;
  updateFovCone(currentNodeId);
};
document.getElementById("fov-sweep").oninput = function() {
  document.getElementById("fov-sweep-value").textContent = this.value + "°";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSweep = parseInt(this.value);
  updateFovCone(currentNodeId);
};
document.getElementById("fov-speed").oninput = function() {
  document.getElementById("fov-speed-value").textContent = this.value + "s";
  if (!currentNodeId) return;
  NODE_DATA[currentNodeId].fovSpeed = parseInt(this.value);
  updateFovCone(currentNodeId);
};
       document.getElementById("node-mac").onclick = () => editNodeMac(id);
       document.getElementById("node-rack").onclick = () => editNodeRack(id);
       document.getElementById("node-uheight").onclick = () => editNodeUHeight(id);
       const currentSize = savedSizes[id] || getDefaultSize();
       document.getElementById("size-slider").value = currentSize;
       document.getElementById("size-value").textContent = currentSize;
       const currentRotation = NODE_DATA[id].rotation || 0;
       document.getElementById("rotation-slider").value = Math.max(-360, Math.min(360, currentRotation));
       document.getElementById("rotation-value").value = currentRotation;
       const styleEntry = savedStyles[id] || {};
       const resolvedStyles = resolveStylesEntry(styleEntry);
       const scopeKey = currentStyleScope || "all";
       const flatProps = ["circleColor", "circleBorder", "titleColor", "titleFont", "titleSize", "subColor", "subFont", "subSize", ];
       const isFlat = flatProps.some((p) => Object.prototype.hasOwnProperty.call(styleEntry, p));
       const scopedStyles = isFlat ? styleEntry : styleEntry[scopeKey] || {};
       const circleColorInput = document.getElementById("circle-color");
       const titleColorInput = document.getElementById("title-color");
       const titleFontSelect = document.getElementById("title-font");
       const titleSizeInput = document.getElementById("title-size");
       const subColorInput = document.getElementById("sub-color");
       const subFontSelect = document.getElementById("sub-font");
       const subSizeInput = document.getElementById("sub-size");
       const shapeSelect = document.getElementById("shape-select");
       const scopeSelect = document.getElementById("style-scope");
      circleColorInput.value = scopedStyles.circleColor || resolvedStyles.circleColor || PAGE_STATE.nodeFill || "#1e293b";
       const circleBorderInput = document.getElementById("circle-border");
       circleBorderInput.value = scopedStyles.circleBorder || resolvedStyles.circleBorder || PAGE_STATE.nodeStroke || "#475569";
        titleColorInput.value = scopedStyles.titleColor || resolvedStyles.titleColor || PAGE_STATE.textMain || "#e2e8f0";
        titleFontSelect.value = scopedStyles.titleFont || resolvedStyles.titleFont || "system-ui, sans-serif";
        titleSizeInput.value = scopedStyles.titleSize || resolvedStyles.titleSize || 18;
        subColorInput.value = scopedStyles.subColor || resolvedStyles.subColor || PAGE_STATE.textSoft || "#94a3b8";
       subFontSelect.value = scopedStyles.subFont || resolvedStyles.subFont || "system-ui, sans-serif";
       subSizeInput.value = scopedStyles.subSize || resolvedStyles.subSize || 13;
       shapeSelect.value = data.shape || "circle";
       scopeSelect.value = currentStyleScope || "all";
       document.getElementById("title-offset-y").value = scopedStyles.titleOffsetY || resolvedStyles.titleOffsetY || 0;
       document.getElementById("title-offset-x").value = scopedStyles.titleOffsetX || resolvedStyles.titleOffsetX || 0;
       document.getElementById("sub-offset-y").value = scopedStyles.subOffsetY || resolvedStyles.subOffsetY || 0;
       document.getElementById("sub-offset-x").value = scopedStyles.subOffsetX || resolvedStyles.subOffsetX || 0;
       const tagEl = document.getElementById("node-tags");
       tagEl.innerHTML = "";
       data.tags.forEach((tag, i) => {
        const b = document.createElement("span");
        b.className = "badge";
        if (tag.toLowerCase().includes("wg")) b.classList.add("wg");
        b.style.cursor = "pointer";
        b.style.position = "relative";
        const tagText = document.createElement("span");
        tagText.textContent = tag;
        tagText.addEventListener("click", (e) => {
         e.stopPropagation();
         showEditModal("Edit Tag", tag, (newTag) => {
          if (newTag) {
           pushUndo("edit tag");
           data.tags[i] = newTag;
           claimTheImmortal(id);
          }
         });
        });
        const deleteTag = document.createElement("span");
        deleteTag.textContent = " ✕";
        deleteTag.style.opacity = "0.6";
        deleteTag.style.marginLeft = "4px";
        deleteTag.style.fontSize = "10px";
        deleteTag.addEventListener("click", (e) => {
         e.stopPropagation();
         pushUndo("delete tag");
         data.tags.splice(i, 1);
         claimTheImmortal(id);
        });
        b.append(tagText, deleteTag);
        tagEl.append(b);
       });
       const addTagBtn = document.createElement("span");
       addTagBtn.className = "badge";
       addTagBtn.style.cursor = "pointer";
       addTagBtn.style.opacity = "0.6";
       addTagBtn.style.borderStyle = "dashed";
       addTagBtn.textContent = "+ Add Tag";
       addTagBtn.addEventListener("click", () => {
        showEditModal("Add Tag(s) : comma separated", "",
         (newTagStr) => {
          if (newTagStr) {
           pushUndo("add tags");
           const newTags = newTagStr.split(",").map((t) => t.trim()).filter((t) => t);
           newTags.forEach((t) => data.tags.push(t));
           claimTheImmortal(id);
          }
         });
       });
       tagEl.append(addTagBtn);
       const notesEl = document.getElementById("node-notes");
       notesEl.innerHTML = "";
       data.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const noteText = document.createElement("span");
        noteText.textContent = note;
        noteText.style.flex = "1";
        const deleteBtn = document.createElement("span");
        deleteBtn.className = "delete-note";
        deleteBtn.textContent = "✕";
        deleteBtn.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Are you sure you want to delete this note?",
          () => {
           pushUndo("delete note");
           data.notes.splice(i, 1);
           claimTheImmortal(id);
          });
        });
        li.append(noteText, deleteBtn);
        noteText.addEventListener("dblclick", () => {
         noteText.classList.add("editing");
         noteText.contentEditable = true;
         noteText.focus();
        });
        noteText.addEventListener("blur", () => {
         noteText.classList.remove("editing");
         noteText.contentEditable = false;
         data.notes[i] = noteText.textContent;
        });
        notesEl.append(li);
       });
      const addLineSelect = document.getElementById("add-line-select");
      addLineSelect.innerHTML = "";
      const currentRack = data.assignedRack || "";
      Object.entries(NODE_DATA).forEach(([nodeId, node]) => {
      if (nodeId !== id) {
      const nodeRack = node.assignedRack || "";
      if (currentRack === nodeRack) {
      const opt = document.createElement("option");
      opt.value = nodeId;
      opt.textContent = node.name;
      addLineSelect.appendChild(opt);
      }
      }
      });
      }
      function selectTheConnection(id) {
	   if (isViewOnly()) return;
       currentEdgeId = id;
       currentNodeId = null;
       currentRectId = null;
       currentTextId = null;
       if (isMobileDevice()) {
        const currentHeight = PAGE_STATE.mobileFooterHeight || 40;
        if (currentHeight <= 20) {
         PAGE_STATE.mobileFooterHeight = 80;
         const root = document.documentElement;
         root.style.setProperty("--mobile-footer-height", "80vh");
         const mobileFooterHeightInput = document.getElementById("mobile-footer-height");
         const mobileFooterHeightVal = document.getElementById("mobile-footer-height-val");
         if (mobileFooterHeightInput) mobileFooterHeightInput.value = 80;
         if (mobileFooterHeightVal) mobileFooterHeightVal.textContent = "80%";
        }
       }
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "block";
       document.getElementById("text-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       document.getElementById("topology-toolbar").style.display = "none";
       document.querySelectorAll(".node-group").forEach((n) => n.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach((r) => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach((t) => t.classList.remove("active"));
       document.querySelectorAll(".edge").forEach((e) => {
        e.classList.toggle("active", e.dataset.edgeId === id);
       });
       const edge = EDGE_DATA.list.find((e) => e.id === id);
       if (!edge) return;
       const directionSymbols = {
        none: "⇄",
        forward: "→",
        backward: "←",
        both: "↔",
       };
       const dirSymbol = directionSymbols[edge.direction] || "⇄";
       let titleText = "Custom line";
       if (edge.from || edge.to) {
        const fromName = edge.from ? NODE_DATA[edge.from]?.name || edge.from : "";
        const toName = edge.to ? NODE_DATA[edge.to]?.name || edge.to : "";
        titleText = `${fromName || "?"} ${dirSymbol} ${toName || "?"}`;
       }
       document.getElementById("edge-title").textContent = titleText;
       const widthInput = document.getElementById("edge-width");
       const colorInput = document.getElementById("edge-color");
       const directionSelect = document.getElementById("edge-direction");
       const lineStyleSelect = document.getElementById("edge-line-style");
       const routingSelect = document.getElementById("edge-routing");
       widthInput.value = edge.width;
       colorInput.value = edge.color;
       directionSelect.value = edge.direction || "none";
       lineStyleSelect.value = edge.lineStyle || "solid";
       routingSelect.value = edge.routing || "curved";
       document.getElementById("edge-animate").checked = edge.animate === true;
       document.getElementById("edge-animation-style").value = edge.animationStyle || "";
       document.getElementById("edge-animation-speed").value = edge.animationSpeed || "";
       const fromPortRow = document.getElementById("edge-from-port-row");
       const toPortRow = document.getElementById("edge-to-port-row");
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (edge.type === "custom") {
        fromPortRow.style.display = "none";
        toPortRow.style.display = "none";
       } else {
        fromPortRow.style.display = "flex";
        toPortRow.style.display = "flex";
        fromPortInput.value = edge.fromPort || "";
        toPortInput.value = edge.toPort || "";
        fromPortInput.onchange = () => updateEdgePortLabels(id);
        toPortInput.onchange = () => updateEdgePortLabels(id);
       }
       const list = document.getElementById("edge-notes");
       list.innerHTML = "";
       edge.notes.forEach((note, i) => {
        const li = document.createElement("li");
        const txt = document.createElement("span");
        txt.textContent = note;
        txt.style.flex = "1";
        const del = document.createElement("span");
        del.className = "delete-note";
        del.textContent = "✕";
        del.addEventListener("click", (e) => {
         e.stopPropagation();
         challengeTheImmortal("Delete this line note?", () => {
          pushUndo("delete edge note");
          edge.notes.splice(i, 1);
          selectTheConnection(id);
         });
        });
        txt.addEventListener("dblclick", () => {
         txt.classList.add("editing");
         txt.contentEditable = true;
         txt.focus();
        });
        txt.addEventListener("blur", () => {
         txt.classList.remove("editing");
         txt.contentEditable = false;
         pushUndo("edit edge note");
         edge.notes[i] = txt.textContent;
        });
        li.append(txt, del);
        list.appendChild(li);
       });
       if (edge.type === "custom" && Array.isArray(edge.points)) {
        forgeTheTopology();
       }
      }
      window.addEventListener("resize", () => {
       forgeTheTopology();
       if (currentEdgeId) {
        selectTheConnection(currentEdgeId);
       } else if (currentNodeId && NODE_DATA[currentNodeId]) {
        claimTheImmortal(currentNodeId);
       } else {
        const availableNodes = Object.keys(NODE_DATA);
        if (availableNodes.length > 0) {
         claimTheImmortal(availableNodes[0]);
        }
       }
      });
      (function initZoomPan() {
       const viewport = document.getElementById("canvas-viewport");
       const svg = document.getElementById("map");
       const hint = document.getElementById("canvas-hint");
       setTimeout(() => {
        hint.classList.add("visible");
        setTimeout(() => hint.classList.remove("visible"), 4000);
       }, 1000);
       viewport.addEventListener("wheel",
        (e) => {
         e.preventDefault();
         const rect = viewport.getBoundingClientRect();
         const mouseX = (e.clientX - rect.left) / rect.width;
         const mouseY = (e.clientY - rect.top) / rect.height;
         const delta = e.deltaY > 0 ? 0.9 : 1.1;
         zoomTo(canvasState.zoom * delta, mouseX, mouseY);
        }, {
         passive: false
        });
       let initialPinchDistance = 0;
       let initialPinchZoom = 1;
       let pinchCenter = {
        x: 0.5,
        y: 0.5
       };
       let threeFingerTapStart = 0;
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.touches.length === 3) {
          e.preventDefault();
          threeFingerTapStart = Date.now();
         }
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          initialPinchDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          initialPinchZoom = canvasState.zoom;
          const rect = viewport.getBoundingClientRect();
          const centerX = (touch1.clientX + touch2.clientX) / 2;
          const centerY = (touch1.clientY + touch2.clientY) / 2;
          pinchCenter.x = (centerX - rect.left) / rect.width;
          pinchCenter.y = (centerY - rect.top) / rect.height;
         }
        }, {
         passive: false
        });
       viewport.addEventListener("touchend", (e) => {
        if (e.touches.length === 0 && threeFingerTapStart > 0) {
         const duration = Date.now() - threeFingerTapStart;
         if (duration < 500) {
          e.preventDefault();
          undo();
          if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
         }
         threeFingerTapStart = 0;
        }
       }, { passive: false });
       viewport.addEventListener("touchmove",
        (e) => {
         if (e.touches.length === 2) {
          e.preventDefault();
          const touch1 = e.touches[0];
          const touch2 = e.touches[1];
          const currentDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
          if (initialPinchDistance > 0) {
           const scale = currentDistance / initialPinchDistance;
           const newZoom = initialPinchZoom * scale;
           zoomTo(newZoom, pinchCenter.x, pinchCenter.y);
          }
         }
        }, {
         passive: false
        });
       let panStartViewX = 0;
       let panStartViewY = 0;
       let lastEmptyTapTime = 0;
       let emptyTapTimeout = null;
       let emptyTapMoved = false;
       let emptyTapStartX = 0;
       let emptyTapStartY = 0;
       viewport.addEventListener("touchend", (e) => {
         if (currentView.mode !== "rack") return;
         if (e.changedTouches.length !== 1) return;
      const isNodeOrEdge = e.target.closest(".node-group") || e.target.closest(".edge-group");
         if (isNodeOrEdge) return;
         if (emptyTapMoved) {
           emptyTapMoved = false;
           return;
         }
         const currentTime = new Date().getTime();
         const tapGap = currentTime - lastEmptyTapTime;
         if (tapGap < 300 && tapGap > 0) {
           e.preventDefault();
           exitRack();
           if (navigator.vibrate) {
             navigator.vibrate(50);
           }
           lastEmptyTapTime = 0;
           if (emptyTapTimeout) {
             clearTimeout(emptyTapTimeout);
             emptyTapTimeout = null;
           }
         } else {
           lastEmptyTapTime = currentTime;
           if (emptyTapTimeout) clearTimeout(emptyTapTimeout);
           emptyTapTimeout = setTimeout(() => {
             lastEmptyTapTime = 0;
           }, 300);
         }
       }, { passive: false });
       viewport.addEventListener("mousedown", (e) => {
        if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
         return;
        }
        if (freeDrawMode || rectDrawMode) {
         return;
        }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
	  if (isViewOnly()) {
         document.body.classList.remove("view-only-inspect");
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
        }
        if (isEmptySpace && e.shiftKey && e.button === 0) {
         if (isViewOnly()) return;
         e.preventDefault();
         startSelection(e);
         return;
        }
        if (isEmptySpace || e.button === 2 || e.button === 1) {
         e.preventDefault();
         canvasState.isPanning = true;
         canvasState.panStartX = e.clientX;
         canvasState.panStartY = e.clientY;
         panStartViewX = canvasState.panX;
         panStartViewY = canvasState.panY;
         viewport.classList.add("panning");
        }
       });
       viewport.addEventListener("touchstart",
        (e) => {
         if (e.target.closest(".draw-toolbar") || e.target.closest(".topology-toolbar") || e.target.closest(".legend-container")) {
          return;
         }
         if (freeDrawMode || rectDrawMode) {
          return;
         }
      const isEmptySpace = e.target === svg || e.target === viewport || e.target.tagName === "svg";
      const isEdgeElement = e.target.closest('.edge') || e.target.classList.contains('edge-edit-point') || e.target.dataset.edgeId;
      const isTextElement = e.target.closest('.text-group') || e.target.closest('.text-element');
      const isRectElement = e.target.closest('.rect-group');
      if (!isEdgeElement && !isTextElement && !isRectElement && currentEdgeId) {
      currentEdgeId = null;
      forgeTheTopology();
      }
      if (!isRectElement && currentRectId) {
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      }
         if (e.touches.length === 1) {
           e.preventDefault();
           emptyTapMoved = false;
           emptyTapStartX = e.touches[0].clientX;
           emptyTapStartY = e.touches[0].clientY;
           canvasState.isPanning = true;
           canvasState.panStartX = e.touches[0].clientX;
           canvasState.panStartY = e.touches[0].clientY;
           panStartViewX = canvasState.panX;
           panStartViewY = canvasState.panY;
           viewport.classList.add("panning");
         }
        }, {
         passive: false
        });
       let panRAFPending = false;
       let lastPanEvent = null;
       document.addEventListener("mousemove", (e) => {
        if (isSelecting) {
         updateSelection(e);
         return;
        }
        if (!canvasState.isPanning) return;
        lastPanEvent = e;
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (lastPanEvent && canvasState.isPanning) {
           const dx = lastPanEvent.clientX - canvasState.panStartX;
           const dy = lastPanEvent.clientY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (!canvasState.isPanning || !e.touches[0]) return;
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;
        const moveDx = Math.abs(touchX - emptyTapStartX);
        const moveDy = Math.abs(touchY - emptyTapStartY);
        if (moveDx > 15 || moveDy > 15) {
         emptyTapMoved = true;
        }
        if (!panRAFPending) {
         panRAFPending = true;
         requestAnimationFrame(() => {
          if (canvasState.isPanning) {
           const dx = touchX - canvasState.panStartX;
           const dy = touchY - canvasState.panStartY;
           const rect = viewport.getBoundingClientRect();
           const viewWidth = CANVAS_WIDTH / canvasState.zoom;
           const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
           const canvasDx = (dx / rect.width) * viewWidth;
           const canvasDy = (dy / rect.height) * viewHeight;
           canvasState.panX = panStartViewX - canvasDx;
           canvasState.panY = panStartViewY - canvasDy;
           constrainPan();
           updateViewBox();
          }
          panRAFPending = false;
         });
        }
       });
       document.addEventListener("mouseup", () => {
        if (isSelecting) {
         endSelection();
        }
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("touchend", () => {
        if (canvasState.isPanning) {
         canvasState.isPanning = false;
         viewport.classList.remove("panning");
        }
       });
       document.addEventListener("keydown", (e) => {
        const isEditing = document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA" || document.activeElement.isContentEditable;
        if (e.code === "Space" && !e.repeat && !isEditing) {
         e.preventDefault();
         canvasState.spacePressed = true;
         viewport.style.cursor = "grab";
        }
       });
       document.addEventListener("keyup", (e) => {
        if (e.code === "Space") {
         canvasState.spacePressed = false;
         viewport.style.cursor = "";
        }
       });
       document.getElementById("zoom-in-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
       });
       document.getElementById("zoom-out-btn").addEventListener("click", () => {
        zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
       });
       document.getElementById("zoom-fit-btn").addEventListener("click", fitToContent);
       document.getElementById("zoom-reset-btn").addEventListener("click", resetView);
       const minimapContainer = document.getElementById("minimap-container");
       const minimapSvg = document.getElementById("minimap");
       let minimapDragging = false;
       minimapContainer.addEventListener("mousedown", (e) => {
        e.preventDefault();
        minimapDragging = true;
        updatePanFromMinimap(e);
       });
       minimapContainer.addEventListener("touchstart",
        (e) => {
         e.preventDefault();
         minimapDragging = true;
         updatePanFromMinimapTouch(e);
        }, {
         passive: false
        });
       document.addEventListener("mousemove", (e) => {
        if (minimapDragging) {
         updatePanFromMinimap(e);
        }
       });
       document.addEventListener("touchmove", (e) => {
        if (minimapDragging && e.touches[0]) {
         updatePanFromMinimapTouch(e);
        }
       });
       document.addEventListener("mouseup", () => {
        minimapDragging = false;
       });
       document.addEventListener("touchend", () => {
        minimapDragging = false;
       });
       function updatePanFromMinimap(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const x = (e.clientX - rect.left) / rect.width;
        const y = (e.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       function updatePanFromMinimapTouch(e) {
        const rect = minimapContainer.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) / rect.width;
        const y = (touch.clientY - rect.top) / rect.height;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        canvasState.panX = x * CANVAS_WIDTH - viewWidth / 2;
        canvasState.panY = y * CANVAS_HEIGHT - viewHeight / 2;
        constrainPan();
        updateViewBox();
       }
       document.addEventListener("keydown", (e) => {
        if (document.activeElement.tagName === "INPUT" || document.activeElement.tagName === "TEXTAREA") return;
        if (
         (e.key === "+" || e.key === "=") && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 1.25, 0.5, 0.5);
        } else if (e.key === "-" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         zoomTo(canvasState.zoom * 0.8, 0.5, 0.5);
        } else if (e.key === "0" && (e.ctrlKey || e.metaKey)) {
         e.preventDefault();
         resetView();
        }
       });
       setTimeout(() => {
        fitToContent();
       }, 100);
      })();
      const sizeSlider = document.getElementById("size-slider");
      const sizeValue = document.getElementById("size-value");
      const resetSizeBtn = document.getElementById("reset-size");
      sizeSlider.addEventListener("input", () => {
       const newSize = parseInt(sizeSlider.value, 10);
       sizeValue.textContent = newSize;
       pushUndo("resize node");
       savedSizes[currentNodeId] = newSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createShapeElement(shapeType, newSize);
        newShape.classList.add("node-circle");
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -newSize * 0.28);
         const labelSize = styles.titleSize || newSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", newSize * 0.4);
         const subSize = styles.subSize || newSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      resetSizeBtn.addEventListener("click", () => {
       pushUndo("reset size");
       delete savedSizes[currentNodeId];
       const defaultSize = getDefaultSize();
       sizeSlider.value = defaultSize;
       sizeValue.textContent = defaultSize;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (nodeGroup) {
        const oldShape = nodeGroup.querySelector(".node-circle");
        if (oldShape) oldShape.remove();
        const shapeType = (NODE_DATA[currentNodeId] && NODE_DATA[currentNodeId].shape) || "circle";
        const newShape = createNodeShape(currentNodeId, defaultSize);
        nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
        const styles = resolveStylesForNode(currentNodeId);
        if (styles.circleColor) newShape.style.fill = styles.circleColor;
        if (styles.circleBorder) newShape.style.stroke = styles.circleBorder;
        const label = nodeGroup.querySelector(".node-label");
        const sub = nodeGroup.querySelector(".node-sub");
        if (label) {
         label.setAttribute("y", -defaultSize * 0.28);
         const labelSize = styles.titleSize || defaultSize * 0.33;
         label.style.fontSize = labelSize + "px";
        }
        if (sub) {
         sub.setAttribute("y", defaultSize * 0.4);
         const subSize = styles.subSize || defaultSize * 0.24;
         sub.style.fontSize = subSize + "px";
        }
       }
      });
      const rotationSlider = document.getElementById("rotation-slider");
      const rotationInput = document.getElementById("rotation-value");
      const resetRotationBtn = document.getElementById("reset-rotation");
      rotationSlider.addEventListener("input", () => {
        const newRotation = parseInt(rotationSlider.value, 10);
        rotationInput.value = newRotation;
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      rotationInput.addEventListener("input", () => {
        const newRotation = parseInt(rotationInput.value, 10) || 0;
        rotationSlider.value = Math.max(-360, Math.min(360, newRotation));
        pushUndo("rotate node");
        NODE_DATA[currentNodeId].rotation = newRotation;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(${newRotation})`);
        }
      });
      resetRotationBtn.addEventListener("click", () => {
        pushUndo("reset rotation");
        NODE_DATA[currentNodeId].rotation = 0;
        rotationSlider.value = 0;
        rotationInput.value = 0;
        const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
        if (nodeGroup) {
          const pos = savedPositions[currentNodeId] || { x: 0, y: 0 };
          nodeGroup.setAttribute("transform", `translate(${pos.x},${pos.y}) rotate(0)`);
        }
      });
      const applyStyle = (property, value) => {
       pushUndo("style change");
       const styleEntry = ensureStyleEntry(currentNodeId);
       const scopeKey = currentStyleScope || "all";
       if (!styleEntry[scopeKey]) styleEntry[scopeKey] = {};
       styleEntry[scopeKey][property] = value;
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const shapeEl = nodeGroup.querySelector(".node-circle");
       const label = nodeGroup.querySelector(".node-label");
       const sub = nodeGroup.querySelector(".node-sub");
       if (property === "circleColor" && shapeEl) shapeEl.style.fill = value;
      else if (property === "circleBorder" && shapeEl) shapeEl.style.stroke = value;
       else if (property === "titleColor" && label) label.style.fill = value;
       else if (property === "titleFont" && label) label.style.fontFamily = value;
       else if (property === "titleSize" && label) label.style.fontSize = value + "px";
       else if (property === "subColor" && sub) sub.style.fill = value;
       else if (property === "subFont" && sub) sub.style.fontFamily = value;
       else if (property === "subSize" && sub) sub.style.fontSize = value + "px";
      };
      document.getElementById("circle-color").addEventListener("input", (e) => applyStyle("circleColor", e.target.value));
      document.getElementById("circle-border").addEventListener("input", (e) => applyStyle("circleBorder", e.target.value));
      document.getElementById("title-color").addEventListener("input", (e) => applyStyle("titleColor", e.target.value));
      document.getElementById("title-font").addEventListener("change", (e) => applyStyle("titleFont", e.target.value));
      document.getElementById("title-size").addEventListener("input", (e) => applyStyle("titleSize", parseInt(e.target.value, 10)));
      document.getElementById("sub-color").addEventListener("input", (e) => applyStyle("subColor", e.target.value));
      document.getElementById("sub-font").addEventListener("change", (e) => applyStyle("subFont", e.target.value));
      document.getElementById("sub-size").addEventListener("input", (e) => applyStyle("subSize", parseInt(e.target.value, 10)));
      document.getElementById("title-offset-y").addEventListener("input", (e) => {
       applyStyle("titleOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("title-offset-x").addEventListener("input", (e) => {
       applyStyle("titleOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-y").addEventListener("input", (e) => {
       applyStyle("subOffsetY", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("sub-offset-x").addEventListener("input", (e) => {
       applyStyle("subOffsetX", parseInt(e.target.value, 10) || 0);
       forgeTheTopology();
       if (currentNodeId) claimTheImmortal(currentNodeId);
      });
      document.getElementById("reset-styles").addEventListener("click", () => {
       delete savedStyles[currentNodeId];
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("style-scope").addEventListener("change", (e) => {
       currentStyleScope = e.target.value || "all";
       claimTheImmortal(currentNodeId);
      });
      document.getElementById("shape-select").addEventListener("change", (e) => {
       const shape = e.target.value || "circle";
       pushUndo("change shape");
       NODE_DATA[currentNodeId].shape = shape;
const fovSection = document.getElementById("fov-section");
if (fovSection) {
  if (shape === "camera" || shape === "cctv") {
    fovSection.style.display = "block";
  } else {
    fovSection.style.display = "none";
  }
}
       const nodeGroup = document.querySelector(`g[data-node-id="${currentNodeId}"]`);
       if (!nodeGroup) return;
       const oldShape = nodeGroup.querySelector(".node-circle");
       if (oldShape) oldShape.remove();
       const size = savedSizes[currentNodeId] || getDefaultSize();
       const newShape = createNodeShape(currentNodeId, size);
       nodeGroup.insertBefore(newShape, nodeGroup.firstChild);
      });
      const addNoteBtn = document.getElementById("add-note-btn");
      const noteInput = document.getElementById("new-note-input");
      addNoteBtn.addEventListener("click", () => {
       const newNote = noteInput.value.trim();
       if (newNote && currentNodeId) {
	    pushUndo("add note");
        NODE_DATA[currentNodeId].notes.push(newNote);
        claimTheImmortal(currentNodeId);
        noteInput.value = "";
       }
      });
      noteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addNoteBtn.click();
       }
      });
      document.getElementById("edge-width").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const v = parseInt(document.getElementById("edge-width").value, 10);
       if (Number.isNaN(v) || v <= 0) return;
       pushUndo("edit edge");
       edge.width = v;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.strokeWidth = v;
      });
      document.getElementById("edge-color").addEventListener("input", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       const color = document.getElementById("edge-color").value;
       pushUndo("edit edge");
       edge.color = color;
       const el = document.querySelector(`.edge[data-edge-id="${currentEdgeId}"]`);
       if (el) el.style.stroke = color;
       forgeTheLegend();
      });
      document.getElementById("edge-direction").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.direction = document.getElementById("edge-direction").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-line-style").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge");
       edge.lineStyle = document.getElementById("edge-line-style").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-routing").addEventListener("change", () => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge routing");
       edge.routing = document.getElementById("edge-routing").value;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animate").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animate");
       edge.animate = e.target.checked;
       forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      document.getElementById("edge-animation-speed").addEventListener("change", (e) => {
       if (!currentEdgeId) return;
       const edge = EDGE_DATA.list.find((ed) => ed.id === currentEdgeId);
       if (!edge) return;
       pushUndo("edit edge animation speed");
       edge.animationSpeed = e.target.value || "";
       if (PAGE_STATE.animateConnections && edge.animate !== false) forgeTheTopology();
       selectTheConnection(currentEdgeId);
      });
      const addEdgeNoteBtn = document.getElementById("add-edge-note");
      const newEdgeNoteInput = document.getElementById("new-edge-note");
      addEdgeNoteBtn.addEventListener("click", () => {
       const txt = newEdgeNoteInput.value.trim();
       if (!txt || !currentEdgeId) return;
       const edge = EDGE_DATA.list.find((e) => e.id === currentEdgeId);
       if (!edge) return;
	   pushUndo("add edge note");
       edge.notes.push(txt);
       newEdgeNoteInput.value = "";
       selectTheConnection(currentEdgeId);
      });
      newEdgeNoteInput.addEventListener("keypress", (e) => {
       if (e.key === "Enter") {
        addEdgeNoteBtn.click();
       }
      });
      function selectTheRect(id) {
	  if (isViewOnly()) return;
      currentRectId = id;
      currentNodeId = null;
      currentEdgeId = null;
      currentTextId = null;
      document.getElementById("node-panel").style.display = "none";
      document.getElementById("edge-panel").style.display = "none";
      document.getElementById("text-panel").style.display = "none";
      document.getElementById("rect-panel").style.display = "block";
      document.getElementById("topology-toolbar").style.display = "none";
      document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
      document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
      document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
      document.querySelectorAll(".rect-group").forEach(r => r.classList.toggle("active", r.dataset.rectId === id));
      const rect = RECT_DATA.list.find(r => r.id === id);
      if (!rect) return;
      document.getElementById("rect-title").textContent = "";
      document.getElementById("rect-color").value = rect.color || "#f97316";
      document.getElementById("rect-border-color").value = rect.borderColor || rect.color || "#f97316";
      document.getElementById("rect-border-width").value = rect.borderWidth !== undefined ? rect.borderWidth : 2;
      document.getElementById("rect-style-select").value = rect.style || "filled";
      document.getElementById("rect-line-style").value = rect.lineStyle || "solid";
	  document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, rect.rotation || 0));
      document.getElementById("rect-rotation-value").value = rect.rotation || 0;
      document.getElementById("rect-fill-row").style.display = (rect.style === "outlined") ? "none" : "flex";
      const list = document.getElementById("rect-notes");
      list.innerHTML = "";
      (rect.notes || []).forEach((note, i) => {
      const li = document.createElement("li");
      const txt = document.createElement("span");
      txt.textContent = note;
      txt.style.flex = "1";
      const del = document.createElement("span");
      del.className = "delete-note";
      del.textContent = "✕";
       del.addEventListener("click", (e) => {
      e.stopPropagation();
      challengeTheImmortal("Delete this note?", () => {
        pushUndo("delete zone note");
        rect.notes.splice(i, 1);
        selectTheRect(id);
      });
      });
      li.appendChild(txt);
      li.appendChild(del);
      list.appendChild(li);
      });
      forgeTheTopology();
      }
      document.getElementById("rect-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.color = document.getElementById("rect-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-color").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderColor = document.getElementById("rect-border-color").value;
      forgeTheTopology();
      });
      document.getElementById("rect-border-width").addEventListener("input", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.borderWidth = parseInt(document.getElementById("rect-border-width").value) || 2;
      forgeTheTopology();
      });
      document.getElementById("rect-style-select").addEventListener("change", () => {
      if (!currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      pushUndo("edit zone");
      rect.style = document.getElementById("rect-style-select").value;
      forgeTheTopology();
      selectTheRect(currentRectId);
      });
document.getElementById("rect-rotation").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        rect.rotation = parseInt(document.getElementById("rect-rotation").value) || 0;
        document.getElementById("rect-rotation-value").value = rect.rotation;
        forgeTheTopology();
      });
      document.getElementById("rect-rotation-value").addEventListener("input", () => {
        if (!currentRectId) return;
        const rect = RECT_DATA.list.find(r => r.id === currentRectId);
        if (!rect) return;
        pushUndo("rotate zone");
        const val = parseInt(document.getElementById("rect-rotation-value").value) || 0;
        rect.rotation = val;
        document.getElementById("rect-rotation").value = Math.max(-360, Math.min(360, val));
        forgeTheTopology();
      });
      document.getElementById("rect-line-style").addEventListener("change", () => {
      if (!currentRectId) return;
      pushUndo("change zone line style");
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      rect.lineStyle = document.getElementById("rect-line-style").value;
      forgeTheTopology();
      });
      document.getElementById("add-rect-note").addEventListener("click", () => {
      const input = document.getElementById("new-rect-note");
      const txt = input.value.trim();
      if (!txt || !currentRectId) return;
      const rect = RECT_DATA.list.find(r => r.id === currentRectId);
      if (!rect) return;
      if (!rect.notes) rect.notes = [];
	  pushUndo("add zone note");
      rect.notes.push(txt);
      input.value = "";
      selectTheRect(currentRectId);
      });
      document.getElementById("new-rect-note").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
      document.getElementById("add-rect-note").click();
      }
      });
      document.getElementById("delete-rect").addEventListener("click", () => {
      if (!currentRectId) return;
      challengeTheImmortal("Delete this zone?", () => {
      pushUndo("delete zone");
      RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
      currentRectId = null;
      document.getElementById("rect-panel").style.display = "none";
      forgeTheTopology();
      });
      });
      document.getElementById("delete-edge").addEventListener("click", () => {
       if (!currentEdgeId) return;
       challengeTheImmortal("Are you sure you want to delete this line?",
        () => {
         pushUndo("delete edge");
         EDGE_DATA.list = EDGE_DATA.list.filter(
          (e) => e.id !== currentEdgeId);
         currentEdgeId = null;
         forgeTheTopology();
         const availableNodes = Object.keys(NODE_DATA);
         if (availableNodes.length > 0) {
          claimTheImmortal(availableNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar", ).style.display = "none";
         }
        });
      });
      document.getElementById("add-line-btn").addEventListener("click", () => {
       if (!currentNodeId) return;
       const select = document.getElementById("add-line-select");
       const directionSelect = document.getElementById("add-line-direction");
       const colorInput = document.getElementById("add-line-color");
       const routingSelect = document.getElementById("add-line-routing");
       const targetId = select.value;
       if (!targetId || targetId === currentNodeId) return;
       const direction = directionSelect.value || "none";
       const lineColor = colorInput.value || "#475569";
       const routing = routingSelect.value || PAGE_STATE.defaultEdgeRouting || "orthogonal";
       const newId = `${currentNodeId}-${targetId}-${Date.now()}`;
       const newEdge = {
        id: newId,
        from: currentNodeId,
        to: targetId,
        width: 4,
        color: lineColor,
        direction: direction,
        routing: routing,
        type: "main",
        notes: [],
        fromPort: "",
        toPort: "",
        lineStyle: "solid",
       };
       pushUndo("add edge");
       EDGE_DATA.list.push(newEdge);
       forgeTheTopology();
       claimTheImmortal(currentNodeId);
      });
      let freeDrawPoints = [];
      let freeDrawPolylineEl = null;
      let freeDrawPointEls = [];
       let rectStartPoint = null;
       let rectPreviewEl = null;
       let rectStyle = "filled";
      const drawToggleBtn = document.getElementById("draw-toggle");
      const drawUndoBtn = document.getElementById("draw-undo");
      const drawColorInput = document.getElementById("draw-color");
      const drawStyleSelect = document.getElementById("draw-style");
      const drawArrowSelect = document.getElementById("draw-arrow");
      const svgMap = document.getElementById("map");
      function updateFreeDrawGraphics() {
       const ns = "http://www.w3.org/2000/svg";
       const svg = svgMap;
       if (!freeDrawPolylineEl && freeDrawPoints.length > 0) {
        freeDrawPolylineEl = document.createElementNS(ns, "polyline");
        freeDrawPolylineEl.classList.add("edge", "free-preview");
        freeDrawPolylineEl.setAttribute("fill", "none");
        svg.appendChild(freeDrawPolylineEl);
       }
       if (freeDrawPolylineEl) {
        if (freeDrawPoints.length === 0) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        } else {
         const ptsStr = freeDrawPoints.map((p) => `${p.x},${p.y}`).join(" ");
         freeDrawPolylineEl.setAttribute("points", ptsStr);
         freeDrawPolylineEl.style.stroke = drawColorInput.value || "#475569";
         freeDrawPolylineEl.style.strokeWidth = 3;
         const lineStyle = drawStyleSelect.value || "solid";
         if (lineStyle === "dashed") {
          freeDrawPolylineEl.style.strokeDasharray = "10,5";
         } else if (lineStyle === "dotted") {
          freeDrawPolylineEl.style.strokeDasharray = "2,4";
         } else if (lineStyle === "wall") {
  freeDrawPolylineEl.style.stroke = "url(#wall-hatch)";
  freeDrawPolylineEl.style.strokeWidth = "12";
  freeDrawPolylineEl.style.strokeDasharray = "none"; 
  } else {
          freeDrawPolylineEl.style.strokeDasharray = "none";
         }
        }
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       freeDrawPoints.forEach((p, idx) => {
        const c = document.createElementNS(ns, "circle");
        c.classList.add("free-point");
        c.setAttribute("cx", p.x);
        c.setAttribute("cy", p.y);
        c.setAttribute("r", 5);
        c.dataset.index = String(idx);
        c.addEventListener("mousedown", (e) => {
         if (!freeDrawMode) return;
         e.preventDefault();
         e.stopPropagation();
         let dragging = true;
         const svgEl = svgMap;
         const moveHandler = (ev) => {
          if (!dragging) return;
          const pt = svgEl.createSVGPoint();
          pt.x = ev.clientX;
          pt.y = ev.clientY;
          const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
          const i = parseInt(c.dataset.index, 10);
          if (Number.isNaN(i) || !freeDrawPoints[i]) return;
          freeDrawPoints[i].x = svgP.x;
          freeDrawPoints[i].y = svgP.y;
          updateFreeDrawGraphics();
         };
         const upHandler = () => {
          dragging = false;
          document.removeEventListener("mousemove", moveHandler);
          document.removeEventListener("mouseup", upHandler);
         };
         document.addEventListener("mousemove", moveHandler);
         document.addEventListener("mouseup", upHandler);
        });
        c.addEventListener("touchstart",
         (e) => {
          if (!freeDrawMode) return;
          e.preventDefault();
          e.stopPropagation();
          let dragging = true;
          const svgEl = svgMap;
          const touchMoveHandler = (ev) => {
           if (!dragging || !ev.touches[0]) return;
           const pt = svgEl.createSVGPoint();
           pt.x = ev.touches[0].clientX;
           pt.y = ev.touches[0].clientY;
           const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
           const i = parseInt(c.dataset.index, 10);
           if (Number.isNaN(i) || !freeDrawPoints[i]) return;
           freeDrawPoints[i].x = svgP.x;
           freeDrawPoints[i].y = svgP.y;
           updateFreeDrawGraphics();
          };
          const touchUpHandler = () => {
           dragging = false;
           document.removeEventListener("touchmove", touchMoveHandler);
           document.removeEventListener("touchend", touchUpHandler);
          };
          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchUpHandler);
         }, {
          passive: false
         });
        svg.appendChild(c);
        freeDrawPointEls.push(c);
       });
       drawUndoBtn.style.display = freeDrawPoints.length ? "inline-block" : "none";
      }
      function addFreeDrawPoint(x, y) {
       freeDrawPoints.push({
        x,
        y
       });
       updateFreeDrawGraphics();
      }
      function startFreeDraw() {
       freeDrawMode = true;
       freeDrawPoints = [];
       if (freeDrawPolylineEl) {
        freeDrawPolylineEl.remove();
        freeDrawPolylineEl = null;
       }
       freeDrawPointEls.forEach((el) => el.remove());
       freeDrawPointEls = [];
       svgMap.style.cursor = "crosshair";
       drawToggleBtn.textContent = "Done";
       drawToggleBtn.classList.add("done-btn-active");
       drawUndoBtn.style.display = "none";
      }
      function finishFreeDraw() {
       freeDrawMode = false;
       svgMap.style.cursor = "";
       drawToggleBtn.textContent = "✏️";
       drawToggleBtn.classList.remove("done-btn-active");
       if (freeDrawPoints.length >= 2) {
        const color = drawColorInput.value || "#475569";
        const lineStyle = drawStyleSelect.value || "solid";
        const arrowDir = drawArrowSelect.value || "none";
        const newId = "custom-" + Date.now();
        const pointsCopy = freeDrawPoints.map((p) => ({
         x: p.x,
         y: p.y,
        }));
        EDGE_DATA.list.push({
         id: newId,
         type: "custom",
         color,
         width: 4,
         lineStyle: lineStyle,
         direction: arrowDir,
         points: pointsCopy,
         notes: [],
        });
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheTopology();
        selectTheConnection(newId);
       } else {
        freeDrawPoints = [];
        if (freeDrawPolylineEl) {
         freeDrawPolylineEl.remove();
         freeDrawPolylineEl = null;
        }
        freeDrawPointEls.forEach((el) => el.remove());
        freeDrawPointEls = [];
        forgeTheLegend();
       }
       drawUndoBtn.style.display = "none";
      }
      drawToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (freeDrawMode) {
        finishFreeDraw();
       } else {
        startFreeDraw();
       }
      });
      drawUndoBtn.addEventListener("click", () => {
       if (!freeDrawMode || !freeDrawPoints.length) return;
       freeDrawPoints.pop();
       updateFreeDrawGraphics();
      });
      const drawToolbar = document.getElementById("draw-toolbar");
      drawToolbar.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawToolbar.addEventListener("click", (e) => {
       if (e.target !== drawToggleBtn && e.target !== drawUndoBtn) {
        e.stopPropagation();
       }
      });
      drawStyleSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawArrowSelect.addEventListener("change", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawColorInput.addEventListener("input", () => {
       if (freeDrawMode) {
        updateFreeDrawGraphics();
       }
      });
      drawStyleSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawStyleSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawArrowSelect.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("mousedown", (e) => {
       e.stopPropagation();
      });
      drawColorInput.addEventListener("click", (e) => {
       e.stopPropagation();
      });
      svgMap.addEventListener("click", (e) => {
       if (!freeDrawMode) return;
       if (e.button !== 0) return;
       const target = e.target;
       if (target && target.classList && target.classList.contains("free-point")) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       addFreeDrawPoint(svgP.x, svgP.y);
      });
      svgMap.addEventListener("touchend",
       (e) => {
        if (!freeDrawMode) return;
        const target = e.target;
        if (target && target.classList && target.classList.contains("free-point")) return;
        if (e.changedTouches && e.changedTouches[0]) {
         e.preventDefault();
         const svgEl = svgMap;
         const pt = svgEl.createSVGPoint();
         pt.x = e.changedTouches[0].clientX;
         pt.y = e.changedTouches[0].clientY;
         const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
         addFreeDrawPoint(svgP.x, svgP.y);
        }
       }, {
        passive: false
       });
       const rectToggleBtn = document.getElementById("rect-toggle");
       const rectStyleSelect = document.getElementById("rect-style");
       function startRectDraw() {
        rectDrawMode = true;
        rectStartPoint = null;
        rectPreviewEl = null;
        svgMap.style.cursor = "crosshair";
        rectToggleBtn.textContent = "Done";
        rectToggleBtn.classList.add("done-btn-active");
        rectStyle = rectStyleSelect.value || "filled";
        if (freeDrawMode) {
         finishFreeDraw();
        }
        updateRectangleDeleteButtons();
       }
       function finishRectDraw() {
        rectDrawMode = false;
        svgMap.style.cursor = "";
        rectToggleBtn.textContent = "▭";
        rectToggleBtn.classList.remove("done-btn-active");
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        updateRectangleDeleteButtons();
       }
       rectToggleBtn.addEventListener("click", () => {
        if (currentView.mode === "rack") {
         alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
         return;
        }
        if (rectDrawMode) {
         finishRectDraw();
        } else {
         startRectDraw();
        }
       });
       rectStyleSelect.addEventListener("mousedown", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("click", (e) => {
        e.stopPropagation();
       });
       rectStyleSelect.addEventListener("change", () => {
        if (rectDrawMode) {
         rectStyle = rectStyleSelect.value || "filled";
        }
       });
       svgMap.addEventListener("mousedown", (e) => {
        if (!rectDrawMode) return;
        if (e.button !== 0) return;
        e.preventDefault();
        e.stopPropagation();
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       });
       svgMap.addEventListener("mousemove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       });
       svgMap.addEventListener("mouseup", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
          const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
       });
       let rectTouchStart = null;
       svgMap.addEventListener("touchstart", (e) => {
        if (!rectDrawMode) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        rectStartPoint = { x: svgP.x, y: svgP.y };
        rectTouchStart = { x: svgP.x, y: svgP.y };
        const ns = "http://www.w3.org/2000/svg";
        rectPreviewEl = document.createElementNS(ns, "rect");
        rectPreviewEl.classList.add("rect-preview");
        rectPreviewEl.setAttribute("x", svgP.x);
        rectPreviewEl.setAttribute("y", svgP.y);
        rectPreviewEl.setAttribute("width", 0);
        rectPreviewEl.setAttribute("height", 0);
        const color = drawColorInput.value || "#f97316";
        rectPreviewEl.style.stroke = color;
        rectPreviewEl.style.strokeWidth = 2;
        rectPreviewEl.style.strokeDasharray = "5,5";
        if (rectStyle === "filled") {
         rectPreviewEl.style.fill = color;
         rectPreviewEl.style.fillOpacity = "0.3";
        } else {
         rectPreviewEl.style.fill = "none";
        }
        svgEl.appendChild(rectPreviewEl);
       }, { passive: false });
       svgMap.addEventListener("touchmove", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (e.touches.length !== 1) return;
        e.preventDefault();
        const touch = e.touches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        rectPreviewEl.setAttribute("x", x);
        rectPreviewEl.setAttribute("y", y);
        rectPreviewEl.setAttribute("width", width);
        rectPreviewEl.setAttribute("height", height);
       }, { passive: false });
       svgMap.addEventListener("touchend", (e) => {
        if (!rectDrawMode || !rectStartPoint || !rectPreviewEl) return;
        if (!rectTouchStart) return;
        e.preventDefault();
        const touch = e.changedTouches[0];
        const svgEl = svgMap;
        const pt = svgEl.createSVGPoint();
        pt.x = touch.clientX;
        pt.y = touch.clientY;
        const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
        const x = Math.min(rectStartPoint.x, svgP.x);
        const y = Math.min(rectStartPoint.y, svgP.y);
        const width = Math.abs(svgP.x - rectStartPoint.x);
        const height = Math.abs(svgP.y - rectStartPoint.y);
        if (width > 10 && height > 10) {
      pushUndo("draw zone");
         const color = drawColorInput.value || "#f97316";
         const newId = "rect-" + Date.now();
        const lineStyle = document.getElementById("draw-style").value || "solid";
         RECT_DATA.list.push({
          id: newId,
          x: x,
          y: y,
          width: width,
          height: height,
          color: color,
          style: rectStyle,
          lineStyle: lineStyle,
          notes: []
         });
         forgeTheTopology();
        }
        if (rectPreviewEl) {
         rectPreviewEl.remove();
         rectPreviewEl = null;
        }
        rectStartPoint = null;
        rectTouchStart = null;
       }, { passive: false });
      const textToggleBtn = document.getElementById("text-toggle");
      function startTextMode() {
       textDrawMode = true;
       svgMap.style.cursor = "crosshair";
       textToggleBtn.textContent = "Done";
       textToggleBtn.classList.add("done-btn-active");
       if (freeDrawMode) {
        finishFreeDraw();
       }
       if (rectDrawMode) {
        finishRectDraw();
       }
       updateTextDeleteButtons();
      }
      function finishTextMode() {
       textDrawMode = false;
       svgMap.style.cursor = "";
       textToggleBtn.textContent = "T";
       textToggleBtn.classList.remove("done-btn-active");
       updateTextDeleteButtons();
      }
      textToggleBtn.addEventListener("click", () => {
       if (currentView.mode === "rack") {
        alert("Drawing tools are disabled in rack view. Exit to topology view to use drawing tools.");
        return;
       }
       if (textDrawMode) {
        finishTextMode();
       } else {
        startTextMode();
       }
      });
      function handleTextPlacement(e) {
       if (!textDrawMode) return;
       const svgEl = svgMap;
       const pt = svgEl.createSVGPoint();
       pt.x = e.clientX;
       pt.y = e.clientY;
       const svgP = pt.matrixTransform(svgEl.getScreenCTM().inverse());
       const newId = "text-" + Date.now();
      pushUndo("add text");
       TEXT_DATA.list.push({
        id: newId,
        x: svgP.x,
        y: svgP.y,
        content: "New Text",
        fontSize: 18,
        color: "#e2e8f0",
        fontWeight: "normal",
        fontStyle: "normal",
        textAlign: "start",
        textDecoration: "none",
        bgColor: "#000000",
        bgEnabled: false,
        opacity: 1
       });
       forgeTheTopology();
       showTextPanel(newId);
      }
      svgMap.addEventListener("click", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       e.preventDefault();
       e.stopPropagation();
       handleTextPlacement(e);
      });
      svgMap.addEventListener("touchend", (e) => {
       if (!textDrawMode) return;
       if (e.target.closest('.text-delete-btn')) return;
       if (e.target.closest('.text-group')) return;
       if (e.touches.length > 0) return;
       e.preventDefault();
       const touch = e.changedTouches[0];
       const fakeEvent = {
        clientX: touch.clientX,
        clientY: touch.clientY,
        preventDefault: () => {},
        stopPropagation: () => {}
       };
       handleTextPlacement(fakeEvent);
      }, { passive: false });
      function showTextPanel(textId) {
	  if (isViewOnly()) return;
       currentTextId = textId;
       currentNodeId = null;
       currentEdgeId = null;
       currentRectId = null;
       const textItem = TEXT_DATA.list.find(t => t.id === textId);
       if (!textItem) return;
       document.getElementById("node-panel").style.display = "none";
       document.getElementById("edge-panel").style.display = "none";
       document.getElementById("rect-panel").style.display = "none";
       const textPanel = document.getElementById("text-panel");
       textPanel.style.display = "block";
       document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active"));
       document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
       document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
       document.querySelectorAll(".text-element").forEach(t => t.classList.toggle("active", t.dataset.textId === textId));
       document.getElementById("text-content").value = textItem.content;
       document.getElementById("text-font-size").value = textItem.fontSize;
       document.getElementById("text-color").value = textItem.color;
       document.getElementById("text-font-weight").value = textItem.fontWeight;
       document.getElementById("text-font-style").value = textItem.fontStyle;
       document.getElementById("text-align").value = textItem.textAlign;
       document.getElementById("text-decoration").value = textItem.textDecoration;
       document.getElementById("text-bg-color").value = textItem.bgColor;
       document.getElementById("text-bg-enabled").checked = textItem.bgEnabled;
       document.getElementById("text-opacity").value = textItem.opacity;
       document.getElementById("text-opacity-val").textContent = Math.round(textItem.opacity * 100) + "%";
       document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, textItem.rotation || 0));
       document.getElementById("text-rotation-val").value = textItem.rotation || 0;
      }
      function updateTextDeleteButtons() {
       const deleteButtons = document.querySelectorAll('.text-delete-btn');
       deleteButtons.forEach(btn => {
        btn.style.display = textDrawMode ? 'block' : 'none';
       });
      }
      function deleteText(textId) {
      pushUndo("delete text");
       TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
       forgeTheTopology();
       if (currentTextId === textId) {
        document.getElementById("text-panel").style.display = "none";
        currentTextId = null;
       }
      }
      document.getElementById("text-content").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
      pushUndo("edit text");
        textItem.content = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-size").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontSize = parseInt(e.target.value);
        forgeTheTopology();
       }
      });
      document.getElementById("text-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.color = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-weight").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontWeight = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-font-style").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.fontStyle = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-align").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textAlign = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-decoration").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.textDecoration = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-color").addEventListener("input", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgColor = e.target.value;
        forgeTheTopology();
       }
      });
      document.getElementById("text-bg-enabled").addEventListener("change", (e) => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        pushUndo("edit text");
        textItem.bgEnabled = e.target.checked;
        forgeTheTopology();
       }
      });
      document.getElementById("text-rotation").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          textItem.rotation = parseInt(e.target.value) || 0;
          document.getElementById("text-rotation-val").value = textItem.rotation;
          forgeTheTopology();
        }
      });
      document.getElementById("text-rotation-val").addEventListener("input", (e) => {
        if (!currentTextId) return;
        const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
        if (textItem) {
          pushUndo("rotate text");
          const val = parseInt(e.target.value) || 0;
          textItem.rotation = val;
          document.getElementById("text-rotation").value = Math.max(-360, Math.min(360, val));
          forgeTheTopology();
        }
      });
      document.getElementById("delete-text").addEventListener("click", () => {
       if (!currentTextId) return;
       const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
       if (textItem) {
        challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
         deleteText(currentTextId);
        });
       }
      });
      const settingsBtn = document.getElementById("settings-btn");
      const settingsModal = document.getElementById("settings-modal");
      const settingsClose = document.getElementById("settings-close");
      settingsBtn.addEventListener("click", () => {
       document.getElementById("page-bg-color").value = PAGE_STATE.background || "#050608";
       document.getElementById("topbar-bg-color").value = PAGE_STATE.topbarBg || "#0b0e13";
       document.getElementById("topbar-border-color").value = PAGE_STATE.topbarBorder || "#1f2533";
       document.getElementById("panel-color").value = PAGE_STATE.panel || "#0b0e13";
       document.getElementById("panel-alt-color").value = PAGE_STATE.panelAlt || "#10141b";
       document.getElementById("sidebar-bg-color").value = PAGE_STATE.sidebarBg || "#10141b";
       document.getElementById("btn-bg-color").value = PAGE_STATE.btnBg || "#0b0e13";
       document.getElementById("btn-text-color").value = PAGE_STATE.btnText || "#e2e8f0";
       document.getElementById("tag-fill-color").value = PAGE_STATE.tagFill || "#1e293b";
       document.getElementById("tag-text-color").value = PAGE_STATE.tagText || "#e2e8f0";
       document.getElementById("tag-border-color").value = PAGE_STATE.tagBorder || "#475569";
       document.getElementById("input-bg-color").value = PAGE_STATE.inputBg || "#0b0e13";
       document.getElementById("input-text-color").value = PAGE_STATE.inputText || "#e2e8f0";
       document.getElementById("input-border-color").value = PAGE_STATE.inputBorder || "#1f2937";
       document.getElementById("input-font-family").value = PAGE_STATE.inputFont || "Inter, system-ui, sans-serif";
       document.getElementById("input-font-size").value = PAGE_STATE.inputFontSize || 14;
       document.getElementById("toolbar-bg-color").value = PAGE_STATE.toolbarBg || "#0f172a";
       document.getElementById("toolbar-border-color").value = PAGE_STATE.toolbarBorder || "#1f2937";
       document.getElementById("toolbar-text-color").value = PAGE_STATE.toolbarText || "#94a3b8";
       document.getElementById("toolbar-btn-bg-color").value = PAGE_STATE.toolbarBtnBg || "#0b0e13";
       document.getElementById("toolbar-btn-text-color").value = PAGE_STATE.toolbarBtnText || "#e2e8f0";
       document.getElementById("minimap-dots-color").value = PAGE_STATE.minimapDots || "#94a3b8";
       document.getElementById("canvas-hint-enabled").checked = PAGE_STATE.canvasHintEnabled !== false;
       document.getElementById("canvas-hint-bg-color").value = PAGE_STATE.canvasHintBg || "#0f172a";
       document.getElementById("canvas-hint-text-color").value = PAGE_STATE.canvasHintColor || "#94a3b8";
       document.getElementById("canvas-hint-text").value = PAGE_STATE.canvasHintText || "";
       document.getElementById("accent-color").value = PAGE_STATE.accent || "#4fd1c5";
       document.getElementById("danger-color").value = PAGE_STATE.danger || "#f56565";
       document.getElementById("text-main-color").value = PAGE_STATE.textMain || "#e2e8f0";
       document.getElementById("text-soft-color").value = PAGE_STATE.textSoft || "#94a3b8";
       document.getElementById("node-fill-color").value = PAGE_STATE.nodeFill || "#1e293b";
       document.getElementById("node-stroke-color").value = PAGE_STATE.nodeStroke || "#475569";
       document.getElementById("node-title-color").value = PAGE_STATE.nodeTitle || "#e2e8f0";
       document.getElementById("node-sub-color").value = PAGE_STATE.nodeSub || "#94a3b8";
       document.getElementById("node-title-size").value = PAGE_STATE.nodeTitleSize || 18;
       document.getElementById("node-sub-size").value = PAGE_STATE.nodeSubSize || 13;
       document.getElementById("node-font-family").value = PAGE_STATE.nodeFont || "Inter, system-ui, sans-serif";
       document.getElementById("default-edge-color").value = PAGE_STATE.defaultEdge || "#475569";
	   document.getElementById("default-edge-routing").value = PAGE_STATE.defaultEdgeRouting || "curved";
      document.getElementById("animate-connections-toggle").checked = PAGE_STATE.animateConnections || false;
      document.getElementById("animation-style-select").value = PAGE_STATE.animationStyle || "arrows";
      document.getElementById("animation-direction-select").value = PAGE_STATE.animationDirection || "all";
      document.getElementById("animation-speed-select").value = PAGE_STATE.animationSpeed || 1.5;
      document.getElementById("animate-connections-toggle").addEventListener("change", (e) => {
       PAGE_STATE.animateConnections = e.target.checked;
       forgeTheTopology();
      });
      document.getElementById("animation-style-select").addEventListener("change", (e) => {
       PAGE_STATE.animationStyle = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-direction-select").addEventListener("change", (e) => {
       PAGE_STATE.animationDirection = e.target.value;
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
      document.getElementById("animation-speed-select").addEventListener("change", (e) => {
       PAGE_STATE.animationSpeed = parseFloat(e.target.value);
       if (PAGE_STATE.animateConnections) forgeTheTopology();
      });
       document.getElementById("add-line-routing").value = PAGE_STATE.defaultEdgeRouting || "orthogonal";
       document.getElementById("selection-handle-color").value = PAGE_STATE.selectionHandle || "#f59e0b";
       document.getElementById("selection-handle-size").value = PAGE_STATE.selectionHandleSize || 8;
       document.getElementById("group-indicator-color").value = PAGE_STATE.groupIndicator || "#4fd1c5";
       document.getElementById("canvas-gradient-top").value = PAGE_STATE.canvasGradientTop || "#1e2532";
       document.getElementById("canvas-gradient-bottom").value = PAGE_STATE.canvasGradientBottom || "#050608";
       document.getElementById("canvas-border-color").value = PAGE_STATE.canvasBorder || "#475569";
       document.getElementById("canvas-grid-color").value = PAGE_STATE.canvasGrid || "#475569";
       document.getElementById("canvas-grid-size").value = PAGE_STATE.canvasGridSize || 50;
	   document.getElementById("canvas-grid-enabled").checked = PAGE_STATE.canvasGridEnabled !== false;
       document.getElementById("rack-frame-fill").value = PAGE_STATE.rackFrameFill || "#0f172a";
       document.getElementById("rack-frame-stroke").value = PAGE_STATE.rackFrameStroke || "#4fd1c5";
       document.getElementById("rack-line-color").value = PAGE_STATE.rackLineColor || "#475569";
	   document.getElementById("rack-grid-enabled").checked = PAGE_STATE.rackGridEnabled !== false;
       document.getElementById("rack-text-color").value = PAGE_STATE.rackTextColor || "#4fd1c5";
	   document.getElementById("view-only-mode").checked = PAGE_STATE.viewOnly === true;
       rebuildThemeDropdown();
       updateDeleteButton();
       settingsModal.classList.add("active");
      });
      settingsClose.addEventListener("click", () => {
       settingsModal.classList.remove("active");
      });
	  document.getElementById("view-only-mode").addEventListener("change", (e) => {
       PAGE_STATE.viewOnly = e.target.checked;
       if (e.target.checked) {
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("rect-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.setProperty('display', 'none', 'important');
        document.getElementById("draw-toolbar").style.setProperty('display', 'none', 'important');
        currentNodeId = null;
        currentEdgeId = null;
        currentRectId = null;
        currentTextId = null;
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        selectedEdges.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        document.querySelectorAll(".node-group").forEach(n => n.classList.remove("active", "selected"));
        document.querySelectorAll(".edge").forEach(e => e.classList.remove("active"));
        document.querySelectorAll(".rect-group").forEach(r => r.classList.remove("active"));
        document.querySelectorAll(".text-element").forEach(t => t.classList.remove("active"));
       }
       wieldThePower();
       if (!e.target.checked) {
        updateDrawToolbarVisibility();
        updateTopologyToolbarVisibility();
       }
       forgeTheTopology();
      });
      settingsModal.addEventListener("click", (e) => {
       if (e.target === settingsModal) {
        settingsModal.classList.remove("active");
       }
      });
      document.getElementById("page-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.background = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("topbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.topbarBorder = e.target.value;
       wieldThePower();
      });
const THEME_PRESETS = {
  defaulted: { panel:"#0b0e13",panelAlt:"#10141b",sidebarBg:"#10141b",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"rgba(9,12,20,0.9)",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#0f172a",toolbarBorder:"#1f2937",toolbarText:"#94a3b8",toolbarBtnBg:"#0b0e13",toolbarBtnText:"#e2e8f0",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#94a3b8",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#475569",canvasGrid:"#475569",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  slate: { panel:"#1e293b",panelAlt:"#334155",sidebarBg:"#1e293b",btnBg:"#334155",btnText:"#f1f5f9",accent:"#3b82f6",danger:"#ef4444",textMain:"#f1f5f9",textSoft:"#94a3b8",topbarBg:"#0f172a",topbarBorder:"#334155",nodeFill:"#334155",nodeStroke:"#3b82f6",nodeTitle:"#f1f5f9",nodeSub:"#94a3b8",defaultEdge:"#64748b",canvasGradientTop:"#1e293b",canvasGradientBottom:"#0f172a",tagFill:"#1e3a5f",tagText:"#93c5fd",tagBorder:"#3b82f6",inputBg:"#0f172a",inputText:"#f1f5f9",inputBorder:"#475569",toolbarBg:"#2563eb",toolbarBorder:"#3b82f6",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#f59e0b",groupIndicator:"#22d3ee",minimapDots:"#64748b",canvasHintBg:"#1e293b",canvasHintColor:"#94a3b8",canvasBorder:"#334155",canvasGrid:"#334155",rackFrameFill:"#1e293b",rackFrameStroke:"#3b82f6",rackLineColor:"#475569",rackTextColor:"#3b82f6" },
  graphite: { panel:"#1f2937",panelAlt:"#374151",sidebarBg:"#111827",btnBg:"#374151",btnText:"#f9fafb",accent:"#f59e0b",danger:"#ef4444",textMain:"#f9fafb",textSoft:"#9ca3af",topbarBg:"#111827",topbarBorder:"#4b5563",nodeFill:"#374151",nodeStroke:"#f59e0b",nodeTitle:"#f9fafb",nodeSub:"#9ca3af",defaultEdge:"#6b7280",canvasGradientTop:"#1f2937",canvasGradientBottom:"#111827",tagFill:"#44403c",tagText:"#fbbf24",tagBorder:"#f59e0b",inputBg:"#111827",inputText:"#f9fafb",inputBorder:"#4b5563",toolbarBg:"#b45309",toolbarBorder:"#f59e0b",toolbarText:"#ffffff",toolbarBtnBg:"#f59e0b",toolbarBtnText:"#000000",selectionHandle:"#10b981",groupIndicator:"#06b6d4",minimapDots:"#6b7280",canvasHintBg:"#1f2937",canvasHintColor:"#9ca3af",canvasBorder:"#4b5563",canvasGrid:"#374151",rackFrameFill:"#1f2937",rackFrameStroke:"#f59e0b",rackLineColor:"#4b5563",rackTextColor:"#fbbf24" },
  frost: { panel:"#f8fafc",panelAlt:"#e2e8f0",sidebarBg:"#f1f5f9",btnBg:"#e2e8f0",btnText:"#1e293b",accent:"#1e40af",danger:"#dc2626",textMain:"#0f172a",textSoft:"#475569",topbarBg:"#1e40af",topbarBorder:"#1e3a8a",nodeFill:"#ffffff",nodeStroke:"#1e40af",nodeTitle:"#0f172a",nodeSub:"#475569",defaultEdge:"#64748b",canvasGradientTop:"#e0e7ef",canvasGradientBottom:"#f8fafc",tagFill:"#dbeafe",tagText:"#1e40af",tagBorder:"#3b82f6",inputBg:"#ffffff",inputText:"#0f172a",inputBorder:"#cbd5e1",toolbarBg:"#1e40af",toolbarBorder:"#1e3a8a",toolbarText:"#ffffff",toolbarBtnBg:"#3b82f6",toolbarBtnText:"#ffffff",selectionHandle:"#ea580c",groupIndicator:"#059669",minimapDots:"#64748b",canvasHintBg:"#e2e8f0",canvasHintColor:"#475569",canvasBorder:"#cbd5e1",canvasGrid:"#cbd5e1",rackFrameFill:"#f1f5f9",rackFrameStroke:"#1e40af",rackLineColor:"#94a3b8",rackTextColor:"#1e40af" },
  synthwave: { panel:"#87366d",panelAlt:"#10141b",sidebarBg:"#340934",btnBg:"#0b0e13",btnText:"#e2e8f0",accent:"#4fd1c5",danger:"#f56565",textMain:"#e2e8f0",textSoft:"#94a3b8",topbarBg:"#781c67",topbarBorder:"#1f2533",nodeFill:"#1e293b",nodeStroke:"#475569",nodeTitle:"#e2e8f0",nodeSub:"#94a3b8",defaultEdge:"#475569",canvasGradientTop:"#1e2532",canvasGradientBottom:"#050608",tagFill:"#1e293b",tagText:"#e2e8f0",tagBorder:"#475569",inputBg:"#0b0e13",inputText:"#e2e8f0",inputBorder:"#1f2937",toolbarBg:"#b95aed",toolbarBorder:"#b800eb",toolbarText:"#000000",toolbarBtnBg:"#ed01fe",toolbarBtnText:"#000000",selectionHandle:"#f59e0b",groupIndicator:"#4fd1c5",minimapDots:"#000000",canvasHintBg:"#0f172a",canvasHintColor:"#94a3b8",canvasBorder:"#000000",canvasGrid:"#000000",rackFrameFill:"#0f172a",rackFrameStroke:"#4fd1c5",rackLineColor:"#475569",rackTextColor:"#4fd1c5" },
  terminal: { panel:"#000000",panelAlt:"#0a0a0a",sidebarBg:"#050505",btnBg:"#0a0a0a",btnText:"#33ff33",accent:"#33ff33",danger:"#ffaa00",textMain:"#33ff33",textSoft:"#1a9a1a",topbarBg:"#000000",topbarBorder:"#33ff33",nodeFill:"#0a0a0a",nodeStroke:"#33ff33",nodeTitle:"#33ff33",nodeSub:"#1a9a1a",defaultEdge:"#1a9a1a",canvasGradientTop:"#0a0f0a",canvasGradientBottom:"#000000",tagFill:"#0a1a0a",tagText:"#33ff33",tagBorder:"#33ff33",inputBg:"#000000",inputText:"#33ff33",inputBorder:"#1a9a1a",toolbarBg:"#1a9a1a",toolbarBorder:"#33ff33",toolbarText:"#000000",toolbarBtnBg:"#33ff33",toolbarBtnText:"#000000",selectionHandle:"#ffaa00",groupIndicator:"#00ffff",minimapDots:"#33ff33",canvasHintBg:"#0a0a0a",canvasHintColor:"#1a9a1a",canvasBorder:"#1a9a1a",canvasGrid:"#0f1f0f",rackFrameFill:"#050505",rackFrameStroke:"#33ff33",rackLineColor:"#1a9a1a",rackTextColor:"#33ff33" },
  dracula: { panel:"#282a36",panelAlt:"#44475a",sidebarBg:"#21222c",btnBg:"#44475a",btnText:"#f8f8f2",accent:"#bd93f9",danger:"#ff5555",textMain:"#f8f8f2",textSoft:"#6272a4",topbarBg:"#21222c",topbarBorder:"#6272a4",nodeFill:"#44475a",nodeStroke:"#ff79c6",nodeTitle:"#f8f8f2",nodeSub:"#8be9fd",defaultEdge:"#bd93f9",canvasGradientTop:"#282a36",canvasGradientBottom:"#1a1b23",tagFill:"#3d3f4a",tagText:"#50fa7b",tagBorder:"#50fa7b",inputBg:"#21222c",inputText:"#f8f8f2",inputBorder:"#6272a4",toolbarBg:"#6272a4",toolbarBorder:"#bd93f9",toolbarText:"#f8f8f2",toolbarBtnBg:"#bd93f9",toolbarBtnText:"#282a36",selectionHandle:"#f1fa8c",groupIndicator:"#ff79c6",minimapDots:"#bd93f9",canvasHintBg:"#282a36",canvasHintColor:"#6272a4",canvasBorder:"#44475a",canvasGrid:"#44475a",rackFrameFill:"#282a36",rackFrameStroke:"#ff79c6",rackLineColor:"#6272a4",rackTextColor:"#8be9fd" },
  cobalt: { panel:"#002240",panelAlt:"#003366",sidebarBg:"#001b33",btnBg:"#003366",btnText:"#ffffff",accent:"#ffc600",danger:"#ff628c",textMain:"#ffffff",textSoft:"#8090a0",topbarBg:"#001525",topbarBorder:"#0088ff",nodeFill:"#003366",nodeStroke:"#0088ff",nodeTitle:"#ffffff",nodeSub:"#80ffbb",defaultEdge:"#0088ff",canvasGradientTop:"#002240",canvasGradientBottom:"#00111f",tagFill:"#004080",tagText:"#ffc600",tagBorder:"#0088ff",inputBg:"#001525",inputText:"#ffffff",inputBorder:"#0066cc",toolbarBg:"#0066cc",toolbarBorder:"#0088ff",toolbarText:"#ffffff",toolbarBtnBg:"#0088ff",toolbarBtnText:"#ffffff",selectionHandle:"#ffc600",groupIndicator:"#3ad900",minimapDots:"#0088ff",canvasHintBg:"#002240",canvasHintColor:"#8090a0",canvasBorder:"#0066cc",canvasGrid:"#003366",rackFrameFill:"#002240",rackFrameStroke:"#0088ff",rackLineColor:"#0066cc",rackTextColor:"#80ffbb" },
  solarized: { panel:"#073642",panelAlt:"#002b36",sidebarBg:"#002b36",btnBg:"#073642",btnText:"#93a1a1",accent:"#268bd2",danger:"#dc322f",textMain:"#93a1a1",textSoft:"#657b83",topbarBg:"#002b36",topbarBorder:"#586e75",nodeFill:"#073642",nodeStroke:"#2aa198",nodeTitle:"#93a1a1",nodeSub:"#839496",defaultEdge:"#657b83",canvasGradientTop:"#073642",canvasGradientBottom:"#002b36",tagFill:"#0a4050",tagText:"#b58900",tagBorder:"#b58900",inputBg:"#002b36",inputText:"#93a1a1",inputBorder:"#586e75",toolbarBg:"#268bd2",toolbarBorder:"#2aa198",toolbarText:"#fdf6e3",toolbarBtnBg:"#2aa198",toolbarBtnText:"#002b36",selectionHandle:"#cb4b16",groupIndicator:"#d33682",minimapDots:"#657b83",canvasHintBg:"#073642",canvasHintColor:"#657b83",canvasBorder:"#586e75",canvasGrid:"#094050",rackFrameFill:"#002b36",rackFrameStroke:"#2aa198",rackLineColor:"#586e75",rackTextColor:"#859900" }
};
document.getElementById("theme-preset").addEventListener("change", function() {
  updateDeleteButton();
  var p = THEME_PRESETS[this.value];
  if (!p && this.value.startsWith("mytheme-")) {
    var found = savedStyleSets.find(function(s) { return s.id === document.getElementById("theme-preset").value; });
    if (found) p = found.styles;
  }
  if (!p) return;
  Object.assign(PAGE_STATE, p);
  document.getElementById("panel-color").value = p.panel;
  document.getElementById("panel-alt-color").value = p.panelAlt;
  document.getElementById("sidebar-bg-color").value = p.sidebarBg;
  document.getElementById("btn-bg-color").value = p.btnBg;
  document.getElementById("btn-text-color").value = p.btnText;
  document.getElementById("accent-color").value = p.accent;
  document.getElementById("danger-color").value = p.danger;
  document.getElementById("text-main-color").value = p.textMain;
  document.getElementById("text-soft-color").value = p.textSoft;
  document.getElementById("topbar-border-color").value = p.topbarBorder;
  document.getElementById("node-fill-color").value = p.nodeFill;
  document.getElementById("node-stroke-color").value = p.nodeStroke;
  document.getElementById("node-title-color").value = p.nodeTitle;
  document.getElementById("node-sub-color").value = p.nodeSub;
  document.getElementById("default-edge-color").value = p.defaultEdge;
  document.getElementById("canvas-gradient-top").value = p.canvasGradientTop;
  document.getElementById("canvas-gradient-bottom").value = p.canvasGradientBottom;
  document.getElementById("tag-fill-color").value = p.tagFill;
  document.getElementById("tag-text-color").value = p.tagText;
  document.getElementById("tag-border-color").value = p.tagBorder;
  document.getElementById("input-bg-color").value = p.inputBg;
  document.getElementById("input-text-color").value = p.inputText;
  document.getElementById("input-border-color").value = p.inputBorder;
  document.getElementById("toolbar-bg-color").value = p.toolbarBg;
  document.getElementById("toolbar-border-color").value = p.toolbarBorder;
  document.getElementById("toolbar-text-color").value = p.toolbarText;
  document.getElementById("toolbar-btn-bg-color").value = p.toolbarBtnBg;
  document.getElementById("toolbar-btn-text-color").value = p.toolbarBtnText;
  document.getElementById("selection-handle-color").value = p.selectionHandle;
  document.getElementById("group-indicator-color").value = p.groupIndicator;
  document.getElementById("minimap-dots-color").value = p.minimapDots;
  document.getElementById("canvas-hint-bg-color").value = p.canvasHintBg;
  document.getElementById("canvas-hint-text-color").value = p.canvasHintColor;
  document.getElementById("canvas-border-color").value = p.canvasBorder;
  document.getElementById("canvas-grid-color").value = p.canvasGrid;
  document.getElementById("rack-frame-fill").value = p.rackFrameFill;
  document.getElementById("rack-frame-stroke").value = p.rackFrameStroke;
  document.getElementById("rack-line-color").value = p.rackLineColor;
  document.getElementById("rack-text-color").value = p.rackTextColor;
  wieldThePower();
  forgeTheTopology();
});
document.querySelectorAll('#settings-modal .style-content input, #settings-modal .style-content select').forEach(el => {
  if (el.id === 'theme-preset') return;
  el.addEventListener('input', () => document.getElementById('theme-preset').value = '');
  el.addEventListener('change', () => document.getElementById('theme-preset').value = '');
});
      document.getElementById("panel-color").addEventListener("input", (e) => {
       PAGE_STATE.panel = e.target.value;
       wieldThePower();
      });
      document.getElementById("panel-alt-color").addEventListener("input", (e) => {
       PAGE_STATE.panelAlt = e.target.value;
       wieldThePower();
      });
      document.getElementById("sidebar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.sidebarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.btnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.btnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("tag-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.tagFill = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-text-color").addEventListener("input", (e) => {
       PAGE_STATE.tagText = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("tag-border-color").addEventListener("input", (e) => {
       PAGE_STATE.tagBorder = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
	  document.getElementById("selection-fill-color").addEventListener("input", function() {
       selectionBoxStyle.fillColor = this.value;
      });
      document.getElementById("selection-fill-opacity").addEventListener("input", function() {
       selectionBoxStyle.fillOpacity = parseFloat(this.value);
       document.getElementById("selection-fill-opacity-val").textContent = Math.round(this.value * 100) + "%";
      });
      document.getElementById("selection-stroke-color").addEventListener("input", function() {
       selectionBoxStyle.strokeColor = this.value;
      });
      document.getElementById("selection-stroke-width").addEventListener("input", function() {
       selectionBoxStyle.strokeWidth = parseInt(this.value) || 2;
      });
      document.getElementById("selection-stroke-style").addEventListener("change", function() {
       selectionBoxStyle.strokeDasharray = this.value;
      });
      document.getElementById("input-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-text-color").addEventListener("input", (e) => {
       PAGE_STATE.inputText = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-border-color").addEventListener("input", (e) => {
       PAGE_STATE.inputBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-family").addEventListener("change", (e) => {
       PAGE_STATE.inputFont = e.target.value;
       wieldThePower();
      });
      document.getElementById("input-font-size").addEventListener("input", (e) => {
       PAGE_STATE.inputFontSize = parseInt(e.target.value) || 14;
       wieldThePower();
      });
      document.getElementById("toolbar-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-border-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBorder = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarText = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("toolbar-btn-text-color").addEventListener("input", (e) => {
       PAGE_STATE.toolbarBtnText = e.target.value;
       wieldThePower();
      });
      document.getElementById("minimap-dots-color").addEventListener("input", (e) => {
       PAGE_STATE.minimapDots = e.target.value;
       wieldThePower();
       forgeTheTopology();
      });
      document.getElementById("canvas-hint-enabled").addEventListener("change", (e) => {
       PAGE_STATE.canvasHintEnabled = e.target.checked;
       wieldThePower();
      });
      document.getElementById("canvas-hint-bg-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintBg = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintColor = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-hint-text").addEventListener("input", (e) => {
       PAGE_STATE.canvasHintText = e.target.value;
       wieldThePower();
      });
      document.getElementById("accent-color").addEventListener("input", (e) => {
       PAGE_STATE.accent = e.target.value;
       wieldThePower();
      });
      document.getElementById("danger-color").addEventListener("input", (e) => {
       PAGE_STATE.danger = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-main-color").addEventListener("input", (e) => {
       PAGE_STATE.textMain = e.target.value;
       wieldThePower();
      });
      document.getElementById("text-soft-color").addEventListener("input", (e) => {
       PAGE_STATE.textSoft = e.target.value;
       wieldThePower();
      });
      document.getElementById("node-fill-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-stroke-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-sub-color").addEventListener("input", (e) => {
       PAGE_STATE.nodeSub = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("node-title-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeTitleSize = parseInt(e.target.value) || 18;
       forgeTheTopology();
      });
      document.getElementById("node-sub-size").addEventListener("input", (e) => {
       PAGE_STATE.nodeSubSize = parseInt(e.target.value) || 13;
       forgeTheTopology();
      });
      document.getElementById("node-font-family").addEventListener("change", (e) => {
       PAGE_STATE.nodeFont = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("default-edge-routing").addEventListener("change", (e) => {
       PAGE_STATE.defaultEdgeRouting = e.target.value;
       document.getElementById("add-line-routing").value = e.target.value;
       wieldThePower();
      });
      document.getElementById("apply-routing-all").addEventListener("click", () => {
       const routing = document.getElementById("default-edge-routing").value;
       if (!confirm(`Apply "${routing}" routing to all ${EDGE_DATA.list.length} connections?`)) return;
       pushUndo("apply routing to all");
       EDGE_DATA.list.forEach(edge => {
        edge.routing = routing;
       });
       forgeTheTopology();
      });
      document.getElementById("default-edge-color").addEventListener("input", (e) => {
       PAGE_STATE.defaultEdge = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-color").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandle = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("selection-handle-size").addEventListener("input", (e) => {
       PAGE_STATE.selectionHandleSize = parseInt(e.target.value) || 8;
       forgeTheTopology();
      });
      document.getElementById("group-indicator-color").addEventListener("input", (e) => {
       PAGE_STATE.groupIndicator = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-gradient-top").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientTop = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-gradient-bottom").addEventListener("input", (e) => {
       PAGE_STATE.canvasGradientBottom = e.target.value;
       wieldThePower();
      });
      document.getElementById("canvas-border-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasBorder = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-color").addEventListener("input", (e) => {
       PAGE_STATE.canvasGrid = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("canvas-grid-size").addEventListener("input", (e) => {
       PAGE_STATE.canvasGridSize = parseInt(e.target.value) || 50;
       forgeTheTopology();
      });
	  document.getElementById("canvas-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.canvasGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-frame-fill").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameFill = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-frame-stroke").addEventListener("input", (e) => {
       PAGE_STATE.rackFrameStroke = e.target.value;
       forgeTheTopology();
      });
      document.getElementById("rack-line-color").addEventListener("input", (e) => {
       PAGE_STATE.rackLineColor = e.target.value;
       forgeTheTopology();
      });
	  document.getElementById("rack-grid-enabled").addEventListener("change", (e) => {
 PAGE_STATE.rackGridEnabled = e.target.checked;
 forgeTheTopology();
});
      document.getElementById("rack-text-color").addEventListener("input", (e) => {
       PAGE_STATE.rackTextColor = e.target.value;
       forgeTheTopology();
      });
      (function initializeResizers() {
        const headerResizer = document.getElementById('header-resizer');
        const sidebarResizer = document.getElementById('sidebar-resizer');
        const mobileFooterResizer = document.getElementById('mobile-footer-resizer');
        let isResizing = false;
        let currentResizer = null;
        let startY = 0;
        let startX = 0;
        let startHeight = 0;
        let startWidth = 0;
        function getClientPos(e) {
          if (e.touches && e.touches.length > 0) {
            return { x: e.touches[0].clientX, y: e.touches[0].clientY };
          }
          return { x: e.clientX, y: e.clientY };
        }
        function startResize(resizer, type, e) {
          isResizing = true;
          currentResizer = type;
          const pos = getClientPos(e);
          if (type === 'header') {
            startY = pos.y;
            startHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
          } else if (type === 'sidebar') {
            startX = pos.x;
            startWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
          } else if (type === 'mobile-footer') {
            startY = pos.y;
            const currentVh = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
            startHeight = (currentVh / 100) * window.innerHeight;
          }
          resizer.classList.add('resizing');
          document.body.classList.add('resizing');
          document.body.style.cursor = (type === 'sidebar') ? 'col-resize' : 'row-resize';
          e.preventDefault();
        }
        if (headerResizer) {
          headerResizer.addEventListener('mousedown', (e) => startResize(headerResizer, 'header', e));
          headerResizer.addEventListener('touchstart', (e) => startResize(headerResizer, 'header', e), { passive: false });
        }
        if (sidebarResizer) {
          sidebarResizer.addEventListener('mousedown', (e) => startResize(sidebarResizer, 'sidebar', e));
          sidebarResizer.addEventListener('touchstart', (e) => startResize(sidebarResizer, 'sidebar', e), { passive: false });
        }
        if (mobileFooterResizer) {
          mobileFooterResizer.addEventListener('mousedown', (e) => startResize(mobileFooterResizer, 'mobile-footer', e));
          mobileFooterResizer.addEventListener('touchstart', (e) => startResize(mobileFooterResizer, 'mobile-footer', e), { passive: false });
        }
        function handleMove(e) {
          if (!isResizing) return;
          const pos = getClientPos(e);
          if (currentResizer === 'header') {
            const deltaY = pos.y - startY;
            const newHeight = Math.max(40, Math.min(150, startHeight + deltaY));
            document.documentElement.style.setProperty('--topbar-height', newHeight + 'px');
          } else if (currentResizer === 'sidebar') {
            const deltaX = startX - pos.x;
            const newWidth = Math.max(200, Math.min(800, startWidth + deltaX));
            document.documentElement.style.setProperty('--sidebar-width', newWidth + 'px');
          } else if (currentResizer === 'mobile-footer') {
            const deltaY = startY - pos.y;
            const newHeight = startHeight + deltaY;
            const newVh = Math.max(15, Math.min(80, (newHeight / window.innerHeight) * 100));
            document.documentElement.style.setProperty('--mobile-footer-height', newVh + 'vh');
          }
          e.preventDefault();
        }
        document.addEventListener('mousemove', handleMove);
        document.addEventListener('touchmove', handleMove, { passive: false });
        function handleEnd() {
          if (isResizing) {
            isResizing = false;
            if (currentResizer === 'header') {
              PAGE_STATE.topbarHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--topbar-height'));
              headerResizer.classList.remove('resizing');
            } else if (currentResizer === 'sidebar') {
              PAGE_STATE.sidebarWidth = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-width'));
              sidebarResizer.classList.remove('resizing');
            } else if (currentResizer === 'mobile-footer') {
              PAGE_STATE.mobileFooterHeight = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--mobile-footer-height'));
              mobileFooterResizer.classList.remove('resizing');
            }
            document.body.classList.remove('resizing');
            document.body.style.cursor = '';
            currentResizer = null;
          }
        }
        document.addEventListener('mouseup', handleEnd);
        document.addEventListener('touchend', handleEnd);
        document.addEventListener('touchcancel', handleEnd);
      })();
      document.getElementById("import-data-file").addEventListener("change", async (e) => {
       const file = e.target.files[0];
       if (!file) return;
       try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data.nodeData || !data.edgeData) {
         alert("Invalid data file. Missing required fields.");
         return;
        }
        const confirmMsg = `This will replace all current data with the imported data.\n\nImporting:\n- ${Object.keys(data.nodeData).length} nodes\n- ${data.edgeData.list?.length || 0} connections\n- ${data.documentTabs?.length || 1} tab(s)\n\nContinue?`;
        if (!confirm(confirmMsg)) {
         e.target.value = "";
         return;
        }
		pushUndo('import json');
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || {
         list: []
        };
        EDGE_LEGEND = data.edgeLegend || {};
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        if (data.page) {
         PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, data.page);
         wieldThePower();
        }
        if (data.canvas) {
         canvasState.zoom = data.canvas.zoom || 1;
         canvasState.panX = data.canvas.panX || 0;
         canvasState.panY = data.canvas.panY || 0;
        }
        if (data.page?.title) {
         document.title = data.page.title;
         document.querySelector(".editable-page-title", ).textContent = data.page.title;
        }
        if (data.savedStyleSets) {
          savedStyleSets = data.savedStyleSets;
        }
        if (data.documentTabs) {
         documentTabs = data.documentTabs;
         currentTabIndex = data.currentTabIndex || 0;
        }
        if (data.savedTopologyView) {
         savedTopologyView = data.savedTopologyView;
        }
        if (data.encryptedSections) {
         encryptedSections = data.encryptedSections;
        }
        if (data.auditLog && Array.isArray(data.auditLog)) {
         auditLog = data.auditLog;
         try {
           localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
         } catch (e) {
           console.warn("Failed to sync audit log to localStorage:", e);
         }
        }
        Object.values(NODE_DATA).forEach(node => {
          if (!node.tags) node.tags = [];
          if (!node.notes) node.notes = [];
        });
        EDGE_DATA.list.forEach(edge => {
          if (!edge.notes) edge.notes = [];
        });
        forgeTheTopology();
        if (typeof forgeTheLegend === 'function') forgeTheLegend();
		logAuditEvent("import", `Imported JSON: ${file.name} (${Object.keys(data.nodeData).length} nodes, ${data.edgeData.list?.length || 0} connections)`);
        updateViewBox();
        const nodeIds = Object.keys(NODE_DATA);
        if (nodeIds.length > 0) {
         claimTheImmortal(nodeIds[0]);
        } else {
         document.getElementById("node-panel").style.display = "none";
         document.getElementById("edge-panel").style.display = "none";
         document.getElementById("topology-toolbar").style.display = "none";
        }
        e.target.value = "";
       } catch (err) {
        console.error("Import error:", err);
        alert(`Failed to import data: ${err.message}`);
        e.target.value = "";
       }
      });
      const saveHelpBtn = document.getElementById("save-help-btn");
      const saveInfoModal = document.getElementById("save-info-modal");
      const saveInfoClose = document.getElementById("save-info-close");
      saveHelpBtn.addEventListener("click", () => {
       saveInfoModal.classList.add("active");
      });
      saveInfoClose.addEventListener("click", () => {
       saveInfoModal.classList.remove("active");
      });
      saveInfoModal.addEventListener("click", (e) => {
       if (e.target === saveInfoModal) {
        saveInfoModal.classList.remove("active");
       }
      });
      document.querySelectorAll(".help-tab").forEach(tab => {
        tab.addEventListener("click", () => {
          document.querySelectorAll(".help-tab").forEach(t => { t.style.background = "var(--panel)"; t.style.color = "var(--text-main)"; });
          tab.style.background = "var(--accent)"; tab.style.color = "var(--bg)";
          document.querySelectorAll(".help-tab-content").forEach(c => c.style.display = "none");
          document.getElementById("help-tab-" + tab.dataset.tab).style.display = "block";
        });
      });
      async function deriveKey(password, salt) {
      const encoder = new TextEncoder();
      const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(password),
      "PBKDF2",
      false,
      ["deriveKey"]
      );
      return crypto.subtle.deriveKey(
      {
      name: "PBKDF2",
      salt: salt,
      iterations: 200000,
      hash: "SHA-256"
      },
      keyMaterial,
      {
      name: "AES-GCM",
      length: 256
      },
      false,
      ["encrypt", "decrypt"]
      );
      }
      async function encryptData(data, password) {
      const encoder = new TextEncoder();
      const salt = crypto.getRandomValues(new Uint8Array(16));
      const iv   = crypto.getRandomValues(new Uint8Array(12));
      const key = await deriveKey(password, salt);
      const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      encoder.encode(data)
      );
      const encryptedU8 = new Uint8Array(encrypted);
      const result = new Uint8Array(salt.length + iv.length + encryptedU8.length);
      result.set(salt, 0);
      result.set(iv, salt.length);
      result.set(encryptedU8, salt.length + iv.length);
      return "ENCRYPTED:" + u8ToBase64(result);
      }
      async function decryptData(encryptedData, password) {
      const base64Data = encryptedData.replace("ENCRYPTED:", "");
      const fullData   = base64ToU8(base64Data);
      const salt      = fullData.slice(0, 16);
      const iv        = fullData.slice(16, 28);
      const encrypted = fullData.slice(28);
      const key = await deriveKey(password, salt);
      const decrypted = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      encrypted
      );
      const decoder = new TextDecoder();
      return decoder.decode(decrypted);
      }
      function isEncrypted(data) {
       return typeof data === "string" && data.startsWith("ENCRYPTED:");
      }
      function captureTheQuickening() {
       const currentTab = documentTabs[currentTabIndex];
       currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
       currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
       currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
       currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
       currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
       currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
       currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
       currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
       currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
       return {
        nodeData: NODE_DATA,
        edgeData: EDGE_DATA,
        rectData: RECT_DATA,
        textData: TEXT_DATA,
        edgeLegend: EDGE_LEGEND,
        nodePositions: savedPositions,
        nodeSizes: savedSizes,
        nodeStyles: savedStyles,
        page: PAGE_STATE,
        canvas: {
         zoom: canvasState.zoom,
         panX: canvasState.panX,
         panY: canvasState.panY,
        },
        savedTopologyView: savedTopologyView,
        documentTabs: documentTabs,
        currentTabIndex: currentTabIndex,
        encryptedSections: encryptedSections,
        auditLog: auditLog,
		savedStyleSets: savedStyleSets,
       };
      }
      function assembleTheImmortalForm() {
      const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const addLineSelect = clone.querySelector("#add-line-select");
       if (addLineSelect) addLineSelect.innerHTML = "";
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) {
        minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       }
       const canvasGrid = clone.querySelector("#canvas-grid");
       if (canvasGrid) canvasGrid.innerHTML = "";
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = JSON.stringify(captureTheQuickening(), null, 2);
       return "<!DOCTYPE html> \n " + clone.outerHTML;
      }
      async function becomeImmortal() {
       saveRollbackVersion("Auto-save");
       const encryptEnabled = document.getElementById("encrypt-toggle").checked;
       let stateData = JSON.stringify(captureTheQuickening(), null, 2);
       if (encryptEnabled) {
        const password = prompt("Enter a password to encrypt your data:\n(Remember this password! You will need it to open this file and its non recoverable!)");
        if (!password) {
         alert("Encryption cancelled. File not saved.");
         return;
        }
        const confirmPassword = prompt("Confirm your password:");
        if (password !== confirmPassword) {
         alert("Passwords do not match. File not saved.");
         return;
        }
        try {
         stateData = await encryptData(stateData, password);
        } catch (e) {
         alert("Encryption failed: " + e.message);
         return;
        }
       }
       const canvasHintEl = document.getElementById("canvas-hint");
       const savedHintHTML = canvasHintEl ? canvasHintEl.innerHTML : "";
       if (canvasHintEl) canvasHintEl.innerHTML = DEFAULT_CANVAS_HINT;
       const clone = document.documentElement.cloneNode(true);
       ["edge-legend-mini", "minimap-mini", "draw-toolbar-mini", "topology-toolbar-mini"].forEach(id => {
        const all = clone.querySelectorAll("#" + id);
        for (let i = 1; i < all.length; i++) {
         all[i].remove();
        }
       });
       const selectsToClear = ["#add-line-select", "#new-edge-from", "#new-edge-to", "#assigned-rack-select"];
       selectsToClear.forEach(sel => {
        const el = clone.querySelector(sel);
        if (el) el.innerHTML = "";
       });
       const minimapSvg = clone.querySelector("#minimap");
       if (minimapSvg) minimapSvg.querySelectorAll(".minimap-node, .minimap-edge").forEach(el => el.remove());
       const mainSvg = clone.querySelector("#map");
       if (mainSvg) mainSvg.innerHTML = "";
       const edgeLegendContent = clone.querySelector("#edge-legend-content");
       if (edgeLegendContent) edgeLegendContent.innerHTML = "";
       const nodeTags = clone.querySelector("#node-tags");
       if (nodeTags) nodeTags.innerHTML = "";
       const nodeNotes = clone.querySelector("#node-notes");
       if (nodeNotes) nodeNotes.innerHTML = "";
       const edgeNotes = clone.querySelector("#edge-notes");
       if (edgeNotes) edgeNotes.innerHTML = "";
       const tabBar = clone.querySelector("#tab-bar");
       if (tabBar) tabBar.innerHTML = "";
       const rollbackList = clone.querySelector("#rollback-list");
       if (rollbackList) rollbackList.innerHTML = "";
       const auditList = clone.querySelector("#audit-log-list");
       if (auditList) auditList.innerHTML = "";
       const nodeScript = clone.querySelector("#nodes-json");
       if (nodeScript) {
        if (encryptEnabled) {
         nodeScript.textContent = JSON.stringify({}, null, 2);
        } else {
         nodeScript.textContent = JSON.stringify(NODE_DATA, null, 2);
        }
       }
       let stateScript = clone.querySelector("#topology-state");
       if (!stateScript) {
        stateScript = document.createElement("script");
        stateScript.id = "topology-state";
        stateScript.type = "application/json";
        const body = clone.querySelector("body") || clone;
        body.appendChild(stateScript);
       }
       stateScript.textContent = stateData;
       const html = "<!DOCTYPE html> \n " + clone.outerHTML;
       const blob = new Blob([html], {
        type: "text/html"
       });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
       a.href = url;
       const safeTitle = (PAGE_STATE.title || document.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
       a.download = safeTitle + ".html";
       document.body.appendChild(a);
       a.click();
       document.body.removeChild(a);
       URL.revokeObjectURL(url);
       if (canvasHintEl) canvasHintEl.innerHTML = savedHintHTML;
       logAuditEvent("save", `File saved: ${safeTitle}.html`);
      }
      function captureState(scope = "all") {
       const clone = typeof structuredClone === 'function' 
         ? (o) => structuredClone(o)
         : (o) => JSON.parse(JSON.stringify(o));
       
       if (scope === "all") {
        return {
         scope: "all",
         nodes: clone(NODE_DATA),
         edges: clone(EDGE_DATA),
         positions: clone(savedPositions),
         sizes: clone(savedSizes),
         styles: clone(savedStyles),
         legend: clone(EDGE_LEGEND),
         rects: clone(RECT_DATA),
         texts: clone(TEXT_DATA)
        };
       }
       
       const state = { scope };
       if (scope.includes("nodes")) state.nodes = clone(NODE_DATA);
       if (scope.includes("edges")) state.edges = clone(EDGE_DATA);
       if (scope.includes("positions")) state.positions = clone(savedPositions);
       if (scope.includes("sizes")) state.sizes = clone(savedSizes);
       if (scope.includes("styles")) state.styles = clone(savedStyles);
       if (scope.includes("legend")) state.legend = clone(EDGE_LEGEND);
       if (scope.includes("rects")) state.rects = clone(RECT_DATA);
       if (scope.includes("texts")) state.texts = clone(TEXT_DATA);
       return state;
      }
      let lastUndoPush = 0;
	  function pushUndo(action = "") {
	   const now = Date.now();
	   if (now - lastUndoPush < 100 && undoStack.length > 0) {
	     return;
    	 }
	   lastUndoPush = now;
       const actionScopes = {
        "move nodes": "positions",
        "nudge": "positions",
        "align nodes": "positions",
        "distribute nodes": "positions",
        "snap to grid": "positions",
        "resize node": "sizes",
        "reset size": "sizes",
        "style change": "styles",
        "edit edge": "edges",
        "edit edge routing": "edges",
        "edit edge point": "edges",
        "add edge": "edges,positions",
        "delete edge": "edges",
        "add edge note": "edges",
        "edit edge note": "edges",
        "delete edge note": "edges",
        "draw zone": "rects",
        "delete zone": "rects",
        "resize zone": "rects",
        "edit zone": "rects",
        "add zone note": "rects",
        "delete zone note": "rects",
        "change zone line style": "rects",
        "add text": "texts",
        "edit text": "texts",
        "delete text": "texts",
       };
       const scope = actionScopes[action] || "all";
       const state = captureState(scope);
	   undoStack.push(state);
        if (undoStack.length > MAX_UNDO_STACK) {
        undoStack.shift();
       }
       redoStack = [];
       updateUndoButtons();
       if (action) {
        const actionTypeMap = {
  "create node": "node",
  "delete node": "node",
  "add node": "node",
  "edit": "node",
  "clone node": "node",
  "paste node": "node",
  "move nodes": "node",
  "nudge": "node",
  "align nodes": "node",
  "distribute nodes": "node",
  "snap to grid": "node",
  "toggle group": "node",
  "toggle lock": "node",
  "create rack": "rack",
  "add rack": "rack",
  "edit rack": "rack",
  "edit mac": "rack",
  "edit U height": "rack",
  "change rack capacity": "rack",
  "change assigned rack": "rack",
  "add connection": "connection",
  "delete connection": "connection",
  "delete edge": "connection",
  "clone edge": "connection",
  "paste edge": "connection",
  "style change": "style",
  "change layer": "layer",
  "add text": "text",
  "edit text": "text",
  "delete text": "text",
  "clone text": "text",
  "paste text": "text",
  "draw zone": "zone",
  "delete zone": "zone",
  "delete rect": "zone",
  "clone rect": "zone",
  "paste rect": "zone",
  "change zone line style": "zone",
  "delete selected": "bulk",
  "clone selected": "bulk",
};
        const type = actionTypeMap[action] || "node";
        logAuditEvent(type, action);
       }
      }
      function undo() {
       if (undoStack.length === 0) return;
       const currentState = captureState();
       redoStack.push(currentState);
       const previousState = undoStack.pop();
       restoreState(previousState);
       updateUndoButtons();
       logAuditEvent("undo", "Undo action performed");
      }
      function redo() {
       if (redoStack.length === 0) return;
       logAuditEvent("redo", "Redo action performed");
       const currentState = captureState();
       undoStack.push(currentState);
       const nextState = redoStack.pop();
       restoreState(nextState);
       updateUndoButtons();
      }
      function restoreState(state) {
      if (state.nodes) NODE_DATA = state.nodes;
      if (state.edges) EDGE_DATA = state.edges;
      if (state.positions) savedPositions = state.positions;
      if (state.sizes) savedSizes = state.sizes;
      if (state.styles) savedStyles = state.styles;
      if (state.legend) EDGE_LEGEND = state.legend;
      if (state.rects) RECT_DATA = state.rects;
      if (state.texts) TEXT_DATA = state.texts;
      forgeTheTopology();
      if (currentNodeId && NODE_DATA[currentNodeId]) {
       claimTheImmortal(currentNodeId);
      } else if (currentEdgeId) {
       selectTheConnection(currentEdgeId);
       }
      }
      function updateUndoButtons() {
       const undoBtn = document.getElementById("undo-btn");
       const redoBtn = document.getElementById("redo-btn");
       if (undoBtn) {
        undoBtn.disabled = undoStack.length === 0;
        undoBtn.style.opacity = undoStack.length === 0 ? "0.5" : "1";
       }
       if (redoBtn) {
        redoBtn.disabled = redoStack.length === 0;
        redoBtn.style.opacity = redoStack.length === 0 ? "0.5" : "1";
       }
      }
      function editNodeMac(id) {
       const currentMac = NODE_DATA[id].mac || "";
       showEditModal("Edit MAC Address", currentMac, (newMac) => {
        pushUndo("edit mac");
        NODE_DATA[id].mac = newMac;
        if (currentNodeId === id) {
         document.getElementById("node-mac").textContent = newMac || "--";
        }
       });
      }
      function editNodeRack(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit Rack Unit";
       document.getElementById("modal-input").value = node.rackUnit || "";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit rack");
        const value = document.getElementById("modal-input").value.trim();
        node.rackUnit = value;
        cleanup();
        claimTheImmortal(id);
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function editNodeUHeight(id) {
       const node = NODE_DATA[id];
       if (!node) return;
       document.getElementById("modal-title").textContent = "Edit U Height";
       document.getElementById("modal-input").value = node.uHeight || "1";
       document.getElementById("edit-modal").style.display = "";
       document.getElementById("edit-modal").classList.add("active");
       document.getElementById("modal-input").focus();
	   const modal = document.getElementById("edit-modal");
       const cleanup = () => {
        modal.classList.remove("active");
        document.getElementById("modal-save").removeEventListener("click", saveHandler);
        document.getElementById("modal-cancel").removeEventListener("click", cancelHandler);
        modal.removeEventListener("click", bgHandler);
        document.removeEventListener("keydown", escHandler);
       };
       const escHandler = (e) => {
        if (e.key === "Escape") cleanup();
       };
       document.addEventListener("keydown", escHandler);
       const saveHandler = () => {
        pushUndo("edit U height");
        const value = document.getElementById("modal-input").value.trim();
        node.uHeight = value;
        cleanup();
        claimTheImmortal(id);
        forgeTheTopology();
       };
       const cancelHandler = () => {
        cleanup();
       };
       const bgHandler = (e) => {
        if (e.target === modal) cancelHandler();
       };
       document.getElementById("modal-save").addEventListener("click", saveHandler);
       document.getElementById("modal-cancel").addEventListener("click", cancelHandler);
       modal.addEventListener("click", bgHandler);
      }
      function updateEdgePortLabels(edgeId) {
       const edge = EDGE_DATA.list.find(e => e.id === edgeId);
       if (!edge || edge.type === "custom") return;
       const fromPortInput = document.getElementById("edge-from-port");
       const toPortInput = document.getElementById("edge-to-port");
       if (fromPortInput && toPortInput) {
        edge.fromPort = fromPortInput.value || "";
        edge.toPort = toPortInput.value || "";
        forgeTheTopology();
       }
      }
      function clearSelection() {
       selectedNodes.clear();
       selectedEdges.clear();
       selectedRects.clear();
       selectedTexts.clear();
       updateAllSelections();
      }
      function updateAllSelections() {
      updateNodeSelection();
      document.querySelectorAll(".edge").forEach(el => {
      const edgeId = el.dataset.edgeId;
      if (selectedEdges.has(edgeId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".rect-group").forEach(el => {
      const rectId = el.dataset.rectId;
      if (selectedRects.has(rectId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      document.querySelectorAll(".text-group").forEach(el => {
      const textId = el.dataset.textId;
      if (selectedTexts.has(textId)) {
      el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
      } else {
      el.style.filter = "";
      }
      });
      const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
      const bulkToolbar = document.getElementById("bulk-toolbar");
      const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
      const bulkCount = document.getElementById("bulk-count");
      const bulkCountMobile = document.getElementById("bulk-count-mobile");
      if (total > 0) {
      if (bulkToolbar) bulkToolbar.style.display = "flex";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
      if (bulkCount) bulkCount.textContent = total;
      if (bulkCountMobile) bulkCountMobile.textContent = total;
      } else {
      if (bulkToolbar) bulkToolbar.style.display = "none";
      if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
      }
      }
      function updateNodeSelection() {
       if (isViewOnly()) {
        selectedNodes.clear();
        selectedRects.clear();
        selectedTexts.clear();
        const bulkToolbar = document.getElementById("bulk-toolbar");
        const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        return;
       }
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       const bulkCountModal = document.getElementById("bulk-count-modal");
       if (selectedNodes.size > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = selectedNodes.size;
        if (bulkCountMobile) bulkCountMobile.textContent = selectedNodes.size;
        if (bulkCountModal) bulkCountModal.textContent = selectedNodes.size;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
        const modal = document.getElementById("bulk-actions-modal");
        if (modal) modal.style.display = "none";
       }
      }
      function deleteSelected() {
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       if (total === 0) return;
       let nodesInsideRacks = [];
       selectedNodes.forEach(nodeId => {
        if (NODE_DATA[nodeId]?.isRack) {
         Object.entries(NODE_DATA).forEach(([id, n]) => {
          if (n.assignedRack === nodeId) nodesInsideRacks.push(n.name || id);
         });
        }
       });
       let message = `Delete ${total} selected item(s)?`;
       if (nodesInsideRacks.length > 0) {
        message += `\n\nThis will also delete ${nodesInsideRacks.length} node(s) inside rack(s):\n• ${nodesInsideRacks.join('\n• ')}`;
       }
       challengeTheImmortal(message, () => {
        pushUndo("delete selected");
        selectedNodes.forEach(nodeId => {
         if (NODE_DATA[nodeId]?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === nodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         delete NODE_DATA[nodeId];
         delete savedPositions[nodeId];
         delete savedSizes[nodeId];
         delete savedStyles[nodeId];
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== nodeId && e.to !== nodeId);
        });
        selectedEdges.forEach(edgeId => {
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== edgeId);
        });
        selectedRects.forEach(rectId => {
         RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== rectId);
        });
        selectedTexts.forEach(textId => {
         TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== textId);
        });
        clearSelection();
        forgeTheTopology();
       });
      }
      function startSelection(event) {
       if (event.button !== 0) return;
       if (event.target.closest(".node-group")) return;
       isSelecting = true;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       selectionStart = { x: svgP.x, y: svgP.y };
       clearSelection();
       preDragSelectedNodes = new Set(selectedNodes);
       preDragSelectedEdges = new Set(selectedEdges);
       preDragSelectedRects = new Set(selectedRects);
       preDragSelectedTexts = new Set(selectedTexts);
       if (!selectionRect || !selectionRect.parentNode) {
        selectionRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        selectionRect.setAttribute("fill", selectionBoxStyle.fillColor);
        selectionRect.setAttribute("fill-opacity", selectionBoxStyle.fillOpacity);
        selectionRect.setAttribute("stroke", selectionBoxStyle.strokeColor);
        selectionRect.setAttribute("stroke-width", selectionBoxStyle.strokeWidth);
        selectionRect.setAttribute("stroke-dasharray", selectionBoxStyle.strokeDasharray);
        svg.appendChild(selectionRect);
       }
       selectionRect.style.display = "block";
      }
      function updateSelection(event) {
       if (!isSelecting || !selectionStart) return;
       const svg = document.getElementById("map");
       const pt = svg.createSVGPoint();
       pt.x = event.clientX;
       pt.y = event.clientY;
       const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
       const x = Math.min(selectionStart.x, svgP.x);
       const y = Math.min(selectionStart.y, svgP.y);
       const width = Math.abs(svgP.x - selectionStart.x);
       const height = Math.abs(svgP.y - selectionStart.y);
       selectionRect.setAttribute("x", x);
       selectionRect.setAttribute("y", y);
       selectionRect.setAttribute("width", width);
       selectionRect.setAttribute("height", height);
       const box = { x, y, width, height };
       Object.entries(savedPositions).forEach(([nodeId, pos]) => {
        const size = savedSizes[nodeId] || 50;
        const halfSize = size / 2;
        const nodeBox = { x: pos.x - halfSize, y: pos.y - halfSize, width: size, height: size };
        if (boxesIntersect(box, nodeBox)) {
         selectedNodes.add(nodeId);
        } else if (!preDragSelectedNodes.has(nodeId)) {
         selectedNodes.delete(nodeId);
        }
       });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.points || edge.points.length === 0) return;
        for (let i = 0; i < edge.points.length - 1; i++) {
         const p1 = edge.points[i];
         const p2 = edge.points[i + 1];
         if (lineIntersectsBox(p1.x, p1.y, p2.x, p2.y, box)) {
          selectedEdges.add(edge.id);
          return;
         }
        }
        if (!preDragSelectedEdges.has(edge.id)) {
         selectedEdges.delete(edge.id);
        }
       });
       RECT_DATA.list.forEach(rect => {
        const rectBox = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
        if (boxesIntersect(box, rectBox)) {
         selectedRects.add(rect.id);
        } else if (!preDragSelectedRects.has(rect.id)) {
         selectedRects.delete(rect.id);
        }
       });
       TEXT_DATA.list.forEach(text => {
        const fontSize = text.fontSize || 18;
        const textBox = { x: text.x - 50, y: text.y - fontSize, width: 100, height: fontSize * 1.5 };
        if (boxesIntersect(box, textBox)) {
         selectedTexts.add(text.id);
        } else if (!preDragSelectedTexts.has(text.id)) {
         selectedTexts.delete(text.id);
        }
       });
       updateAllSelectionVisuals();
      }
      function endSelection() {
       isSelecting = false;
       if (selectionRect) {
        selectionRect.style.display = "none";
       }
      }
      function boxesIntersect(a, b) {
       return !(a.x + a.width < b.x || b.x + b.width < a.x || a.y + a.height < b.y || b.y + b.height < a.y);
      }
      function lineIntersectsBox(x1, y1, x2, y2, box) {
       if (pointInBox(x1, y1, box) || pointInBox(x2, y2, box)) return true;
       const lines = [
        [box.x, box.y, box.x + box.width, box.y],
        [box.x + box.width, box.y, box.x + box.width, box.y + box.height],
        [box.x + box.width, box.y + box.height, box.x, box.y + box.height],
        [box.x, box.y + box.height, box.x, box.y]
       ];
       for (const [bx1, by1, bx2, by2] of lines) {
        if (linesIntersect(x1, y1, x2, y2, bx1, by1, bx2, by2)) return true;
       }
       return false;
      }
      function pointInBox(x, y, box) {
       return x >= box.x && x <= box.x + box.width && y >= box.y && y <= box.y + box.height;
      }
      function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
       const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
       if (Math.abs(denom) < 0.0001) return false;
       const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
       const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
       return ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1;
      }
      function updateAllSelectionVisuals() {
       document.querySelectorAll(".node-group").forEach(node => {
        const nodeId = node.dataset.nodeId;
        if (selectedNodes.has(nodeId)) {
         node.classList.add("selected");
        } else {
         node.classList.remove("selected");
        }
       });
       document.querySelectorAll(".edge").forEach(edge => {
        const edgeId = edge.dataset.edgeId;
        if (selectedEdges.has(edgeId)) {
         edge.style.filter = "drop-shadow(0 0 6px #4fd1c5)";
        } else {
         edge.style.filter = "";
        }
       });
       document.querySelectorAll(".rect-group rect").forEach(el => {
        const rectId = el.closest(".rect-group")?.dataset?.rectId;
        if (selectedRects.has(rectId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       document.querySelectorAll(".text-group, .text-element").forEach(el => {
        const textId = el.dataset?.textId;
        if (selectedTexts.has(textId)) {
         el.style.filter = "drop-shadow(0 0 8px #4fd1c5)";
        } else {
         el.style.filter = "";
        }
       });
       const total = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
       const bulkToolbar = document.getElementById("bulk-toolbar");
       const bulkToolbarMobile = document.getElementById("bulk-toolbar-mobile");
       const bulkCount = document.getElementById("bulk-count");
       const bulkCountMobile = document.getElementById("bulk-count-mobile");
       if (total > 0) {
        if (bulkToolbar) bulkToolbar.style.display = "flex";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "flex";
        if (bulkCount) bulkCount.textContent = total;
        if (bulkCountMobile) bulkCountMobile.textContent = total;
       } else {
        if (bulkToolbar) bulkToolbar.style.display = "none";
        if (bulkToolbarMobile) bulkToolbarMobile.style.display = "none";
       }
      }
      function cloneNode(sourceId, skipUndo) {
       if (!NODE_DATA[sourceId]) return;
       if (!skipUndo) pushUndo("clone node");
       const source = NODE_DATA[sourceId];
       const baseName = source.name + " copy";
       let newName = baseName;
       let counter = 1;
       while (Object.values(NODE_DATA).some(n => n.name === newName)) {
        newName = `${baseName} ${counter}`;
        counter++;
       }
       const baseId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
       let newId = baseId;
       counter = 1;
       while (NODE_DATA[newId]) {
        newId = `${baseId}-${counter}`;
        counter++;
       }
NODE_DATA[newId] = {
 shape: source.shape,
 name: newName,
 ip: source.ip,
 role: source.role,
 tags: [...source.tags],
 notes: [...source.notes],
 mac: source.mac || "",
 rackUnit: source.rackUnit || "",
 uHeight: source.uHeight || "1",
 layer: source.layer || "physical",
 assignedRack: source.assignedRack || "",
 rackCapacity: source.rackCapacity || "42",
 isRack: source.isRack || false,
 fovEnabled: source.fovEnabled || false,
 fovAngle: source.fovAngle || 90,
 fovDistance: source.fovDistance || 150,
 fovRotation: source.fovRotation || 0,
 fovColor: source.fovColor || "#f59e0b",
 fovAnimate: source.fovAnimate || false,
 fovSweep: source.fovSweep || 120,
 fovSpeed: source.fovSpeed || 4
};
       if (source.isRack) {
        const childNodes = Object.entries(NODE_DATA).filter(([id, n]) =>
         id !== newId && n.assignedRack === sourceId
        );
        childNodes.forEach(([childId, childNode]) => {
         const childBaseName = childNode.name + " copy";
         let childNewName = childBaseName;
         let c = 1;
         while (Object.values(NODE_DATA).some(n => n.name === childNewName)) {
          childNewName = `${childBaseName} ${c}`;
          c++;
         }
         const childBaseId = childNewName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         let childNewId = childBaseId;
         c = 1;
         while (NODE_DATA[childNewId]) {
          childNewId = `${childBaseId}-${c}`;
          c++;
         }
         NODE_DATA[childNewId] = {
          ...JSON.parse(JSON.stringify(childNode)),
          name: childNewName,
          assignedRack: newId
         };
         if (savedPositions[childId]) {
          savedPositions[childNewId] = { ...savedPositions[childId] };
         }
         if (savedSizes[childId]) {
          savedSizes[childNewId] = savedSizes[childId];
         }
         if (savedStyles[childId]) {
          savedStyles[childNewId] = JSON.parse(JSON.stringify(savedStyles[childId]));
         }
        });
       }
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[newId].assignedRack = currentView.rackId;
       }
       const sourcePos = savedPositions[sourceId];
       savedPositions[newId] = {
        x: sourcePos.x + 100,
        y: sourcePos.y + 100
       };
       if (savedSizes[sourceId]) {
        savedSizes[newId] = savedSizes[sourceId];
       }
       if (savedStyles[sourceId]) {
        savedStyles[newId] = JSON.parse(JSON.stringify(savedStyles[sourceId]));
       }
       forgeTheTopology();
       claimTheImmortal(newId);
      }
      function alignSelectedNodes(direction) {
       if (selectedNodes.size < 2) return;
       pushUndo("align nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       switch(direction) {
        case "left":
         const minX = Math.min(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = minX);
         break;
        case "right":
         const maxX = Math.max(...nodes.map(n => n.pos.x));
         nodes.forEach(n => savedPositions[n.id].x = maxX);
         break;
        case "top":
         const minY = Math.min(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = minY);
         break;
        case "bottom":
         const maxY = Math.max(...nodes.map(n => n.pos.y));
         nodes.forEach(n => savedPositions[n.id].y = maxY);
         break;
        case "center-h":
         const avgX = nodes.reduce((sum, n) => sum + n.pos.x, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].x = avgX);
         break;
        case "center-v":
         const avgY = nodes.reduce((sum, n) => sum + n.pos.y, 0) / nodes.length;
         nodes.forEach(n => savedPositions[n.id].y = avgY);
         break;
       }
       forgeTheTopology();
      }
      function distributeSelectedNodes(direction) {
       if (selectedNodes.size < 3) return;
       pushUndo("distribute nodes");
       const nodes = Array.from(selectedNodes).map(id => ({
        id,
        pos: savedPositions[id]
       }));
       if (direction === "horizontal") {
        nodes.sort((a, b) => a.pos.x - b.pos.x);
        const minX = nodes[0].pos.x;
        const maxX = nodes[nodes.length - 1].pos.x;
        const gap = (maxX - minX) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].x = minX + (gap * i);
        });
       } else {
        nodes.sort((a, b) => a.pos.y - b.pos.y);
        const minY = nodes[0].pos.y;
        const maxY = nodes[nodes.length - 1].pos.y;
        const gap = (maxY - minY) / (nodes.length - 1);
        nodes.forEach((n, i) => {
         savedPositions[n.id].y = minY + (gap * i);
        });
       }
       forgeTheTopology();
      }
      function snapToGrid(nodeId, gridSize = 50) {
       if (!savedPositions[nodeId]) return;
       pushUndo("snap to grid");
       const pos = savedPositions[nodeId];
       pos.x = Math.round(pos.x / gridSize) * gridSize;
       pos.y = Math.round(pos.y / gridSize) * gridSize;
       forgeTheTopology();
      }
		function searchNodes(query) {
		   if (!query) {
			currentSearchQuery = "";
			currentSearchResults = [];
			clearSearchHighlight();
			return [];
		   }
		   currentSearchQuery = query;
		   query = query.toLowerCase();
		   const results = [];
		   Object.entries(NODE_DATA).forEach(([id, data]) => {
			try {
			 const nameMatch = data.name && data.name.toLowerCase().includes(query);
			 const ipMatch = data.ip && data.ip.toLowerCase().includes(query);
			 const roleMatch = data.role && data.role.toLowerCase().includes(query);
			 const tagsMatch = data.tags && Array.isArray(data.tags) && data.tags.some(tag => tag && tag.toLowerCase().includes(query));
			 const macMatch = data.mac && data.mac.toLowerCase().includes(query);
			 const rackUnitMatch = data.rackUnit && String(data.rackUnit).toLowerCase().includes(query);
			 if (nameMatch || ipMatch || roleMatch || tagsMatch || macMatch || rackUnitMatch) {
			  results.push(id);
			 }
			} catch (e) {
			 console.warn("Search error for node:", id, e);
			}
		   });
		   currentSearchResults = results;
		   highlightSearchResults(results, true);
		   if (results.length > 0) {
		    focusOnNodes(results);
		   }
		   return results;
		}
		function highlightSearchResults(nodeIds, hasQuery = false) {
		   document.querySelectorAll(".node-group").forEach(node => {
			const nodeId = node.dataset.nodeId;
			if (nodeIds.includes(nodeId)) {
			 node.classList.add("search-highlight");
			 node.classList.remove("search-faded");
			} else {
			 node.classList.remove("search-highlight");
			 if (hasQuery) {
			  node.classList.add("search-faded");
			 } else {
			  node.classList.remove("search-faded");
			 }
			}
		   });
		   document.querySelectorAll(".edge-group").forEach(edge => {
			const fromId = edge.dataset.from;
			const toId = edge.dataset.to;
			if (hasQuery && !nodeIds.includes(fromId) && !nodeIds.includes(toId)) {
			 edge.classList.add("search-faded");
			} else {
			 edge.classList.remove("search-faded");
			}
		   });
		}
		function clearSearchHighlight() {
   document.querySelectorAll(".search-highlight").forEach(node => {
    node.classList.remove("search-highlight");
   });
   document.querySelectorAll(".search-faded").forEach(el => {
    el.classList.remove("search-faded");
   });
}
      function nudgeSelectedNodes(direction, distance) {
        const nodesToNudge = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToNudge = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToNudge = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToNudge.length === 0 && rectsToNudge.length === 0 && textsToNudge.length === 0) return;
        const unlockedNodes = nodesToNudge.filter(id => !NODE_DATA[id]?.locked);
        const unlockedRects = rectsToNudge.filter(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        const unlockedTexts = textsToNudge.filter(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        if (unlockedNodes.length === 0 && unlockedRects.length === 0 && unlockedTexts.length === 0) return;
        pushUndo("nudge");
        const dx = direction === "ArrowLeft" ? -distance : direction === "ArrowRight" ? distance : 0;
        const dy = direction === "ArrowUp" ? -distance : direction === "ArrowDown" ? distance : 0;
        unlockedNodes.forEach(id => {
          if (!savedPositions[id]) savedPositions[id] = { x: 0, y: 0 };
          savedPositions[id].x += dx;
          savedPositions[id].y += dy;
        });
        unlockedRects.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) { r.x += dx; r.y += dy; }
        });
        unlockedTexts.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) { t.x += dx; t.y += dy; }
        });
        forgeTheTopology();
      }
      function cycleNodes(reverse = false) {
        const nodeIds = Object.keys(NODE_DATA).filter(id => {
          if (currentView.mode === "rack" && currentView.rackId) {
            return NODE_DATA[id].assignedRack === currentView.rackId;
          }
          return !NODE_DATA[id].assignedRack;
        });
        if (nodeIds.length === 0) return;
        let currentIndex = nodeIds.indexOf(currentNodeId);
        if (reverse) {
          currentIndex = currentIndex <= 0 ? nodeIds.length - 1 : currentIndex - 1;
        } else {
          currentIndex = currentIndex >= nodeIds.length - 1 ? 0 : currentIndex + 1;
        }
        const nextNodeId = nodeIds[currentIndex];
        claimTheImmortal(nextNodeId);
        selectedNodes.clear();
        updateNodeSelection();
      }
      function focusOnSelected() {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        let hasItems = false;
        const nodesToFocus = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        nodesToFocus.forEach(id => {
          const pos = savedPositions[id];
          if (pos) {
            hasItems = true;
            const size = savedSizes[id] || 50;
            minX = Math.min(minX, pos.x - size/2);
            minY = Math.min(minY, pos.y - size/2);
            maxX = Math.max(maxX, pos.x + size/2);
            maxY = Math.max(maxY, pos.y + size/2);
          }
        });
        const rectsToFocus = selectedRects.size > 0 ? Array.from(selectedRects) : (currentRectId ? [currentRectId] : []);
        rectsToFocus.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) {
            hasItems = true;
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.width);
            maxY = Math.max(maxY, r.y + r.height);
          }
        });
        const textsToFocus = selectedTexts.size > 0 ? Array.from(selectedTexts) : (currentTextId ? [currentTextId] : []);
        textsToFocus.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) {
            hasItems = true;
            minX = Math.min(minX, t.x - 50);
            minY = Math.min(minY, t.y - 20);
            maxX = Math.max(maxX, t.x + 50);
            maxY = Math.max(maxY, t.y + 20);
          }
        });
        const edgesToFocus = selectedEdges.size > 0 ? Array.from(selectedEdges) : (currentEdgeId ? [currentEdgeId] : []);
        edgesToFocus.forEach(id => {
          const e = EDGE_DATA.list.find(x => x.id === id);
          if (e) {
            const fromPos = savedPositions[e.from];
            const toPos = savedPositions[e.to];
            if (fromPos && toPos) {
              hasItems = true;
              minX = Math.min(minX, fromPos.x, toPos.x);
              minY = Math.min(minY, fromPos.y, toPos.y);
              maxX = Math.max(maxX, fromPos.x, toPos.x);
              maxY = Math.max(maxY, fromPos.y, toPos.y);
            }
          }
        });
        if (!hasItems || !isFinite(minX)) return;
        const padding = 100;
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        const width = maxX - minX + padding * 2;
        const height = maxY - minY + padding * 2;
        const zoomX = CANVAS_WIDTH / width;
        const zoomY = CANVAS_HEIGHT / height;
        const targetZoom = Math.min(zoomX, zoomY, 2);
        canvasState.zoom = targetZoom;
        canvasState.panX = centerX - (CANVAS_WIDTH / targetZoom) / 2;
        canvasState.panY = centerY - (CANVAS_HEIGHT / targetZoom) / 2;
		updateViewBox();
      }
      function toggleLockSelected() {
        const nodesToToggle = selectedNodes.size > 0
          ? Array.from(selectedNodes)
          : (currentNodeId ? [currentNodeId] : []);
        const rectsToToggle = selectedRects.size > 0
          ? Array.from(selectedRects)
          : (currentRectId ? [currentRectId] : []);
        const textsToToggle = selectedTexts.size > 0
          ? Array.from(selectedTexts)
          : (currentTextId ? [currentTextId] : []);
        if (nodesToToggle.length === 0 && rectsToToggle.length === 0 && textsToToggle.length === 0) return;
        pushUndo("toggle lock");
        let hasUnlocked = nodesToToggle.some(id => !NODE_DATA[id]?.locked);
        hasUnlocked = hasUnlocked || rectsToToggle.some(id => { const r = RECT_DATA.list.find(x => x.id === id); return r && !r.locked; });
        hasUnlocked = hasUnlocked || textsToToggle.some(id => { const t = TEXT_DATA.list.find(x => x.id === id); return t && !t.locked; });
        nodesToToggle.forEach(id => {
          if (NODE_DATA[id]) NODE_DATA[id].locked = hasUnlocked;
        });
        rectsToToggle.forEach(id => {
          const r = RECT_DATA.list.find(x => x.id === id);
          if (r) r.locked = hasUnlocked;
        });
        textsToToggle.forEach(id => {
          const t = TEXT_DATA.list.find(x => x.id === id);
          if (t) t.locked = hasUnlocked;
        });
        forgeTheTopology();
      }
      function toggleGroupSelected() {
      const nodesToGroup = Array.from(selectedNodes);
      const rectsToGroup = Array.from(selectedRects);
      const textsToGroup = Array.from(selectedTexts);
      const edgesToGroup = Array.from(selectedEdges);
      const totalItems = nodesToGroup.length + rectsToGroup.length + textsToGroup.length + edgesToGroup.length;
      if (totalItems < 2) return;
      pushUndo("toggle group");
      const allGroupIds = [];
      nodesToGroup.forEach(id => { if (NODE_DATA[id]?.groupId) allGroupIds.push(NODE_DATA[id].groupId); });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r?.groupId) allGroupIds.push(r.groupId); });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t?.groupId) allGroupIds.push(t.groupId); });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e?.groupId) allGroupIds.push(e.groupId); });
      const uniqueGroups = [...new Set(allGroupIds)];
      if (uniqueGroups.length === 1 && allGroupIds.length === totalItems) {
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = null; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = null; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = null; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = null; });
      } else {
      const newGroupId = "group-" + Date.now();
      nodesToGroup.forEach(id => { if (NODE_DATA[id]) NODE_DATA[id].groupId = newGroupId; });
      rectsToGroup.forEach(id => { const r = RECT_DATA.list.find(x => x.id === id); if (r) r.groupId = newGroupId; });
      textsToGroup.forEach(id => { const t = TEXT_DATA.list.find(x => x.id === id); if (t) t.groupId = newGroupId; });
      edgesToGroup.forEach(id => { const e = EDGE_DATA.list.find(x => x.id === id); if (e) e.groupId = newGroupId; });
      }
      forgeTheTopology();
      }
      function handleKeyDown(event) {
       if (event.metaKey && !event.ctrlKey) event.ctrlKey = true;
       if (event.target.tagName === "INPUT" || event.target.tagName === "TEXTAREA" || event.target.isContentEditable) {
        return;
       }
       if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.preventDefault();
        const distance = event.shiftKey ? 10 : 1;
        nudgeSelectedNodes(event.key, distance);
       }
       if (event.key === "Tab") {
        event.preventDefault();
        cycleNodes(event.shiftKey);
       }
       if (event.key === "f" || event.key === "F") {
        event.preventDefault();
        focusOnSelected();
       }
       if (event.key === "l" || event.key === "L") {
        event.preventDefault();
        toggleLockSelected();
       }
       if (event.key === "g" || event.key === "G") {
        event.preventDefault();
        toggleGroupSelected();
       }
       if (event.ctrlKey && event.key === "z") {
        event.preventDefault();
        undo();
       }
       if ((event.ctrlKey && event.key === "y") || (event.ctrlKey && event.shiftKey && event.key === "z")) {
        event.preventDefault();
        redo();
       }
 if (event.ctrlKey && event.key === "c") {
        event.preventDefault();
        clipboard = null;
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         clipboard = {
          type: "node",
          data: JSON.parse(JSON.stringify(NODE_DATA[currentNodeId])),
          size: savedSizes[currentNodeId],
          style: savedStyles[currentNodeId] ? JSON.parse(JSON.stringify(savedStyles[currentNodeId])) : null
         };
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) clipboard = { type: "edge", data: JSON.parse(JSON.stringify(edge)) };
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) clipboard = { type: "rect", data: JSON.parse(JSON.stringify(rect)) };
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) clipboard = { type: "text", data: JSON.parse(JSON.stringify(text)) };
        }
       }
       if (event.ctrlKey && event.key === "v") {
        event.preventDefault();
        if (!clipboard) return;
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        if (clipboard.type === "node") {
         const data = clipboard.data;
         let newName = data.name + " copy";
         let counter = 1;
         while (Object.values(NODE_DATA).some(n => n.name === newName)) {
          newName = data.name + " copy " + counter;
          counter++;
         }
         let newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
         counter = 1;
         while (NODE_DATA[newId]) {
          newId = newName.toLowerCase().replace(/[^a-z0-9]+/g, "-") + "-" + counter;
          counter++;
         }
         pushUndo("paste node");
         NODE_DATA[newId] = { ...data, name: newName };
         savedPositions[newId] = { x: centerX, y: centerY };
         if (clipboard.size) savedSizes[newId] = clipboard.size;
         if (clipboard.style) savedStyles[newId] = JSON.parse(JSON.stringify(clipboard.style));
         forgeTheTopology();
         claimTheImmortal(newId);
        } else if (clipboard.type === "edge") {
         pushUndo("paste edge");
         const newEdge = { ...clipboard.data, id: "edge-" + Date.now() };
         EDGE_DATA.list.push(newEdge);
         forgeTheTopology();
         selectTheConnection(newEdge.id);
        } else if (clipboard.type === "rect") {
         pushUndo("paste rect");
         const newRect = { ...clipboard.data, id: "rect-" + Date.now(), x: centerX - (clipboard.data.width || 100) / 2, y: centerY - (clipboard.data.height || 100) / 2 };
         RECT_DATA.list.push(newRect);
         forgeTheTopology();
         selectTheRect(newRect.id);
        } else if (clipboard.type === "text") {
         pushUndo("paste text");
         const newText = { ...clipboard.data, id: "text-" + Date.now(), x: centerX, y: centerY };
         TEXT_DATA.list.push(newText);
         forgeTheTopology();
         showTextPanel(newText.id);
        }
       }
       if (event.key === "Delete") {
        event.preventDefault();
        const totalSelected = selectedNodes.size + selectedEdges.size + selectedRects.size + selectedTexts.size;
        if (totalSelected > 0) {
         deleteSelected();
        } else if (currentNodeId && NODE_DATA[currentNodeId]) {
         challengeTheImmortal(`Delete node "${NODE_DATA[currentNodeId].name}"?`, () => {
          pushUndo("delete node");
          delete NODE_DATA[currentNodeId];
          delete savedPositions[currentNodeId];
          delete savedSizes[currentNodeId];
          delete savedStyles[currentNodeId];
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
          currentNodeId = null;
          forgeTheTopology();
          document.getElementById("node-panel").style.display = "none";
         });
        } else if (currentEdgeId) {
         challengeTheImmortal("Delete this line?", () => {
          pushUndo("delete edge");
          EDGE_DATA.list = EDGE_DATA.list.filter(e => e.id !== currentEdgeId);
          currentEdgeId = null;
          forgeTheTopology();
          document.getElementById("edge-panel").style.display = "none";
         });
        } else if (currentRectId) {
         challengeTheImmortal("Delete this zone?", () => {
          pushUndo("delete rect");
          RECT_DATA.list = RECT_DATA.list.filter(r => r.id !== currentRectId);
          currentRectId = null;
          forgeTheTopology();
          document.getElementById("rect-panel").style.display = "none";
         });
        } else if (currentTextId) {
         const textItem = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (textItem) {
          challengeTheImmortal(`Delete text "${(textItem.content || '').substring(0, 30)}..."?`, () => {
           pushUndo("delete text");
           TEXT_DATA.list = TEXT_DATA.list.filter(t => t.id !== currentTextId);
           currentTextId = null;
           forgeTheTopology();
           document.getElementById("text-panel").style.display = "none";
          });
         }
        }
       }
       if (event.ctrlKey && event.key === "a") {
        event.preventDefault();
        Object.keys(NODE_DATA).forEach(id => selectedNodes.add(id));
        EDGE_DATA.list.forEach(e => selectedEdges.add(e.id));
        RECT_DATA.list.forEach(r => selectedRects.add(r.id));
        TEXT_DATA.list.forEach(t => selectedTexts.add(t.id));
        updateAllSelections();
       }
       if (event.key === "Escape") {
        clearSelection();
        clearSearchHighlight();
       }
       if (event.ctrlKey && event.key === "d") {
        event.preventDefault();
        if (currentNodeId && NODE_DATA[currentNodeId]) {
         cloneNode(currentNodeId);
        } else if (currentEdgeId) {
         const edge = EDGE_DATA.list.find(e => e.id === currentEdgeId);
         if (edge) {
          pushUndo("clone edge");
          const newEdge = { ...JSON.parse(JSON.stringify(edge)), id: "edge-" + Date.now() };
          EDGE_DATA.list.push(newEdge);
          forgeTheTopology();
          selectTheConnection(newEdge.id);
         }
        } else if (currentRectId) {
         const rect = RECT_DATA.list.find(r => r.id === currentRectId);
         if (rect) {
          pushUndo("clone rect");
          const newRect = { ...JSON.parse(JSON.stringify(rect)), id: "rect-" + Date.now(), x: rect.x + 50, y: rect.y + 50 };
          RECT_DATA.list.push(newRect);
          forgeTheTopology();
          selectTheRect(newRect.id);
         }
        } else if (currentTextId) {
         const text = TEXT_DATA.list.find(t => t.id === currentTextId);
         if (text) {
          pushUndo("clone text");
          const newText = { ...JSON.parse(JSON.stringify(text)), id: "text-" + Date.now(), x: text.x + 50, y: text.y + 50 };
          TEXT_DATA.list.push(newText);
          forgeTheTopology();
          showTextPanel(newText.id);
         }
        }
       }
      }
      function saveRollbackVersion(description = "Auto-save") {
        const version = {
          timestamp: Date.now(),
          description,
          data: captureTheQuickening()
        };
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
        } catch (e) {
          rollbackVersions = [];
        }
        rollbackVersions.unshift(version);
        if (rollbackVersions.length > MAX_ROLLBACK_VERSIONS) {
          rollbackVersions = rollbackVersions.slice(0, MAX_ROLLBACK_VERSIONS);
        }
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to save rollback version:", e);
        }
      }
      function loadRollbackVersions() {
        try {
          const stored = localStorage.getItem(ROLLBACK_STORAGE_KEY);
          rollbackVersions = stored ? JSON.parse(stored) : [];
          displayRollbackVersions();
        } catch (e) {
          console.warn("Failed to load rollback versions:", e);
          rollbackVersions = [];
        }
      }
      function displayRollbackVersions() {
        const listEl = document.getElementById("rollback-list");
        if (!listEl) return;
        if (rollbackVersions.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No version history yet. Versions are saved automatically when you save the file.</div>';
          return;
        }
        listEl.innerHTML = rollbackVersions.map((version, index) => {
          const date = new Date(version.timestamp);
          const timeStr = date.toLocaleString();
          const nodeCount = Object.keys(version.data.nodeData || {}).length;
          const edgeCount = (version.data.edgeData?.list || []).length;
          return `
            <div class="version-item" onclick="restoreRollbackVersion(${index})">
              <div class="version-info">
                <div class="timestamp">${escapeHtml(timeStr)}</div>
                <div class="details">${escapeHtml(version.description)} • ${nodeCount} nodes • ${edgeCount} connections</div>
              </div>
              <div class="version-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); deleteRollbackVersion(${index})" title="Delete this version">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      function restoreRollbackVersion(index) {
        if (!confirm(`Restore version from ${new Date(rollbackVersions[index].timestamp).toLocaleString()}?\n\nYour current work will be lost unless you save first.`)) {
          return;
        }
        const version = rollbackVersions[index];
        const data = version.data;
        NODE_DATA = data.nodeData || {};
        EDGE_DATA = data.edgeData || { list: [] };
        RECT_DATA = data.rectData || { list: [] };
        TEXT_DATA = data.textData || { list: [] };
        EDGE_LEGEND = data.edgeLegend || {};
        savedPositions = data.nodePositions || {};
        savedSizes = data.nodeSizes || {};
        savedStyles = data.nodeStyles || {};
        PAGE_STATE = data.page || PAGE_STATE;
        if (data.canvas) {
          canvasState.zoom = data.canvas.zoom;
          canvasState.panX = data.canvas.panX;
          canvasState.panY = data.canvas.panY;
        }
        wieldThePower();
        forgeTheTopology();
        document.getElementById("rollback-modal").classList.remove("active");
        logAuditEvent("rollback", `Restored version from ${new Date(version.timestamp).toLocaleString()}`);
      }
      function deleteRollbackVersion(index) {
        if (!confirm("Delete this version from history?")) return;
        rollbackVersions.splice(index, 1);
        try {
          localStorage.setItem(ROLLBACK_STORAGE_KEY, JSON.stringify(rollbackVersions));
        } catch (e) {
          console.warn("Failed to delete version:", e);
        }
        displayRollbackVersions();
      }
      function clearRollbackHistory() {
        if (!confirm("Clear all version history?\n\nThis cannot be undone.")) return;
        rollbackVersions = [];
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);
        displayRollbackVersions();
      }
      function createManualSnapshot() {
        const description = prompt("Enter a description for this snapshot:", "Manual snapshot");
        if (!description) return;
        saveRollbackVersion(description);
        displayRollbackVersions();
      }
      function switchTab(index) {
        if (index === currentTabIndex) return;
        const currentTab = documentTabs[currentTabIndex];
        currentTab.nodes = JSON.parse(JSON.stringify(NODE_DATA));
        currentTab.edges = JSON.parse(JSON.stringify(EDGE_DATA));
        currentTab.positions = JSON.parse(JSON.stringify(savedPositions));
        currentTab.sizes = JSON.parse(JSON.stringify(savedSizes));
        currentTab.styles = JSON.parse(JSON.stringify(savedStyles));
        currentTab.legend = JSON.parse(JSON.stringify(EDGE_LEGEND));
        currentTab.rects = JSON.parse(JSON.stringify(RECT_DATA));
        currentTab.texts = JSON.parse(JSON.stringify(TEXT_DATA));
        currentTab.pageState = JSON.parse(JSON.stringify(PAGE_STATE));
        currentTabIndex = index;
        const newTab = documentTabs[index];
        NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
        EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
        savedPositions = JSON.parse(JSON.stringify(newTab.positions));
        savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
        savedStyles = JSON.parse(JSON.stringify(newTab.styles));
        EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
        RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
        TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
        wieldThePower();
        document.title = PAGE_STATE.title || newTab.name;
        document.getElementById("page-title").textContent = PAGE_STATE.title || newTab.name;
        forgeTheTopology();
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        displayTabs();
        logAuditEvent("tab", `Switched to tab: ${newTab.name}`);
      }
      function createNewTab() {
        const nameInput = document.getElementById("new-tab-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a tab name");
          return;
        }
        const newTab = {
          id: `tab-${Date.now()}`,
          name,
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
      pageState: null
        };
        documentTabs.push(newTab);
        nameInput.value = "";
        displayTabs();
        logAuditEvent("tab", `Created new tab: ${name}`);
      }
      function renameTab(index) {
        const tab = documentTabs[index];
        const newName = prompt("Enter new name:", tab.name);
        if (!newName || newName === tab.name) return;
        tab.name = newName;
        displayTabs();
        logAuditEvent("tab", `Renamed tab to: ${newName}`);
      }
      function deleteTab(index) {
        if (documentTabs.length === 1) {
          alert("Cannot delete the last tab");
          return;
        }
        if (!confirm(`Delete tab "${documentTabs[index].name}"?`)) return;
        const wasCurrentTab = (index === currentTabIndex);
        documentTabs.splice(index, 1);
        if (currentTabIndex >= documentTabs.length) {
          currentTabIndex = documentTabs.length - 1;
        } else if (index < currentTabIndex) {
          currentTabIndex--;
        }
        if (wasCurrentTab) {
          const newTab = documentTabs[currentTabIndex];
          NODE_DATA = JSON.parse(JSON.stringify(newTab.nodes));
          EDGE_DATA = JSON.parse(JSON.stringify(newTab.edges));
          savedPositions = JSON.parse(JSON.stringify(newTab.positions));
          savedSizes = JSON.parse(JSON.stringify(newTab.sizes));
          savedStyles = JSON.parse(JSON.stringify(newTab.styles));
          EDGE_LEGEND = JSON.parse(JSON.stringify(newTab.legend));
          RECT_DATA = JSON.parse(JSON.stringify(newTab.rects));
          TEXT_DATA = JSON.parse(JSON.stringify(newTab.texts));
          PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, newTab.pageState || {});
          wieldThePower();
          forgeTheTopology();
          currentNodeId = null;
          currentEdgeId = null;
          currentTextId = null;
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("text-panel").style.display = "none";
        }
        displayTabs();
        logAuditEvent("tab", `Deleted tab`);
      }
      function saveCurrentTheme() {
        const name = prompt("Enter a name for this theme:", "My Theme " + (savedStyleSets.length + 1));
        if (!name || !name.trim()) return;
        const existingIndex = savedStyleSets.findIndex(s => s.name.toLowerCase() === name.trim().toLowerCase());
        if (existingIndex !== -1) {
          if (!confirm("A theme named \"" + name + "\" already exists. Replace it?")) return;
          savedStyleSets.splice(existingIndex, 1);
        }
        const styleSet = {
          id: "mytheme-" + Date.now(),
          name: name.trim(),
          styles: JSON.parse(JSON.stringify(PAGE_STATE))
        };
        delete styleSet.styles.title;
        delete styleSet.styles.viewOnly;
        savedStyleSets.push(styleSet);
        rebuildThemeDropdown();
        document.getElementById("theme-preset").value = styleSet.id;
        updateDeleteButton();
        logAuditEvent("style", "Saved theme: " + name);
      }
      function deleteCurrentTheme() {
        const select = document.getElementById("theme-preset");
        const val = select.value;
        if (!val.startsWith("mytheme-")) return;
        const index = savedStyleSets.findIndex(s => s.id === val);
        if (index === -1) return;
        if (!confirm("Delete theme \"" + savedStyleSets[index].name + "\"?")) return;
        savedStyleSets.splice(index, 1);
        rebuildThemeDropdown();
        select.value = "defaulted";
        updateDeleteButton();
        logAuditEvent("style", "Deleted theme");
      }
      function rebuildThemeDropdown() {
        const group = document.getElementById("my-themes-group");
        if (!group) return;
        const select = document.getElementById("theme-preset");
        const currentValue = select ? select.value : "";
        group.innerHTML = "";
        savedStyleSets.forEach(function(s) {
          const opt = document.createElement("option");
          opt.value = s.id;
          opt.textContent = s.name;
          group.appendChild(opt);
        });
        if (select && currentValue) {
          select.value = currentValue;
        }
      }
      function updateDeleteButton() {
        const select = document.getElementById("theme-preset");
        const btn = document.getElementById("delete-theme-btn");
        if (!btn) return;
        btn.style.display = select.value.startsWith("mytheme-") ? "block" : "none";
      }
      function displayTabs() {
        const listEl = document.getElementById("tabs-list");
        if (!listEl) return;
        listEl.innerHTML = documentTabs.map((tab, index) => {
          const nodeCount = Object.keys(tab.nodes).length;
          const edgeCount = tab.edges.list.length;
          const isActive = index === currentTabIndex;
          return `
            <div class="tab-item ${isActive ? 'active' : ''}" onclick="switchTab(${index})">
              <div class="tab-name">${escapeHtml(tab.name)}</div>
              <div class="tab-stats">${nodeCount} nodes • ${edgeCount} connections</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="event.stopPropagation(); renameTab(${index})" title="Rename tab">✏️</button>
                ${documentTabs.length > 1 ? '<button class="btn-cancel" onclick="event.stopPropagation(); deleteTab(' + index + ')" title="Delete tab">🗑️</button>' : ''}
              </div>
            </div>
          `;
        }).join('');
      }
      function logAuditEvent(type, description, details = {}) {
        const event = {
          timestamp: Date.now(),
          type,
          description,
          details,
          tab: documentTabs[currentTabIndex]?.name || "Main"
        };
        auditLog.unshift(event);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to save audit log:", e);
        }
      }
      function loadAuditLog() {
        let embeddedLog = [];
        let localLog = [];
        try {
          const stateScript = document.getElementById("topology-state");
          if (stateScript) {
            const stateData = JSON.parse(stateScript.textContent);
            if (stateData.auditLog && Array.isArray(stateData.auditLog)) {
              embeddedLog = stateData.auditLog;
            }
          }
        } catch (e) {
          console.warn("Failed to load embedded audit log:", e);
        }
        try {
          const stored = localStorage.getItem(AUDIT_STORAGE_KEY);
          if (stored) {
            localLog = JSON.parse(stored);
          }
        } catch (e) {
          console.warn("Failed to load localStorage audit log:", e);
        }
        const merged = [...embeddedLog, ...localLog];
        const seen = new Set();
        auditLog = merged.filter(entry => {
          const key = entry.timestamp + entry.description;
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        }).sort((a, b) => b.timestamp - a.timestamp);
        if (auditLog.length > MAX_AUDIT_ENTRIES) {
          auditLog = auditLog.slice(0, MAX_AUDIT_ENTRIES);
        }
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log:", e);
        }
      }
      function displayAuditLog(filter = "all") {
        const listEl = document.getElementById("audit-log-list");
        if (!listEl) return;
        const filtered = filter === "all" ? auditLog : auditLog.filter(e => e.type === filter);
        if (filtered.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No audit entries yet</div>';
          return;
        }
        listEl.innerHTML = filtered.map(event => {
          const date = new Date(event.timestamp);
          const timeStr = date.toLocaleString();
          return `
            <div class="audit-entry ${escapeHtml(event.type)}">
              <div class="time">[${escapeHtml(timeStr)}] ${escapeHtml(event.tab)}</div>
              <div class="action">[${escapeHtml(event.type.toUpperCase())}] ${escapeHtml(event.description)}</div>
            </div>
          `;
        }).join('');
      }
      function clearAuditLog() {
        if (!confirm("Clear all audit log entries?\n\nThis cannot be undone.")) return;
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        displayAuditLog();
      }
      function exportAuditLog() {
        if (auditLog.length === 0) {
          alert("No audit entries to export");
          return;
        }
        const csv = [
          ["Timestamp", "Tab", "Type", "Description"],
          ...auditLog.map(e => [
            new Date(e.timestamp).toISOString(),
            e.tab,
            e.type,
            e.description
          ])
        ].map(row => row.map(cell => `"${cell}"`).join(",")).join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `audit-log-${Date.now()}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }
      let currentSecretName = null;
      function createNewSecret() {
        const nameInput = document.getElementById("new-secret-name");
        const name = nameInput.value.trim();
        if (!name) {
          alert("Please enter a note name");
          return;
        }
        if (encryptedSections[name]) {
          alert("A note with this name already exists");
          return;
        }
        currentSecretName = name;
        encryptedSections[name] = { encrypted: false, data: "" };
        nameInput.value = "";
        document.getElementById("secret-editor-title").textContent = `New note: ${name}`;
        document.getElementById("secret-editor-content").value = "";
        document.getElementById("secrets-modal").classList.remove("active");
        document.getElementById("secret-editor-modal").classList.add("active");
        displaySecrets();
      }
      function editSecret(name) {
        currentSecretName = name;
        const section = encryptedSections[name];
        if (section.encrypted) {
          const password = prompt(`Enter password to decrypt "${name}":`);
          if (!password) return;
          try {
            decryptData(section.data, password).then(decrypted => {
              document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
              document.getElementById("secret-editor-content").value = decrypted;
              document.getElementById("secrets-modal").classList.remove("active");
              document.getElementById("secret-editor-modal").classList.add("active");
            }).catch(e => {
              alert("Failed to decrypt. Wrong password?");
            });
          } catch (e) {
            alert("Failed to decrypt. Wrong password?");
          }
        } else {
          document.getElementById("secret-editor-title").textContent = `Edit note: ${name}`;
          document.getElementById("secret-editor-content").value = section.data;
          document.getElementById("secrets-modal").classList.remove("active");
          document.getElementById("secret-editor-modal").classList.add("active");
        }
      }
      async function saveSecret() {
        if (!currentSecretName) return;
        const content = document.getElementById("secret-editor-content").value;
        const autoEncrypt = document.getElementById("secret-auto-encrypt").checked;
        if (autoEncrypt) {
          const password = prompt(`Enter password to encrypt "${currentSecretName}":`);
          if (!password) return;
          const confirmPassword = prompt("Confirm password:");
          if (password !== confirmPassword) {
            alert("Passwords do not match");
            return;
          }
          try {
            const encrypted = await encryptData(content, password);
            encryptedSections[currentSecretName] = { encrypted: true, data: encrypted };
          } catch (e) {
            alert("Encryption failed: " + e.message);
            return;
          }
        } else {
          encryptedSections[currentSecretName] = { encrypted: false, data: content };
        }
        closeSecretEditor();
        displaySecrets();
        logAuditEvent("secret", `Saved note: ${currentSecretName}`);
      }
      function closeSecretEditor() {
        document.getElementById("secret-editor-modal").classList.remove("active");
        document.getElementById("secrets-modal").classList.add("active");
        currentSecretName = null;
      }
      function deleteSecret(name) {
        if (!confirm(`Delete note "${name}"?`)) return;
        delete encryptedSections[name];
        displaySecrets();
        logAuditEvent("secret", `Deleted note: ${name}`);
      }
      function displaySecrets() {
        const listEl = document.getElementById("secrets-list");
        if (!listEl) return;
        const secrets = Object.keys(encryptedSections);
        if (secrets.length === 0) {
          listEl.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No notes yet</div>';
          return;
        }
        listEl.innerHTML = secrets.map(name => {
          const section = encryptedSections[name];
          const status = section.encrypted ? "🔒 Encrypted" : "🔓 Plaintext";
          return `
            <div class="secret-item">
              <div class="secret-name">${escapeHtml(name)}</div>
              <div class="secret-status">${status}</div>
              <div class="tab-actions">
                <button class="btn-cancel" onclick="editSecret('${escapeHtml(name)}')" title="Edit note">✏️</button>
                <button class="btn-cancel" onclick="deleteSecret('${escapeHtml(name)}')" title="Delete note">🗑️</button>
              </div>
            </div>
          `;
        }).join('');
      }
      let rafId = null;
      let lastRender = 0;
      const RENDER_THROTTLE = 16;
      function setupDragToCreate() {
        const addNodeBtn = document.getElementById("add-node-btn");
        const addRackBtn = document.getElementById("add-rack-btn");
        const canvas = document.getElementById("map");
        if (!addNodeBtn || !addRackBtn || !canvas) return;
        let dragType = null;
        [addNodeBtn, addRackBtn].forEach(btn => {
          btn.setAttribute("draggable", "true");
          btn.addEventListener("dragstart", e => {
            dragType = btn.id === "add-node-btn" ? "node" : "rack";
            e.dataTransfer.effectAllowed = "copy";
            e.dataTransfer.setData("text/plain", dragType);
          });
        });
        canvas.addEventListener("dragover", e => {
          if (dragType) {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          }
        });
        canvas.addEventListener("drop", e => {
          if (!dragType) return;
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left) / canvasState.zoom + canvasState.panX;
          const y = (e.clientY - rect.top) / canvasState.zoom + canvasState.panY;
          if (dragType === "node") {
            createNodeAtPosition(x, y);
          } else if (dragType === "rack") {
            createRackAtPosition(x, y);
          }
          dragType = null;
        });
      }
      function createNodeAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `host-${timestamp}`;
		pushUndo("create node");
        NODE_DATA[newId] = {
          name: "New Node",
          ip: "0.0.0.0",
          shape: "server",
          role: "",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: false
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("node", `Created node at (${Math.round(x)}, ${Math.round(y)})`);
      }
      function createRackAtPosition(x, y) {
        const timestamp = Date.now();
        const newId = `rack-${timestamp}`;
		pushUndo("create rack");
        NODE_DATA[newId] = {
          name: "New Rack",
          ip: "",
          shape: "server",
          role: "rack",
          tags: [],
          notes: [],
          layer: "physical",
          isRack: true,
          rackCapacity: 42
        };
        savedPositions[newId] = { x, y };
        savedSizes[newId] = 55;
        populateRackDropdown();
        forgeTheTopology();
        claimTheImmortal(newId);
        logAuditEvent("rack", `Created rack at (${Math.round(x)}, ${Math.round(y)})`);
      }
      document.addEventListener("keydown", handleKeyDown);
      document.getElementById("save-file-btn").addEventListener("click", becomeImmortal);
      const addNodeBtn = document.getElementById("add-node-btn");
      const addNodeModal = document.getElementById("add-node-modal");
      const addNodeCancel = document.getElementById("add-node-cancel");
      const addNodeSave = document.getElementById("add-node-save");
      const undoBtn = document.getElementById("undo-btn");
      const redoBtn = document.getElementById("redo-btn");
      if (undoBtn) undoBtn.addEventListener("click", undo);
      if (redoBtn) redoBtn.addEventListener("click", redo);
      const backToTopologyBtn = document.getElementById("back-to-topology-btn");
      if (backToTopologyBtn) {
       backToTopologyBtn.addEventListener("click", exitRack);
      }
      const canvasViewport = document.getElementById("canvas-viewport");
      if (canvasViewport) {
       canvasViewport.addEventListener("dblclick", (e) => {
        if (currentView.mode === "rack" && e.target.id === "map") {
         exitRack();
        }
       });
      }
      const layersBtn = document.getElementById("layers-btn");
      const layerModal = document.getElementById("layer-modal");
      const layerModalClose = document.getElementById("layer-modal-close");
      if (layersBtn && layerModal) {
       layersBtn.addEventListener("click", () => {
        layerModal.classList.add("active");
       });
      }
      if (layerModalClose && layerModal) {
       layerModalClose.addEventListener("click", () => {
        layerModal.classList.remove("active");
       });
      }
      if (layerModal) {
       layerModal.addEventListener("click", (e) => {
        if (e.target === layerModal) {
         layerModal.classList.remove("active");
        }
       });
      }
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const tabsBtn = document.getElementById("tabs-btn");
      const tabsModal = document.getElementById("tabs-modal");
      const tabsModalClose = document.getElementById("tabs-modal-close");
      if (tabsBtn && tabsModal) {
        tabsBtn.addEventListener("click", () => {
          displayTabs();
          tabsModal.classList.add("active");
        });
      }
      if (tabsModalClose && tabsModal) {
        tabsModalClose.addEventListener("click", () => {
          tabsModal.classList.remove("active");
        });
      }
      if (tabsModal) {
        tabsModal.addEventListener("click", (e) => {
          if (e.target === tabsModal) {
            tabsModal.classList.remove("active");
          }
        });
      }
      const rollbackBtn = document.getElementById("rollback-btn");
      const rollbackModal = document.getElementById("rollback-modal");
      const rollbackModalClose = document.getElementById("rollback-modal-close");
      if (rollbackBtn && rollbackModal) {
        rollbackBtn.addEventListener("click", () => {
          loadRollbackVersions();
          rollbackModal.classList.add("active");
        });
      }
      if (rollbackModalClose && rollbackModal) {
        rollbackModalClose.addEventListener("click", () => {
          rollbackModal.classList.remove("active");
        });
      }
      if (rollbackModal) {
        rollbackModal.addEventListener("click", (e) => {
          if (e.target === rollbackModal) {
            rollbackModal.classList.remove("active");
          }
        });
      }
      const auditLogBtn = document.getElementById("audit-log-btn");
      const auditLogModal = document.getElementById("audit-log-modal");
      const auditLogModalClose = document.getElementById("audit-log-modal-close");
      const auditFilter = document.getElementById("audit-filter");
      if (auditLogBtn && auditLogModal) {
        auditLogBtn.addEventListener("click", () => {
          loadAuditLog();
          displayAuditLog();
          auditLogModal.classList.add("active");
        });
      }
      if (auditFilter) {
        auditFilter.addEventListener("change", (e) => {
          displayAuditLog(e.target.value);
        });
      }
      if (auditLogModalClose && auditLogModal) {
        auditLogModalClose.addEventListener("click", () => {
          auditLogModal.classList.remove("active");
        });
      }
	  const portMapBtn = document.getElementById("port-map-btn");
      const portMapModal = document.getElementById("port-map-modal");
      const portMapClose = document.getElementById("port-map-modal-close");
      const portMapSearch = document.getElementById("port-map-search");
      const portMapFilter = document.getElementById("port-map-filter");
      function renderPortMap() {
        const container = document.getElementById("port-map-table");
        const search = (document.getElementById("port-map-search")?.value || "").toLowerCase();
        const filter = document.getElementById("port-map-filter")?.value || "all";
        let edges = EDGE_DATA.list || [];
        if (filter === "with-ports") edges = edges.filter(e => e.fromPort || e.toPort);
        if (filter === "without-ports") edges = edges.filter(e => !e.fromPort && !e.toPort);
        if (search) {
          edges = edges.filter(e => {
            const fromName = (NODE_DATA[e.from]?.name || e.from || "").toLowerCase();
            const toName = (NODE_DATA[e.to]?.name || e.to || "").toLowerCase();
            return fromName.includes(search) || toName.includes(search) || (e.fromPort || "").toLowerCase().includes(search) || (e.toPort || "").toLowerCase().includes(search) || (e.notes || []).join(" ").toLowerCase().includes(search);
          });
        }
        if (edges.length === 0) {
          container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-soft);">No connections found</div>';
          return;
        }
        let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
        html += '<thead><tr style="background: var(--panel-alt); position: sticky; top: 0;"><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">From Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Device</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">To Port</th><th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--edge-main);">Notes</th></tr></thead><tbody>';
        edges.forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from;
          const toName = NODE_DATA[e.to]?.name || e.to;
          const notes = (e.notes || []).join(", ");
          const edgeColor = e.color || EDGE_LEGEND[e.type]?.color || 'var(--edge-main)';
          const fromPortDisplay = e.fromPort ? escapeHtml(e.fromPort) : "-";
          const toPortDisplay = e.toPort ? escapeHtml(e.toPort) : "-";
          const goToEdge = `document.getElementById('port-map-modal').classList.remove('active'); selectTheConnection('${escapeHtml(e.id)}'); focusOnSelected()`;
          html += `<tr style="border-bottom: 1px solid var(--edge-main);"><td style="padding: 8px;"><span style="display: inline-block; width: 8px; height: 8px; border-radius: 50%; background: ${edgeColor}; margin-right: 6px;"></span><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.from)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(fromName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'from')" style="background: ${e.fromPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.fromPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${fromPortDisplay}</button></td><td style="padding: 8px;"><button onclick="document.getElementById('port-map-modal').classList.remove('active'); claimTheImmortal('${escapeHtml(e.to)}'); focusOnSelected()" style="background: var(--panel-alt); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;">${escapeHtml(toName)}</button></td><td style="padding: 8px;"><button onclick="editPortFromMap('${escapeHtml(e.id)}', 'to')" style="background: ${e.toPort ? 'var(--accent)' : 'var(--panel)'}; color: ${e.toPort ? 'var(--bg)' : 'var(--text-soft)'}; border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-family: monospace; font-size: 13px; min-height: 36px;">${toPortDisplay}</button></td><td style="padding: 8px;"><button onclick="${goToEdge}" style="background: var(--panel); color: var(--text-main); border: 1px solid var(--edge-main); border-radius: 4px; padding: 6px 10px; cursor: pointer; font-size: 13px; min-height: 36px;" title="Go to connection">Go</button></td></tr>`;
        });
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      window.editPortFromMap = function(edgeId, which) {
        const edge = EDGE_DATA.list.find(e => e.id === edgeId);
        if (!edge) return;
        const fromName = NODE_DATA[edge.from]?.name || edge.from;
        const toName = NODE_DATA[edge.to]?.name || edge.to;
        const nodeId = which === 'from' ? edge.from : edge.to;
        const nodeName = which === 'from' ? fromName : toName;
        const label = `Port on ${nodeName}:`;
        const currentVal = which === 'from' ? (edge.fromPort || '') : (edge.toPort || '');
        const newVal = prompt(label, currentVal);
        if (newVal !== null && newVal !== '') {
          const isDuplicate = (EDGE_DATA.list || []).some(e => {
            if (e.id === edgeId) return false;
            if (e.from === nodeId && e.fromPort === newVal) return true;
            if (e.to === nodeId && e.toPort === newVal) return true;
            return false;
          });
          if (isDuplicate && !confirm(`Warning: Port "${newVal}" is already used on ${nodeName}. Use anyway?`)) {
            return;
          }
          if (which === 'from') edge.fromPort = newVal;
          else edge.toPort = newVal;
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        } else if (newVal === '') {
          if (which === 'from') edge.fromPort = '';
          else edge.toPort = '';
          renderPortMap();
          if (currentNodeId && (edge.from === currentNodeId || edge.to === currentNodeId)) {
            claimTheImmortal(currentNodeId);
          }
        }
      };
      window.exportPortMap = function() {
        let csv = "From Device,From Port,To Device,To Port,Notes\n";
        (EDGE_DATA.list || []).forEach(e => {
          const fromName = NODE_DATA[e.from]?.name || e.from || "";
          const toName = NODE_DATA[e.to]?.name || e.to || "";
          const notes = (e.notes || []).join("; ");
          csv += `${csvEscape(fromName)},${csvEscape(e.fromPort || "")},${csvEscape(toName)},${csvEscape(e.toPort || "")},${csvEscape(notes)}\n`;
        });
        const blob = new Blob([csv], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "port-map.csv";
        a.click();
        URL.revokeObjectURL(url);
      };
      if (portMapBtn && portMapModal) {
        portMapBtn.addEventListener("click", () => { renderPortMap(); portMapModal.classList.add("active"); });
      }
      if (portMapClose && portMapModal) {
        portMapClose.addEventListener("click", () => { portMapModal.classList.remove("active"); });
      }
      if (portMapSearch) { portMapSearch.addEventListener("input", renderPortMap); }
      if (portMapFilter) { portMapFilter.addEventListener("change", renderPortMap); }
      if (portMapModal) {
        portMapModal.addEventListener("click", (e) => { if (e.target === portMapModal) portMapModal.classList.remove("active"); });
      }
      if (auditLogModal) {
        auditLogModal.addEventListener("click", (e) => {
          if (e.target === auditLogModal) {
            auditLogModal.classList.remove("active");
          }
        });
      }
      const secretsBtn = document.getElementById("secrets-btn");
      const secretsModal = document.getElementById("secrets-modal");
      const secretsModalClose = document.getElementById("secrets-modal-close");
      const secretEditorModal = document.getElementById("secret-editor-modal");
      if (secretsBtn && secretsModal) {
        secretsBtn.addEventListener("click", () => {
          displaySecrets();
          secretsModal.classList.add("active");
        });
      }
      if (secretsModalClose && secretsModal) {
        secretsModalClose.addEventListener("click", () => {
          secretsModal.classList.remove("active");
        });
      }
      if (secretsModal) {
        secretsModal.addEventListener("click", (e) => {
          if (e.target === secretsModal) {
            secretsModal.classList.remove("active");
          }
        });
      }
      if (secretEditorModal) {
        secretEditorModal.addEventListener("click", (e) => {
          if (e.target === secretEditorModal) {
            closeSecretEditor();
          }
        });
      }
      loadAuditLog();
      setupDragToCreate();
      ["physical", "logical", "security", "application"].forEach(layer => {
       const checkbox = document.getElementById(`layer-${layer}`);
       if (checkbox) {
        checkbox.addEventListener("change", applyLayerFilter);
       }
      });
      const layerSelect = document.getElementById("node-layer");
      if (layerSelect) {
       layerSelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change layer");
         NODE_DATA[currentNodeId].layer = e.target.value;
         forgeTheTopology();
        }
       });
      }
       const assignedRackSelect = document.getElementById("node-assigned-rack");
       if (assignedRackSelect) {
      assignedRackSelect.addEventListener("change", (e) => {
      if (currentNodeId) {
      pushUndo("change assigned rack");
      EDGE_DATA.list = EDGE_DATA.list.filter(edge => edge.from !== currentNodeId && edge.to !== currentNodeId);
      NODE_DATA[currentNodeId].assignedRack = e.target.value;
      forgeTheTopology();
      claimTheImmortal(currentNodeId);
      }
      });
       }
      const rackCapacitySelect = document.getElementById("node-rack-capacity");
      if (rackCapacitySelect) {
       rackCapacitySelect.addEventListener("change", (e) => {
        if (currentNodeId) {
         pushUndo("change rack capacity");
         NODE_DATA[currentNodeId].rackCapacity = e.target.value;
         forgeTheTopology();
        }
       });
      }
      const bulkToolbarClose = document.getElementById("bulk-toolbar-close");
      if (bulkToolbarClose) {
       bulkToolbarClose.addEventListener("click", clearSelection);
      }
      const bulkAlignLeft = document.getElementById("bulk-align-left");
      if (bulkAlignLeft) {
       bulkAlignLeft.addEventListener("click", () => alignSelectedNodes("left"));
      }
      const bulkAlignRight = document.getElementById("bulk-align-right");
      if (bulkAlignRight) {
       bulkAlignRight.addEventListener("click", () => alignSelectedNodes("right"));
      }
      const bulkAlignTop = document.getElementById("bulk-align-top");
      if (bulkAlignTop) {
       bulkAlignTop.addEventListener("click", () => alignSelectedNodes("top"));
      }
      const bulkAlignBottom = document.getElementById("bulk-align-bottom");
      if (bulkAlignBottom) {
       bulkAlignBottom.addEventListener("click", () => alignSelectedNodes("bottom"));
      }
      const bulkDistributeH = document.getElementById("bulk-distribute-h");
      if (bulkDistributeH) {
       bulkDistributeH.addEventListener("click", () => distributeSelectedNodes("horizontal"));
      }
      const bulkDistributeV = document.getElementById("bulk-distribute-v");
      if (bulkDistributeV) {
       bulkDistributeV.addEventListener("click", () => distributeSelectedNodes("vertical"));
      }
      const bulkClone = document.getElementById("bulk-clone");
      if (bulkClone) {
       bulkClone.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id, true);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
       });
      }
      const bulkDelete = document.getElementById("bulk-delete");
      if (bulkDelete) {
       bulkDelete.addEventListener("click", deleteSelected);
      }
      const bulkMobileBtn = document.getElementById("bulk-mobile-btn");
      const bulkActionsModal = document.getElementById("bulk-actions-modal");
      const bulkModalClose = document.getElementById("bulk-modal-close");
      if (bulkMobileBtn) {
       bulkMobileBtn.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "block";
       });
      }
      if (bulkModalClose) {
       bulkModalClose.addEventListener("click", () => {
        if (bulkActionsModal) bulkActionsModal.style.display = "none";
       });
      }
      const closeModalAfterAction = () => {
       if (bulkActionsModal) bulkActionsModal.style.display = "none";
      };
      const bulkAlignLeftMobile = document.getElementById("bulk-align-left-mobile");
      if (bulkAlignLeftMobile) {
       bulkAlignLeftMobile.addEventListener("click", () => {
        alignSelectedNodes("left");
        closeModalAfterAction();
       });
      }
      const bulkAlignRightMobile = document.getElementById("bulk-align-right-mobile");
      if (bulkAlignRightMobile) {
       bulkAlignRightMobile.addEventListener("click", () => {
        alignSelectedNodes("right");
        closeModalAfterAction();
       });
      }
      const bulkAlignTopMobile = document.getElementById("bulk-align-top-mobile");
      if (bulkAlignTopMobile) {
       bulkAlignTopMobile.addEventListener("click", () => {
        alignSelectedNodes("top");
        closeModalAfterAction();
       });
      }
      const bulkAlignBottomMobile = document.getElementById("bulk-align-bottom-mobile");
      if (bulkAlignBottomMobile) {
       bulkAlignBottomMobile.addEventListener("click", () => {
        alignSelectedNodes("bottom");
        closeModalAfterAction();
       });
      }
      const bulkDistributeHMobile = document.getElementById("bulk-distribute-h-mobile");
      if (bulkDistributeHMobile) {
       bulkDistributeHMobile.addEventListener("click", () => {
        distributeSelectedNodes("horizontal");
        closeModalAfterAction();
       });
      }
      const bulkDistributeVMobile = document.getElementById("bulk-distribute-v-mobile");
      if (bulkDistributeVMobile) {
       bulkDistributeVMobile.addEventListener("click", () => {
        distributeSelectedNodes("vertical");
        closeModalAfterAction();
       });
      }
      const bulkCloneMobile = document.getElementById("bulk-clone-mobile");
      if (bulkCloneMobile) {
       bulkCloneMobile.addEventListener("click", () => {
        if (selectedNodes.size === 0) return;
        pushUndo("clone selected");
        const nodesToClone = Array.from(selectedNodes);
        selectedNodes.clear();
        nodesToClone.forEach(id => {
         cloneNode(id);
         selectedNodes.add(currentNodeId);
        });
        updateNodeSelection();
        closeModalAfterAction();
       });
      }
      const bulkDeleteMobile = document.getElementById("bulk-delete-mobile");
      if (bulkDeleteMobile) {
       bulkDeleteMobile.addEventListener("click", () => {
        deleteSelected();
        closeModalAfterAction();
       });
      }
      const bulkLockMobile = document.getElementById("bulk-lock-mobile");
      if (bulkLockMobile) {
       bulkLockMobile.addEventListener("click", () => {
        toggleLockSelected();
        closeModalAfterAction();
       });
      }
      const bulkGroupMobile = document.getElementById("bulk-group-mobile");
      if (bulkGroupMobile) {
       bulkGroupMobile.addEventListener("click", () => {
        toggleGroupSelected();
        closeModalAfterAction();
       });
      }
      const bulkClearMobile = document.getElementById("bulk-clear-mobile");
      if (bulkClearMobile) {
       bulkClearMobile.addEventListener("click", () => {
        clearSelection();
        closeModalAfterAction();
       });
      }
      const searchInput = document.getElementById("search-nodes");
      let searchTimeout = null;
      if (searchInput) {
       searchInput.addEventListener("input", (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => { searchNodes(e.target.value); }, 150);
       });
      }
      addNodeBtn.addEventListener("click", () => {
	  if (isViewOnly()) return;
       document.getElementById("new-node-name").value = "";
       document.getElementById("new-node-ip").value = "";
       document.getElementById("new-node-tags").value = "";
       document.getElementById("new-node-shape").value = "circle";
       addNodeModal.classList.add("active");
       document.getElementById("new-node-name").focus();
      });
      const addRackBtn = document.getElementById("add-rack-btn");
      const addRackModal = document.getElementById("add-rack-modal");
      const addRackCancel = document.getElementById("add-rack-cancel");
      const addRackSave = document.getElementById("add-rack-save");
      if (addRackBtn && addRackModal) {
       addRackBtn.addEventListener("click", () => {
	   if (isViewOnly()) return;
        document.getElementById("new-rack-name").value = "";
        document.getElementById("new-rack-ip").value = "";
        document.getElementById("new-rack-tags").value = "";
        document.getElementById("new-rack-shape").value = "server";
        document.getElementById("new-rack-capacity").value = "42";
        addRackModal.classList.add("active");
        document.getElementById("new-rack-name").focus();
       });
      }
      if (addRackCancel && addRackModal) {
       addRackCancel.addEventListener("click", () => {
        addRackModal.classList.remove("active");
       });
      }
      if (addRackModal) {
       addRackModal.addEventListener("click", (e) => {
        if (e.target === addRackModal) {
         addRackModal.classList.remove("active");
        }
       });
      }
      if (addRackSave && addRackModal) {
       addRackSave.addEventListener("click", () => {
        const name = document.getElementById("new-rack-name").value.trim();
        const ip = document.getElementById("new-rack-ip").value.trim();
        const tagsStr = document.getElementById("new-rack-tags").value.trim();
        const shape = document.getElementById("new-rack-shape").value;
        const capacity = document.getElementById("new-rack-capacity").value;
        if (!name) {
         alert("Please enter a rack name.");
         return;
        }
        const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
        let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
        if (!baseId) baseId = "rack";
        let nodeId = baseId;
        let counter = 1;
        while (NODE_DATA[nodeId]) {
         nodeId = baseId + "-" + counter;
         counter++;
        }
        pushUndo("add rack");
        NODE_DATA[nodeId] = {
         shape: shape,
         name: name,
         ip: ip || "",
         role: "Rack",
         tags: tags,
         notes: [],
         mac: "",
         rackUnit: "",
         uHeight: "1",
         layer: "physical",
         assignedRack: "",
         rackCapacity: capacity,
         isRack: true,
         locked: false,
         groupId: null
        };
        const viewWidth = CANVAS_WIDTH / canvasState.zoom;
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerX = canvasState.panX + (viewWidth / 2);
        const centerY = canvasState.panY + (viewHeight / 2);
        savedPositions[nodeId] = {
         x: centerX,
         y: centerY
        };
        addRackModal.classList.remove("active");
        forgeTheTopology();
        claimTheImmortal(nodeId);
       });
       ["new-rack-name", "new-rack-ip", "new-rack-tags"].forEach((inputId) => {
        const input = document.getElementById(inputId);
        if (input) {
         input.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
           addRackSave.click();
          }
         });
        }
       });
      }
      addNodeCancel.addEventListener("click", () => {
       addNodeModal.classList.remove("active");
      });
      addNodeModal.addEventListener("click", (e) => {
       if (e.target === addNodeModal) {
        addNodeModal.classList.remove("active");
       }
      });
      addNodeSave.addEventListener("click", () => {
       const name = document.getElementById("new-node-name").value.trim();
       const ip = document.getElementById("new-node-ip").value.trim();
       const tagsStr = document.getElementById("new-node-tags").value.trim();
       const shape = document.getElementById("new-node-shape").value;
       if (!name) {
        alert("Please enter a node name.");
        return;
       }
       const tags = tagsStr ? tagsStr.split(",").map((t) => t.trim()).filter((t) => t) : [];
       let baseId = name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
       if (!baseId) baseId = "node";
       let nodeId = baseId;
       let counter = 1;
       while (NODE_DATA[nodeId]) {
        nodeId = baseId + "-" + counter;
        counter++;
       }
	   pushUndo("add node");
       NODE_DATA[nodeId] = {
        shape: shape || "circle",
        name: name,
        ip: ip || "0.0.0.0",
        role: "",
        tags: tags,
        notes: [],
        mac: "",
        rackUnit: "",
        uHeight: "1",
        layer: "physical",
        assignedRack: "",
        rackCapacity: "42",
        isRack: false,
        locked: false,
        groupId: null
       };
       if (currentView.mode === "rack" && currentView.rackId) {
        NODE_DATA[nodeId].assignedRack = currentView.rackId;
        NODE_DATA[nodeId].layer = "physical";
        const rackCapacity = getRackCapacity(currentView.rackId);
        const rackUHeight = getRackUHeight(currentView.rackId);
        const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
        const centerY = canvasState.panY + (viewHeight / 2);
        let unit = rackCapacity - Math.round((centerY - RACK_START_Y) / rackUHeight);
        unit = Math.max(1, Math.min(rackCapacity, unit));
        NODE_DATA[nodeId].rackUnit = String(unit);
       }
      const viewWidth = CANVAS_WIDTH / canvasState.zoom;
      const viewHeight = CANVAS_HEIGHT / canvasState.zoom;
      const centerX = canvasState.panX + (viewWidth / 2);
      const centerY = canvasState.panY + (viewHeight / 2);
      savedPositions[nodeId] = {
      x: centerX,
      y: centerY
      };
       addNodeModal.classList.remove("active");
       forgeTheTopology();
       claimTheImmortal(nodeId);
      });
      ["new-node-name", "new-node-ip", "new-node-tags"].forEach(
       (inputId) => {
        document.getElementById(inputId).addEventListener("keypress", (e) => {
         if (e.key === "Enter") {
          addNodeSave.click();
         }
        });
       });
      const clearAllBtn = document.getElementById("clear-all-btn");
      const clearAllModal = document.getElementById("clear-all-modal");
      const clearAllCancel = document.getElementById("clear-all-cancel");
      const clearAllConfirm = document.getElementById("clear-all-confirm");
      clearAllBtn.addEventListener("click", () => {
       clearAllModal.classList.add("active");
      });
      clearAllCancel.addEventListener("click", () => {
       clearAllModal.classList.remove("active");
      });
      clearAllModal.addEventListener("click", (e) => {
       if (e.target === clearAllModal) {
        clearAllModal.classList.remove("active");
       }
      });
      clearAllConfirm.addEventListener("click", () => {
        NODE_DATA = {};
        EDGE_DATA = { list: [] };
        EDGE_LEGEND = {};
        RECT_DATA = { list: [] };
        TEXT_DATA = { list: [] };
        savedPositions = {};
        savedSizes = {};
        savedStyles = {};
        undoStack = [];
        redoStack = [];
        updateUndoButtons();
        auditLog = [];
        localStorage.removeItem(AUDIT_STORAGE_KEY);
        rollbackVersions = [];
        currentRollbackIndex = -1;
        localStorage.removeItem(ROLLBACK_STORAGE_KEY);   
        clipboard = null;      
        selectedNodes.clear();
        selectedEdges.clear();
        selectedRects.clear();
        selectedTexts.clear();
        documentTabs = [{
          id: "main",
          name: "Main Topology",
          nodes: {},
          edges: { list: [] },
          positions: {},
          sizes: {},
          styles: {},
          legend: {},
          rects: { list: [] },
          texts: { list: [] },
          pageState: null
        }];
        currentTabIndex = 0;
        displayTabs();
        clearAutosave();
        try {
          Object.keys(localStorage).forEach(key => {
            if (key.startsWith("theonefile")) {
              localStorage.removeItem(key);
            }
          });
        } catch(e) {}
        const addLineSelect = document.getElementById("add-line-select");
        if (addLineSelect) addLineSelect.innerHTML = "";
        const edgeLegendContent = document.getElementById("edge-legend-content");
        if (edgeLegendContent) edgeLegendContent.innerHTML = "";
        clearAllModal.classList.remove("active");
        forgeTheTopology();
        document.getElementById("node-panel").style.display = "none";
        document.getElementById("edge-panel").style.display = "none";
        document.getElementById("text-panel").style.display = "none";
        document.getElementById("topology-toolbar").style.display = "none";
        currentNodeId = null;
        currentEdgeId = null;
        currentTextId = null;
        if (typeof displayRollbackVersions === "function") displayRollbackVersions();
        if (typeof displayAuditLog === "function") displayAuditLog();
        if (typeof forgeTheLegend === "function") forgeTheLegend();
      });
      (function addDeleteNodeButton() {
       const nodePanel = document.getElementById("node-panel");
       if (!nodePanel) return;
       let deleteBtn = document.getElementById("delete-node-btn");
       if (!deleteBtn) {
        deleteBtn = document.createElement("button");
        deleteBtn.id = "delete-node-btn";
        deleteBtn.textContent = "Delete Node";
        deleteBtn.style.cssText = "margin-top:15px; padding:10px 16px; background:var(--danger); color:#fff; border:none; border-radius:6px; cursor:pointer; font-size:clamp(14px,1.6vw,18px); font-weight:600; width:100%;";
        nodePanel.appendChild(deleteBtn);
       }
       deleteBtn.addEventListener("click", () => {
        if (!currentNodeId) return;
        const nodeData = NODE_DATA[currentNodeId];
        let confirmMessage;
        let nodesInsideRack = [];
        if (nodeData?.isRack) {
         nodesInsideRack = Object.entries(NODE_DATA)
          .filter(([id, n]) => n.assignedRack === currentNodeId)
          .map(([id, n]) => n.name || id);
         if (nodesInsideRack.length > 0) {
          confirmMessage = `Delete rack "${nodeData.name}"?\n\nThis will also delete ${nodesInsideRack.length} node(s) inside:\n• ${nodesInsideRack.join('\n• ')}`;
         } else {
          confirmMessage = `Delete rack "${nodeData.name}"? (empty rack)`;
         }
        } else {
         confirmMessage = `Delete node "${nodeData?.name || currentNodeId}" and all its connections?`;
        }
        challengeTheImmortal(confirmMessage, () => {
         pushUndo("delete node");
         if (nodeData?.isRack) {
          Object.keys(NODE_DATA).forEach(id => {
           if (NODE_DATA[id]?.assignedRack === currentNodeId) {
            EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== id && e.to !== id);
            delete NODE_DATA[id];
            delete savedPositions[id];
            delete savedSizes[id];
            delete savedStyles[id];
           }
          });
         }
         EDGE_DATA.list = EDGE_DATA.list.filter(e => e.from !== currentNodeId && e.to !== currentNodeId);
         delete NODE_DATA[currentNodeId];
         delete savedPositions[currentNodeId];
         delete savedSizes[currentNodeId];
         delete savedStyles[currentNodeId];
         currentNodeId = null;
         currentEdgeId = null;
         forgeTheTopology();
         const remainingNodes = Object.keys(NODE_DATA);
         if (remainingNodes.length > 0) {
          claimTheImmortal(remainingNodes[0]);
         } else {
          document.getElementById("node-panel").style.display = "none";
          document.getElementById("edge-panel").style.display = "none";
          document.getElementById("topology-toolbar").style.display = "none";
         }
        });
       });
      })();
      function screenshotCanvas() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       svgClone.setAttribute("viewBox", `${x} ${y} ${width} ${height}`);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       function inlineStyles(original, clone) {
        const elements = original.querySelectorAll("*");
        const clonedElements = clone.querySelectorAll("*");
        const rootStyles = getComputedStyle(document.documentElement);
        const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
        const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        bgRect.setAttribute("x", x);
        bgRect.setAttribute("y", y);
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", bgColor);
        clone.insertBefore(bgRect, clone.firstChild);
        elements.forEach((el, index) => {
         const clonedEl = clonedElements[index];
         if (!clonedEl) return;
         const computedStyle = getComputedStyle(el);
         const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
         svgProps.forEach((prop) => {
          const value = computedStyle.getPropertyValue(prop);
          if (value && value !== "none" && value !== "normal") {
           clonedEl.style[prop] = value;
          }
         });
         clonedEl.removeAttribute("class");
        });
       }
       inlineStyles(svg, svgClone);
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const svgBlob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(svgBlob);
       const img = new Image();
       img.onload = function() {
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        canvas.toBlob(function(blob) {
         const link = document.createElement("a");
         const timestamp = new Date().toISOString().slice(0, 10);
         link.download = `topology-${timestamp}.png`;
         link.href = URL.createObjectURL(blob);
         link.click();
         URL.revokeObjectURL(url);
         URL.revokeObjectURL(link.href);
        }, "image/png");
       };
       img.onerror = function() {
        console.error("Failed to load SVG image");
        alert("Screenshot failed. Please try again.");
        URL.revokeObjectURL(url);
       };
       img.src = url;
      }
      function exportCanvasSVG() {
       const svg = document.getElementById("map");
       const svgClone = svg.cloneNode(true);
       const viewBox = svg.getAttribute("viewBox").split(" ").map(Number);
       const [x, y, width, height] = viewBox;
       svgClone.setAttribute("width", width);
       svgClone.setAttribute("height", height);
       const rootStyles = getComputedStyle(document.documentElement);
       const bgColor = rootStyles.getPropertyValue("--bg").trim() || "#050608";
       const bgRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
       bgRect.setAttribute("x", x);
       bgRect.setAttribute("y", y);
       bgRect.setAttribute("width", width);
       bgRect.setAttribute("height", height);
       bgRect.setAttribute("fill", bgColor);
       svgClone.insertBefore(bgRect, svgClone.firstChild);
       const wrapper = document.createElement("div");
       wrapper.style.position = "absolute";
       wrapper.style.left = "-9999px";
       wrapper.appendChild(svgClone);
       document.body.appendChild(wrapper);
       const elements = svg.querySelectorAll("*");
       const clonedElements = svgClone.querySelectorAll("*");
       elements.forEach((el, index) => {
        const clonedEl = clonedElements[index];
        if (!clonedEl) return;
        const computedStyle = getComputedStyle(el);
        const svgProps = ["fill", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "opacity", "font-family", "font-size", "font-weight", "font-style", "text-anchor", "dominant-baseline", "marker-start", "marker-end", ];
        svgProps.forEach((prop) => {
         const value = computedStyle.getPropertyValue(prop);
         if (value && value !== "none" && value !== "normal") {
          clonedEl.setAttribute(prop, value);
         }
        });
        clonedEl.removeAttribute("class");
       });
       const svgData = new XMLSerializer().serializeToString(svgClone);
       document.body.removeChild(wrapper);
       const blob = new Blob([svgData], {
        type: "image/svg+xml;charset=utf-8",
       });
       const url = URL.createObjectURL(blob);
       const link = document.createElement("a");
       const timestamp = new Date().toISOString().slice(0, 10);
       link.download = `topology-${timestamp}.svg`;
       link.href = url;
       link.click();
       URL.revokeObjectURL(url);
      }
      let resizeTimeout;
       window.addEventListener('resize', () => {
       clearTimeout(resizeTimeout);
       resizeTimeout = setTimeout(() => {
       updateDrawToolbarVisibility();
       updateTopologyToolbarVisibility();
       }, 100);
      });
	document.addEventListener('DOMContentLoaded', () => {
	  document.querySelectorAll('.dropdown').forEach(dropdown => {
		const btn = dropdown.querySelector('.dropdown-btn');
		const menu = dropdown.querySelector('.dropdown-menu');
		if (!btn || !menu) return;
		btn.addEventListener('click', (e) => {
		  e.stopPropagation();
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => {
			if (m !== menu) m.classList.remove('open');
		  });
		  menu.classList.toggle('open');
		});
	  });
	  document.addEventListener('click', (e) => {
		if (!e.target.closest('.dropdown')) {
		  document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		}
	  });
	  document.querySelectorAll('.dropdown-menu button').forEach(btn => {
		btn.addEventListener('click', () => {
		  setTimeout(() => {
			document.querySelectorAll('.dropdown-menu.open').forEach(m => m.classList.remove('open'));
		  }, 100);
		});
	  });
	  });
function showFormatHelp() {
  document.getElementById('save-info-modal').classList.add('active');
  document.querySelectorAll('.help-tab').forEach(t => {
    t.style.background = 'var(--panel)';
    t.style.color = 'var(--text-main)';
  });
  document.querySelectorAll('.help-tab-content').forEach(c => c.style.display = 'none');
  const formatsTab = document.querySelector('.help-tab[data-tab="formats"]');
  if (formatsTab) {
    formatsTab.style.background = 'var(--accent)';
    formatsTab.style.color = 'var(--bg)';
  }
  document.getElementById('help-tab-formats').style.display = 'block';
}
	function printTopology() {
	  const svg = document.getElementById('map');
	  if (!svg) { window.print(); return; }
	  const originalViewBox = svg.getAttribute('viewBox');
	  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
	  
	  Object.values(savedPositions).forEach(pos => {
		minX = Math.min(minX, pos.x - 100);
		minY = Math.min(minY, pos.y - 100);
		maxX = Math.max(maxX, pos.x + 100);
		maxY = Math.max(maxY, pos.y + 100);
	  });
	  
	  RECT_DATA.list.forEach(rect => {
		minX = Math.min(minX, rect.x);
		minY = Math.min(minY, rect.y);
		maxX = Math.max(maxX, rect.x + rect.width);
		maxY = Math.max(maxY, rect.y + rect.height);
	  });
	  
	  TEXT_DATA.list.forEach(text => {
		minX = Math.min(minX, text.x - 50);
		minY = Math.min(minY, text.y - 50);
		maxX = Math.max(maxX, text.x + 200);
		maxY = Math.max(maxY, text.y + 50);
	  });

	  const padding = 50;
	  minX -= padding;
	  minY -= padding;
	  maxX += padding;
	  maxY += padding;

	  if (minX !== Infinity) {
		svg.setAttribute('viewBox', `${minX} ${minY} ${maxX - minX} ${maxY - minY}`);
	  }

	  window.print();

	  setTimeout(() => {
		svg.setAttribute('viewBox', originalViewBox);
	  }, 1000);
	}
	function exportJSONFile() {
	  const data = captureTheQuickening();
	  const jsonStr = JSON.stringify(data, null, 2);
	  const blob = new Blob([jsonStr], { type: "application/json" });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement("a");
	  a.href = url;
	  const safeTitle = (PAGE_STATE.title || "network-topology").toLowerCase().replace(/[^a-z0-9\-]+/g, "-");
	  a.download = `${safeTitle}.json`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent("export", `Exported JSON: ${a.download}`);
	}
	function exportCSV() {
	  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
	  const timestamp = new Date().toISOString();
  const config = captureTheQuickening();
	  let csv = `#THEONEFILE_CONFIG:${JSON.stringify(config)}\n`;
	  csv += `#\n# ${PAGE_STATE.title || 'Network Topology'} - Node List\n`;
	  csv += `# Exported from The One File on ${timestamp}\n`;
	  const headers = ['name','ip','role','shape','tags','layer','mac','rackUnit','uHeight','assignedRack','rackCapacity','isRack','locked','groupId','x','y','size','notes','styles'];
	  csv += headers.join(',') + '\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] ? JSON.stringify(savedStyles[id]) : '';
		const row = [
		  csvEscape(node.name || ''), csvEscape(node.ip || ''), csvEscape(node.role || ''),
		  node.shape || 'circle', csvEscape((node.tags || []).join(';')), node.layer || 'physical',
		  csvEscape(node.mac || ''), csvEscape(node.rackUnit || ''), node.uHeight || '1',
		  node.assignedRack || '', node.rackCapacity || '', node.isRack ? 'true' : 'false',
		  node.locked ? 'true' : 'false', node.groupId || '', Math.round(pos.x), Math.round(pos.y),
		  size, csvEscape((node.notes || []).join('|')), csvEscape(styles)
		];
		csv += row.join(',') + '\n';
	  });
	  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.csv`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported CSV: ${a.download}`);
	}
	function csvEscape(val) {
	  if (val === null || val === undefined) return '';
	  const str = String(val);
	  if (str.includes(',') || str.includes('"') || str.includes('\n') || str.includes('\r')) {
		return '"' + str.replace(/"/g, '""') + '"';
	  }
	  return str;
	}
	document.getElementById('import-csv-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  try {
		const text = await file.text();
		const lines = text.split(/\r?\n/);
		let config = null;
		let dataLines = [];
		let headers = null;
		for (const line of lines) {
		  const trimmed = line.trim();
		  if (!trimmed) continue;
		  if (trimmed.startsWith('#THEONEFILE_CONFIG:')) {
			try { config = JSON.parse(trimmed.substring(19)); } catch (err) { console.warn('Failed to parse CSV config:', err); }
			continue;
		  }
		  if (trimmed.startsWith('#')) continue;
		  if (!headers) { headers = parseCSVLine(trimmed).map(h => h.toLowerCase().trim()); continue; }
		  dataLines.push(trimmed);
		}
		if (!headers || dataLines.length === 0) { alert('CSV file has no data rows'); return; }
		const nameIdx = headers.indexOf('name');
		if (nameIdx === -1) { alert('CSV must have a "name" column'); return; }
		const nodes = dataLines.map(line => {
		  const values = parseCSVLine(line);
		  const node = {};
		  headers.forEach((h, idx) => { node[h] = values[idx] || ''; });
		  return node;
		});
		const hasFullBackup = config && config.documentTabs;
    const hasConfig = config && (config.pageState || config.page);
    
    let importMode = 'add'; 
    
    if (hasFullBackup) {
      const choice = confirm(
        `This CSV contains a full backup.\n\n` +
        `• ${nodes.length} nodes in CSV data\n` +
        `• ${config.documentTabs?.length || 1} tab(s) in backup\n` +
        `• ${config.edgeData?.list?.length || 0} connections in backup\n\n` +
        `Click OK for FULL RESTORE (replace all data)\n` +
        `Click Cancel to just ADD the ${nodes.length} nodes`
      );
      if (choice) {
        importMode = 'full';
      }
    } else {
      let confirmMsg = `Import ${nodes.length} nodes from CSV?\n\n`;
      confirmMsg += hasConfig ? 'This will ADD nodes and RESTORE settings/theme.\n' : 'This will ADD nodes to your existing topology.\n';
      confirmMsg += '\nNote: CSV does not include connections, zones, or text labels.';
      if (!confirm(confirmMsg)) return;
    }
    
    pushUndo('import csv');
    
    if (importMode === 'full' && hasFullBackup) {
      NODE_DATA = config.nodeData || {};
      EDGE_DATA = config.edgeData || { list: [] };
      EDGE_LEGEND = config.edgeLegend || {};
      RECT_DATA = config.rectData || { list: [] };
      TEXT_DATA = config.textData || { list: [] };
      savedPositions = config.nodePositions || {};
      savedSizes = config.nodeSizes || {};
      savedStyles = config.nodeStyles || {};
      if (config.page) {
        PAGE_STATE = Object.assign({}, DEFAULT_PAGE_STATE, config.page);
        wieldThePower();
      }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.page?.title) {
        document.title = config.page.title;
        document.querySelector(".editable-page-title").textContent = config.page.title;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedStyleSets) {
        savedStyleSets = config.savedStyleSets;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
      Object.values(NODE_DATA).forEach(node => {
        if (!node.tags) node.tags = [];
        if (!node.notes) node.notes = [];
      });
      EDGE_DATA.list.forEach(edge => {
        if (!edge.notes) edge.notes = [];
      });
      forgeTheTopology();
      if (typeof forgeTheLegend === 'function') forgeTheLegend();
      updateViewBox();
      logAuditEvent('import', `Imported CSV (full restore): ${file.name}`);
      alert(`Full restore complete from CSV backup`);
      return;
    }
	
		if (hasConfig) {
		  Object.assign(PAGE_STATE, config.pageState || config.page);
		  if (config.canvasView || config.canvas) {
			canvasState.zoom = (config.canvasView || config.canvas).zoom || 1;
			canvasState.panX = (config.canvasView || config.canvas).panX || 0;
			canvasState.panY = (config.canvasView || config.canvas).panY || 0;
		  }
		  if (config.legend || config.edgeLegend) Object.assign(EDGE_LEGEND, config.legend || config.edgeLegend);
		  wieldThePower();
		}
		let gridX = 200, gridY = 200;
		const spacing = 150;
		const perRow = Math.ceil(Math.sqrt(nodes.length));
		let gridIndex = 0;
		nodes.forEach((n) => {
		  let baseId = (n.name || 'node').toLowerCase().replace(/[^a-z0-9]+/g, '-');
		  if (!baseId) baseId = 'node';
		  let nodeId = baseId;
		  let counter = 1;
		  while (NODE_DATA[nodeId]) { nodeId = `${baseId}-${counter}`; counter++; }
		  NODE_DATA[nodeId] = {
			name: n.name || 'Unnamed', ip: n.ip || '', role: n.role || '', shape: n.shape || 'circle',
			tags: n.tags ? n.tags.split(';').map(t => t.trim()).filter(t => t) : [],
			notes: n.notes ? n.notes.split('|').map(t => t.trim()).filter(t => t) : [],
			layer: n.layer || 'physical', mac: n.mac || '', rackUnit: n.rackunit || '',
			uHeight: n.uheight || '1', assignedRack: n.assignedrack || '', rackCapacity: n.rackcapacity || '',
			isRack: n.israck === 'true', locked: n.locked === 'true', groupId: n.groupid || null
		  };
		  const hasPosition = n.x && n.y && !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y));
		  if (hasPosition) {
			savedPositions[nodeId] = { x: parseFloat(n.x), y: parseFloat(n.y) };
		  } else {
			const row = Math.floor(gridIndex / perRow);
			const col = gridIndex % perRow;
			savedPositions[nodeId] = { x: gridX + col * spacing, y: gridY + row * spacing };
			gridIndex++;
		  }
		  if (n.size && !isNaN(parseFloat(n.size))) savedSizes[nodeId] = parseFloat(n.size);
		  if (n.styles) { try { savedStyles[nodeId] = JSON.parse(n.styles); } catch (err) {} }
		});
		forgeTheTopology();
		updateViewBox();
		logAuditEvent('import', `Imported CSV: ${file.name} (${nodes.length} nodes)`);
		alert(`Successfully imported ${nodes.length} nodes`);
	  } catch (err) {
		console.error('CSV import error:', err);
		alert('Failed to import CSV: ' + err.message);
	  }
	});
	function parseCSVLine(line) {
	  const result = [];
	  let current = '';
	  let inQuotes = false;
	  for (let i = 0; i < line.length; i++) {
		const char = line[i];
		if (char === '"') {
		  if (inQuotes && line[i + 1] === '"') { current += '"'; i++; }
		  else { inQuotes = !inQuotes; }
		} else if (char === ',' && !inQuotes) { result.push(current); current = ''; }
		else { current += char; }
	  }
	  result.push(current);
	  return result;
	}
	function exportMarkdown() {
  const safeTitle = (PAGE_STATE.title || 'topology').toLowerCase().replace(/[^a-z0-9]+/g, '-');
  const timestamp = new Date().toISOString();
  const title = PAGE_STATE.title || 'Network Topology';
  const fullData = captureTheQuickening();
  const config = fullData;
	  let md = `<!--THEONEFILE_CONFIG\n${JSON.stringify(config, null, 2)}\nTHEONEFILE_CONFIG-->\n\n`;
	  md += `# ${title}\n\n> Exported from The One File on ${timestamp}\n\n`;
	  md += `## Legend\n\n`;
	  if (Object.keys(EDGE_LEGEND).length > 0) {
		Object.entries(EDGE_LEGEND).forEach(([color, label]) => { md += `- ${color}: ${label}\n`; });
	  } else { md += `_No legend entries_\n`; }
	  md += '\n## Nodes\n\n';
	  Object.entries(NODE_DATA).forEach(([id, node]) => {
		const pos = savedPositions[id] || { x: 0, y: 0 };
		const size = savedSizes[id] || 50;
		const styles = savedStyles[id] || null;
		md += `### ${id}\n`;
		md += `- **Name:** ${node.name || ''}\n- **IP:** ${node.ip || ''}\n- **Role:** ${node.role || ''}\n`;
		md += `- **Shape:** ${node.shape || 'circle'}\n- **Tags:** ${(node.tags || []).join('; ') || '_none_'}\n`;
		md += `- **Layer:** ${node.layer || 'physical'}\n- **MAC:** ${node.mac || ''}\n`;
		md += `- **Rack Unit:** ${node.rackUnit || ''}\n- **U Height:** ${node.uHeight || '1'}\n`;
		md += `- **Assigned Rack:** ${node.assignedRack || ''}\n- **Rack Capacity:** ${node.rackCapacity || ''}\n`;
		md += `- **Is Rack:** ${node.isRack ? 'true' : 'false'}\n- **Locked:** ${node.locked ? 'true' : 'false'}\n`;
		md += `- **Group ID:** ${node.groupId || ''}\n- **Position:** ${Math.round(pos.x)}, ${Math.round(pos.y)}\n- **Size:** ${size}\n`;
		if (node.notes && node.notes.length > 0) { md += `- **Notes:**\n`; node.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		if (styles) { md += `- **Styles:** \`${JSON.stringify(styles)}\`\n`; }
		md += '\n';
	  });
	  md += `## Connections\n\n`;
	  if (EDGE_DATA.list && EDGE_DATA.list.length > 0) {
		EDGE_DATA.list.forEach(edge => {
		  const fromPort = edge.fromPort ? ` (${edge.fromPort})` : '';
		  const toPort = edge.toPort ? ` (${edge.toPort})` : '';
		  md += `- ${edge.from}${fromPort} --> ${edge.to}${toPort}\n`;
		  md += `  - **ID:** ${edge.id}\n  - **Label:** ${(edge.label || '').replace(/\n/g, '<br>')}\n  - **Color:** ${edge.color || ''}\n`;
		  md += `  - **Width:** ${edge.width || 4}\n  - **Direction:** ${edge.direction || 'none'}\n`;
		  md += `  - **Routing:** ${edge.routing || 'curved'}\n  - **Type:** ${edge.type || 'main'}\n`;
		  md += `  - **Line Style:** ${edge.lineStyle || 'solid'}\n  - **Group ID:** ${edge.groupId || ''}\n`;
		  if (edge.points && edge.points.length > 0) { md += `  - **Points:** ${edge.points.map(p => `${Math.round(p.x)},${Math.round(p.y)}`).join(' ')}\n`; }
		  if (edge.notes && edge.notes.length > 0) { md += `  - **Notes:**\n`; edge.notes.forEach(note => { md += `    - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No connections_\n\n`; }
	  md += `## Zones\n\n`;
	  if (RECT_DATA.list && RECT_DATA.list.length > 0) {
		RECT_DATA.list.forEach(rect => {
		  md += `### ${rect.id}\n`;
		  md += `- **Position:** ${Math.round(rect.x)}, ${Math.round(rect.y)}\n- **Size:** ${Math.round(rect.width)} x ${Math.round(rect.height)}\n`;
		  md += `- **Color:** ${rect.color || ''}\n- **Style:** ${rect.style || 'filled'}\n- **Line Style:** ${rect.lineStyle || 'solid'}\n`;
		  md += `- **Border Color:** ${rect.borderColor || ''}\n- **Border Width:** ${rect.borderWidth !== undefined ? rect.borderWidth : 2}\n`;
		  if (rect.notes && rect.notes.length > 0) { md += `- **Notes:**\n`; rect.notes.forEach(note => { md += `  - ${note.replace(/\n/g, '<br>')}\n`; }); }
		  md += '\n';
		});
	  } else { md += `_No zones_\n\n`; }
	  md += `## Text Labels\n\n`;
	  if (TEXT_DATA.list && TEXT_DATA.list.length > 0) {
		TEXT_DATA.list.forEach(text => {
		  md += `### ${text.id}\n`;
		  md += `- **Content:** ${(text.content || '').replace(/\n/g, '<br>')}\n- **Position:** ${Math.round(text.x)}, ${Math.round(text.y)}\n`;
		  md += `- **Font Size:** ${text.fontSize || 18}\n- **Color:** ${text.color || '#e2e8f0'}\n`;
		  md += `- **Font Weight:** ${text.fontWeight || 'normal'}\n- **Font Style:** ${text.fontStyle || 'normal'}\n`;
		  md += `- **Text Align:** ${text.textAlign || 'start'}\n- **Text Decoration:** ${text.textDecoration || 'none'}\n`;
		  md += `- **Background Color:** ${text.bgColor || '#000000'}\n- **Background Enabled:** ${text.bgEnabled ? 'true' : 'false'}\n`;
		  md += `- **Opacity:** ${text.opacity !== undefined ? text.opacity : 1}\n\n`;
		});
	  } else { md += `_No text labels_\n\n`; }
	  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8;' });
	  const url = URL.createObjectURL(blob);
	  const a = document.createElement('a');
	  a.href = url;
	  a.download = `${safeTitle}.md`;
	  a.click();
	  URL.revokeObjectURL(url);
	  logAuditEvent('export', `Exported Markdown: ${a.download}`);
	}
document.getElementById('import-markdown-file').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  e.target.value = '';
  try {
    const text = await file.text();
    let config = null;
    const configMatch = text.match(/<!--THEONEFILE_CONFIG\s*([\s\S]*?)\s*THEONEFILE_CONFIG-->/);
    if (configMatch) { try { config = JSON.parse(configMatch[1].trim()); } catch (err) { console.warn('Failed to parse Markdown config:', err); } }
    const nodes = {}, positions = {}, sizes = {}, styles = {}, edges = [], rects = [], texts = [], legend = {};
    const sections = text.split(/^## /m);
    sections.forEach(section => {
      const lines = section.trim().split('\n');
      const sectionTitle = lines[0]?.trim().toLowerCase();
      if (sectionTitle === 'legend') {
        lines.slice(1).forEach(line => {
          const match = line.match(/^- (#[a-fA-F0-9]{3,8}):\s*(.+)$/);
          if (match) legend[match[1]] = match[2].trim();
        });
      } else if (sectionTitle === 'nodes') {
        let currentNodeId = null, currentNode = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const nodeMatch = line.match(/^### (.+)$/);
          if (nodeMatch) {
            if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
            currentNodeId = nodeMatch[1].trim();
            currentNode = { tags: [], notes: [] };
            inNotes = false;
            return;
          }
          if (!currentNode) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentNode.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'name': currentNode.name = val; break;
              case 'ip': currentNode.ip = val; break;
              case 'role': currentNode.role = val; break;
              case 'shape': currentNode.shape = val; break;
              case 'tags': currentNode.tags = val === '_none_' ? [] : val.split(';').map(t => t.trim()).filter(t => t); break;
              case 'layer': currentNode.layer = val; break;
              case 'mac': currentNode.mac = val; break;
              case 'rack unit': currentNode.rackUnit = val; break;
              case 'u height': currentNode.uHeight = val; break;
              case 'assigned rack': currentNode.assignedRack = val; break;
              case 'rack capacity': currentNode.rackCapacity = val; break;
              case 'is rack': currentNode.isRack = val === 'true'; break;
              case 'locked': currentNode.locked = val === 'true'; break;
              case 'group id': currentNode.groupId = val || null; break;
              case 'position':
                const posMatch = val.match(/(-?\d+),\s*(-?\d+)/);
                if (posMatch) positions[currentNodeId] = { x: parseFloat(posMatch[1]), y: parseFloat(posMatch[2]) };
                break;
              case 'size': sizes[currentNodeId] = parseFloat(val) || 50; break;
              case 'notes': inNotes = true; break;
              case 'styles':
                const stylesMatch = val.match(/`(.+)`/);
                if (stylesMatch) { try { styles[currentNodeId] = JSON.parse(stylesMatch[1]); } catch (err) {} }
                break;
            }
          }
        });
        if (currentNodeId && currentNode) nodes[currentNodeId] = currentNode;
         } else if (sectionTitle === 'connections') {
        let currentEdge = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const connMatch = line.match(/^- (.+?)\s*(?:\(([^)]*)\))?\s*-->\s*(.+?)\s*(?:\(([^)]*)\))?$/);
          if (connMatch) {
            if (currentEdge) edges.push(currentEdge);
            currentEdge = { from: connMatch[1].trim(), to: connMatch[3].trim(), fromPort: connMatch[2] || '', toPort: connMatch[4] || '', notes: [] };
            inNotes = false;
            return;
          }
          if (!currentEdge) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentEdge.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^\s+- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'id': currentEdge.id = val; break;
              case 'label': currentEdge.label = val.replace(/<br>/g, '\n'); break;
              case 'color': currentEdge.color = val; break;
              case 'width': currentEdge.width = parseFloat(val) || 4; break;
              case 'direction': currentEdge.direction = val; break;
              case 'routing': currentEdge.routing = val; break;
              case 'type': currentEdge.type = val; break;
              case 'line style': currentEdge.lineStyle = val; break;
              case 'group id': currentEdge.groupId = val || null; break;
              case 'points':
                currentEdge.points = val.split(' ').map(p => { const [x, y] = p.split(',').map(Number); return { x, y }; }).filter(p => !isNaN(p.x) && !isNaN(p.y));
                break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentEdge) edges.push(currentEdge);
      } else if (sectionTitle === 'zones') {
        let currentRect = null, inNotes = false;
        lines.slice(1).forEach(line => {
          const rectMatch = line.match(/^### (.+)$/);
          if (rectMatch) {
            if (currentRect) rects.push(currentRect);
            currentRect = { id: rectMatch[1].trim(), notes: [] };
            inNotes = false;
            return;
          }
          if (!currentRect) return;
          if (inNotes && line.match(/^\s+-\s+(.+)$/)) {
            const noteMatch = line.match(/^\s+-\s+(.+)$/);
            if (noteMatch) currentRect.notes.push(noteMatch[1].trim().replace(/<br>/g, '\n'));
            return;
          }
          inNotes = false;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentRect.x = parseFloat(posMatch[1]); currentRect.y = parseFloat(posMatch[2]); } break;
              case 'size': const sizeMatch = val.match(/(\d+)\s*x\s*(\d+)/); if (sizeMatch) { currentRect.width = parseFloat(sizeMatch[1]); currentRect.height = parseFloat(sizeMatch[2]); } break;
              case 'color': currentRect.color = val; break;
              case 'style': currentRect.style = val; break;
              case 'line style': currentRect.lineStyle = val; break;
              case 'border color': currentRect.borderColor = val; break;
              case 'border width': currentRect.borderWidth = parseFloat(val) || 2; break;
              case 'notes': inNotes = true; break;
            }
          }
        });
        if (currentRect) rects.push(currentRect);
      } else if (sectionTitle === 'text labels') {
        let currentText = null;
        lines.slice(1).forEach(line => {
          const textMatch = line.match(/^### (.+)$/);
          if (textMatch) {
            if (currentText) texts.push(currentText);
            currentText = { id: textMatch[1].trim() };
            return;
          }
          if (!currentText) return;
          const propMatch = line.match(/^- \*\*(.+?):\*\*\s*(.*)$/);
          if (propMatch) {
            const key = propMatch[1].trim().toLowerCase(), val = propMatch[2].trim();
            switch (key) {
              case 'content': currentText.content = val.replace(/<br>/g, '\n'); break;
              case 'position': const posMatch = val.match(/(-?\d+),\s*(-?\d+)/); if (posMatch) { currentText.x = parseFloat(posMatch[1]); currentText.y = parseFloat(posMatch[2]); } break;
              case 'font size': currentText.fontSize = parseFloat(val) || 18; break;
              case 'color': currentText.color = val; break;
              case 'font weight': currentText.fontWeight = val; break;
              case 'font style': currentText.fontStyle = val; break;
              case 'text align': currentText.textAlign = val; break;
              case 'text decoration': currentText.textDecoration = val; break;
              case 'background color': currentText.bgColor = val; break;
              case 'background enabled': currentText.bgEnabled = val === 'true'; break;
              case 'opacity': currentText.opacity = parseFloat(val) || 1; break;
            }
          }
        });
        if (currentText) texts.push(currentText);
      }
    });
    const nodeCount = Object.keys(nodes).length, edgeCount = edges.length, rectCount = rects.length, textCount = texts.length;
    if (nodeCount === 0 && edgeCount === 0 && rectCount === 0 && textCount === 0) {
      alert('No valid topology data found in Markdown file.\n\nMake sure the file was exported from The One File.');
      return;
    }
    let confirmMsg = `Import Markdown topology?\n\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels\n\nThis will REPLACE all current data.`;
    if (!confirm(confirmMsg)) return;
    pushUndo('import markdown');
    if (config && config.documentTabs) {
      if (config.page) { Object.assign(PAGE_STATE, config.page); wieldThePower(); }
      if (config.canvas) {
        canvasState.zoom = config.canvas.zoom || 1;
        canvasState.panX = config.canvas.panX || 0;
        canvasState.panY = config.canvas.panY || 0;
      }
      if (config.documentTabs) {
        documentTabs = config.documentTabs;
        currentTabIndex = config.currentTabIndex || 0;
      }
      if (config.savedTopologyView) {
        savedTopologyView = config.savedTopologyView;
      }
      if (config.encryptedSections) {
        encryptedSections = config.encryptedSections;
      }
      if (config.auditLog && Array.isArray(config.auditLog)) {
        auditLog = config.auditLog;
        try {
          localStorage.setItem(AUDIT_STORAGE_KEY, JSON.stringify(auditLog));
        } catch (e) {
          console.warn("Failed to sync audit log to localStorage:", e);
        }
      }
    } else if (config && config.pageState) {
      Object.assign(PAGE_STATE, config.pageState);
      wieldThePower();
      if (config.canvasView) {
        canvasState.zoom = config.canvasView.zoom || 1;
        canvasState.panX = config.canvasView.panX || 0;
        canvasState.panY = config.canvasView.panY || 0;
      }
    }
    Object.keys(NODE_DATA).forEach(k => delete NODE_DATA[k]);
    Object.keys(savedPositions).forEach(k => delete savedPositions[k]);
    Object.keys(savedSizes).forEach(k => delete savedSizes[k]);
    Object.keys(savedStyles).forEach(k => delete savedStyles[k]);
    EDGE_DATA.list = [];
    RECT_DATA.list = [];
    TEXT_DATA.list = [];
    Object.keys(EDGE_LEGEND).forEach(k => delete EDGE_LEGEND[k]);
    Object.assign(EDGE_LEGEND, legend);
    Object.entries(nodes).forEach(([id, node]) => {
      NODE_DATA[id] = { name: node.name || '', ip: node.ip || '', role: node.role || '', shape: node.shape || 'circle', tags: node.tags || [], notes: node.notes || [], mac: node.mac || '', rackUnit: node.rackUnit || '', uHeight: node.uHeight || '1', layer: node.layer || 'physical', assignedRack: node.assignedRack || '', rackCapacity: node.rackCapacity || '', isRack: node.isRack || false, locked: node.locked || false, groupId: node.groupId || null };
      savedPositions[id] = positions[id] || { x: 500, y: 300 };
      if (sizes[id]) savedSizes[id] = sizes[id];
      if (styles[id]) savedStyles[id] = styles[id];
    });
    let skippedEdges = 0;
    edges.forEach(edge => {
      if (!NODE_DATA[edge.from] || !NODE_DATA[edge.to]) {
        console.warn(`Skipping orphan edge: ${edge.from} -> ${edge.to}`);
        skippedEdges++;
        return;
      }
      EDGE_DATA.list.push({ id: edge.id || `edge-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, from: edge.from, to: edge.to, fromPort: edge.fromPort || '', toPort: edge.toPort || '', label: edge.label || '', color: edge.color || '', width: edge.width || 4, direction: edge.direction || 'none', routing: edge.routing || 'curved', type: edge.type || 'main', lineStyle: edge.lineStyle || 'solid', groupId: edge.groupId || null, points: edge.points || [], notes: edge.notes || [] });
    });
    if (skippedEdges > 0) console.warn(`Total skipped orphan edges: ${skippedEdges}`);
    rects.forEach(rect => {
      RECT_DATA.list.push({ id: rect.id, x: rect.x || 0, y: rect.y || 0, width: rect.width || 100, height: rect.height || 100, color: rect.color || '#f97316', style: rect.style || 'filled', lineStyle: rect.lineStyle || 'solid', borderColor: rect.borderColor || '', borderWidth: rect.borderWidth !== undefined ? rect.borderWidth : 2, notes: rect.notes || [] });
    });
    texts.forEach(text => {
      TEXT_DATA.list.push({ id: text.id, x: text.x || 0, y: text.y || 0, content: text.content || '', fontSize: text.fontSize || 18, color: text.color || '#e2e8f0', fontWeight: text.fontWeight || 'normal', fontStyle: text.fontStyle || 'normal', textAlign: text.textAlign || 'start', textDecoration: text.textDecoration || 'none', bgColor: text.bgColor || '#000000', bgEnabled: text.bgEnabled || false, opacity: text.opacity !== undefined ? text.opacity : 1 });
    });
    forgeTheTopology();
    if (typeof forgeTheLegend === 'function') forgeTheLegend();
    updateViewBox();
    logAuditEvent('import', `Imported Markdown: ${file.name} (${nodeCount} nodes, ${edgeCount} connections)`);
    alert(`Successfully imported:\n- ${nodeCount} nodes\n- ${edgeCount} connections\n- ${rectCount} zones\n- ${textCount} text labels`);
     } catch (err) {
    console.error('Markdown import error:', err);
    alert('Failed to import Markdown: ' + err.message);
     }
	});
	document.getElementById('import-json-file').addEventListener('change', async (e) => {
	  const file = e.target.files[0];
	  if (!file) return;
	  e.target.value = '';
	  const existingInput = document.getElementById('import-data-file');
	  if (existingInput) {
		const dt = new DataTransfer();
		dt.items.add(file);
		existingInput.files = dt.files;
		existingInput.dispatchEvent(new Event('change'));
	  }
	});
	document.getElementById('mobile-export-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-export-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-import-btn')?.addEventListener('click', () => {
	  document.getElementById('mobile-import-modal').classList.add('active');
	  document.getElementById('topbar-menu').classList.remove('open');
	});
	document.getElementById('mobile-export-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-export-modal') e.target.classList.remove('active');
	});
	document.getElementById('mobile-import-modal')?.addEventListener('click', (e) => {
	  if (e.target.id === 'mobile-import-modal') e.target.classList.remove('active');
	});
    </script>
  
</body></html>